var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var types = {
  "[object Array]": "array",
  "[object Date]": "date",
  "[object Object]": "object",
  "[object String]": "string",
  "[object Null]": "null"
};
var type = function(object) {
  var typeOfObject = Object.prototype.toString.call(object);
  return typeof object === "object" ? types[typeOfObject] || "object" : typeof object;
};
var isBoolean = function(object) {
  return typeof object === "boolean";
};
var isExponential = function(value2) {
  return isNumeric(value2) && value2.toString().indexOf("e") !== -1;
};
var isDate = function(object) {
  return type(object) === "date";
};
var isDefined = function(object) {
  return object !== null && object !== void 0;
};
var isFunction$1 = function(object) {
  return typeof object === "function";
};
var isString$1 = function(object) {
  return typeof object === "string";
};
var isNumeric = function(object) {
  return typeof object === "number" && isFinite(object) || !isNaN(object - parseFloat(object));
};
var isObject$1 = function(object) {
  return type(object) === "object";
};
var isEmptyObject = function(object) {
  var property;
  for (property in object) {
    return false;
  }
  return true;
};
var isPlainObject = function(object) {
  if (!object || Object.prototype.toString.call(object) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(object);
  var ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof ctor === "function" && Object.toString.call(ctor) === Object.toString.call(Object);
};
var isPrimitive = function(value2) {
  return ["object", "array", "function"].indexOf(type(value2)) === -1;
};
var isWindow = function(object) {
  return object != null && object === object.window;
};
var isRenderer = function(object) {
  return !!(object.jquery || object.dxRenderer);
};
var isPromise$1 = function(object) {
  return object && isFunction$1(object.then);
};
var isDeferred = function(object) {
  return object && isFunction$1(object.done) && isFunction$1(object.fail);
};
var isEvent = function(object) {
  return !!(object && object.preventDefault);
};
var map = (values, callback) => {
  if (Array.isArray(values)) {
    return values.map(callback);
  }
  var result = [];
  for (var key in values) {
    result.push(callback(values[key], key));
  }
  return result;
};
var each = (values, callback) => {
  if (!values) {
    return;
  }
  if ("length" in values) {
    for (var i = 0; i < values.length; i++) {
      if (callback.call(values[i], i, values[i]) === false) {
        break;
      }
    }
  } else {
    for (var key in values) {
      if (callback.call(values[key], key, values[key]) === false) {
        break;
      }
    }
  }
  return values;
};
var noop$1 = function() {
};
var getConsoleMethod = function(method) {
  if (typeof console === "undefined" || !isFunction$1(console[method])) {
    return noop$1;
  }
  return console[method].bind(console);
};
var logger = {
  info: getConsoleMethod("info"),
  warn: getConsoleMethod("warn"),
  error: getConsoleMethod("error")
};
var extendFromObject = function(target, source, overrideExistingValues) {
  target = target || {};
  for (var prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      var value2 = source[prop];
      if (!(prop in target) || overrideExistingValues) {
        target[prop] = value2;
      }
    }
  }
  return target;
};
var extend = function extend2(target) {
  target = target || {};
  var i = 1;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i++;
  }
  for (; i < arguments.length; i++) {
    var source = arguments[i];
    if (source == null) {
      continue;
    }
    for (var key in source) {
      var targetValue = target[key];
      var sourceValue = source[key];
      var sourceValueIsArray = false;
      var clone = void 0;
      if (key === "__proto__" || key === "constructor" || target === sourceValue) {
        continue;
      }
      if (deep && sourceValue && (isPlainObject(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
        if (sourceValueIsArray) {
          clone = targetValue && Array.isArray(targetValue) ? targetValue : [];
        } else {
          clone = targetValue && isPlainObject(targetValue) ? targetValue : {};
        }
        target[key] = extend2(deep, clone, sourceValue);
      } else if (sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
  }
  return target;
};
var encodeHtml = function() {
  var encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
  return function(str) {
    return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;");
  };
}();
var splitQuad = function(raw) {
  switch (typeof raw) {
    case "string":
      return raw.split(/\s+/, 4);
    case "object":
      return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
    case "number":
      return [raw];
    default:
      return raw;
  }
};
var quadToObject = function(raw) {
  var quad = splitQuad(raw);
  var left = parseInt(quad && quad[0], 10);
  var top = parseInt(quad && quad[1], 10);
  var right = parseInt(quad && quad[2], 10);
  var bottom = parseInt(quad && quad[3], 10);
  if (!isFinite(left)) {
    left = 0;
  }
  if (!isFinite(top)) {
    top = left;
  }
  if (!isFinite(right)) {
    right = left;
  }
  if (!isFinite(bottom)) {
    bottom = top;
  }
  return {
    top,
    right,
    bottom,
    left
  };
};
function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if (isFunction$1(template)) {
    return template(...values);
  }
  values.forEach((value2, index2) => {
    if (isString$1(value2)) {
      value2 = value2.replace(/\$/g, "$$$$");
    }
    var placeholderReg = new RegExp("\\{" + index2 + "\\}", "gm");
    template = template.replace(placeholderReg, value2);
  });
  return template;
}
var isEmpty$1 = function() {
  var SPACE_REGEXP = /\s/g;
  return function(text) {
    return !text || !text.replace(SPACE_REGEXP, "");
  };
}();
var version = "21.1.5";
var ERROR_URL = "http://js.devexpress.com/error/" + version.split(".").slice(0, 2).join("_") + "/";
function errorUtils(baseErrors, errors2) {
  var exports2 = {
    ERROR_MESSAGES: extend(errors2, baseErrors),
    Error: function() {
      return makeError([].slice.call(arguments));
    },
    log: function(id) {
      var method = "log";
      if (/^E\d+$/.test(id)) {
        method = "error";
      } else if (/^W\d+$/.test(id)) {
        method = "warn";
      }
      logger[method](method === "log" ? id : combineMessage([].slice.call(arguments)));
    }
  };
  function combineMessage(args) {
    var id = args[0];
    args = args.slice(1);
    return formatMessage(id, formatDetails(id, args));
  }
  function formatDetails(id, args) {
    args = [exports2.ERROR_MESSAGES[id]].concat(args);
    return format.apply(this, args).replace(/\.*\s*?$/, "");
  }
  function formatMessage(id, details) {
    return format.apply(this, ["{0} - {1}. See:\n{2}", id, details, getErrorUrl(id)]);
  }
  function makeError(args) {
    var id = args[0];
    args = args.slice(1);
    var details = formatDetails(id, args);
    var url = getErrorUrl(id);
    var message = formatMessage(id, details);
    return extend(new Error(message), {
      __id: id,
      __details: details,
      url
    });
  }
  function getErrorUrl(id) {
    return ERROR_URL + id;
  }
  return exports2;
}
var errors$2 = errorUtils({
  E0001: "Method is not implemented",
  E0002: "Member name collision: {0}",
  E0003: "A class must be instantiated using the 'new' keyword",
  E0004: "The NAME property of the component is not specified",
  E0005: "Unknown device",
  E0006: "Unknown endpoint key is requested",
  E0007: "'Invalidate' method is called outside the update transaction",
  E0008: "Type of the option name is not appropriate to create an action",
  E0009: "Component '{0}' has not been initialized for an element",
  E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
  E0011: "Unknown animation type '{0}'",
  E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
  E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
  E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
  E0015: "Queued task returned an unexpected result",
  E0017: "Event namespace is not defined",
  E0018: "DevExpress.ui.DevExpressPopup widget is required",
  E0020: "Template engine '{0}' is not supported",
  E0021: "Unknown theme is set: {0}",
  E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
  E0023: "Template name is not specified",
  E0024: "DevExtreme bundle already included",
  E0025: "Unexpected argument type",
  E0100: "Unknown validation type is detected",
  E0101: "Misconfigured range validation rule is detected",
  E0102: "Misconfigured comparison validation rule is detected",
  E0103: "validationCallback of an asynchronous rule should return a jQuery or a native promise",
  E0110: "Unknown validation group is detected",
  E0120: "Adapter for a DevExpressValidator component cannot be configured",
  E0121: "The 'customItem' field of the 'onCustomItemCreating' function's parameter should contain a custom item or Promise that is resolved after the item is created.",
  W0000: "'{0}' is deprecated in {1}. {2}",
  W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
  W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
  W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
  W0004: "Timeout for theme loading is over: {0}",
  W0005: "'{0}' event is deprecated in {1}. {2}",
  W0006: "Invalid recurrence rule: '{0}'",
  W0007: "'{0}' Globalize culture is not defined",
  W0008: "Invalid view name: '{0}'",
  W0009: "Invalid time zone name: '{0}'",
  W0010: "{0} is deprecated in {1}. {2}",
  W0011: "Number parsing is invoked while the parser is not defined",
  W0012: "Date parsing is invoked while the parser is not defined",
  W0013: "'{0}' file is deprecated in {1}. {2}",
  W0014: "{0} - '{1}' type is deprecated in {2}. {3}",
  W0015: "Instead of returning a value from the '{0}' function, write it into the '{1}' field of the function's parameter.",
  W0016: 'The "{0}" option does not accept the "{1}" value since v.{2}. {3}.'
});
var wrapOverridden = function(baseProto, methodName, method) {
  return function() {
    var prevCallBase = this.callBase;
    this.callBase = baseProto[methodName];
    try {
      return method.apply(this, arguments);
    } finally {
      this.callBase = prevCallBase;
    }
  };
};
var clonePrototype = function(obj) {
  var func = function() {
  };
  func.prototype = obj.prototype;
  return new func();
};
var redefine = function(members) {
  var overridden;
  var memberName;
  var member;
  if (!members) {
    return this;
  }
  for (memberName in members) {
    member = members[memberName];
    overridden = typeof this.prototype[memberName] === "function" && typeof member === "function";
    this.prototype[memberName] = overridden ? wrapOverridden(this.parent.prototype, memberName, member) : member;
  }
  return this;
};
var include = function() {
  var classObj = this;
  var argument;
  var name2;
  var i;
  var hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
  var isES6Class = !hasClassObjOwnProperty("_includedCtors") && !hasClassObjOwnProperty("_includedPostCtors");
  if (isES6Class) {
    classObj._includedCtors = classObj._includedCtors.slice(0);
    classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
  }
  for (i = 0; i < arguments.length; i++) {
    argument = arguments[i];
    if (argument.ctor) {
      classObj._includedCtors.push(argument.ctor);
    }
    if (argument.postCtor) {
      classObj._includedPostCtors.push(argument.postCtor);
    }
    for (name2 in argument) {
      if (name2 === "ctor" || name2 === "postCtor" || name2 === "default") {
        continue;
      }
      classObj.prototype[name2] = argument[name2];
    }
  }
  return classObj;
};
var subclassOf = function(parentClass) {
  var hasParentProperty = Object.prototype.hasOwnProperty.bind(this)("parent");
  var isES6Class = !hasParentProperty && this.parent;
  if (isES6Class) {
    var baseClass = Object.getPrototypeOf(this);
    return baseClass === parentClass || baseClass.subclassOf(parentClass);
  } else {
    if (this.parent === parentClass) {
      return true;
    }
    if (!this.parent || !this.parent.subclassOf) {
      return false;
    }
    return this.parent.subclassOf(parentClass);
  }
};
var abstract$6 = function() {
  throw errors$2.Error("E0001");
};
var copyStatic = function() {
  var hasOwn = Object.prototype.hasOwnProperty;
  return function(source, destination) {
    for (var key in source) {
      if (!hasOwn.call(source, key)) {
        return;
      }
      destination[key] = source[key];
    }
  };
}();
var classImpl = function() {
};
classImpl.inherit = function(members) {
  var inheritor = function() {
    if (!this || isWindow(this) || typeof this.constructor !== "function") {
      throw errors$2.Error("E0003");
    }
    var instance = this;
    var ctor = instance.ctor;
    var includedCtors = instance.constructor._includedCtors;
    var includedPostCtors = instance.constructor._includedPostCtors;
    var i;
    for (i = 0; i < includedCtors.length; i++) {
      includedCtors[i].call(instance);
    }
    if (ctor) {
      ctor.apply(instance, arguments);
    }
    for (i = 0; i < includedPostCtors.length; i++) {
      includedPostCtors[i].call(instance);
    }
  };
  inheritor.prototype = clonePrototype(this);
  copyStatic(this, inheritor);
  inheritor.inherit = this.inherit;
  inheritor.abstract = abstract$6;
  inheritor.redefine = redefine;
  inheritor.include = include;
  inheritor.subclassOf = subclassOf;
  inheritor.parent = this;
  inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
  inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
  inheritor.prototype.constructor = inheritor;
  inheritor.redefine(members);
  return inheritor;
};
classImpl.abstract = abstract$6;
function injector(object) {
  var BaseClass = classImpl.inherit(object);
  var InjectedClass = BaseClass;
  var instance = new InjectedClass(object);
  var initialFields = {};
  var injectFields = function(injectionObject, initial) {
    each(injectionObject, function(key) {
      if (isFunction$1(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function() {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }
        object[key] = instance[key];
      }
    });
  };
  injectFields(object, true);
  object.inject = function(injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };
  object.resetInjection = function() {
    extend(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };
  return object;
}
var variableWrapper = injector({
  isWrapped: function() {
    return false;
  },
  isWritableWrapped: function() {
    return false;
  },
  wrap: function(value2) {
    return value2;
  },
  unwrap: function(value2) {
    return value2;
  },
  assign: function() {
    logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.");
  }
});
var orderEach = function(map2, func) {
  var keys2 = [];
  var key;
  var i;
  for (key in map2) {
    if (Object.prototype.hasOwnProperty.call(map2, key)) {
      keys2.push(key);
    }
  }
  keys2.sort(function(x, y) {
    var isNumberX = isNumeric(x);
    var isNumberY = isNumeric(y);
    if (isNumberX && isNumberY) {
      return x - y;
    }
    if (isNumberX && !isNumberY) {
      return -1;
    }
    if (!isNumberX && isNumberY) {
      return 1;
    }
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  });
  for (i = 0; i < keys2.length; i++) {
    key = keys2[i];
    func(key, map2[key]);
  }
};
var assignValueToProperty = function(target, property, value2, assignByReference) {
  if (!assignByReference && variableWrapper.isWrapped(target[property])) {
    variableWrapper.assign(target[property], value2);
  } else {
    target[property] = value2;
  }
};
var deepExtendArraySafe = function deepExtendArraySafe2(target, changes, extendComplexObject, assignByReference) {
  var prevValue;
  var newValue;
  for (var name2 in changes) {
    prevValue = target[name2];
    newValue = changes[name2];
    if (name2 === "__proto__" || name2 === "constructor" || target === newValue) {
      continue;
    }
    if (isPlainObject(newValue)) {
      var goDeeper = extendComplexObject ? isObject$1(prevValue) : isPlainObject(prevValue);
      newValue = deepExtendArraySafe2(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference);
    }
    if (newValue !== void 0 && prevValue !== newValue) {
      assignValueToProperty(target, name2, newValue, assignByReference);
    }
  }
  return target;
};
var config = {
  rtlEnabled: false,
  defaultCurrency: "USD",
  oDataFilterToLower: true,
  serverDecimalSeparator: ".",
  decimalSeparator: ".",
  thousandsSeparator: ",",
  forceIsoDateParsing: true,
  wrapActionsBeforeExecute: true,
  useLegacyStoreResult: false,
  useJQuery: void 0,
  editorStylingMode: void 0,
  useLegacyVisibleIndex: false,
  floatingActionButtonConfig: {
    icon: "add",
    closeIcon: "close",
    label: "",
    position: {
      at: "right bottom",
      my: "right bottom",
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: false,
    direction: "auto"
  },
  optionsParser: (optionsString) => {
    if (optionsString.trim().charAt(0) !== "{") {
      optionsString = "{" + optionsString + "}";
    }
    try {
      return new Function("return " + optionsString)();
    } catch (ex) {
      throw errors$2.Error("E3018", ex, optionsString);
    }
  }
};
var deprecatedFields = ["decimalSeparator", "thousandsSeparator"];
var configMethod = function() {
  if (!arguments.length) {
    return config;
  }
  var newConfig = arguments.length <= 0 ? void 0 : arguments[0];
  deprecatedFields.forEach((deprecatedField) => {
    if (newConfig[deprecatedField]) {
      var message = "Now, the ".concat(deprecatedField, " is selected based on the specified locale.");
      errors$2.log("W0003", "config", deprecatedField, "19.2", message);
    }
  });
  extend(config, newConfig);
};
if (typeof DevExpress !== "undefined" && DevExpress.config) {
  configMethod(DevExpress.config);
}
var Guid = classImpl.inherit({
  ctor: function(value2) {
    if (value2) {
      value2 = String(value2);
    }
    this._value = this._normalize(value2 || this._generate());
  },
  _normalize: function(value2) {
    value2 = value2.replace(/[^a-f0-9]/gi, "").toLowerCase();
    while (value2.length < 32) {
      value2 += "0";
    }
    return [value2.substr(0, 8), value2.substr(8, 4), value2.substr(12, 4), value2.substr(16, 4), value2.substr(20, 12)].join("-");
  },
  _generate: function() {
    var value2 = "";
    for (var i = 0; i < 32; i++) {
      value2 += Math.round(15 * Math.random()).toString(16);
    }
    return value2;
  },
  toString: function() {
    return this._value;
  },
  valueOf: function() {
    return this._value;
  },
  toJSON: function() {
    return this._value;
  }
});
var Callback = function(options) {
  this._options = options || {};
  this._list = [];
  this._queue = [];
  this._firing = false;
  this._fired = false;
  this._firingIndexes = [];
};
Callback.prototype._fireCore = function(context2, args) {
  var firingIndexes = this._firingIndexes;
  var list = this._list;
  var stopOnFalse = this._options.stopOnFalse;
  var step = firingIndexes.length;
  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
    var result = list[firingIndexes[step]].apply(context2, args);
    if (result === false && stopOnFalse) {
      break;
    }
  }
  firingIndexes.pop();
};
Callback.prototype.add = function(fn) {
  if (typeof fn === "function" && (!this._options.unique || !this.has(fn))) {
    this._list.push(fn);
  }
  return this;
};
Callback.prototype.remove = function(fn) {
  var list = this._list;
  var firingIndexes = this._firingIndexes;
  var index2 = list.indexOf(fn);
  if (index2 > -1) {
    list.splice(index2, 1);
    if (this._firing && firingIndexes.length) {
      for (var step = 0; step < firingIndexes.length; step++) {
        if (index2 <= firingIndexes[step]) {
          firingIndexes[step]--;
        }
      }
    }
  }
  return this;
};
Callback.prototype.has = function(fn) {
  var list = this._list;
  return fn ? list.indexOf(fn) > -1 : !!list.length;
};
Callback.prototype.empty = function(fn) {
  this._list = [];
  return this;
};
Callback.prototype.fireWith = function(context2, args) {
  var queue = this._queue;
  args = args || [];
  args = args.slice ? args.slice() : args;
  if (this._options.syncStrategy) {
    this._firing = true;
    this._fireCore(context2, args);
  } else {
    queue.push([context2, args]);
    if (this._firing) {
      return;
    }
    this._firing = true;
    while (queue.length) {
      var memory = queue.shift();
      this._fireCore(memory[0], memory[1]);
    }
  }
  this._firing = false;
  this._fired = true;
  return this;
};
Callback.prototype.fire = function() {
  this.fireWith(this, arguments);
};
Callback.prototype.fired = function() {
  return this._fired;
};
var Callbacks = function(options) {
  return new Callback(options);
};
var deferredConfig = [{
  method: "resolve",
  handler: "done",
  state: "resolved"
}, {
  method: "reject",
  handler: "fail",
  state: "rejected"
}, {
  method: "notify",
  handler: "progress"
}];
var _DeferredObj = function() {
  var that = this;
  this._state = "pending";
  this._promise = {};
  deferredConfig.forEach(function(config2) {
    var methodName = config2.method;
    this[methodName + "Callbacks"] = new Callbacks();
    this[methodName] = function() {
      return this[methodName + "With"](this._promise, arguments);
    }.bind(this);
    this._promise[config2.handler] = function(handler) {
      if (!handler) {
        return this;
      }
      var callbacks2 = that[methodName + "Callbacks"];
      if (callbacks2.fired()) {
        handler.apply(that[methodName + "Context"], that[methodName + "Args"]);
      } else {
        callbacks2.add(function(context2, args) {
          handler.apply(context2, args);
        }.bind(this));
      }
      return this;
    };
  }.bind(this));
  this._promise.always = function(handler) {
    return this.done(handler).fail(handler);
  };
  this._promise.catch = function(handler) {
    return this.then(null, handler);
  };
  this._promise.then = function(resolve, reject) {
    var result = new _DeferredObj();
    ["done", "fail"].forEach(function(method) {
      var callback = method === "done" ? resolve : reject;
      this[method](function() {
        if (!callback) {
          result[method === "done" ? "resolve" : "reject"].apply(this, arguments);
          return;
        }
        var callbackResult = callback && callback.apply(this, arguments);
        if (isDeferred(callbackResult)) {
          callbackResult.done(result.resolve).fail(result.reject);
        } else if (isPromise$1(callbackResult)) {
          callbackResult.then(result.resolve, result.reject);
        } else {
          result.resolve.apply(this, isDefined(callbackResult) ? [callbackResult] : arguments);
        }
      });
    }.bind(this));
    return result.promise();
  };
  this._promise.state = function() {
    return that._state;
  };
  this._promise.promise = function(args) {
    return args ? extend(args, that._promise) : that._promise;
  };
  this._promise.promise(this);
};
deferredConfig.forEach(function(config2) {
  var methodName = config2.method;
  var state = config2.state;
  _DeferredObj.prototype[methodName + "With"] = function(context2, args) {
    var callbacks2 = this[methodName + "Callbacks"];
    if (this.state() === "pending") {
      this[methodName + "Args"] = args;
      this[methodName + "Context"] = context2;
      if (state) {
        this._state = state;
      }
      callbacks2.fire(context2, args);
    }
    return this;
  };
});
function fromPromise(promise2, context2) {
  if (isDeferred(promise2)) {
    return promise2;
  } else if (isPromise$1(promise2)) {
    var d = new _DeferredObj();
    promise2.then(function() {
      d.resolveWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    }, function() {
      d.rejectWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    });
    return d;
  }
  return new _DeferredObj().resolveWith(context2, [promise2]);
}
var whenFunc = function() {
  if (arguments.length === 1) {
    return fromPromise(arguments[0]);
  }
  var values = [].slice.call(arguments);
  var contexts = [];
  var resolvedCount = 0;
  var deferred = new _DeferredObj();
  var updateState = function(i2) {
    return function(value2) {
      contexts[i2] = this;
      values[i2] = arguments.length > 1 ? [].slice.call(arguments) : value2;
      resolvedCount++;
      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
    };
  };
  for (var i = 0; i < values.length; i++) {
    if (isDeferred(values[i])) {
      values[i].promise().done(updateState(i)).fail(deferred.reject);
    } else {
      resolvedCount++;
    }
  }
  if (resolvedCount === values.length) {
    deferred.resolveWith(contexts, values);
  }
  return deferred.promise();
};
function Deferred() {
  return new _DeferredObj();
}
function when() {
  return whenFunc.apply(this, arguments);
}
var unwrapVariable = variableWrapper.unwrap;
var isWrapped = variableWrapper.isWrapped;
var assign = variableWrapper.assign;
var bracketsToDots = function(expr) {
  return expr.replace(/\[/g, ".").replace(/\]/g, "");
};
var readPropValue = function(obj, propName, options) {
  options = options || {};
  if (propName === "this") {
    return unwrap(obj, options);
  }
  return unwrap(obj[propName], options);
};
var assignPropValue = function(obj, propName, value2, options) {
  if (propName === "this") {
    throw new errors$2.Error("E4016");
  }
  var propValue = obj[propName];
  if (options.unwrapObservables && isWrapped(propValue)) {
    assign(propValue, value2);
  } else {
    obj[propName] = value2;
  }
};
var prepareOptions = function(options) {
  options = options || {};
  options.unwrapObservables = options.unwrapObservables !== void 0 ? options.unwrapObservables : true;
  return options;
};
function unwrap(value2, options) {
  return options.unwrapObservables ? unwrapVariable(value2) : value2;
}
var compileGetter = function(expr) {
  if (arguments.length > 1) {
    expr = [].slice.call(arguments);
  }
  if (!expr || expr === "this") {
    return function(obj) {
      return obj;
    };
  }
  if (typeof expr === "string") {
    expr = bracketsToDots(expr);
    var path = expr.split(".");
    return function(obj, options) {
      options = prepareOptions(options);
      var functionAsIs = options.functionsAsIs;
      var hasDefaultValue = "defaultValue" in options;
      var current2 = unwrap(obj, options);
      for (var i = 0; i < path.length; i++) {
        if (!current2) {
          if (current2 == null && hasDefaultValue) {
            return options.defaultValue;
          }
          break;
        }
        var pathPart = path[i];
        if (hasDefaultValue && isObject$1(current2) && !(pathPart in current2)) {
          return options.defaultValue;
        }
        var next = unwrap(current2[pathPart], options);
        if (!functionAsIs && isFunction$1(next)) {
          next = next.call(current2);
        }
        current2 = next;
      }
      return current2;
    };
  }
  if (Array.isArray(expr)) {
    return combineGetters(expr);
  }
  if (isFunction$1(expr)) {
    return expr;
  }
};
function combineGetters(getters) {
  var compiledGetters = {};
  for (var i = 0, l = getters.length; i < l; i++) {
    var getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }
  return function(obj, options) {
    var result;
    each(compiledGetters, function(name2) {
      var value2 = this(obj, options);
      if (value2 === void 0) {
        return;
      }
      var current2 = result || (result = {});
      var path = name2.split(".");
      var last = path.length - 1;
      for (var _i = 0; _i < last; _i++) {
        var pathItem = path[_i];
        if (!(pathItem in current2)) {
          current2[pathItem] = {};
        }
        current2 = current2[pathItem];
      }
      current2[path[last]] = value2;
    });
    return result;
  };
}
var ensurePropValueDefined = function(obj, propName, value2, options) {
  if (isDefined(value2)) {
    return value2;
  }
  var newValue = {};
  assignPropValue(obj, propName, newValue, options);
  return newValue;
};
var compileSetter = function(expr) {
  expr = bracketsToDots(expr || "this").split(".");
  var lastLevelIndex = expr.length - 1;
  return function(obj, value2, options) {
    options = prepareOptions(options);
    var currentValue = unwrap(obj, options);
    expr.forEach(function(propertyName, levelIndex) {
      var propertyValue = readPropValue(currentValue, propertyName, options);
      var isPropertyFunc = !options.functionsAsIs && isFunction$1(propertyValue) && !isWrapped(propertyValue);
      if (levelIndex === lastLevelIndex) {
        if (options.merge && isPlainObject(value2) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {
          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
          deepExtendArraySafe(propertyValue, value2, false, true);
        } else if (isPropertyFunc) {
          currentValue[propertyName](value2);
        } else {
          assignPropValue(currentValue, propertyName, value2, options);
        }
      } else {
        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
        if (isPropertyFunc) {
          propertyValue = propertyValue.call(currentValue);
        }
        currentValue = propertyValue;
      }
    });
  };
};
var toComparable = function(value2, caseSensitive) {
  if (value2 instanceof Date) {
    return value2.getTime();
  }
  if (value2 && value2 instanceof classImpl && value2.valueOf) {
    return value2.valueOf();
  }
  if (!caseSensitive && typeof value2 === "string") {
    return value2.toLowerCase();
  }
  return value2;
};
var ensureDefined = function(value2, defaultValue) {
  return isDefined(value2) ? value2 : defaultValue;
};
var executeAsync = function(action, context2) {
  var deferred = new Deferred();
  var normalizedContext = context2 || this;
  var task = {
    promise: deferred.promise(),
    abort: function() {
      clearTimeout(timerId);
      deferred.rejectWith(normalizedContext);
    }
  };
  var callback = function() {
    var result = action.call(normalizedContext);
    if (result && result.done && isFunction$1(result.done)) {
      result.done(function() {
        deferred.resolveWith(normalizedContext);
      });
    } else {
      deferred.resolveWith(normalizedContext);
    }
  };
  var timerId = (arguments[2] || setTimeout)(callback, typeof context2 === "number" ? context2 : 0);
  return task;
};
var delayedFuncs = [];
var delayedNames = [];
var delayedDeferreds = [];
var executingName;
var deferExecute = function(name2, func, deferred) {
  if (executingName && executingName !== name2) {
    delayedFuncs.push(func);
    delayedNames.push(name2);
    deferred = deferred || new Deferred();
    delayedDeferreds.push(deferred);
    return deferred;
  } else {
    var oldExecutingName = executingName;
    var currentDelayedCount = delayedDeferreds.length;
    executingName = name2;
    var result = func();
    if (!result) {
      if (delayedDeferreds.length > currentDelayedCount) {
        result = when.apply(this, delayedDeferreds.slice(currentDelayedCount));
      } else if (deferred) {
        deferred.resolve();
      }
    }
    executingName = oldExecutingName;
    if (deferred && result && result.done) {
      result.done(deferred.resolve).fail(deferred.reject);
    }
    if (!executingName && delayedFuncs.length) {
      (delayedNames.shift() === "render" ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
    }
    return result || when();
  }
};
var deferRender = function(func, deferred) {
  return deferExecute("render", func, deferred);
};
var deferUpdate = function(func, deferred) {
  return deferExecute("update", func, deferred);
};
var deferRenderer = function(func) {
  return function() {
    var that = this;
    return deferExecute("render", function() {
      return func.call(that);
    });
  };
};
var deferUpdater = function(func) {
  return function() {
    var that = this;
    return deferExecute("update", function() {
      return func.call(that);
    });
  };
};
var findBestMatches = function(targetFilter, items, mapFn) {
  var bestMatches = [];
  var maxMatchCount = 0;
  each(items, (index2, itemSrc) => {
    var matchCount = 0;
    var item = mapFn ? mapFn(itemSrc) : itemSrc;
    each(targetFilter, (paramName, targetValue) => {
      var value2 = item[paramName];
      if (value2 === void 0) {
        return;
      }
      if (match(value2, targetValue)) {
        matchCount++;
        return;
      }
      matchCount = -1;
      return false;
    });
    if (matchCount < maxMatchCount) {
      return;
    }
    if (matchCount > maxMatchCount) {
      bestMatches.length = 0;
      maxMatchCount = matchCount;
    }
    bestMatches.push(itemSrc);
  });
  return bestMatches;
};
var match = function(value2, targetValue) {
  if (Array.isArray(value2) && Array.isArray(targetValue)) {
    var mismatch = false;
    each(value2, (index2, valueItem) => {
      if (valueItem !== targetValue[index2]) {
        mismatch = true;
        return false;
      }
    });
    if (mismatch) {
      return false;
    }
    return true;
  }
  if (value2 === targetValue) {
    return true;
  }
  return false;
};
var splitPair = function(raw) {
  var _raw$x, _raw$y;
  switch (type(raw)) {
    case "string":
      return raw.split(/\s+/, 2);
    case "object":
      return [(_raw$x = raw.x) !== null && _raw$x !== void 0 ? _raw$x : raw.h, (_raw$y = raw.y) !== null && _raw$y !== void 0 ? _raw$y : raw.v];
    case "number":
      return [raw];
    case "array":
      return raw;
    default:
      return null;
  }
};
var pairToObject = function(raw, preventRound) {
  var pair = splitPair(raw);
  var h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
  var v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
  if (!isFinite(h)) {
    h = 0;
  }
  if (!isFinite(v)) {
    v = h;
  }
  return {
    h,
    v
  };
};
var getKeyHash = function(key) {
  if (key instanceof Guid) {
    return key.toString();
  } else if (isObject$1(key) || Array.isArray(key)) {
    try {
      var keyHash = JSON.stringify(key);
      return keyHash === "{}" ? key : keyHash;
    } catch (e) {
      return key;
    }
  }
  return key;
};
var escapeRegExp = function(string) {
  return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, "\\$&");
};
var noop = function() {
};
var asyncNoop = function() {
  return new Deferred().resolve().promise();
};
var grep = function(elements, checkFunction, invert) {
  var result = [];
  var check;
  var expectedCheck = !invert;
  for (var i = 0; i < elements.length; i++) {
    check = !!checkFunction(elements[i], i);
    if (check === expectedCheck) {
      result.push(elements[i]);
    }
  }
  return result;
};
var arraysEqualByValue = function(array1, array2, depth) {
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i = 0; i < array1.length; i++) {
    if (!equalByValue(array1[i], array2[i], depth + 1)) {
      return false;
    }
  }
  return true;
};
var objectsEqualByValue = function(object1, object2, depth, strict) {
  for (var propertyName in object1) {
    if (Object.prototype.hasOwnProperty.call(object1, propertyName) && !equalByValue(object1[propertyName], object2[propertyName], depth + 1, strict)) {
      return false;
    }
  }
  for (var _propertyName in object2) {
    if (!(_propertyName in object1)) {
      return false;
    }
  }
  return true;
};
var maxEqualityDepth = 3;
var equalByValue = function(object1, object2) {
  var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var strict = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  object1 = toComparable(object1, true);
  object2 = toComparable(object2, true);
  var comparisonResult = strict ? object1 === object2 : object1 == object2;
  if (comparisonResult || depth >= maxEqualityDepth) {
    return true;
  }
  if (isObject$1(object1) && isObject$1(object2)) {
    return objectsEqualByValue(object1, object2, depth, strict);
  } else if (Array.isArray(object1) && Array.isArray(object2)) {
    return arraysEqualByValue(object1, object2, depth);
  }
  return false;
};
var ELEMENT_NODE = 1;
var TEXT_NODE$1 = 3;
var DOCUMENT_NODE = 9;
var nativeDOMAdapterStrategy = {
  querySelectorAll: (element, selector) => element.querySelectorAll(selector),
  elementMatches(element, selector) {
    var matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || ((selector2) => {
      var doc = element.document || element.ownerDocument;
      if (!doc) {
        return false;
      }
      var items = this.querySelectorAll(doc, selector2);
      for (var i = 0; i < items.length; i++) {
        if (items[i] === element) {
          return true;
        }
      }
    });
    return matches.call(element, selector);
  },
  createElement(tagName, context2) {
    context2 = context2 || this._document;
    return context2.createElement(tagName);
  },
  createElementNS(ns, tagName, context2) {
    context2 = context2 || this._document;
    return context2.createElementNS(ns, tagName);
  },
  createTextNode(text, context2) {
    context2 = context2 || this._document;
    return context2.createTextNode(text);
  },
  isNode: (element) => element && typeof element === "object" && "nodeType" in element && "nodeName" in element,
  isElementNode: (element) => element && element.nodeType === ELEMENT_NODE,
  isTextNode: (element) => element && element.nodeType === TEXT_NODE$1,
  isDocument: (element) => element && element.nodeType === DOCUMENT_NODE,
  removeElement(element) {
    var parentNode = element && element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  },
  insertElement(parentElement, newElement, nextSiblingElement) {
    if (parentElement && newElement && parentElement !== newElement) {
      if (nextSiblingElement) {
        parentElement.insertBefore(newElement, nextSiblingElement);
      } else {
        parentElement.appendChild(newElement);
      }
    }
  },
  getAttribute: (element, name2) => element.getAttribute(name2),
  setAttribute(element, name2, value2) {
    element.setAttribute(name2, value2);
  },
  removeAttribute(element, name2) {
    element.removeAttribute(name2);
  },
  setProperty(element, name2, value2) {
    element[name2] = value2;
  },
  setText(element, text) {
    if (element) {
      element.textContent = text;
    }
  },
  setClass(element, className, isAdd) {
    if (element.nodeType === 1 && className) {
      if (element.classList) {
        if (isAdd) {
          element.classList.add(className);
        } else {
          element.classList.remove(className);
        }
      } else {
        var classNameSupported = typeof element.className === "string";
        var elementClass = classNameSupported ? element.className : this.getAttribute(element, "class") || "";
        var classNames = elementClass.split(" ");
        var classIndex = classNames.indexOf(className);
        var resultClassName;
        if (isAdd && classIndex < 0) {
          resultClassName = elementClass ? elementClass + " " + className : className;
        }
        if (!isAdd && classIndex >= 0) {
          classNames.splice(classIndex, 1);
          resultClassName = classNames.join(" ");
        }
        if (resultClassName !== void 0) {
          if (classNameSupported) {
            element.className = resultClassName;
          } else {
            this.setAttribute(element, "class", resultClassName);
          }
        }
      }
    }
  },
  setStyle(element, name2, value2) {
    element.style[name2] = value2 || "";
  },
  _document: typeof document === "undefined" ? void 0 : document,
  getDocument() {
    return this._document;
  },
  getActiveElement() {
    return this._document.activeElement;
  },
  getBody() {
    return this._document.body;
  },
  createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation() {
    return this._document.location;
  },
  getSelection() {
    return this._document.selection;
  },
  getReadyState() {
    return this._document.readyState;
  },
  getHead() {
    return this._document.head;
  },
  hasDocumentProperty(property) {
    return property in this._document;
  },
  listen(element, event, callback, options) {
    if (!element || !("addEventListener" in element)) {
      return noop;
    }
    element.addEventListener(event, callback, options);
    return () => {
      element.removeEventListener(event, callback);
    };
  }
};
var domAdapter = injector(nativeDOMAdapterStrategy);
var hasWindowValue = typeof window !== "undefined";
var hasWindow$1 = () => hasWindowValue;
var windowObject = hasWindow$1() ? window : void 0;
if (!windowObject) {
  windowObject = {};
  windowObject.window = windowObject;
}
var getWindow = () => windowObject;
var hasProperty = (prop) => hasWindow$1() && prop in windowObject;
var getNavigator = () => hasWindow$1() ? windowObject.navigator : {
  userAgent: ""
};
var navigator$5 = getNavigator();
var webkitRegExp = /(webkit)[ /]([\w.]+)/;
var ieRegExp = /(msie) (\d{1,2}\.\d)/;
var ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/;
var msEdge = /(edge)\/((\d+)?[\w.]+)/;
var mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
var browserFromUA = function(ua2) {
  ua2 = ua2.toLowerCase();
  var result = {};
  var matches = ieRegExp.exec(ua2) || ie11RegExp.exec(ua2) || msEdge.exec(ua2) || ua2.indexOf("compatible") < 0 && mozillaRegExp.exec(ua2) || webkitRegExp.exec(ua2) || [];
  var browserName = matches[1];
  var browserVersion = matches[2];
  if (browserName === "webkit") {
    result.webkit = true;
    if (ua2.indexOf("chrome") >= 0 || ua2.indexOf("crios") >= 0) {
      browserName = "chrome";
      browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua2);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua2.indexOf("fxios") >= 0) {
      browserName = "mozilla";
      browserVersion = /fxios\/(\d+\.\d+)/.exec(ua2);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua2.indexOf("safari") >= 0 && /version|phantomjs/.test(ua2)) {
      browserName = "safari";
      browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua2);
      browserVersion = browserVersion && browserVersion[1];
    } else {
      browserName = "unknown";
      browserVersion = /applewebkit\/([0-9.]+)/.exec(ua2);
      browserVersion = browserVersion && browserVersion[1];
    }
  }
  if (browserName === "trident" || browserName === "edge") {
    browserName = "msie";
  }
  if (browserName) {
    result[browserName] = true;
    result.version = browserVersion;
  }
  return result;
};
var coreBrowserUtils = extend({
  _fromUA: browserFromUA
}, browserFromUA(navigator$5.userAgent));
var isIE11$2 = coreBrowserUtils.msie && parseInt(coreBrowserUtils.version) <= 11;
var isEmpty = function(entity) {
  return Array.isArray(entity) && !entity.length;
};
var wrapToArray = function(entity) {
  return Array.isArray(entity) ? entity : [entity];
};
var inArray = function(value2, object) {
  if (!object) {
    return -1;
  }
  var array = Array.isArray(object) ? object : object.toArray();
  return array.indexOf(value2);
};
var uniqueValues = function(data2) {
  if (isIE11$2) {
    return data2.filter(function(item, position2) {
      return data2.indexOf(item) === position2;
    });
  }
  return [...new Set(data2)];
};
var removeDuplicates = function(from, what) {
  if (!Array.isArray(from) || from.length === 0) {
    return [];
  }
  var result = from.slice();
  if (!Array.isArray(what) || what.length === 0) {
    return result;
  }
  each(what, function(_2, value2) {
    var index2 = inArray(value2, result);
    result.splice(index2, 1);
  });
  return result;
};
var normalizeIndexes = function(items, indexParameterName, currentItem, needIndexCallback) {
  var indexedItems = {};
  var parameterIndex = 0;
  var useLegacyVisibleIndex = configMethod().useLegacyVisibleIndex;
  each(items, function(index2, item) {
    index2 = item[indexParameterName];
    if (index2 >= 0) {
      indexedItems[index2] = indexedItems[index2] || [];
      if (item === currentItem) {
        indexedItems[index2].unshift(item);
      } else {
        indexedItems[index2].push(item);
      }
    } else {
      item[indexParameterName] = void 0;
    }
  });
  if (!useLegacyVisibleIndex) {
    each(items, function() {
      if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
        while (indexedItems[parameterIndex]) {
          parameterIndex++;
        }
        indexedItems[parameterIndex] = [this];
        parameterIndex++;
      }
    });
  }
  parameterIndex = 0;
  orderEach(indexedItems, function(index2, items2) {
    each(items2, function() {
      if (index2 >= 0) {
        this[indexParameterName] = parameterIndex++;
      }
    });
  });
  if (useLegacyVisibleIndex) {
    each(items, function() {
      if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
        this[indexParameterName] = parameterIndex++;
      }
    });
  }
  return parameterIndex;
};
var merge = function(array1, array2) {
  for (var i = 0; i < array2.length; i++) {
    array1[array1.length] = array2[i];
  }
  return array1;
};
var find = function(array, condition) {
  for (var i = 0; i < array.length; i++) {
    if (condition(array[i])) {
      return array[i];
    }
  }
};
var groupBy = (array, cb) => array.reduce((result, item) => _extends({}, result, {
  [cb(item)]: [...result[cb(item)] || [], item]
}), {});
var weakMap = hasWindow$1() ? getWindow().WeakMap : WeakMap;
if (!weakMap) {
  weakMap = function() {
    var keys2 = [];
    var values = [];
    this.set = function(key, value2) {
      var index2 = inArray(key, keys2);
      if (index2 === -1) {
        keys2.push(key);
        values.push(value2);
      } else {
        values[index2] = value2;
      }
    };
    this.get = function(key) {
      var index2 = inArray(key, keys2);
      if (index2 === -1) {
        return;
      }
      return values[index2];
    };
    this.has = function(key) {
      var index2 = inArray(key, keys2);
      if (index2 === -1) {
        return false;
      }
      return true;
    };
    this.delete = function(key) {
      var index2 = inArray(key, keys2);
      if (index2 === -1) {
        return;
      }
      keys2.splice(index2, 1);
      values.splice(index2, 1);
    };
  };
}
var WeakMap$3 = weakMap;
class MemorizedCallbacks {
  constructor() {
    this.memory = [];
    this.callbacks = Callbacks();
  }
  add(fn) {
    each(this.memory, (_2, item) => fn.apply(fn, item));
    this.callbacks.add(fn);
  }
  remove(fn) {
    this.callbacks.remove(fn);
  }
  fire() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.memory.push(args);
    this.callbacks.fire.apply(this.callbacks, args);
  }
}
var callbacks$2 = new MemorizedCallbacks();
var touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
var touchPropHook = function(name2, event) {
  if (event[name2] && !event.touches || !event.touches) {
    return event[name2];
  }
  var touches = event.touches.length ? event.touches : event.changedTouches;
  if (!touches.length) {
    return;
  }
  return touches[0][name2];
};
function hookTouchProps(callback) {
  touchPropsToHook.forEach(function(name2) {
    callback(name2, function(event) {
      return touchPropHook(name2, event);
    });
  }, this);
}
var callOnce = function(handler) {
  var result;
  var _wrappedHandler = function() {
    result = handler.apply(this, arguments);
    _wrappedHandler = function() {
      return result;
    };
    return result;
  };
  return function() {
    return _wrappedHandler.apply(this, arguments);
  };
};
var window$m = getWindow();
var EMPTY_EVENT_NAME = "dxEmptyEventType";
var NATIVE_EVENTS_TO_SUBSCRIBE = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
};
var NATIVE_EVENTS_TO_TRIGGER = {
  focusin: "focus",
  focusout: "blur"
};
var NO_BUBBLE_EVENTS = ["blur", "focus", "load"];
var forcePassiveFalseEventNames = ["touchmove", "wheel", "mousewheel", "touchstart"];
function matchesSafe(target, selector) {
  return !isWindow(target) && target.nodeName !== "#document" && domAdapter.elementMatches(target, selector);
}
var elementDataMap = new WeakMap$3();
var guid = 0;
var skipEvent;
var special = function() {
  var specialData = {};
  callbacks$2.add(function(eventName, eventObject) {
    specialData[eventName] = eventObject;
  });
  return {
    getField: function(eventName, field) {
      return specialData[eventName] && specialData[eventName][field];
    },
    callMethod: function(eventName, methodName, context2, args) {
      return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context2, args);
    }
  };
}();
var eventsEngine = injector({
  on: getHandler(normalizeOnArguments(iterate(function(element, eventName, selector, data2, handler) {
    var handlersController = getHandlersController(element, eventName);
    handlersController.addHandler(handler, selector, data2);
  }))),
  one: getHandler(normalizeOnArguments(function(element, eventName, selector, data2, handler) {
    eventsEngine.on(element, eventName, selector, data2, function oneTimeHandler() {
      eventsEngine.off(element, eventName, selector, oneTimeHandler);
      handler.apply(this, arguments);
    });
  })),
  off: getHandler(normalizeOffArguments(iterate(function(element, eventName, selector, handler) {
    var handlersController = getHandlersController(element, eventName);
    handlersController.removeHandler(handler, selector);
  }))),
  trigger: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
    var eventName = event.type;
    var handlersController = getHandlersController(element, event.type);
    special.callMethod(eventName, "trigger", element, [event, extraParameters]);
    handlersController.callHandlers(event, extraParameters);
    var noBubble = special.getField(eventName, "noBubble") || event.isPropagationStopped() || NO_BUBBLE_EVENTS.indexOf(eventName) !== -1;
    if (!noBubble) {
      var parents = [];
      !function getParents(element2) {
        var parent = element2.parentNode;
        if (parent) {
          parents.push(parent);
          getParents(parent);
        }
      }(element);
      parents.push(window$m);
      var i = 0;
      while (parents[i] && !event.isPropagationStopped()) {
        var parentDataByEvent = getHandlersController(parents[i], event.type);
        parentDataByEvent.callHandlers(extend(event, {
          currentTarget: parents[i]
        }), extraParameters);
        i++;
      }
    }
    if (element.nodeType || isWindow(element)) {
      special.callMethod(eventName, "_default", element, [event, extraParameters]);
      callNativeMethod(eventName, element);
    }
  })),
  triggerHandler: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
    var handlersController = getHandlersController(element, event.type);
    handlersController.callHandlers(event, extraParameters);
  }))
});
function applyForEach(args, method) {
  var element = args[0];
  if (!element) {
    return;
  }
  if (domAdapter.isNode(element) || isWindow(element)) {
    method.apply(eventsEngine, args);
  } else if (!isString$1(element) && "length" in element) {
    var itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, function(itemElement) {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw errors$2.Error("E0025");
  }
}
function getHandler(method) {
  return function() {
    applyForEach(arguments, method);
  };
}
function detectPassiveEventHandlersSupport() {
  var isSupported = false;
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        isSupported = true;
        return true;
      }
    });
    window$m.addEventListener("test", null, options);
  } catch (e) {
  }
  return isSupported;
}
var passiveEventHandlersSupported = callOnce(detectPassiveEventHandlersSupport);
var contains$1 = (container, element) => {
  if (isWindow(container)) {
    return contains$1(container.document, element);
  }
  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};
function getHandlersController(element, eventName) {
  var elementData = elementDataMap.get(element);
  eventName = eventName || "";
  var eventNameParts = eventName.split(".");
  var namespaces = eventNameParts.slice(1);
  var eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }
  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }
  var eventData2 = elementData[eventName];
  return {
    addHandler: function(handler, selector, data2) {
      var callHandler = function(e, extraParameters) {
        var handlerArgs = [e];
        var target = e.currentTarget;
        var relatedTarget = e.relatedTarget;
        var secondaryTargetIsInside;
        var result;
        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains$1(target, relatedTarget));
        }
        if (extraParameters !== void 0) {
          handlerArgs.push(extraParameters);
        }
        special.callMethod(eventName, "handle", element, [e, data2]);
        if (!secondaryTargetIsInside) {
          result = handler.apply(target, handlerArgs);
        }
        if (result === false) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      var handleObject = {
        handler,
        wrappedHandler: function(e, extraParameters) {
          if (skipEvent && e.type === skipEvent) {
            return;
          }
          e.data = data2;
          e.delegateTarget = element;
          if (selector) {
            var currentTarget = e.target;
            while (currentTarget && currentTarget !== element) {
              if (matchesSafe(currentTarget, selector)) {
                e.currentTarget = currentTarget;
                callHandler(e, extraParameters);
              }
              currentTarget = currentTarget.parentNode;
            }
          } else {
            e.currentTarget = e.delegateTarget || e.target;
            callHandler(e, extraParameters);
          }
        },
        selector,
        type: eventName,
        data: data2,
        namespace: namespaces.join("."),
        namespaces,
        guid: ++guid
      };
      eventData2.handleObjects.push(handleObject);
      var firstHandlerForTheType = eventData2.handleObjects.length === 1;
      var shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      var nativeListenerOptions;
      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, "setup", element, [data2, namespaces, handler]);
      }
      if (shouldAddNativeListener) {
        eventData2.nativeHandler = getNativeHandler(eventName);
        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.indexOf(eventName) > -1) {
          nativeListenerOptions = {
            passive: false
          };
        }
        eventData2.removeListener = domAdapter.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData2.nativeHandler, nativeListenerOptions);
      }
      special.callMethod(eventName, "add", element, [handleObject]);
    },
    removeHandler: function(handler, selector) {
      var removeByEventName = function(eventName2) {
        var eventData3 = elementData[eventName2];
        if (!eventData3.handleObjects.length) {
          delete elementData[eventName2];
          return;
        }
        var removedHandler;
        eventData3.handleObjects = eventData3.handleObjects.filter(function(handleObject) {
          var skip = namespaces.length && !isSubset(handleObject.namespaces, namespaces) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName2, "remove", element, [handleObject]);
          }
          return skip;
        });
        var lastHandlerForTheType = !eventData3.handleObjects.length;
        var shouldRemoveNativeListener = lastHandlerForTheType && eventName2 !== EMPTY_EVENT_NAME;
        if (shouldRemoveNativeListener) {
          special.callMethod(eventName2, "teardown", element, [namespaces, removedHandler]);
          if (eventData3.nativeHandler) {
            eventData3.removeListener();
          }
          delete elementData[eventName2];
        }
      };
      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        for (var name2 in elementData) {
          removeByEventName(name2);
        }
      }
      var elementDataIsEmpty = Object.keys(elementData).length === 0;
      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers: function(event, extraParameters) {
      var forceStop = false;
      var handleCallback = function(handleObject) {
        if (forceStop) {
          return;
        }
        if (!namespaces.length || isSubset(handleObject.namespaces, namespaces)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };
      eventData2.handleObjects.forEach(handleCallback);
      if (namespaces.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}
function getNativeHandler(subscribeName) {
  return function(event, extraParameters) {
    var handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}
function isSubset(original, checked) {
  for (var i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) {
      return false;
    }
  }
  return true;
}
function normalizeOnArguments(callback) {
  return function(element, eventName, selector, data2, handler) {
    if (!handler) {
      handler = data2;
      data2 = void 0;
    }
    if (typeof selector !== "string") {
      data2 = selector;
      selector = void 0;
    }
    if (!handler && typeof eventName === "string") {
      handler = data2 || selector;
      selector = void 0;
      data2 = void 0;
    }
    callback(element, eventName, selector, data2, handler);
  };
}
function normalizeOffArguments(callback) {
  return function(element, eventName, selector, handler) {
    if (typeof selector === "function") {
      handler = selector;
      selector = void 0;
    }
    callback(element, eventName, selector, handler);
  };
}
function normalizeTriggerArguments(callback) {
  return function(element, src, extraParameters) {
    if (typeof src === "string") {
      src = {
        type: src
      };
    }
    if (!src.target) {
      src.target = element;
    }
    src.currentTarget = element;
    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }
    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }
    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}
function normalizeEventArguments(callback) {
  return function(src, config2) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config2);
    }
    if (!src) {
      src = {};
    }
    if (typeof src === "string") {
      src = {
        type: src
      };
    }
    if (!config2) {
      config2 = {};
    }
    callback.call(this, src, config2);
  };
}
function iterate(callback) {
  var iterateEventNames = function(element, eventName) {
    if (eventName && eventName.indexOf(" ") > -1) {
      var args = Array.prototype.slice.call(arguments, 0);
      eventName.split(" ").forEach(function(eventName2) {
        args[1] = eventName2;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };
  return function(element, eventName) {
    if (typeof eventName === "object") {
      var args = Array.prototype.slice.call(arguments, 0);
      for (var name2 in eventName) {
        args[1] = name2;
        args[args.length - 1] = eventName[name2];
        iterateEventNames.apply(this, args);
      }
    } else {
      iterateEventNames.apply(this, arguments);
    }
  };
}
function callNativeMethod(eventName, element) {
  var nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
  if (function(eventName2, element2) {
    return eventName2 === "click" && element2.localName === "a";
  }(eventName, element)) {
    return;
  }
  if (isFunction$1(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = void 0;
  }
}
function calculateWhich(event) {
  if (function(event2) {
    return event2.which == null && event2.type.indexOf("key") === 0;
  }(event)) {
    return event.charCode != null ? event.charCode : event.keyCode;
  }
  if (function(event2) {
    return !event2.which && event2.button !== void 0 && /^(?:mouse|pointer|contextmenu|drag|drop)|click/.test(event2.type);
  }(event)) {
    return {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    }[event.button];
  }
  return event.which;
}
function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}
initEvent(normalizeEventArguments(function(src, config2) {
  var that = this;
  var propagationStopped = false;
  var immediatePropagationStopped = false;
  var defaultPrevented = false;
  extend(that, src);
  if (src instanceof eventsEngine.Event || hasWindow$1() && src instanceof window$m.Event) {
    that.originalEvent = src;
    that.currentTarget = void 0;
  }
  if (!(src instanceof eventsEngine.Event)) {
    extend(that, {
      isPropagationStopped: function() {
        return !!(propagationStopped || that.originalEvent && that.originalEvent.propagationStopped);
      },
      stopPropagation: function() {
        propagationStopped = true;
        that.originalEvent && that.originalEvent.stopPropagation();
      },
      isImmediatePropagationStopped: function() {
        return immediatePropagationStopped;
      },
      stopImmediatePropagation: function() {
        this.stopPropagation();
        immediatePropagationStopped = true;
        that.originalEvent && that.originalEvent.stopImmediatePropagation();
      },
      isDefaultPrevented: function() {
        return !!(defaultPrevented || that.originalEvent && that.originalEvent.defaultPrevented);
      },
      preventDefault: function() {
        defaultPrevented = true;
        that.originalEvent && that.originalEvent.preventDefault();
      }
    });
  }
  addProperty("which", calculateWhich, that);
  if (src.type.indexOf("touch") === 0) {
    delete config2.pageX;
    delete config2.pageY;
  }
  extend(that, config2);
  that.guid = ++guid;
}));
function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get: function() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set: function(value2) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value2
      });
    }
  });
}
hookTouchProps(addProperty);
var beforeSetStrategy = Callbacks();
var afterSetStrategy = Callbacks();
eventsEngine.set = function(engine) {
  beforeSetStrategy.fire();
  eventsEngine.inject(engine);
  initEvent(engine.Event);
  afterSetStrategy.fire();
};
eventsEngine.subscribeGlobal = function() {
  applyForEach(arguments, normalizeOnArguments(function() {
    var args = arguments;
    eventsEngine.on.apply(this, args);
    beforeSetStrategy.add(function() {
      var offArgs = Array.prototype.slice.call(args, 0);
      offArgs.splice(3, 1);
      eventsEngine.off.apply(this, offArgs);
    });
    afterSetStrategy.add(function() {
      eventsEngine.on.apply(this, args);
    });
  }));
};
eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
var dataMap = new WeakMap$3();
var strategy$1;
var strategyChanging = new MemorizedCallbacks();
var beforeCleanDataFunc = function() {
};
var setDataStrategy = function(value2) {
  strategyChanging.fire(value2);
  strategy$1 = value2;
  var cleanData = strategy$1.cleanData;
  strategy$1.cleanData = function(nodes) {
    beforeCleanDataFunc(nodes);
    var result = cleanData.call(this, nodes);
    return result;
  };
};
setDataStrategy({
  data: function() {
    var element = arguments[0];
    var key = arguments[1];
    var value2 = arguments[2];
    if (!element) {
      return;
    }
    var elementData = dataMap.get(element);
    if (!elementData) {
      elementData = {};
      dataMap.set(element, elementData);
    }
    if (key === void 0) {
      return elementData;
    }
    if (arguments.length === 2) {
      return elementData[key];
    }
    elementData[key] = value2;
    return value2;
  },
  removeData: function(element, key) {
    if (!element) {
      return;
    }
    if (key === void 0) {
      dataMap.delete(element);
    } else {
      var elementData = dataMap.get(element);
      if (elementData) {
        delete elementData[key];
      }
    }
  },
  cleanData: function(elements) {
    for (var i = 0; i < elements.length; i++) {
      eventsEngine.off(elements[i]);
      dataMap.delete(elements[i]);
    }
  }
});
function data() {
  return strategy$1.data.apply(this, arguments);
}
function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}
function removeData(element, key) {
  return strategy$1.removeData.call(this, element, key);
}
function cleanDataRecursive(element, cleanSelf) {
  if (!domAdapter.isElementNode(element)) {
    return;
  }
  var childElements = element.getElementsByTagName("*");
  strategy$1.cleanData(childElements);
  if (cleanSelf) {
    strategy$1.cleanData([element]);
  }
}
var _normalize = function(text) {
  if (text === void 0 || text === null) {
    return "";
  }
  return String(text);
};
var _upperCaseFirst = function(text) {
  return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
};
var _chop = function(text) {
  return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/);
};
var dasherize = function(text) {
  return map(_chop(text), function(p) {
    return p.toLowerCase();
  }).join("-");
};
var camelize = function(text, upperFirst) {
  return map(_chop(text), function(p, i) {
    p = p.toLowerCase();
    if (upperFirst || i > 0) {
      p = _upperCaseFirst(p);
    }
    return p;
  }).join("");
};
var humanize = function(text) {
  return _upperCaseFirst(dasherize(text).replace(/-/g, " "));
};
var titleize = function(text) {
  return map(_chop(text), function(p) {
    return _upperCaseFirst(p.toLowerCase());
  }).join(" ");
};
var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"];
var cssPrefixes = {
  "": "",
  Webkit: "-webkit-",
  Moz: "-moz-",
  O: "-o-",
  ms: "-ms-"
};
var getStyles = callOnce(function() {
  return domAdapter.createElement("dx").style;
});
var forEachPrefixes = function(prop, callBack) {
  prop = camelize(prop, true);
  var result;
  for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
    var jsPrefix = jsPrefixes[i];
    var prefixedProp = jsPrefix + prop;
    var lowerPrefixedProp = camelize(prefixedProp);
    result = callBack(lowerPrefixedProp, jsPrefix);
    if (result === void 0) {
      result = callBack(prefixedProp, jsPrefix);
    }
    if (result !== void 0) {
      break;
    }
  }
  return result || "";
};
var styleProp = function(name2) {
  if (name2 in getStyles()) {
    return name2;
  }
  var originalName = name2;
  name2 = name2.charAt(0).toUpperCase() + name2.substr(1);
  for (var i = 1; i < jsPrefixes.length; i++) {
    var prefixedProp = jsPrefixes[i].toLowerCase() + name2;
    if (prefixedProp in getStyles()) {
      return prefixedProp;
    }
  }
  return originalName;
};
var stylePropPrefix = function(prop) {
  return forEachPrefixes(prop, function(specific, jsPrefix) {
    if (specific in getStyles()) {
      return cssPrefixes[jsPrefix];
    }
  });
};
var pxExceptions = ["fillOpacity", "columnCount", "flexGrow", "flexShrink", "fontWeight", "lineHeight", "opacity", "zIndex", "zoom"];
var normalizeStyleProp = function(prop, value2) {
  if (isNumeric(value2) && pxExceptions.indexOf(prop) === -1) {
    value2 += "px";
  }
  return value2;
};
var window$l = getWindow();
var SPECIAL_HEIGHT_VALUES = ["auto", "none", "inherit", "initial"];
var getSizeByStyles = function(elementStyles, styles) {
  var result = 0;
  styles.forEach(function(style) {
    result += parseFloat(elementStyles[style]) || 0;
  });
  return result;
};
var getElementBoxParams = function(name2, elementStyles) {
  var beforeName = name2 === "width" ? "Left" : "Top";
  var afterName = name2 === "width" ? "Right" : "Bottom";
  return {
    padding: getSizeByStyles(elementStyles, ["padding" + beforeName, "padding" + afterName]),
    border: getSizeByStyles(elementStyles, ["border" + beforeName + "Width", "border" + afterName + "Width"]),
    margin: getSizeByStyles(elementStyles, ["margin" + beforeName, "margin" + afterName])
  };
};
var getBoxSizingOffset = function(name2, elementStyles, boxParams) {
  var size = elementStyles[name2];
  if (elementStyles.boxSizing === "border-box" && size.length && size[size.length - 1] !== "%") {
    return boxParams.border + boxParams.padding;
  }
  return 0;
};
var getSize = function(element, name2, include2) {
  var elementStyles = window$l.getComputedStyle(element);
  var boxParams = getElementBoxParams(name2, elementStyles);
  var clientRect = element.getClientRects().length;
  var boundingClientRect = element.getBoundingClientRect()[name2];
  var result = clientRect ? boundingClientRect : 0;
  if (result <= 0) {
    result = parseFloat(elementStyles[name2] || element.style[name2]) || 0;
    result -= getBoxSizingOffset(name2, elementStyles, boxParams);
  } else {
    result -= boxParams.padding + boxParams.border;
  }
  if (include2.paddings) {
    result += boxParams.padding;
  }
  if (include2.borders) {
    result += boxParams.border;
  }
  if (include2.margins) {
    result += boxParams.margin;
  }
  return result;
};
var getContainerHeight = function(container) {
  return isWindow(container) ? container.innerHeight : container.offsetHeight;
};
var parseHeight = function(value2, container) {
  if (value2.indexOf("px") > 0) {
    value2 = parseInt(value2.replace("px", ""));
  } else if (value2.indexOf("%") > 0) {
    value2 = parseInt(value2.replace("%", "")) * getContainerHeight(container) / 100;
  } else if (!isNaN(value2)) {
    value2 = parseInt(value2);
  }
  return value2;
};
var getHeightWithOffset = function(value2, offset2, container) {
  if (!value2) {
    return null;
  }
  if (SPECIAL_HEIGHT_VALUES.indexOf(value2) > -1) {
    return offset2 ? null : value2;
  }
  if (isString$1(value2)) {
    value2 = parseHeight(value2, container);
  }
  if (isNumeric(value2)) {
    return Math.max(0, value2 + offset2);
  }
  var operationString = offset2 < 0 ? " - " : " ";
  return "calc(" + value2 + operationString + Math.abs(offset2) + "px)";
};
var addOffsetToMaxHeight = function(value2, offset2, container) {
  var maxHeight = getHeightWithOffset(value2, offset2, container);
  return maxHeight !== null ? maxHeight : "none";
};
var addOffsetToMinHeight = function(value2, offset2, container) {
  var minHeight = getHeightWithOffset(value2, offset2, container);
  return minHeight !== null ? minHeight : 0;
};
var getVerticalOffsets = function(element, withMargins) {
  if (!element) {
    return 0;
  }
  var boxParams = getElementBoxParams("height", window$l.getComputedStyle(element));
  return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
};
var getVisibleHeight = function(element) {
  if (element) {
    var boundingClientRect = element.getBoundingClientRect();
    if (boundingClientRect.height) {
      return boundingClientRect.height;
    }
  }
  return 0;
};
var isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
var tagWrappers = {
  default: {
    tagsCount: 0,
    startTags: "",
    endTags: ""
  },
  thead: {
    tagsCount: 1,
    startTags: "<table>",
    endTags: "</table>"
  },
  td: {
    tagsCount: 3,
    startTags: "<table><tbody><tr>",
    endTags: "</tr></tbody></table>"
  },
  col: {
    tagsCount: 2,
    startTags: "<table><colgroup>",
    endTags: "</colgroup></table>"
  },
  tr: {
    tagsCount: 2,
    startTags: "<table><tbody>",
    endTags: "</tbody></table>"
  }
};
tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
tagWrappers.th = tagWrappers.td;
var parseHTML = function(html) {
  if (typeof html !== "string") {
    return null;
  }
  var fragment = domAdapter.createDocumentFragment();
  var container = fragment.appendChild(domAdapter.createElement("div"));
  var tags = isTagName.exec(html);
  var firstRootTag = tags && tags[1].toLowerCase();
  var tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
  container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
  for (var i = 0; i < tagWrapper.tagsCount; i++) {
    container = container.lastChild;
  }
  return merge([], container.childNodes);
};
var isTablePart = function(html) {
  var tags = isTagName.exec(html);
  return tags && tags[1] in tagWrappers;
};
var window$k = getWindow();
var renderer;
var initRender = function(selector, context2) {
  if (!selector) {
    this.length = 0;
    return this;
  }
  if (typeof selector === "string") {
    if (selector === "body") {
      this[0] = context2 ? context2.body : domAdapter.getBody();
      this.length = 1;
      return this;
    }
    context2 = context2 || domAdapter.getDocument();
    if (selector[0] === "<") {
      this[0] = domAdapter.createElement(selector.slice(1, -1), context2);
      this.length = 1;
      return this;
    }
    [].push.apply(this, domAdapter.querySelectorAll(context2, selector));
    return this;
  } else if (domAdapter.isNode(selector) || isWindow(selector)) {
    this[0] = selector;
    this.length = 1;
    return this;
  } else if (Array.isArray(selector)) {
    [].push.apply(this, selector);
    return this;
  }
  return renderer(selector.toArray ? selector.toArray() : [selector]);
};
renderer = function(selector, context2) {
  return new initRender(selector, context2);
};
renderer.fn = {
  dxRenderer: true
};
initRender.prototype = renderer.fn;
var repeatMethod = function(methodName, args) {
  for (var i = 0; i < this.length; i++) {
    var item = renderer(this[i]);
    item[methodName].apply(item, args);
  }
  return this;
};
var setAttributeValue = function(element, attrName, value2) {
  if (value2 !== void 0 && value2 !== null) {
    domAdapter.setAttribute(element, attrName, value2);
  } else {
    domAdapter.removeAttribute(element, attrName);
  }
};
initRender.prototype.show = function() {
  return this.toggle(true);
};
initRender.prototype.hide = function() {
  return this.toggle(false);
};
initRender.prototype.toggle = function(value2) {
  if (this[0]) {
    this.toggleClass("dx-state-invisible", !value2);
  }
  return this;
};
initRender.prototype.attr = function(attrName, value2) {
  if (this.length > 1 && arguments.length > 1) {
    return repeatMethod.call(this, "attr", arguments);
  }
  if (!this[0]) {
    if (isObject$1(attrName) || value2 !== void 0) {
      return this;
    } else {
      return;
    }
  }
  if (!this[0].getAttribute) {
    return this.prop(attrName, value2);
  }
  if (typeof attrName === "string" && arguments.length === 1) {
    var result = this[0].getAttribute(attrName);
    return result == null ? void 0 : result;
  } else if (isPlainObject(attrName)) {
    for (var key in attrName) {
      this.attr(key, attrName[key]);
    }
  } else {
    setAttributeValue(this[0], attrName, value2);
  }
  return this;
};
initRender.prototype.removeAttr = function(attrName) {
  this[0] && domAdapter.removeAttribute(this[0], attrName);
  return this;
};
initRender.prototype.prop = function(propName, value2) {
  if (!this[0]) {
    return this;
  }
  if (typeof propName === "string" && arguments.length === 1) {
    return this[0][propName];
  } else if (isPlainObject(propName)) {
    for (var key in propName) {
      this.prop(key, propName[key]);
    }
  } else {
    domAdapter.setProperty(this[0], propName, value2);
  }
  return this;
};
initRender.prototype.addClass = function(className) {
  return this.toggleClass(className, true);
};
initRender.prototype.removeClass = function(className) {
  return this.toggleClass(className, false);
};
initRender.prototype.hasClass = function(className) {
  if (!this[0] || this[0].className === void 0) {
    return false;
  }
  var classNames = className.split(" ");
  for (var i = 0; i < classNames.length; i++) {
    if (this[0].classList) {
      if (this[0].classList.contains(classNames[i])) {
        return true;
      }
    } else {
      var _className = isString$1(this[0].className) ? this[0].className : domAdapter.getAttribute(this[0], "class");
      if ((_className || "").split(" ").indexOf(classNames[i]) >= 0) {
        return true;
      }
    }
  }
  return false;
};
initRender.prototype.toggleClass = function(className, value2) {
  if (this.length > 1) {
    return repeatMethod.call(this, "toggleClass", arguments);
  }
  if (!this[0] || !className) {
    return this;
  }
  value2 = value2 === void 0 ? !this.hasClass(className) : value2;
  var classNames = className.split(" ");
  for (var i = 0; i < classNames.length; i++) {
    domAdapter.setClass(this[0], classNames[i], value2);
  }
  return this;
};
["width", "height", "outerWidth", "outerHeight", "innerWidth", "innerHeight"].forEach(function(methodName) {
  var partialName = methodName.toLowerCase().indexOf("width") >= 0 ? "Width" : "Height";
  var propName = partialName.toLowerCase();
  var isOuter = methodName.indexOf("outer") === 0;
  var isInner = methodName.indexOf("inner") === 0;
  initRender.prototype[methodName] = function(value2) {
    if (this.length > 1 && arguments.length > 0) {
      return repeatMethod.call(this, methodName, arguments);
    }
    var element = this[0];
    if (!element) {
      return;
    }
    if (isWindow(element)) {
      return isOuter ? element["inner" + partialName] : domAdapter.getDocumentElement()["client" + partialName];
    }
    if (domAdapter.isDocument(element)) {
      var documentElement = domAdapter.getDocumentElement();
      var body = domAdapter.getBody();
      return Math.max(body["scroll" + partialName], body["offset" + partialName], documentElement["scroll" + partialName], documentElement["offset" + partialName], documentElement["client" + partialName]);
    }
    if (arguments.length === 0 || typeof value2 === "boolean") {
      var include2 = {
        paddings: isInner || isOuter,
        borders: isOuter,
        margins: value2
      };
      return getSize(element, propName, include2);
    }
    if (value2 === void 0 || value2 === null) {
      return this;
    }
    if (isNumeric(value2)) {
      var elementStyles = window$k.getComputedStyle(element);
      var sizeAdjustment = getElementBoxParams(propName, elementStyles);
      var isBorderBox = elementStyles.boxSizing === "border-box";
      value2 = Number(value2);
      if (isOuter) {
        value2 -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
      } else if (isInner) {
        value2 += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
      } else if (isBorderBox) {
        value2 += sizeAdjustment.border + sizeAdjustment.padding;
      }
    }
    value2 += isNumeric(value2) ? "px" : "";
    domAdapter.setStyle(element, propName, value2);
    return this;
  };
});
initRender.prototype.html = function(value2) {
  if (!arguments.length) {
    return this[0].innerHTML;
  }
  this.empty();
  if (typeof value2 === "string" && !isTablePart(value2) || typeof value2 === "number") {
    this[0].innerHTML = value2;
    return this;
  }
  return this.append(parseHTML(value2));
};
var appendElements = function(element, nextSibling) {
  if (!this[0] || !element) {
    return;
  }
  if (typeof element === "string") {
    element = parseHTML(element);
  } else if (element.nodeType) {
    element = [element];
  } else if (isNumeric(element)) {
    element = [domAdapter.createTextNode(element)];
  }
  for (var i = 0; i < element.length; i++) {
    var item = element[i];
    var container = this[0];
    var wrapTR = container.tagName === "TABLE" && item.tagName === "TR";
    if (wrapTR && container.tBodies && container.tBodies.length) {
      container = container.tBodies[0];
    }
    domAdapter.insertElement(container, item.nodeType ? item : item[0], nextSibling);
  }
};
var setCss = function(name2, value2) {
  if (!this[0] || !this[0].style) {
    return;
  }
  if (value2 === null || typeof value2 === "number" && isNaN(value2)) {
    return;
  }
  name2 = styleProp(name2);
  for (var i = 0; i < this.length; i++) {
    this[i].style[name2] = normalizeStyleProp(name2, value2);
  }
};
initRender.prototype.css = function(name2, value2) {
  if (isString$1(name2)) {
    if (arguments.length === 2) {
      setCss.call(this, name2, value2);
    } else {
      if (!this[0]) {
        return;
      }
      name2 = styleProp(name2);
      var result = window$k.getComputedStyle(this[0])[name2] || this[0].style[name2];
      return isNumeric(result) ? result.toString() : result;
    }
  } else if (isPlainObject(name2)) {
    for (var key in name2) {
      setCss.call(this, key, name2[key]);
    }
  }
  return this;
};
initRender.prototype.prepend = function(element) {
  if (arguments.length > 1) {
    for (var i = 0; i < arguments.length; i++) {
      this.prepend(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element, this[0].firstChild]);
  return this;
};
initRender.prototype.append = function(element) {
  if (arguments.length > 1) {
    for (var i = 0; i < arguments.length; i++) {
      this.append(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element]);
  return this;
};
initRender.prototype.prependTo = function(element) {
  if (this.length > 1) {
    for (var i = this.length - 1; i >= 0; i--) {
      renderer(this[i]).prependTo(element);
    }
    return this;
  }
  element = renderer(element);
  if (element[0]) {
    domAdapter.insertElement(element[0], this[0], element[0].firstChild);
  }
  return this;
};
initRender.prototype.appendTo = function(element) {
  if (this.length > 1) {
    return repeatMethod.call(this, "appendTo", arguments);
  }
  domAdapter.insertElement(renderer(element)[0], this[0]);
  return this;
};
initRender.prototype.insertBefore = function(element) {
  if (element && element[0]) {
    domAdapter.insertElement(element[0].parentNode, this[0], element[0]);
  }
  return this;
};
initRender.prototype.insertAfter = function(element) {
  if (element && element[0]) {
    domAdapter.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
  }
  return this;
};
initRender.prototype.before = function(element) {
  if (this[0]) {
    domAdapter.insertElement(this[0].parentNode, element[0], this[0]);
  }
  return this;
};
initRender.prototype.after = function(element) {
  if (this[0]) {
    domAdapter.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
  }
  return this;
};
initRender.prototype.wrap = function(wrapper) {
  if (this[0]) {
    var wrap = renderer(wrapper);
    wrap.insertBefore(this);
    wrap.append(this);
  }
  return this;
};
initRender.prototype.wrapInner = function(wrapper) {
  var contents = this.contents();
  if (contents.length) {
    contents.wrap(wrapper);
  } else {
    this.append(wrapper);
  }
  return this;
};
initRender.prototype.replaceWith = function(element) {
  if (!(element && element[0])) {
    return;
  }
  if (element.is(this)) {
    return this;
  }
  element.insertBefore(this);
  this.remove();
  return element;
};
initRender.prototype.remove = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "remove", arguments);
  }
  cleanDataRecursive(this[0], true);
  domAdapter.removeElement(this[0]);
  return this;
};
initRender.prototype.detach = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "detach", arguments);
  }
  domAdapter.removeElement(this[0]);
  return this;
};
initRender.prototype.empty = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "empty", arguments);
  }
  cleanDataRecursive(this[0]);
  domAdapter.setText(this[0], "");
  return this;
};
initRender.prototype.clone = function() {
  var result = [];
  for (var i = 0; i < this.length; i++) {
    result.push(this[i].cloneNode(true));
  }
  return renderer(result);
};
initRender.prototype.text = function(value2) {
  if (!arguments.length) {
    var result = "";
    for (var i = 0; i < this.length; i++) {
      result += this[i] && this[i].textContent || "";
    }
    return result;
  }
  var text = isFunction$1(value2) ? value2() : value2;
  cleanDataRecursive(this[0], false);
  domAdapter.setText(this[0], isDefined(text) ? text : "");
  return this;
};
initRender.prototype.val = function(value2) {
  if (arguments.length === 1) {
    return this.prop("value", isDefined(value2) ? value2 : "");
  }
  return this.prop("value");
};
initRender.prototype.contents = function() {
  if (!this[0]) {
    return renderer();
  }
  var result = [];
  result.push.apply(result, this[0].childNodes);
  return renderer(result);
};
initRender.prototype.find = function(selector) {
  var result = renderer();
  if (!selector) {
    return result;
  }
  var nodes = [];
  var i;
  if (typeof selector === "string") {
    selector = selector.trim();
    for (i = 0; i < this.length; i++) {
      var element = this[i];
      if (domAdapter.isElementNode(element)) {
        var elementId = element.getAttribute("id");
        var queryId = elementId || "dx-query-children";
        if (!elementId) {
          setAttributeValue(element, "id", queryId);
        }
        queryId = "[id='" + queryId + "'] ";
        var querySelector = queryId + selector.replace(/([^\\])(,)/g, "$1, " + queryId);
        nodes.push.apply(nodes, domAdapter.querySelectorAll(element, querySelector));
        setAttributeValue(element, "id", elementId);
      } else if (domAdapter.isDocument(element)) {
        nodes.push.apply(nodes, domAdapter.querySelectorAll(element, selector));
      }
    }
  } else {
    for (i = 0; i < this.length; i++) {
      selector = domAdapter.isNode(selector) ? selector : selector[0];
      if (this[i] !== selector && this[i].contains(selector)) {
        nodes.push(selector);
      }
    }
  }
  return result.add(nodes);
};
var isVisible = function(_2, element) {
  if (!element.nodeType) {
    return true;
  }
  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
};
initRender.prototype.filter = function(selector) {
  if (!selector) {
    return renderer();
  }
  if (selector === ":visible") {
    return this.filter(isVisible);
  } else if (selector === ":hidden") {
    return this.filter(function(_2, element) {
      return !isVisible(_2, element);
    });
  }
  var result = [];
  for (var i = 0; i < this.length; i++) {
    var item = this[i];
    if (domAdapter.isElementNode(item) && type(selector) === "string") {
      domAdapter.elementMatches(item, selector) && result.push(item);
    } else if (domAdapter.isNode(selector) || isWindow(selector)) {
      selector === item && result.push(item);
    } else if (isFunction$1(selector)) {
      selector.call(item, i, item) && result.push(item);
    } else {
      for (var j = 0; j < selector.length; j++) {
        selector[j] === item && result.push(item);
      }
    }
  }
  return renderer(result);
};
initRender.prototype.not = function(selector) {
  var result = [];
  var nodes = this.filter(selector).toArray();
  for (var i = 0; i < this.length; i++) {
    if (nodes.indexOf(this[i]) === -1) {
      result.push(this[i]);
    }
  }
  return renderer(result);
};
initRender.prototype.is = function(selector) {
  return !!this.filter(selector).length;
};
initRender.prototype.children = function(selector) {
  var result = [];
  for (var i = 0; i < this.length; i++) {
    var nodes = this[i] ? this[i].childNodes : [];
    for (var j = 0; j < nodes.length; j++) {
      if (domAdapter.isElementNode(nodes[j])) {
        result.push(nodes[j]);
      }
    }
  }
  result = renderer(result);
  return selector ? result.filter(selector) : result;
};
initRender.prototype.siblings = function() {
  var element = this[0];
  if (!element || !element.parentNode) {
    return renderer();
  }
  var result = [];
  var parentChildNodes = element.parentNode.childNodes || [];
  for (var i = 0; i < parentChildNodes.length; i++) {
    var node = parentChildNodes[i];
    if (domAdapter.isElementNode(node) && node !== element) {
      result.push(node);
    }
  }
  return renderer(result);
};
initRender.prototype.each = function(callback) {
  for (var i = 0; i < this.length; i++) {
    if (callback.call(this[i], i, this[i]) === false) {
      break;
    }
  }
};
initRender.prototype.index = function(element) {
  if (!element) {
    return this.parent().children().index(this);
  }
  element = renderer(element);
  return this.toArray().indexOf(element[0]);
};
initRender.prototype.get = function(index2) {
  return this[index2 < 0 ? this.length + index2 : index2];
};
initRender.prototype.eq = function(index2) {
  index2 = index2 < 0 ? this.length + index2 : index2;
  return renderer(this[index2]);
};
initRender.prototype.first = function() {
  return this.eq(0);
};
initRender.prototype.last = function() {
  return this.eq(-1);
};
initRender.prototype.parent = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  var result = renderer(this[0].parentNode);
  return !selector || result.is(selector) ? result : renderer();
};
initRender.prototype.parents = function(selector) {
  var result = [];
  var parent = this.parent();
  while (parent && parent[0] && !domAdapter.isDocument(parent[0])) {
    if (domAdapter.isElementNode(parent[0])) {
      if (!selector || parent.is(selector)) {
        result.push(parent.get(0));
      }
    }
    parent = parent.parent();
  }
  return renderer(result);
};
initRender.prototype.closest = function(selector) {
  if (this.is(selector)) {
    return this;
  }
  var parent = this.parent();
  while (parent && parent.length) {
    if (parent.is(selector)) {
      return parent;
    }
    parent = parent.parent();
  }
  return renderer();
};
initRender.prototype.next = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  var next = renderer(this[0].nextSibling);
  if (!arguments.length) {
    return next;
  }
  while (next && next.length) {
    if (next.is(selector)) {
      return next;
    }
    next = next.next();
  }
  return renderer();
};
initRender.prototype.prev = function() {
  if (!this[0]) {
    return renderer();
  }
  return renderer(this[0].previousSibling);
};
initRender.prototype.add = function(selector) {
  var targets = renderer(selector);
  var result = this.toArray();
  for (var i = 0; i < targets.length; i++) {
    var target = targets[i];
    if (result.indexOf(target) === -1) {
      result.push(target);
    }
  }
  return renderer(result);
};
var emptyArray = [];
initRender.prototype.splice = function() {
  return renderer(emptyArray.splice.apply(this, arguments));
};
initRender.prototype.slice = function() {
  return renderer(emptyArray.slice.apply(this, arguments));
};
initRender.prototype.toArray = function() {
  return emptyArray.slice.call(this);
};
var getWindowByElement = function(element) {
  return isWindow(element) ? element : element.defaultView;
};
initRender.prototype.offset = function() {
  if (!this[0]) {
    return;
  }
  if (!this[0].getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }
  var rect = this[0].getBoundingClientRect();
  var win = getWindowByElement(this[0].ownerDocument);
  var docElem = this[0].ownerDocument.documentElement;
  return {
    top: rect.top + win.pageYOffset - docElem.clientTop,
    left: rect.left + win.pageXOffset - docElem.clientLeft
  };
};
initRender.prototype.offsetParent = function() {
  if (!this[0]) {
    return renderer();
  }
  var offsetParent = renderer(this[0].offsetParent);
  while (offsetParent[0] && offsetParent.css("position") === "static") {
    offsetParent = renderer(offsetParent[0].offsetParent);
  }
  offsetParent = offsetParent[0] ? offsetParent : renderer(domAdapter.getDocumentElement());
  return offsetParent;
};
initRender.prototype.position = function() {
  if (!this[0]) {
    return;
  }
  var offset2;
  var marginTop = parseFloat(this.css("marginTop"));
  var marginLeft = parseFloat(this.css("marginLeft"));
  if (this.css("position") === "fixed") {
    offset2 = this[0].getBoundingClientRect();
    return {
      top: offset2.top - marginTop,
      left: offset2.left - marginLeft
    };
  }
  offset2 = this.offset();
  var offsetParent = this.offsetParent();
  var parentOffset = {
    top: 0,
    left: 0
  };
  if (offsetParent[0].nodeName !== "HTML") {
    parentOffset = offsetParent.offset();
  }
  parentOffset = {
    top: parentOffset.top + parseFloat(offsetParent.css("borderTopWidth")),
    left: parentOffset.left + parseFloat(offsetParent.css("borderLeftWidth"))
  };
  return {
    top: offset2.top - parentOffset.top - marginTop,
    left: offset2.left - parentOffset.left - marginLeft
  };
};
[{
  name: "scrollLeft",
  offsetProp: "pageXOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(value2, win.pageYOffset);
  }
}, {
  name: "scrollTop",
  offsetProp: "pageYOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(win.pageXOffset, value2);
  }
}].forEach(function(directionStrategy) {
  var propName = directionStrategy.name;
  initRender.prototype[propName] = function(value2) {
    if (!this[0]) {
      return;
    }
    var window2 = getWindowByElement(this[0]);
    if (value2 === void 0) {
      return window2 ? window2[directionStrategy.offsetProp] : this[0][propName];
    }
    if (window2) {
      directionStrategy.scrollWindow(window2, value2);
    } else {
      this[0][propName] = value2;
    }
    return this;
  };
});
initRender.prototype.data = function(key, value2) {
  if (!this[0]) {
    return;
  }
  if (arguments.length < 2) {
    return data.call(renderer, this[0], key);
  }
  data.call(renderer, this[0], key, value2);
  return this;
};
initRender.prototype.removeData = function(key) {
  this[0] && removeData(this[0], key);
  return this;
};
var rendererWrapper = function() {
  return renderer.apply(this, arguments);
};
Object.defineProperty(rendererWrapper, "fn", {
  enumerable: true,
  configurable: true,
  get: function() {
    return renderer.fn;
  },
  set: function(value2) {
    renderer.fn = value2;
  }
});
var rendererBase = {
  set: function(strategy2) {
    renderer = strategy2;
  },
  get: function() {
    return rendererWrapper;
  }
};
var $ = rendererBase.get();
var callbacks$1 = new MemorizedCallbacks();
var registerEvent = function(name2, eventObject) {
  var strategy2 = {};
  if ("noBubble" in eventObject) {
    strategy2.noBubble = eventObject.noBubble;
  }
  if ("bindType" in eventObject) {
    strategy2.bindType = eventObject.bindType;
  }
  if ("delegateType" in eventObject) {
    strategy2.delegateType = eventObject.delegateType;
  }
  each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_2, methodName) {
    if (!eventObject[methodName]) {
      return;
    }
    strategy2[methodName] = function() {
      var args = [].slice.call(arguments);
      args.unshift(this);
      return eventObject[methodName].apply(eventObject, args);
    };
  });
  callbacks$2.fire(name2, strategy2);
};
registerEvent.callbacks = callbacks$2;
var removeEvent = "dxremove";
var eventPropName = "dxRemoveEvent";
beforeCleanData(function(elements) {
  elements = [].slice.call(elements);
  for (var i = 0; i < elements.length; i++) {
    var $element = $(elements[i]);
    if ($element.prop(eventPropName)) {
      $element[0][eventPropName] = null;
      eventsEngine.triggerHandler($element, removeEvent);
    }
  }
});
registerEvent(removeEvent, {
  noBubble: true,
  setup: function(element) {
    $(element).prop(eventPropName, true);
  }
});
var COMPONENT_NAMES_DATA_KEY = "dxComponents";
var ANONYMOUS_COMPONENT_DATA_KEY = "dxPrivateComponent";
var componentNames = new WeakMap$3();
var nextAnonymousComponent = 0;
var getName = function(componentClass, newName) {
  if (isDefined(newName)) {
    componentNames.set(componentClass, newName);
    return;
  }
  if (!componentNames.has(componentClass)) {
    var generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
    componentNames.set(componentClass, generatedName);
    return generatedName;
  }
  return componentNames.get(componentClass);
};
function attachInstanceToElement($element, componentInstance, disposeFn) {
  var data$1 = data($element.get(0));
  var name2 = getName(componentInstance.constructor);
  data$1[name2] = componentInstance;
  if (disposeFn) {
    eventsEngine.one($element, removeEvent, function() {
      disposeFn.call(componentInstance);
    });
  }
  if (!data$1[COMPONENT_NAMES_DATA_KEY]) {
    data$1[COMPONENT_NAMES_DATA_KEY] = [];
  }
  data$1[COMPONENT_NAMES_DATA_KEY].push(name2);
}
function getInstanceByElement($element, componentClass) {
  var name2 = getName(componentClass);
  return data($element.get(0), name2);
}
var registerComponent = function(name2, namespace, componentClass) {
  if (!componentClass) {
    componentClass = namespace;
  } else {
    namespace[name2] = componentClass;
  }
  getName(componentClass, name2);
  callbacks$1.fire(name2, componentClass);
};
var registerRendererComponent = function(name2, componentClass) {
  $.fn[name2] = function(options) {
    var isMemberInvoke = typeof options === "string";
    var result;
    if (isMemberInvoke) {
      var memberName = options;
      var memberArgs = [].slice.call(arguments).slice(1);
      this.each(function() {
        var instance = componentClass.getInstance(this);
        if (!instance) {
          throw errors$2.Error("E0009", name2);
        }
        var member = instance[memberName];
        var memberValue = member.apply(instance, memberArgs);
        if (result === void 0) {
          result = memberValue;
        }
      });
    } else {
      this.each(function() {
        var instance = componentClass.getInstance(this);
        if (instance) {
          instance.option(options);
        } else {
          new componentClass(this, options);
        }
      });
      result = this;
    }
    return result;
  };
};
callbacks$1.add(registerRendererComponent);
var strategy = function(element) {
  return element && element.get(0);
};
function getPublicElement(element) {
  return strategy(element);
}
var callbacks = [];
var isReady = () => domAdapter.getReadyState() === "complete" || domAdapter.getReadyState() !== "loading" && !domAdapter.getDocumentElement().doScroll;
var subscribeReady = callOnce(() => {
  var removeListener = domAdapter.listen(domAdapter.getDocument(), "DOMContentLoaded", () => {
    readyCallbacks.fire();
    removeListener();
  });
});
var readyCallbacks = {
  add: (callback) => {
    var windowExists = hasWindow$1();
    if (windowExists && isReady()) {
      callback();
    } else {
      callbacks.push(callback);
      windowExists && subscribeReady();
    }
  },
  fire: () => {
    callbacks.forEach((callback) => callback());
    callbacks = [];
  }
};
var readyCallback = injector(readyCallbacks);
var resizeCallbacks = function() {
  var prevSize;
  var callbacks2 = Callbacks();
  var originalCallbacksAdd = callbacks2.add;
  var originalCallbacksRemove = callbacks2.remove;
  if (!hasWindow$1()) {
    return callbacks2;
  }
  var formatSize = function() {
    var window2 = getWindow();
    return {
      width: window2.innerWidth,
      height: window2.innerHeight
    };
  };
  var handleResize = function() {
    var now = formatSize();
    if (now.width === prevSize.width && now.height === prevSize.height) {
      return;
    }
    var changedDimension;
    if (now.width === prevSize.width) {
      changedDimension = "height";
    }
    if (now.height === prevSize.height) {
      changedDimension = "width";
    }
    prevSize = now;
    callbacks2.fire(changedDimension);
  };
  var setPrevSize = callOnce(function() {
    prevSize = formatSize();
  });
  var removeListener;
  callbacks2.add = function() {
    var result = originalCallbacksAdd.apply(callbacks2, arguments);
    setPrevSize();
    readyCallback.add(function() {
      if (!removeListener && callbacks2.has()) {
        removeListener = domAdapter.listen(getWindow(), "resize", handleResize);
      }
    });
    return result;
  };
  callbacks2.remove = function() {
    var result = originalCallbacksRemove.apply(callbacks2, arguments);
    if (!callbacks2.has() && removeListener) {
      removeListener();
      removeListener = void 0;
    }
    return result;
  };
  return callbacks2;
}();
class EventsStrategy {
  constructor(owner) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this._events = {};
    this._owner = owner;
    this._options = options;
  }
  static create(owner, strategy2) {
    if (strategy2) {
      return isFunction$1(strategy2) ? strategy2(owner) : strategy2;
    } else {
      return new EventsStrategy(owner);
    }
  }
  hasEvent(eventName) {
    var callbacks2 = this._events[eventName];
    return callbacks2 ? callbacks2.has() : false;
  }
  fireEvent(eventName, eventArgs) {
    var callbacks2 = this._events[eventName];
    if (callbacks2) {
      callbacks2.fireWith(this._owner, eventArgs);
    }
    return this._owner;
  }
  on(eventName, eventHandler) {
    if (isPlainObject(eventName)) {
      each(eventName, (e, h) => {
        this.on(e, h);
      });
    } else {
      var callbacks2 = this._events[eventName];
      if (!callbacks2) {
        callbacks2 = Callbacks({
          syncStrategy: this._options.syncStrategy
        });
        this._events[eventName] = callbacks2;
      }
      var addFn = callbacks2.originalAdd || callbacks2.add;
      addFn.call(callbacks2, eventHandler);
    }
  }
  off(eventName, eventHandler) {
    var callbacks2 = this._events[eventName];
    if (callbacks2) {
      if (isFunction$1(eventHandler)) {
        callbacks2.remove(eventHandler);
      } else {
        callbacks2.empty();
      }
    }
  }
  dispose() {
    each(this._events, (eventName, event) => {
      event.empty();
    });
  }
}
var window$j = getWindow();
var getSessionStorage = function() {
  var sessionStorage;
  try {
    sessionStorage = window$j.sessionStorage;
  } catch (e) {
  }
  return sessionStorage;
};
var ready$4 = readyCallback.add;
var changeCallback = Callbacks();
var $originalViewPort = $();
var value = function() {
  var $current;
  return function(element) {
    if (!arguments.length) {
      return $current;
    }
    var $element = $(element);
    $originalViewPort = $element;
    var isNewViewportFound = !!$element.length;
    var prevViewPort = value();
    $current = isNewViewportFound ? $element : $("body");
    changeCallback.fire(isNewViewportFound ? value() : $(), prevViewPort);
  };
}();
ready$4(function() {
  value(".dx-viewport");
});
function originalViewPort() {
  return $originalViewPort;
}
var navigator$4 = getNavigator();
var window$i = getWindow();
var KNOWN_UA_TABLE = {
  iPhone: "iPhone",
  iPhone5: "iPhone",
  iPhone6: "iPhone",
  iPhone6plus: "iPhone",
  iPad: "iPad",
  iPadMini: "iPad Mini",
  androidPhone: "Android Mobile",
  androidTablet: "Android",
  msSurface: "Windows ARM Tablet PC",
  desktop: "desktop"
};
var DEFAULT_DEVICE = {
  deviceType: "desktop",
  platform: "generic",
  version: [],
  phone: false,
  tablet: false,
  android: false,
  ios: false,
  generic: true,
  grade: "A",
  mac: false
};
var uaParsers = {
  generic(userAgent) {
    var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
    var isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
    var isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
    var isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
    if (!(isPhone || isTablet || isDesktop || isMac)) {
      return;
    }
    return {
      deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
      platform: "generic",
      version: [],
      grade: "A",
      mac: isMac
    };
  },
  ios(userAgent) {
    if (!/ip(hone|od|ad)/i.test(userAgent)) {
      return;
    }
    var isPhone = /ip(hone|od)/i.test(userAgent);
    var matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i);
    var version2 = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
    var isIPhone4 = window$i.screen.height === 480;
    var grade = isIPhone4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "ios",
      version: version2,
      grade
    };
  },
  android(userAgent) {
    if (!/android|htc_|silk/i.test(userAgent)) {
      return;
    }
    var isPhone = /mobile/i.test(userAgent);
    var matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
    var version2 = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
    var worseThan4_4 = version2.length > 1 && (version2[0] < 4 || version2[0] === 4 && version2[1] < 4);
    var grade = worseThan4_4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "android",
      version: version2,
      grade
    };
  }
};
class Devices {
  constructor(options) {
    this._window = (options === null || options === void 0 ? void 0 : options.window) || window$i;
    this._realDevice = this._getDevice();
    this._currentDevice = void 0;
    this._currentOrientation = void 0;
    this._eventsStrategy = new EventsStrategy(this);
    this.changed = Callbacks();
    if (hasWindow$1()) {
      readyCallback.add(this._recalculateOrientation.bind(this));
      resizeCallbacks.add(this._recalculateOrientation.bind(this));
    }
  }
  current(deviceOrName) {
    if (deviceOrName) {
      this._currentDevice = this._getDevice(deviceOrName);
      this._forced = true;
      this.changed.fire();
      return;
    }
    if (!this._currentDevice) {
      deviceOrName = void 0;
      try {
        deviceOrName = this._getDeviceOrNameFromWindowScope();
      } catch (e) {
        deviceOrName = this._getDeviceNameFromSessionStorage();
      } finally {
        if (!deviceOrName) {
          deviceOrName = this._getDeviceNameFromSessionStorage();
        }
        if (deviceOrName) {
          this._forced = true;
        }
      }
      this._currentDevice = this._getDevice(deviceOrName);
    }
    return this._currentDevice;
  }
  real(forceDevice) {
    return extend({}, this._realDevice);
  }
  orientation() {
    return this._currentOrientation;
  }
  isForced() {
    return this._forced;
  }
  isRippleEmulator() {
    return !!this._window.tinyHippos;
  }
  _getCssClasses(device) {
    var result = [];
    var realDevice2 = this._realDevice;
    device = device || this.current();
    if (device.deviceType) {
      result.push("dx-device-".concat(device.deviceType));
      if (device.deviceType !== "desktop") {
        result.push("dx-device-mobile");
      }
    }
    result.push("dx-device-".concat(realDevice2.platform));
    if (realDevice2.version && realDevice2.version.length) {
      result.push("dx-device-".concat(realDevice2.platform, "-").concat(realDevice2.version[0]));
    }
    if (this.isSimulator()) {
      result.push("dx-simulator");
    }
    if (configMethod().rtlEnabled) {
      result.push("dx-rtl");
    }
    return result;
  }
  attachCssClasses(element, device) {
    this._deviceClasses = this._getCssClasses(device).join(" ");
    $(element).addClass(this._deviceClasses);
  }
  detachCssClasses(element) {
    $(element).removeClass(this._deviceClasses);
  }
  isSimulator() {
    try {
      return this._isSimulator || hasWindow$1() && this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator();
    } catch (e) {
      return false;
    }
  }
  forceSimulator() {
    this._isSimulator = true;
  }
  _getDevice(deviceName) {
    if (deviceName === "genericPhone") {
      deviceName = {
        deviceType: "phone",
        platform: "generic",
        generic: true
      };
    }
    if (isPlainObject(deviceName)) {
      return this._fromConfig(deviceName);
    } else {
      var ua2;
      if (deviceName) {
        ua2 = KNOWN_UA_TABLE[deviceName];
        if (!ua2) {
          throw errors$2.Error("E0005");
        }
      } else {
        ua2 = navigator$4.userAgent;
      }
      return this._fromUA(ua2);
    }
  }
  _getDeviceOrNameFromWindowScope() {
    var result;
    if (hasWindow$1() && (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"])) {
      result = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"];
    }
    return result;
  }
  _getDeviceNameFromSessionStorage() {
    var sessionStorage = getSessionStorage();
    if (!sessionStorage) {
      return;
    }
    var deviceOrName = sessionStorage.getItem("dx-force-device");
    try {
      return JSON.parse(deviceOrName);
    } catch (ex) {
      return deviceOrName;
    }
  }
  _fromConfig(config2) {
    var result = extend({}, DEFAULT_DEVICE, this._currentDevice, config2);
    var shortcuts = {
      phone: result.deviceType === "phone",
      tablet: result.deviceType === "tablet",
      android: result.platform === "android",
      ios: result.platform === "ios",
      generic: result.platform === "generic"
    };
    return extend(result, shortcuts);
  }
  _fromUA(ua2) {
    var config2;
    each(uaParsers, (platform, parser) => {
      config2 = parser(ua2);
      return !config2;
    });
    if (config2) {
      return this._fromConfig(config2);
    }
    return DEFAULT_DEVICE;
  }
  _changeOrientation() {
    var $window = $(this._window);
    var orientation = $window.height() > $window.width() ? "portrait" : "landscape";
    if (this._currentOrientation === orientation) {
      return;
    }
    this._currentOrientation = orientation;
    this._eventsStrategy.fireEvent("orientationChanged", [{
      orientation
    }]);
  }
  _recalculateOrientation() {
    var windowWidth = $(this._window).width();
    if (this._currentWidth === windowWidth) {
      return;
    }
    this._currentWidth = windowWidth;
    this._changeOrientation();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
}
var devices = new Devices();
var viewPortElement = value();
if (viewPortElement) {
  devices.attachCssClasses(viewPortElement);
}
changeCallback.add((viewPort2, prevViewport) => {
  devices.detachCssClasses(prevViewport);
  devices.attachCssClasses(viewPort2);
});
var window$h = getWindow();
var resetActiveElement = function() {
  var activeElement = domAdapter.getActiveElement();
  var body = domAdapter.getBody();
  if (activeElement && activeElement !== body && activeElement.blur) {
    try {
      activeElement.blur();
    } catch (e) {
      body.blur();
    }
  }
};
var clearSelection = function() {
  var selection = window$h.getSelection();
  if (!selection) {
    return;
  }
  if (selection.type === "Caret") {
    return;
  }
  if (selection.empty) {
    selection.empty();
  } else if (selection.removeAllRanges) {
    try {
      selection.removeAllRanges();
    } catch (e) {
    }
  }
};
var closestCommonParent = function(startTarget, endTarget) {
  var $startTarget = $(startTarget);
  var $endTarget = $(endTarget);
  if ($startTarget[0] === $endTarget[0]) {
    return $startTarget[0];
  }
  var $startParents = $startTarget.parents();
  var $endParents = $endTarget.parents();
  var startingParent = Math.min($startParents.length, $endParents.length);
  for (var i = -startingParent; i < 0; i++) {
    if ($startParents.get(i) === $endParents.get(i)) {
      return $startParents.get(i);
    }
  }
};
var extractTemplateMarkup = function(element) {
  element = $(element);
  var templateTag = element.length && element.filter(function() {
    var $node = $(this);
    return $node.is("script[type]") && $node.attr("type").indexOf("script") < 0;
  });
  if (templateTag.length) {
    return templateTag.eq(0).html();
  } else {
    element = $("<div>").append(element);
    return element.html();
  }
};
var normalizeTemplateElement = function normalizeTemplateElement2(element) {
  var $element = isDefined(element) && (element.nodeType || isRenderer(element)) ? $(element) : $("<div>").html(element).contents();
  if ($element.length === 1) {
    if ($element.is("script")) {
      $element = normalizeTemplateElement2($element.html().trim());
    } else if ($element.is("table")) {
      $element = $element.children("tbody").contents();
    }
  }
  return $element;
};
var clipboardText = function(event, text) {
  var clipboard = event.originalEvent && event.originalEvent.clipboardData || window$h.clipboardData;
  if (arguments.length === 1) {
    return clipboard && clipboard.getData("Text");
  }
  clipboard && clipboard.setData("Text", text);
};
var contains = function contains2(container, element) {
  if (!element) {
    return false;
  }
  if (domAdapter.isTextNode(element)) {
    element = element.parentNode;
  }
  if (domAdapter.isDocument(container)) {
    return container.documentElement.contains(element);
  }
  if (isWindow(container)) {
    return contains2(container.document, element);
  }
  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};
var window$g = hasWindow$1() ? getWindow() : {};
var FRAME_ANIMATION_STEP_TIME = 1e3 / 60;
var request = function(callback) {
  return setTimeout(callback, FRAME_ANIMATION_STEP_TIME);
};
var cancel = function(requestID) {
  clearTimeout(requestID);
};
var setAnimationFrameMethods = callOnce(function() {
  var nativeRequest = window$g.requestAnimationFrame || window$g.webkitRequestAnimationFrame || window$g.mozRequestAnimationFrame || window$g.oRequestAnimationFrame || window$g.msRequestAnimationFrame;
  var nativeCancel = window$g.cancelAnimationFrame || window$g.webkitCancelAnimationFrame || window$g.mozCancelAnimationFrame || window$g.oCancelAnimationFrame || window$g.msCancelAnimationFrame;
  if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel;
  }
  if (nativeRequest && !nativeCancel) {
    var canceledRequests = {};
    request = function(callback) {
      var requestId = nativeRequest.call(window$g, function() {
        try {
          if (requestId in canceledRequests) {
            return;
          }
          callback.apply(this, arguments);
        } finally {
          delete canceledRequests[requestId];
        }
      });
      return requestId;
    };
    cancel = function(requestId) {
      canceledRequests[requestId] = true;
    };
  }
});
function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window$g, arguments);
}
function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window$g, arguments);
}
var addNamespace$2 = (eventNames, namespace) => {
  if (!namespace) {
    throw errors$2.Error("E0017");
  }
  if (Array.isArray(eventNames)) {
    return eventNames.map((eventName) => addNamespace$2(eventName, namespace)).join(" ");
  }
  if (eventNames.indexOf(" ") !== -1) {
    return addNamespace$2(eventNames.split(/\s+/g), namespace);
  }
  return "".concat(eventNames, ".").concat(namespace);
};
var focusableFn = function(element, tabIndex) {
  if (!visible(element)) {
    return false;
  }
  var nodeName = element.nodeName.toLowerCase();
  var isTabIndexNotNaN = !isNaN(tabIndex);
  var isDisabled = element.disabled;
  var isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
  var isHyperlink = nodeName === "a";
  var isFocusable = true;
  var isContentEditable = element.isContentEditable;
  if (isDefaultFocus || isContentEditable) {
    isFocusable = !isDisabled;
  } else if (isHyperlink) {
    isFocusable = element.href || isTabIndexNotNaN;
  } else {
    isFocusable = isTabIndexNotNaN;
  }
  return isFocusable;
};
function visible(element) {
  var $element = $(element);
  return $element.is(":visible") && $element.css("visibility") !== "hidden" && $element.parents().css("visibility") !== "hidden";
}
var focusable = function(index2, element) {
  return focusableFn(element, $(element).attr("tabIndex"));
};
var tabbable = function(index2, element) {
  var tabIndex = $(element).attr("tabIndex");
  return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
};
var focused = function($element) {
  var element = $($element).get(0);
  return domAdapter.getActiveElement() === element;
};
var KEY_MAP = {
  backspace: "backspace",
  tab: "tab",
  enter: "enter",
  escape: "escape",
  pageup: "pageUp",
  pagedown: "pageDown",
  end: "end",
  home: "home",
  arrowleft: "leftArrow",
  arrowup: "upArrow",
  arrowright: "rightArrow",
  arrowdown: "downArrow",
  delete: "del",
  " ": "space",
  f: "F",
  a: "A",
  "*": "asterisk",
  "-": "minus",
  alt: "alt",
  control: "control",
  shift: "shift",
  left: "leftArrow",
  up: "upArrow",
  right: "rightArrow",
  down: "downArrow",
  multiply: "asterisk",
  spacebar: "space",
  del: "del",
  subtract: "minus",
  esc: "escape"
};
var LEGACY_KEY_CODES = {
  8: "backspace",
  9: "tab",
  13: "enter",
  27: "escape",
  33: "pageUp",
  34: "pageDown",
  35: "end",
  36: "home",
  37: "leftArrow",
  38: "upArrow",
  39: "rightArrow",
  40: "downArrow",
  46: "del",
  32: "space",
  70: "F",
  65: "A",
  106: "asterisk",
  109: "minus",
  189: "minus",
  173: "minus",
  16: "shift",
  17: "control",
  18: "alt"
};
var EVENT_SOURCES_REGEX = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
};
var fixMethod = (e) => e;
var copyEvent = (originalEvent) => fixMethod(eventsEngine.Event(originalEvent, originalEvent));
var isDxEvent = (e) => eventSource(e) === "dx";
var isNativeMouseEvent = (e) => eventSource(e) === "mouse";
var isNativeTouchEvent = (e) => eventSource(e) === "touch";
var eventSource = (_ref) => {
  var {
    type: type2
  } = _ref;
  var result = "other";
  each(EVENT_SOURCES_REGEX, function(key) {
    if (this.test(type2)) {
      result = key;
      return false;
    }
  });
  return result;
};
var isPointerEvent = (e) => eventSource(e) === "pointer";
var isMouseEvent = (e) => isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === "mouse";
var isDxMouseWheelEvent = (e) => e && e.type === "dxmousewheel";
var isTouchEvent = (e) => isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === "touch";
var eventData = (_ref3) => {
  var {
    pageX,
    pageY,
    timeStamp
  } = _ref3;
  return {
    x: pageX,
    y: pageY,
    time: timeStamp
  };
};
var eventDelta = (from, to) => ({
  x: to.x - from.x,
  y: to.y - from.y,
  time: to.time - from.time || 1
});
var hasTouches = (e) => {
  var {
    originalEvent,
    pointers
  } = e;
  if (isNativeTouchEvent(e)) {
    return (originalEvent.touches || []).length;
  }
  if (isDxEvent(e)) {
    return (pointers || []).length;
  }
  return 0;
};
var needSkipEvent = (e) => {
  var {
    target
  } = e;
  var $target = $(target);
  var isDropDown = $target.is(".dx-dropdownlist-popup-wrapper *, .dx-dropdownlist-popup-wrapper");
  var isContentEditable = (target === null || target === void 0 ? void 0 : target.isContentEditable) || (target === null || target === void 0 ? void 0 : target.hasAttribute("contenteditable"));
  var touchInEditable = $target.is("input, textarea, select") || isContentEditable;
  if ($target.is(".dx-skip-gesture-event *, .dx-skip-gesture-event") && !isDropDown) {
    return true;
  }
  if (isDxMouseWheelEvent(e)) {
    var isTextArea = $target.is("textarea") && $target.hasClass("dx-texteditor-input");
    if (isTextArea || isContentEditable) {
      return false;
    }
    var isInputFocused = $target.is("input[type='number'], textarea, select") && $target.is(":focus");
    return isInputFocused;
  }
  if (isMouseEvent(e)) {
    return touchInEditable || e.which > 1;
  }
  if (isTouchEvent(e)) {
    return touchInEditable && focused($target);
  }
};
var createEvent = (originalEvent, args) => {
  var event = copyEvent(originalEvent);
  args && extend(event, args);
  return event;
};
var fireEvent = (props) => {
  var {
    originalEvent,
    delegateTarget
  } = props;
  var event = createEvent(originalEvent, props);
  eventsEngine.trigger(delegateTarget || event.target, event);
  return event;
};
var normalizeKeyName = (_ref4) => {
  var {
    key,
    which
  } = _ref4;
  var isKeySupported = !!key;
  key = isKeySupported ? key : which;
  if (key) {
    if (isKeySupported) {
      key = KEY_MAP[key.toLowerCase()] || key;
    } else {
      key = LEGACY_KEY_CODES[key] || String.fromCharCode(key);
    }
    return key;
  }
};
var getChar = (_ref5) => {
  var {
    key,
    which
  } = _ref5;
  return key || String.fromCharCode(which);
};
var addNamespace$1 = addNamespace$2;
var isCommandKeyPressed = (_ref6) => {
  var {
    ctrlKey,
    metaKey
  } = _ref6;
  return ctrlKey || metaKey;
};
var REMOVE_EVENT_NAME = "dxremove";
function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter((node) => !!node);
}
var subscribeNodesDisposing = (event, callback) => {
  eventsEngine.one(nodesByEvent(event), REMOVE_EVENT_NAME, callback);
};
var unsubscribeNodesDisposing = (event, callback) => {
  eventsEngine.off(nodesByEvent(event), REMOVE_EVENT_NAME, callback);
};
var {
  maxTouchPoints,
  msMaxTouchPoints,
  pointerEnabled
} = getNavigator();
var transitionEndEventNames = {
  webkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd",
  msTransition: "MsTransitionEnd",
  transition: "transitionend"
};
var supportProp = function(prop) {
  return !!styleProp(prop);
};
var isNativeScrollingSupported = function() {
  var {
    platform,
    version: version2,
    mac: isMac
  } = devices.real();
  var isObsoleteAndroid = version2 && version2[0] < 4 && platform === "android";
  var isNativeScrollDevice = !isObsoleteAndroid && inArray(platform, ["ios", "android"]) > -1 || isMac;
  return isNativeScrollDevice;
};
var inputType = function(type2) {
  if (type2 === "text") {
    return true;
  }
  var input = domAdapter.createElement("input");
  try {
    input.setAttribute("type", type2);
    input.value = "wrongValue";
    return !input.value;
  } catch (e) {
    return false;
  }
};
var detectTouchEvents = function(hasWindowProperty, maxTouchPoints2) {
  return (hasWindowProperty("ontouchstart") || !!maxTouchPoints2) && !hasWindowProperty("callPhantom");
};
var detectPointerEvent = function(hasWindowProperty, pointerEnabled2) {
  var isPointerEnabled = ensureDefined(pointerEnabled2, true);
  var canUsePointerEvent = ensureDefined(pointerEnabled2, false);
  return hasWindowProperty("PointerEvent") && isPointerEnabled || canUsePointerEvent;
};
var touchEvents = detectTouchEvents(hasProperty, maxTouchPoints);
var pointerEvents = detectPointerEvent(hasProperty, pointerEnabled);
var touchPointersPresent = !!maxTouchPoints || !!msMaxTouchPoints;
var touch = touchEvents || pointerEvents && touchPointersPresent;
var transition = callOnce(function() {
  return supportProp("transition");
});
var transitionEndEventName = callOnce(function() {
  return transitionEndEventNames[styleProp("transition")];
});
var animation = callOnce(function() {
  return supportProp("animation");
});
var nativeScrolling = isNativeScrollingSupported();
var support = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  touchEvents,
  pointerEvents,
  styleProp,
  stylePropPrefix,
  supportProp,
  inputType,
  touch,
  transition,
  transitionEndEventName,
  animation,
  nativeScrolling
});
var POINTER_EVENTS_NAMESPACE = "dxPointerEvents";
var BaseStrategy = classImpl.inherit({
  ctor: function(eventName, originalEvents) {
    this._eventName = eventName;
    this._originalEvents = addNamespace$1(originalEvents, POINTER_EVENTS_NAMESPACE);
    this._handlerCount = 0;
    this.noBubble = this._isNoBubble();
  },
  _isNoBubble: function() {
    var eventName = this._eventName;
    return eventName === "dxpointerenter" || eventName === "dxpointerleave";
  },
  _handler: function(e) {
    var delegateTarget = this._getDelegateTarget(e);
    return this._fireEvent({
      type: this._eventName,
      pointerType: e.pointerType || eventSource(e),
      originalEvent: e,
      delegateTarget,
      timeStamp: coreBrowserUtils.mozilla ? new Date().getTime() : e.timeStamp
    });
  },
  _getDelegateTarget: function(e) {
    var delegateTarget;
    if (this.noBubble) {
      delegateTarget = e.delegateTarget;
    }
    return delegateTarget;
  },
  _fireEvent: function(args) {
    return fireEvent(args);
  },
  _setSelector: function(handleObj) {
    this._selector = this.noBubble && handleObj ? handleObj.selector : null;
  },
  _getSelector: function() {
    return this._selector;
  },
  setup: function() {
    return true;
  },
  add: function(element, handleObj) {
    if (this._handlerCount <= 0 || this.noBubble) {
      element = this.noBubble ? element : domAdapter.getDocument();
      this._setSelector(handleObj);
      var that = this;
      eventsEngine.on(element, this._originalEvents, this._getSelector(), function(e) {
        that._handler(e);
      });
    }
    if (!this.noBubble) {
      this._handlerCount++;
    }
  },
  remove: function(handleObj) {
    this._setSelector(handleObj);
    if (!this.noBubble) {
      this._handlerCount--;
    }
  },
  teardown: function(element) {
    if (this._handlerCount && !this.noBubble) {
      return;
    }
    element = this.noBubble ? element : domAdapter.getDocument();
    if (this._originalEvents !== "." + POINTER_EVENTS_NAMESPACE) {
      eventsEngine.off(element, this._originalEvents, this._getSelector());
    }
  },
  dispose: function(element) {
    element = this.noBubble ? element : domAdapter.getDocument();
    eventsEngine.off(element, this._originalEvents);
  }
});
var eventMap$3 = {
  dxpointerdown: "touchstart",
  dxpointermove: "touchmove",
  dxpointerup: "touchend",
  dxpointercancel: "touchcancel",
  dxpointerover: "",
  dxpointerout: "",
  dxpointerenter: "",
  dxpointerleave: ""
};
var normalizeTouchEvent = function(e) {
  var pointers = [];
  each(e.touches, function(_2, touch2) {
    pointers.push(extend({
      pointerId: touch2.identifier
    }, touch2));
  });
  return {
    pointers,
    pointerId: e.changedTouches[0].identifier
  };
};
var skipTouchWithSameIdentifier = function(pointerEvent) {
  return devices.real().platform === "ios" && (pointerEvent === "dxpointerdown" || pointerEvent === "dxpointerup");
};
var TouchStrategy = BaseStrategy.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._pointerId = 0;
  },
  _handler: function(e) {
    if (skipTouchWithSameIdentifier(this._eventName)) {
      var touch2 = e.changedTouches[0];
      if (this._pointerId === touch2.identifier && this._pointerId !== 0) {
        return;
      }
      this._pointerId = touch2.identifier;
    }
    return this.callBase.apply(this, arguments);
  },
  _fireEvent: function(args) {
    return this.callBase(extend(normalizeTouchEvent(args.originalEvent), args));
  }
});
TouchStrategy.map = eventMap$3;
TouchStrategy.normalize = normalizeTouchEvent;
var addEventsListener = function(events, handler) {
  readyCallback.add(function() {
    events.split(" ").forEach(function(event) {
      domAdapter.listen(domAdapter.getDocument(), event, handler, true);
    });
  });
};
var Observer = function(eventMap2, pointerEquals, onPointerAdding) {
  onPointerAdding = onPointerAdding || function() {
  };
  var pointers = [];
  var getPointerIndex = function(e) {
    var index2 = -1;
    each(pointers, function(i, pointer2) {
      if (!pointerEquals(e, pointer2)) {
        return true;
      }
      index2 = i;
      return false;
    });
    return index2;
  };
  var removePointer = function(e) {
    var index2 = getPointerIndex(e);
    if (index2 > -1) {
      pointers.splice(index2, 1);
    }
  };
  addEventsListener(eventMap2.dxpointerdown, function(e) {
    if (getPointerIndex(e) === -1) {
      onPointerAdding(e);
      pointers.push(e);
    }
  });
  addEventsListener(eventMap2.dxpointermove, function(e) {
    pointers[getPointerIndex(e)] = e;
  });
  addEventsListener(eventMap2.dxpointerup, removePointer);
  addEventsListener(eventMap2.dxpointercancel, removePointer);
  this.pointers = function() {
    return pointers;
  };
  this.reset = function() {
    pointers = [];
  };
};
var eventMap$2 = {
  dxpointerdown: "pointerdown",
  dxpointermove: "pointermove",
  dxpointerup: "pointerup",
  dxpointercancel: "pointercancel",
  dxpointerover: "pointerover",
  dxpointerout: "pointerout",
  dxpointerenter: "pointerenter",
  dxpointerleave: "pointerleave"
};
var observer$1;
var activated$2 = false;
var activateStrategy$2 = function() {
  if (activated$2) {
    return;
  }
  observer$1 = new Observer(eventMap$2, function(a, b) {
    return a.pointerId === b.pointerId;
  }, function(e) {
    if (e.isPrimary) {
      observer$1.reset();
    }
  });
  activated$2 = true;
};
var MsPointerStrategy = BaseStrategy.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    activateStrategy$2();
  },
  _fireEvent: function(args) {
    return this.callBase(extend({
      pointers: observer$1.pointers(),
      pointerId: args.originalEvent.pointerId
    }, args));
  }
});
MsPointerStrategy.map = eventMap$2;
MsPointerStrategy.resetObserver = function() {
  observer$1.reset();
};
var eventMap$1 = {
  dxpointerdown: "mousedown",
  dxpointermove: "mousemove",
  dxpointerup: "mouseup",
  dxpointercancel: "",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
var normalizeMouseEvent = function(e) {
  e.pointerId = 1;
  return {
    pointers: observer.pointers(),
    pointerId: 1
  };
};
var observer;
var activated$1 = false;
var activateStrategy$1 = function() {
  if (activated$1) {
    return;
  }
  observer = new Observer(eventMap$1, function() {
    return true;
  });
  activated$1 = true;
};
var MouseStrategy = BaseStrategy.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    activateStrategy$1();
  },
  _fireEvent: function(args) {
    return this.callBase(extend(normalizeMouseEvent(args.originalEvent), args));
  }
});
MouseStrategy.map = eventMap$1;
MouseStrategy.normalize = normalizeMouseEvent;
MouseStrategy.activate = activateStrategy$1;
MouseStrategy.resetObserver = function() {
  observer.reset();
};
var eventMap = {
  dxpointerdown: "touchstart mousedown",
  dxpointermove: "touchmove mousemove",
  dxpointerup: "touchend mouseup",
  dxpointercancel: "touchcancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
var activated = false;
var activateStrategy = function() {
  if (activated) {
    return;
  }
  MouseStrategy.activate();
  activated = true;
};
var MouseAndTouchStrategy = BaseStrategy.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor: function() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _handler: function(e) {
    var isMouse = isMouseEvent(e);
    if (!isMouse) {
      this._skipNextEvents = true;
    }
    if (isMouse && this._mouseLocked) {
      return;
    }
    if (isMouse && this._skipNextEvents) {
      this._skipNextEvents = false;
      this._mouseLocked = true;
      clearTimeout(this._unlockMouseTimer);
      var that = this;
      this._unlockMouseTimer = setTimeout(function() {
        that._mouseLocked = false;
      }, this.EVENT_LOCK_TIMEOUT);
      return;
    }
    return this.callBase(e);
  },
  _fireEvent: function(args) {
    var normalizer = isMouseEvent(args.originalEvent) ? MouseStrategy.normalize : TouchStrategy.normalize;
    return this.callBase(extend(normalizer(args.originalEvent), args));
  },
  dispose: function() {
    this.callBase();
    this._skipNextEvents = false;
    this._mouseLocked = false;
    clearTimeout(this._unlockMouseTimer);
  }
});
MouseAndTouchStrategy.map = eventMap;
MouseAndTouchStrategy.resetObserver = MouseStrategy.resetObserver;
var getStrategy = (support2, device, browser) => {
  if (support2.pointerEvents && browser.msie) {
    return MsPointerStrategy;
  }
  var {
    tablet,
    phone
  } = device;
  if (support2.touch && !(tablet || phone)) {
    return MouseAndTouchStrategy;
  }
  if (support2.touch) {
    return TouchStrategy;
  }
  return MouseStrategy;
};
var EventStrategy = getStrategy(support, devices.real(), coreBrowserUtils);
each(EventStrategy.map, (pointerEvent, originalEvents) => {
  registerEvent(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
});
var pointer = {
  down: "dxpointerdown",
  up: "dxpointerup",
  move: "dxpointermove",
  cancel: "dxpointercancel",
  enter: "dxpointerenter",
  leave: "dxpointerleave",
  over: "dxpointerover",
  out: "dxpointerout"
};
var Emitter = classImpl.inherit({
  ctor: function(element) {
    this._$element = $(element);
    this._cancelCallback = Callbacks();
    this._acceptCallback = Callbacks();
  },
  getElement: function() {
    return this._$element;
  },
  validate: function(e) {
    return !isDxMouseWheelEvent(e);
  },
  validatePointers: function(e) {
    return hasTouches(e) === 1;
  },
  allowInterruptionByMouseWheel: function() {
    return true;
  },
  configure: function(data2) {
    extend(this, data2);
  },
  addCancelCallback: function(callback) {
    this._cancelCallback.add(callback);
  },
  removeCancelCallback: function() {
    this._cancelCallback.empty();
  },
  _cancel: function(e) {
    this._cancelCallback.fire(this, e);
  },
  addAcceptCallback: function(callback) {
    this._acceptCallback.add(callback);
  },
  removeAcceptCallback: function() {
    this._acceptCallback.empty();
  },
  _accept: function(e) {
    this._acceptCallback.fire(this, e);
  },
  _requestAccept: function(e) {
    this._acceptRequestEvent = e;
  },
  _forgetAccept: function() {
    this._accept(this._acceptRequestEvent);
    this._acceptRequestEvent = null;
  },
  start: noop,
  move: noop,
  end: noop,
  cancel: noop,
  reset: function() {
    if (this._acceptRequestEvent) {
      this._accept(this._acceptRequestEvent);
    }
  },
  _fireEvent: function(eventName, e, params) {
    var eventData2 = extend({
      type: eventName,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, params);
    e = fireEvent(eventData2);
    if (e.cancel) {
      this._cancel(e);
    }
    return e;
  },
  _getEmitterTarget: function(e) {
    return (this.delegateSelector ? $(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: noop
});
var EVENT_NAME = "dxmousewheel";
var EVENT_NAMESPACE = "dxWheel";
var NATIVE_EVENT_NAME = "wheel";
var PIXEL_MODE = 0;
var DELTA_MUTLIPLIER = 30;
var wheel = {
  setup: function(element) {
    var $element = $(element);
    eventsEngine.on($element, addNamespace$1(NATIVE_EVENT_NAME, EVENT_NAMESPACE), wheel._wheelHandler.bind(wheel));
  },
  teardown: function(element) {
    eventsEngine.off(element, ".".concat(EVENT_NAMESPACE));
  },
  _wheelHandler: function(e) {
    var {
      deltaMode,
      deltaY,
      deltaX,
      deltaZ
    } = e.originalEvent;
    fireEvent({
      type: EVENT_NAME,
      originalEvent: e,
      delta: this._normalizeDelta(deltaY, deltaMode),
      deltaX,
      deltaY,
      deltaZ,
      deltaMode,
      pointerType: "mouse"
    });
    e.stopPropagation();
  },
  _normalizeDelta(delta) {
    var deltaMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : PIXEL_MODE;
    if (deltaMode === PIXEL_MODE) {
      return -delta;
    } else {
      return -DELTA_MUTLIPLIER * delta;
    }
  }
};
registerEvent(EVENT_NAME, wheel);
var MANAGER_EVENT = "dxEventManager";
var EMITTER_DATA = "dxEmitter";
var EventManager = classImpl.inherit({
  ctor: function() {
    this._attachHandlers();
    this.reset();
    this._proxiedCancelHandler = this._cancelHandler.bind(this);
    this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers: function() {
    readyCallback.add(function() {
      var document2 = domAdapter.getDocument();
      eventsEngine.subscribeGlobal(document2, addNamespace$1(pointer.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
      eventsEngine.subscribeGlobal(document2, addNamespace$1(pointer.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
      eventsEngine.subscribeGlobal(document2, addNamespace$1([pointer.up, pointer.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this));
      eventsEngine.subscribeGlobal(document2, addNamespace$1(EVENT_NAME, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
    }.bind(this));
  },
  _eachEmitter: function(callback) {
    var activeEmitters = this._activeEmitters || [];
    var i = 0;
    while (activeEmitters.length > i) {
      var emitter = activeEmitters[i];
      if (callback(emitter) === false) {
        break;
      }
      if (activeEmitters[i] === emitter) {
        i++;
      }
    }
  },
  _applyToEmitters: function(method, arg) {
    this._eachEmitter(function(emitter) {
      emitter[method].call(emitter, arg);
    });
  },
  reset: function() {
    this._eachEmitter(this._proxiedCancelHandler);
    this._activeEmitters = [];
  },
  resetEmitter: function(emitter) {
    this._proxiedCancelHandler(emitter);
  },
  _pointerDownHandler: function(e) {
    if (isMouseEvent(e) && e.which > 1) {
      return;
    }
    this._updateEmitters(e);
  },
  _updateEmitters: function(e) {
    if (!this._isSetChanged(e)) {
      return;
    }
    this._cleanEmitters(e);
    this._fetchEmitters(e);
  },
  _isSetChanged: function(e) {
    var currentSet = this._closestEmitter(e);
    var previousSet = this._emittersSet || [];
    var setChanged = currentSet.length !== previousSet.length;
    each(currentSet, function(index2, emitter) {
      setChanged = setChanged || previousSet[index2] !== emitter;
      return !setChanged;
    });
    this._emittersSet = currentSet;
    return setChanged;
  },
  _closestEmitter: function(e) {
    var that = this;
    var result = [];
    var $element = $(e.target);
    function handleEmitter(_2, emitter) {
      if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
        emitter.addCancelCallback(that._proxiedCancelHandler);
        emitter.addAcceptCallback(that._proxiedAcceptHandler);
        result.push(emitter);
      }
    }
    while ($element.length) {
      var emitters = data($element.get(0), EMITTER_DATA) || [];
      each(emitters, handleEmitter);
      $element = $element.parent();
    }
    return result;
  },
  _acceptHandler: function(acceptedEmitter, e) {
    var that = this;
    this._eachEmitter(function(emitter) {
      if (emitter !== acceptedEmitter) {
        that._cancelEmitter(emitter, e);
      }
    });
  },
  _cancelHandler: function(canceledEmitter, e) {
    this._cancelEmitter(canceledEmitter, e);
  },
  _cancelEmitter: function(emitter, e) {
    var activeEmitters = this._activeEmitters;
    if (e) {
      emitter.cancel(e);
    } else {
      emitter.reset();
    }
    emitter.removeCancelCallback();
    emitter.removeAcceptCallback();
    var emitterIndex = inArray(emitter, activeEmitters);
    if (emitterIndex > -1) {
      activeEmitters.splice(emitterIndex, 1);
    }
  },
  _cleanEmitters: function(e) {
    this._applyToEmitters("end", e);
    this.reset(e);
  },
  _fetchEmitters: function(e) {
    this._activeEmitters = this._emittersSet.slice();
    this._applyToEmitters("start", e);
  },
  _pointerMoveHandler: function(e) {
    this._applyToEmitters("move", e);
  },
  _pointerUpHandler: function(e) {
    this._updateEmitters(e);
  },
  _mouseWheelHandler: function(e) {
    if (!this._allowInterruptionByMouseWheel()) {
      return;
    }
    e.pointers = [null];
    this._pointerDownHandler(e);
    this._adjustWheelEvent(e);
    this._pointerMoveHandler(e);
    e.pointers = [];
    this._pointerUpHandler(e);
  },
  _allowInterruptionByMouseWheel: function() {
    var allowInterruption = true;
    this._eachEmitter(function(emitter) {
      allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
      return allowInterruption;
    });
    return allowInterruption;
  },
  _adjustWheelEvent: function(e) {
    var closestGestureEmitter = null;
    this._eachEmitter(function(emitter) {
      if (!emitter.gesture) {
        return;
      }
      var direction2 = emitter.getDirection(e);
      if (direction2 !== "horizontal" && !e.shiftKey || direction2 !== "vertical" && e.shiftKey) {
        closestGestureEmitter = emitter;
        return false;
      }
    });
    if (!closestGestureEmitter) {
      return;
    }
    var direction = closestGestureEmitter.getDirection(e);
    var verticalGestureDirection = direction === "both" && !e.shiftKey || direction === "vertical";
    var prop = verticalGestureDirection ? "pageY" : "pageX";
    e[prop] += e.delta;
  },
  isActive: function(element) {
    var result = false;
    this._eachEmitter(function(emitter) {
      result = result || emitter.getElement().is(element);
    });
    return result;
  }
});
var eventManager = new EventManager();
var EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
var registerEmitter = function(emitterConfig) {
  var emitterClass = emitterConfig.emitter;
  var emitterName = emitterConfig.events[0];
  var emitterEvents = emitterConfig.events;
  each(emitterEvents, function(_2, eventName) {
    registerEvent(eventName, {
      noBubble: !emitterConfig.bubble,
      setup: function(element) {
        var subscriptions = data(element, EMITTER_SUBSCRIPTION_DATA) || {};
        var emitters = data(element, EMITTER_DATA) || {};
        var emitter = emitters[emitterName] || new emitterClass(element);
        subscriptions[eventName] = true;
        emitters[emitterName] = emitter;
        data(element, EMITTER_DATA, emitters);
        data(element, EMITTER_SUBSCRIPTION_DATA, subscriptions);
      },
      add: function(element, handleObj) {
        var emitters = data(element, EMITTER_DATA);
        var emitter = emitters[emitterName];
        emitter.configure(extend({
          delegateSelector: handleObj.selector
        }, handleObj.data), handleObj.type);
      },
      teardown: function(element) {
        var subscriptions = data(element, EMITTER_SUBSCRIPTION_DATA);
        var emitters = data(element, EMITTER_DATA);
        var emitter = emitters[emitterName];
        delete subscriptions[eventName];
        var disposeEmitter = true;
        each(emitterEvents, function(_3, eventName2) {
          disposeEmitter = disposeEmitter && !subscriptions[eventName2];
          return disposeEmitter;
        });
        if (disposeEmitter) {
          if (eventManager.isActive(element)) {
            eventManager.resetEmitter(emitter);
          }
          emitter && emitter.dispose();
          delete emitters[emitterName];
        }
      }
    });
  });
};
function compare(x, y, maxLevel) {
  function normalizeArg(value2) {
    if (typeof value2 === "string") {
      return value2.split(".");
    }
    if (typeof value2 === "number") {
      return [value2];
    }
    return value2;
  }
  x = normalizeArg(x);
  y = normalizeArg(y);
  var length = Math.max(x.length, y.length);
  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }
  for (var i = 0; i < length; i++) {
    var xItem = parseInt(x[i] || 0, 10);
    var yItem = parseInt(y[i] || 0, 10);
    if (xItem < yItem) {
      return -1;
    }
    if (xItem > yItem) {
      return 1;
    }
  }
  return 0;
}
var CLICK_EVENT_NAME$2 = "dxclick";
var TOUCH_BOUNDARY$2 = 10;
var abs$2 = Math.abs;
var isInput = function(element) {
  return $(element).is("input, textarea, select, button ,:focus, :focus *");
};
var misc = {
  requestAnimationFrame,
  cancelAnimationFrame
};
var ClickEmitter = Emitter.inherit({
  ctor: function(element) {
    this.callBase(element);
    this._makeElementClickable($(element));
  },
  _makeElementClickable: function($element) {
    if (!$element.attr("onclick")) {
      $element.attr("onclick", "void(0)");
    }
  },
  start: function(e) {
    this._blurPrevented = e.isDefaultPrevented();
    this._startTarget = e.target;
    this._startEventData = eventData(e);
  },
  end: function(e) {
    if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === pointer.cancel) {
      this._cancel(e);
      return;
    }
    if (!isInput(e.target) && !this._blurPrevented) {
      resetActiveElement();
    }
    this._accept(e);
    this._clickAnimationFrame = misc.requestAnimationFrame(function() {
      this._fireClickEvent(e);
    }.bind(this));
  },
  _eventOutOfElement: function(e, element) {
    var target = e.target;
    var targetChanged = !contains(element, target) && element !== target;
    var gestureDelta = eventDelta(eventData(e), this._startEventData);
    var boundsExceeded = abs$2(gestureDelta.x) > TOUCH_BOUNDARY$2 || abs$2(gestureDelta.y) > TOUCH_BOUNDARY$2;
    return targetChanged || boundsExceeded;
  },
  _fireClickEvent: function(e) {
    this._fireEvent(CLICK_EVENT_NAME$2, e, {
      target: closestCommonParent(this._startTarget, e.target)
    });
  },
  dispose: function() {
    misc.cancelAnimationFrame(this._clickAnimationFrame);
  }
});
var realDevice$2 = devices.real();
var useNativeClick = realDevice$2.generic || realDevice$2.ios && compare(realDevice$2.version, [9, 3]) >= 0 || realDevice$2.android && compare(realDevice$2.version, [5]) >= 0;
!function() {
  var isNativeClickEvent = function(target) {
    return useNativeClick || $(target).closest(".dx-native-click").length;
  };
  var prevented = null;
  var lastFiredEvent = null;
  function onNodeRemove() {
    lastFiredEvent = null;
  }
  var clickHandler = function(e) {
    var originalEvent = e.originalEvent;
    var eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
    var leftButton = !e.which || e.which === 1;
    if (leftButton && !prevented && isNativeClickEvent(e.target) && !eventAlreadyFired) {
      if (originalEvent) {
        originalEvent.DXCLICK_FIRED = true;
      }
      unsubscribeNodesDisposing(lastFiredEvent, onNodeRemove);
      lastFiredEvent = originalEvent;
      subscribeNodesDisposing(lastFiredEvent, onNodeRemove);
      fireEvent({
        type: CLICK_EVENT_NAME$2,
        originalEvent: e
      });
    }
  };
  ClickEmitter = ClickEmitter.inherit({
    _makeElementClickable: function($element) {
      if (!isNativeClickEvent($element)) {
        this.callBase($element);
      }
      eventsEngine.on($element, "click", clickHandler);
    },
    configure: function(data2) {
      this.callBase(data2);
      if (data2.useNative) {
        this.getElement().addClass("dx-native-click");
      }
    },
    start: function(e) {
      prevented = null;
      if (!isNativeClickEvent(e.target)) {
        this.callBase(e);
      }
    },
    end: function(e) {
      if (!isNativeClickEvent(e.target)) {
        this.callBase(e);
      }
    },
    cancel: function() {
      prevented = true;
    },
    dispose: function() {
      this.callBase();
      eventsEngine.off(this.getElement(), "click", clickHandler);
    }
  });
}();
!function() {
  var desktopDevice = devices.real().generic;
  if (!desktopDevice) {
    var startTarget = null;
    var blurPrevented = false;
    var document2 = domAdapter.getDocument();
    eventsEngine.subscribeGlobal(document2, addNamespace$1(pointer.down, "NATIVE_CLICK_FIXER"), function(e) {
      startTarget = e.target;
      blurPrevented = e.isDefaultPrevented();
    });
    eventsEngine.subscribeGlobal(document2, addNamespace$1("click", "NATIVE_CLICK_FIXER"), function(e) {
      var $target = $(e.target);
      if (!blurPrevented && startTarget && !$target.is(startTarget) && !$(startTarget).is("label") && isInput($target)) {
        resetActiveElement();
      }
      startTarget = null;
      blurPrevented = false;
    });
  }
}();
registerEmitter({
  emitter: ClickEmitter,
  bubble: true,
  events: [CLICK_EVENT_NAME$2]
});
var parentLocales = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CA": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PH": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  nb: "no",
  nn: "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "root",
  "az-Cyrl": "root",
  "blt-Latn": "root",
  "bm-Nkoo": "root",
  "bs-Cyrl": "root",
  "byn-Latn": "root",
  "cu-Glag": "root",
  "dje-Arab": "root",
  "dyo-Arab": "root",
  "en-Dsrt": "root",
  "en-Shaw": "root",
  "ff-Adlm": "root",
  "ff-Arab": "root",
  "ha-Arab": "root",
  "hi-Latn": "root",
  "iu-Latn": "root",
  "kk-Arab": "root",
  "ks-Deva": "root",
  "ku-Arab": "root",
  "ky-Arab": "root",
  "ky-Latn": "root",
  "ml-Arab": "root",
  "mn-Mong": "root",
  "mni-Mtei": "root",
  "ms-Arab": "root",
  "pa-Arab": "root",
  "sat-Deva": "root",
  "sd-Deva": "root",
  "sd-Khoj": "root",
  "sd-Sind": "root",
  "shi-Latn": "root",
  "so-Arab": "root",
  "sr-Latn": "root",
  "sw-Arab": "root",
  "tg-Arab": "root",
  "ug-Cyrl": "root",
  "uz-Arab": "root",
  "uz-Cyrl": "root",
  "vai-Latn": "root",
  "wo-Arab": "root",
  "yo-Arab": "root",
  "yue-Hans": "root",
  "zh-Hant": "root",
  "zh-Hant-MO": "zh-Hant-HK"
};
var PARENT_LOCALE_SEPARATOR = "-";
var getParentLocale = (parentLocales2, locale2) => {
  var parentLocale = parentLocales2[locale2];
  if (parentLocale) {
    return parentLocale !== "root" && parentLocale;
  }
  return locale2.substr(0, locale2.lastIndexOf(PARENT_LOCALE_SEPARATOR));
};
var DEFAULT_LOCALE = "en";
var core = injector({
  locale: (() => {
    var currentLocale = DEFAULT_LOCALE;
    return (locale2) => {
      if (!locale2) {
        return currentLocale;
      }
      currentLocale = locale2;
    };
  })(),
  getValueByClosestLocale: function(getter) {
    var locale2 = this.locale();
    var value2 = getter(locale2);
    var isRootLocale;
    while (!value2 && !isRootLocale) {
      locale2 = getParentLocale(parentLocales, locale2);
      if (locale2) {
        value2 = getter(locale2);
      } else {
        isRootLocale = true;
      }
    }
    if (value2 === void 0 && locale2 !== DEFAULT_LOCALE) {
      return getter(DEFAULT_LOCALE);
    }
    return value2;
  }
});
var defaultMessages = {
  en: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Clear: "Clear",
    Done: "Done",
    Loading: "Loading...",
    Select: "Select...",
    Search: "Search",
    Back: "Back",
    OK: "OK",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxFileUploader-selectFile": "Select file",
    "dxFileUploader-dropFile": "or Drop file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "kb",
    "dxFileUploader-Mb": "Mb",
    "dxFileUploader-Gb": "Gb",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Fix",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "To the left",
    "dxDataGrid-columnFixingRightPosition": "To the right",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows",
    "dxDataGrid-exportAll": "Export all data",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaDataGrid": "Data grid",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxTreeList-ariaTreeList": "Tree list",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSizesAllText": "All",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
    "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}"
  }
};
var baseDictionary = extend(true, {}, defaultMessages);
var getDataByLocale = (localeData, locale2) => localeData[locale2] || {};
var newMessages = {};
var messageLocalization = injector({
  engine: function() {
    return "base";
  },
  _dictionary: baseDictionary,
  load: function(messages) {
    extend(true, this._dictionary, messages);
  },
  _localizablePrefix: "@",
  setup: function(localizablePrefix) {
    this._localizablePrefix = localizablePrefix;
  },
  localizeString: function(text) {
    var that = this;
    var regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g");
    var escapeString = that._localizablePrefix + that._localizablePrefix;
    return text.replace(regex, (str, prefix, escape, localizationKey) => {
      var defaultResult = that._localizablePrefix + localizationKey;
      var result;
      if (escape !== escapeString) {
        result = that.format(localizationKey);
      }
      if (!result) {
        newMessages[localizationKey] = humanize(localizationKey);
      }
      return prefix + (result || defaultResult);
    });
  },
  localizeNode: function(node) {
    var that = this;
    $(node).each((index2, nodeItem) => {
      if (!nodeItem.nodeType) {
        return;
      }
      if (nodeItem.nodeType === 3) {
        nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue);
      } else if (!$(nodeItem).is("iframe")) {
        each(nodeItem.attributes || [], (index3, attr) => {
          if (typeof attr.value === "string") {
            var localizedValue = that.localizeString(attr.value);
            if (attr.value !== localizedValue) {
              attr.value = localizedValue;
            }
          }
        });
        $(nodeItem).contents().each((index3, node2) => {
          that.localizeNode(node2);
        });
      }
    });
  },
  getMessagesByLocales: function() {
    return this._dictionary;
  },
  getDictionary: function(onlyNew) {
    if (onlyNew) {
      return newMessages;
    }
    return extend({}, newMessages, this.getMessagesByLocales()[core.locale()]);
  },
  getFormatter: function(key) {
    return this._getFormatterBase(key) || this._getFormatterBase(key, "en");
  },
  _getFormatterBase: function(key, locale2) {
    var message = core.getValueByClosestLocale((locale3) => getDataByLocale(this._dictionary, locale3)[key]);
    if (message) {
      return function() {
        var args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        args.unshift(message);
        return format.apply(this, args);
      };
    }
  },
  format: function(key) {
    var formatter = this.getFormatter(key);
    var values = Array.prototype.slice.call(arguments, 1);
    return formatter && formatter.apply(this, values) || "";
  }
});
class Action {
  constructor(action, config2) {
    config2 = config2 || {};
    this._action = action;
    this._context = config2.context || getWindow();
    this._beforeExecute = config2.beforeExecute;
    this._afterExecute = config2.afterExecute;
    this._component = config2.component;
    this._validatingTargetName = config2.validatingTargetName;
    var excludeValidators = this._excludeValidators = {};
    if (config2.excludeValidators) {
      for (var i = 0; i < config2.excludeValidators.length; i++) {
        excludeValidators[config2.excludeValidators[i]] = true;
      }
    }
  }
  execute() {
    var e = {
      action: this._action,
      args: Array.prototype.slice.call(arguments),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: false,
      handled: false
    };
    var beforeExecute = this._beforeExecute;
    var afterExecute = this._afterExecute;
    var argsBag = e.args[0] || {};
    if (!this._validateAction(e)) {
      return;
    }
    beforeExecute === null || beforeExecute === void 0 ? void 0 : beforeExecute.call(this._context, e);
    if (e.cancel) {
      return;
    }
    var result = this._executeAction(e);
    if (argsBag.cancel) {
      return;
    }
    afterExecute === null || afterExecute === void 0 ? void 0 : afterExecute.call(this._context, e);
    return result;
  }
  _validateAction(e) {
    var excludeValidators = this._excludeValidators;
    var {
      executors
    } = Action;
    for (var name2 in executors) {
      if (!excludeValidators[name2]) {
        var _executor$validate;
        var executor = executors[name2];
        (_executor$validate = executor.validate) === null || _executor$validate === void 0 ? void 0 : _executor$validate.call(executor, e);
        if (e.cancel) {
          return false;
        }
      }
    }
    return true;
  }
  _executeAction(e) {
    var result;
    var {
      executors
    } = Action;
    for (var name2 in executors) {
      var _executor$execute;
      var executor = executors[name2];
      (_executor$execute = executor.execute) === null || _executor$execute === void 0 ? void 0 : _executor$execute.call(executor, e);
      if (e.handled) {
        result = e.result;
        break;
      }
    }
    return result;
  }
  static registerExecutor(name2, executor) {
    if (isPlainObject(name2)) {
      each(name2, Action.registerExecutor);
      return;
    }
    Action.executors[name2] = executor;
  }
  static unregisterExecutor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    each(args, function() {
      delete Action.executors[this];
    });
  }
}
Action.executors = {};
var createValidatorByTargetElement = (condition) => (e) => {
  if (!e.args.length) {
    return;
  }
  var args = e.args[0];
  var element = args[e.validatingTargetName] || args.element;
  if (element && condition($(element))) {
    e.cancel = true;
  }
};
Action.registerExecutor({
  disabled: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-disabled, .dx-state-disabled *"))
  },
  readOnly: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)"))
  },
  undefined: {
    execute: (e) => {
      if (!e.action) {
        e.result = void 0;
        e.handled = true;
      }
    }
  },
  func: {
    execute: (e) => {
      if (isFunction$1(e.action)) {
        e.result = e.action.call(e.context, e.args[0]);
        e.handled = true;
      }
    }
  }
});
var hasNegation = function(oldValue, newValue) {
  return 1 / oldValue === 1 / newValue;
};
var equals = function(oldValue, newValue) {
  oldValue = toComparable(oldValue, true);
  newValue = toComparable(newValue, true);
  if (oldValue && newValue && isRenderer(oldValue) && isRenderer(newValue)) {
    return newValue.is(oldValue);
  }
  var oldValueIsNaN = oldValue !== oldValue;
  var newValueIsNaN = newValue !== newValue;
  if (oldValueIsNaN && newValueIsNaN) {
    return true;
  }
  if (oldValue === 0 && newValue === 0) {
    return hasNegation(oldValue, newValue);
  }
  if (oldValue === null || typeof oldValue !== "object" || domAdapter.isElementNode(oldValue)) {
    return oldValue === newValue;
  }
  return false;
};
var cachedGetters$1 = {};
var convertRulesToOptions = (rules) => {
  var currentDevice = devices.current();
  return rules.reduce((options, _ref) => {
    var {
      device,
      options: ruleOptions
    } = _ref;
    var deviceFilter = device || {};
    var match2 = isFunction$1(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
    if (match2) {
      extend(true, options, ruleOptions);
    }
    return options;
  }, {});
};
var normalizeOptions = (options, value2) => typeof options !== "string" ? options : {
  [options]: value2
};
var deviceMatch = (device, filter) => isEmptyObject(filter) || findBestMatches(device, [filter]).length > 0;
var getFieldName = (fullName) => fullName.substr(fullName.lastIndexOf(".") + 1);
var getParentName = (fullName) => fullName.substr(0, fullName.lastIndexOf("."));
var getNestedOptionValue = function(optionsObject, name2) {
  cachedGetters$1[name2] = cachedGetters$1[name2] || compileGetter(name2);
  return cachedGetters$1[name2](optionsObject, {
    functionsAsIs: true
  });
};
var cachedGetters = {};
var cachedSetters = {};
class OptionManager {
  constructor(options, optionsByReference) {
    this._options = options;
    this._optionsByReference = optionsByReference;
    this._changingCallback;
    this._changedCallback;
    this._namePreparedCallbacks;
  }
  _setByReference(options, rulesOptions) {
    extend(true, options, rulesOptions);
    for (var fieldName in this._optionsByReference) {
      if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
        options[fieldName] = rulesOptions[fieldName];
      }
    }
  }
  _setPreparedValue(name2, value2, merge2, silent) {
    var previousValue = this.get(this._options, name2, false);
    if (!equals(previousValue, value2)) {
      var path = name2.split(/[.[]/);
      !silent && this._changingCallback(name2, previousValue, value2);
      cachedSetters[name2] = cachedSetters[name2] || compileSetter(name2);
      cachedSetters[name2](this._options, value2, {
        functionsAsIs: true,
        merge: isDefined(merge2) ? merge2 : !this._optionsByReference[name2],
        unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
      });
      !silent && this._changedCallback(name2, value2, previousValue);
    }
  }
  _prepareRelevantNames(options, name2, value2, silent) {
    if (isPlainObject(value2)) {
      for (var valueName in value2) {
        this._prepareRelevantNames(options, "".concat(name2, ".").concat(valueName), value2[valueName]);
      }
    }
    this._namePreparedCallbacks(options, name2, value2, silent);
  }
  get() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._options;
    var name2 = arguments.length > 1 ? arguments[1] : void 0;
    var unwrapObservables = arguments.length > 2 ? arguments[2] : void 0;
    cachedGetters[name2] = cachedGetters[name2] || compileGetter(name2);
    return cachedGetters[name2](options, {
      functionsAsIs: true,
      unwrapObservables
    });
  }
  set(options, value2, merge2, silent) {
    options = normalizeOptions(options, value2);
    for (var name2 in options) {
      this._prepareRelevantNames(options, name2, options[name2], silent);
    }
    for (var _name in options) {
      this._setPreparedValue(_name, options[_name], merge2, silent);
    }
  }
  onRelevantNamesPrepared(callBack) {
    this._namePreparedCallbacks = callBack;
  }
  onChanging(callBack) {
    this._changingCallback = callBack;
  }
  onChanged(callBack) {
    this._changedCallback = callBack;
  }
  dispose() {
    this._changingCallback = noop;
    this._changedCallback = noop;
  }
}
class Options {
  constructor(options, defaultOptions, optionsByReference, deprecatedOptions) {
    this._deprecatedCallback;
    this._startChangeCallback;
    this._endChangeCallback;
    this._default = defaultOptions;
    this._deprecated = deprecatedOptions;
    this._deprecatedNames = [];
    this._initDeprecatedNames();
    this._optionManager = new OptionManager(options, optionsByReference);
    this._optionManager.onRelevantNamesPrepared((options2, name2, value2, silent) => this._setRelevantNames(options2, name2, value2, silent));
    this._cachedOptions = {};
    this._rules = [];
  }
  set _initial(value2) {
    this._initialOptions = value2;
  }
  get _initial() {
    if (!this._initialOptions) {
      var rulesOptions = this._getByRules(this.silent("defaultOptionsRules"));
      this._initialOptions = this._default;
      this._optionManager._setByReference(this._initialOptions, rulesOptions);
    }
    return this._initialOptions;
  }
  _initDeprecatedNames() {
    for (var optionName in this._deprecated) {
      this._deprecatedNames.push(optionName);
    }
  }
  _getByRules(rules) {
    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
    return convertRulesToOptions(rules);
  }
  _notifyDeprecated(option) {
    var info = this._deprecated[option];
    if (info) {
      this._deprecatedCallback(option, info);
    }
  }
  _setRelevantNames(options, name2, value2, silent) {
    if (name2) {
      var normalizedName = this._normalizeName(name2, silent);
      if (normalizedName && normalizedName !== name2) {
        this._setField(options, normalizedName, value2);
        this._clearField(options, name2);
      }
    }
  }
  _setField(options, fullName, value2) {
    var fieldName = "";
    var fieldObject = null;
    do {
      fieldName = fieldName ? ".".concat(fieldName) : "";
      fieldName = getFieldName(fullName) + fieldName;
      fullName = getParentName(fullName);
      fieldObject = fullName ? this._optionManager.get(options, fullName, false) : options;
    } while (!fieldObject);
    fieldObject[fieldName] = value2;
  }
  _clearField(options, name2) {
    delete options[name2];
    var previousFieldName = getParentName(name2);
    var fieldObject = previousFieldName ? this._optionManager.get(options, previousFieldName, false) : options;
    if (fieldObject) {
      delete fieldObject[getFieldName(name2)];
    }
  }
  _normalizeName(name2, silent) {
    if (this._deprecatedNames.length && name2) {
      for (var i = 0; i < this._deprecatedNames.length; i++) {
        if (this._deprecatedNames[i] === name2) {
          var deprecate = this._deprecated[name2];
          if (deprecate) {
            !silent && this._notifyDeprecated(name2);
            return deprecate.alias || name2;
          }
        }
      }
    }
    return name2;
  }
  addRules(rules) {
    this._rules = rules.concat(this._rules);
  }
  applyRules(rules) {
    var options = this._getByRules(rules);
    this.silent(options);
  }
  dispose() {
    this._deprecatedCallback = noop;
    this._startChangeCallback = noop;
    this._endChangeCallback = noop;
    this._optionManager.dispose();
  }
  onChanging(callBack) {
    this._optionManager.onChanging(callBack);
  }
  onChanged(callBack) {
    this._optionManager.onChanged(callBack);
  }
  onDeprecated(callBack) {
    this._deprecatedCallback = callBack;
  }
  onStartChange(callBack) {
    this._startChangeCallback = callBack;
  }
  onEndChange(callBack) {
    this._endChangeCallback = callBack;
  }
  isInitial(name2) {
    var value2 = this.silent(name2);
    var initialValue = this.initial(name2);
    var areFunctions = isFunction$1(value2) && isFunction$1(initialValue);
    return areFunctions ? value2.toString() === initialValue.toString() : equalByValue(value2, initialValue);
  }
  initial(name2) {
    return getNestedOptionValue(this._initial, name2);
  }
  option(options, value2) {
    var isGetter = arguments.length < 2 && type(options) !== "object";
    if (isGetter) {
      return this._optionManager.get(void 0, this._normalizeName(options));
    } else {
      this._startChangeCallback();
      try {
        this._optionManager.set(options, value2);
      } finally {
        this._endChangeCallback();
      }
    }
  }
  silent(options, value2) {
    var isGetter = arguments.length < 2 && type(options) !== "object";
    if (isGetter) {
      return this._optionManager.get(void 0, options, void 0, true);
    } else {
      this._optionManager.set(options, value2, void 0, true);
    }
  }
  reset(name2) {
    if (name2) {
      var fullPath = name2.replace(/\[([^\]])\]/g, ".$1").split(".");
      var value2 = fullPath.reduce((value3, field) => value3 ? value3[field] : this.initial(field), null);
      var defaultValue = isObject$1(value2) ? _extends({}, value2) : value2;
      this._optionManager.set(name2, defaultValue, false);
    }
  }
  getAliasesByName(name2) {
    return Object.keys(this._deprecated).filter((aliasName) => name2 === this._deprecated[aliasName].alias);
  }
  isDeprecated(name2) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, name2);
  }
  cache(name2, options) {
    var isGetter = arguments.length < 2;
    if (isGetter) {
      return this._cachedOptions[name2];
    } else {
      this._cachedOptions[name2] = extend(this._cachedOptions[name2], options);
    }
  }
}
class PostponedOperations {
  constructor() {
    this._postponedOperations = {};
  }
  add(key, fn, postponedPromise) {
    if (key in this._postponedOperations) {
      postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
    } else {
      var completePromise = new Deferred();
      this._postponedOperations[key] = {
        fn,
        completePromise,
        promises: postponedPromise ? [postponedPromise] : []
      };
    }
    return this._postponedOperations[key].completePromise.promise();
  }
  callPostponedOperations() {
    for (var key in this._postponedOperations) {
      var operation = this._postponedOperations[key];
      if (isDefined(operation)) {
        if (operation.promises && operation.promises.length) {
          when(...operation.promises).done(operation.fn).then(operation.completePromise.resolve);
        } else {
          operation.fn().done(operation.completePromise.resolve);
        }
      }
    }
    this._postponedOperations = {};
  }
}
var getEventName$1 = (actionName) => actionName.charAt(2).toLowerCase() + actionName.substr(3);
var isInnerOption = (optionName) => optionName.indexOf("_", 0) === 0;
var Component = classImpl.inherit({
  _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  },
  _getDeprecatedOptions() {
    return this._deprecatedOptions;
  },
  _getDefaultOptions: () => ({
    onInitialized: null,
    onOptionChanged: null,
    onDisposing: null,
    defaultOptionsRules: null
  }),
  _defaultOptionsRules: () => [],
  _setOptionsByDevice(rules) {
    this._options.applyRules(rules);
  },
  _convertRulesToOptions: (rules) => convertRulesToOptions(rules),
  _isInitialOptionValue(name2) {
    return this._options.isInitial(name2);
  },
  _setOptionsByReference() {
    this._optionsByReference = {};
  },
  _getOptionsByReference() {
    return this._optionsByReference;
  },
  ctor() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var {
      _optionChangedCallbacks,
      _disposingCallbacks
    } = options;
    this.NAME = getName(this.constructor);
    this._eventsStrategy = EventsStrategy.create(this, options.eventsStrategy);
    this._updateLockCount = 0;
    this._optionChangedCallbacks = _optionChangedCallbacks || Callbacks();
    this._disposingCallbacks = _disposingCallbacks || Callbacks();
    this.postponedOperations = new PostponedOperations();
    this._createOptions(options);
  },
  _createOptions(options) {
    this.beginUpdate();
    try {
      this._setOptionsByReference();
      this._setDeprecatedOptions();
      this._options = new Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
      this._options.onChanging((name2, previousValue, value2) => this._initialized && this._optionChanging(name2, previousValue, value2));
      this._options.onDeprecated((option, info) => this._logDeprecatedOptionWarning(option, info));
      this._options.onChanged((name2, value2, previousValue) => this._notifyOptionChanged(name2, value2, previousValue));
      this._options.onStartChange(() => this.beginUpdate());
      this._options.onEndChange(() => this.endUpdate());
      this._options.addRules(this._defaultOptionsRules());
      if (options && options.onInitializing) {
        options.onInitializing.apply(this, [options]);
      }
      this._setOptionsByDevice(options.defaultOptionsRules);
      this._initOptions(options);
    } finally {
      this.endUpdate();
    }
  },
  _initOptions(options) {
    this.option(options);
  },
  _init() {
    this._createOptionChangedAction();
    this.on("disposing", (args) => {
      this._disposingCallbacks.fireWith(this, [args]);
    });
  },
  _logDeprecatedOptionWarning(option, info) {
    var message = info.message || "Use the '".concat(info.alias, "' option instead");
    errors$2.log("W0001", this.NAME, option, info.since, message);
  },
  _logDeprecatedComponentWarning(since, alias) {
    errors$2.log("W0000", this.NAME, since, "Use the '".concat(alias, "' widget instead"));
  },
  _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption("onOptionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _createDisposingAction() {
    this._disposingAction = this._createActionByOption("onDisposing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case "onDisposing":
      case "onInitialized":
        break;
      case "onOptionChanged":
        this._createOptionChangedAction();
    }
  },
  _dispose() {
    this._optionChangedCallbacks.empty();
    this._createDisposingAction();
    this._disposingAction();
    this._eventsStrategy.dispose();
    this._options.dispose();
    this._disposed = true;
  },
  _lockUpdate() {
    this._updateLockCount++;
  },
  _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  },
  _isUpdateAllowed() {
    return this._updateLockCount === 0;
  },
  _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  },
  _commitUpdate() {
    this.postponedOperations.callPostponedOperations();
    this._isInitializingRequired() && this._initializeComponent();
  },
  _initializeComponent() {
    this._initializing = true;
    try {
      this._init();
    } finally {
      this._initializing = false;
      this._lockUpdate();
      this._createActionByOption("onInitialized", {
        excludeValidators: ["disabled", "readOnly"]
      })();
      this._unlockUpdate();
      this._initialized = true;
    }
  },
  instance() {
    return this;
  },
  beginUpdate: function() {
    this._lockUpdate();
  },
  endUpdate: function() {
    this._unlockUpdate();
    this._isUpdateAllowed() && this._commitUpdate();
  },
  _optionChanging: noop,
  _notifyOptionChanged(option, value2, previousValue) {
    if (this._initialized) {
      var optionNames = [option].concat(this._options.getAliasesByName(option));
      for (var i = 0; i < optionNames.length; i++) {
        var name2 = optionNames[i];
        var args = {
          name: name2.split(/[.[]/)[0],
          fullName: name2,
          value: value2,
          previousValue
        };
        if (!isInnerOption(name2)) {
          this._optionChangedCallbacks.fireWith(this, [extend(this._defaultActionArgs(), args)]);
          this._optionChangedAction(extend({}, args));
        }
        if (!this._disposed && this._cancelOptionChange !== name2) {
          this._optionChanged(args);
        }
      }
    }
  },
  initialOption(name2) {
    return this._options.initial(name2);
  },
  _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  },
  _defaultActionArgs() {
    return {
      component: this
    };
  },
  _createAction(actionSource, config2) {
    var action;
    return (e) => {
      if (!isDefined(e)) {
        e = {};
      }
      if (!isPlainObject(e)) {
        e = {
          actionValue: e
        };
      }
      action = action || new Action(actionSource, extend(config2, this._defaultActionConfig()));
      return action.execute.call(action, extend(e, this._defaultActionArgs()));
    };
  },
  _createActionByOption(optionName, config2) {
    var _this = this;
    var action;
    var eventName;
    var actionFunc;
    var result = function() {
      if (!eventName) {
        config2 = config2 || {};
        if (typeof optionName !== "string") {
          throw errors$2.Error("E0008");
        }
        if (optionName.indexOf("on") === 0) {
          eventName = getEventName$1(optionName);
        }
        actionFunc = _this.option(optionName);
      }
      if (!action && !actionFunc && !config2.beforeExecute && !config2.afterExecute && !_this._eventsStrategy.hasEvent(eventName)) {
        return;
      }
      if (!action) {
        var beforeExecute = config2.beforeExecute;
        config2.beforeExecute = function() {
          for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            props[_key2] = arguments[_key2];
          }
          beforeExecute && beforeExecute.apply(_this, props);
          _this._eventsStrategy.fireEvent(eventName, props[0].args);
        };
        action = _this._createAction(actionFunc, config2);
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (configMethod().wrapActionsBeforeExecute) {
        var beforeActionExecute = _this.option("beforeActionExecute") || noop;
        var wrappedAction = beforeActionExecute(_this, action, config2) || action;
        return wrappedAction.apply(_this, args);
      }
      return action.apply(_this, args);
    };
    if (configMethod().wrapActionsBeforeExecute) {
      return result;
    }
    var onActionCreated = this.option("onActionCreated") || noop;
    return onActionCreated(this, result, config2) || result;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  },
  hasActionSubscription: function(actionName) {
    return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName$1(actionName));
  },
  isOptionDeprecated(name2) {
    return this._options.isDeprecated(name2);
  },
  _setOptionWithoutOptionChange(name2, value2) {
    this._cancelOptionChange = name2;
    this.option(name2, value2);
    this._cancelOptionChange = false;
  },
  _getOptionValue(name2, context2) {
    var value2 = this.option(name2);
    if (isFunction$1(value2)) {
      return value2.bind(context2)();
    }
    return value2;
  },
  option() {
    return this._options.option(...arguments);
  },
  resetOption(name2) {
    this.beginUpdate();
    this._options.reset(name2);
    this.endUpdate();
  }
});
var triggerVisibilityChangeEvent = function(eventName) {
  return function(element) {
    var $element = $(element || "body");
    var changeHandlers = $element.filter(".dx-visibility-change-handler").add($element.find(".dx-visibility-change-handler"));
    for (var i = 0; i < changeHandlers.length; i++) {
      eventsEngine.triggerHandler(changeHandlers[i], eventName);
    }
  };
};
var triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
var triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
var triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");
var renderedCallbacks = Callbacks({
  syncStrategy: true
});
class TemplateBase {
  render(options) {
    options = options || {};
    var onRendered = options.onRendered;
    delete options.onRendered;
    var $result = this._renderCore(options);
    this._ensureResultInContainer($result, options.container);
    renderedCallbacks.fire($result, options.container);
    onRendered && onRendered();
    return $result;
  }
  _ensureResultInContainer($result, container) {
    if (!container) {
      return;
    }
    var $container = $(container);
    var resultInContainer = contains($container.get(0), $result.get(0));
    $container.append($result);
    if (resultInContainer) {
      return;
    }
    var resultInBody = domAdapter.getBody().contains($container.get(0));
    if (!resultInBody) {
      return;
    }
    triggerShownEvent($result);
  }
  _renderCore() {
    throw errors$2.Error("E0001");
  }
}
class FunctionTemplate extends TemplateBase {
  constructor(render2) {
    super();
    this._render = render2;
  }
  _renderCore(options) {
    return normalizeTemplateElement(this._render(options));
  }
}
class EmptyTemplate extends TemplateBase {
  _renderCore() {
    return $();
  }
}
class ChildDefaultTemplate extends TemplateBase {
  constructor(name2) {
    super();
    this.name = name2;
  }
}
var templateEngines = {};
var currentTemplateEngine;
function registerTemplateEngine(name2, templateEngine) {
  templateEngines[name2] = templateEngine;
}
function setTemplateEngine(templateEngine) {
  if (isString$1(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];
    if (!currentTemplateEngine) {
      throw errors$2.Error("E0020", templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}
function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}
registerTemplateEngine("jquery-tmpl", {
  compile: (element) => extractTemplateMarkup(element),
  render: (template, data2) => jQuery.tmpl(template, data2)
});
registerTemplateEngine("jsrender", {
  compile: (element) => (jQuery ? jQuery : jsrender).templates(extractTemplateMarkup(element)),
  render: (template, data2) => template.render(data2)
});
registerTemplateEngine("mustache", {
  compile: (element) => extractTemplateMarkup(element),
  render: (template, data2) => Mustache.render(template, data2)
});
registerTemplateEngine("hogan", {
  compile: (element) => Hogan.compile(extractTemplateMarkup(element)),
  render: (template, data2) => template.render(data2)
});
registerTemplateEngine("underscore", {
  compile: (element) => _.template(extractTemplateMarkup(element)),
  render: (template, data2) => template(data2)
});
registerTemplateEngine("handlebars", {
  compile: (element) => Handlebars.compile(extractTemplateMarkup(element)),
  render: (template, data2) => template(data2)
});
registerTemplateEngine("doT", {
  compile: (element) => doT.template(extractTemplateMarkup(element)),
  render: (template, data2) => template(data2)
});
registerTemplateEngine("default", {
  compile: (element) => normalizeTemplateElement(element),
  render: (template, model, index2) => template.clone()
});
setTemplateEngine("default");
class Template extends TemplateBase {
  constructor(element) {
    super();
    this._element = element;
  }
  _renderCore(options) {
    var transclude = options.transclude;
    if (!transclude && !this._compiledTemplate) {
      this._compiledTemplate = getCurrentTemplateEngine().compile(this._element);
    }
    return $("<div>").append(transclude ? this._element : getCurrentTemplateEngine().render(this._compiledTemplate, options.model, options.index)).contents();
  }
  source() {
    return $(this._element).clone();
  }
}
var findTemplates = (element, name2) => {
  var templates = $(element).contents().filter("[".concat("data-options", '*="').concat(name2, '"]'));
  return [].slice.call(templates).map((element2) => {
    var optionsString = $(element2).attr("data-options") || "";
    return {
      element: element2,
      options: configMethod().optionsParser(optionsString)[name2]
    };
  }).filter((template) => !!template.options);
};
var suitableTemplatesByName = (rawTemplates) => {
  var templatesMap = groupBy(rawTemplates, (template) => template.options.name);
  if (templatesMap[void 0]) {
    throw errors$2.Error("E0023");
  }
  var result = {};
  Object.keys(templatesMap).forEach((name2) => {
    var _findBestMatches$;
    var suitableTemplate = (_findBestMatches$ = findBestMatches(devices.current(), templatesMap[name2], (template) => template.options)[0]) === null || _findBestMatches$ === void 0 ? void 0 : _findBestMatches$.element;
    if (suitableTemplate) {
      result[name2] = suitableTemplate;
    }
  });
  return result;
};
var addOneRenderedCall = (template) => {
  var render2 = template.render.bind(template);
  return extend({}, template, {
    render(options) {
      var templateResult = render2(options);
      options && options.onRendered && options.onRendered();
      return templateResult;
    }
  });
};
var getNormalizedTemplateArgs = (options) => {
  var args = [];
  if ("model" in options) {
    args.push(options.model);
  }
  if ("index" in options) {
    args.push(options.index);
  }
  args.push(options.container);
  return args;
};
var validateTemplateSource = (templateSource) => typeof templateSource === "string" ? normalizeTemplateElement(templateSource) : templateSource;
var templateKey = (templateSource) => isRenderer(templateSource) && templateSource[0] || templateSource;
var defaultCreateElement = (element) => new Template(element);
var acquireIntegrationTemplate = (templateSource, templates, isAsyncTemplate, skipTemplates) => {
  var integrationTemplate = null;
  if (!skipTemplates || skipTemplates.indexOf(templateSource) === -1) {
    integrationTemplate = templates[templateSource];
    if (integrationTemplate && !(integrationTemplate instanceof TemplateBase) && !isAsyncTemplate) {
      integrationTemplate = addOneRenderedCall(integrationTemplate);
    }
  }
  return integrationTemplate;
};
var acquireTemplate = (templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) => {
  if (templateSource == null) {
    return new EmptyTemplate();
  }
  if (templateSource instanceof ChildDefaultTemplate) {
    return defaultTemplates[templateSource.name];
  }
  if (templateSource instanceof TemplateBase) {
    return templateSource;
  }
  if (isFunction$1(templateSource.render) && !isRenderer(templateSource)) {
    return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
  }
  if (templateSource.nodeType || isRenderer(templateSource)) {
    return createTemplate($(templateSource));
  }
  return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
};
var TEXT_NODE = 3;
var ANONYMOUS_TEMPLATE_NAME$4 = "template";
var TEMPLATE_OPTIONS_NAME = "dxTemplate";
var TEMPLATE_WRAPPER_CLASS$2 = "dx-template-wrapper";
var DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate((_ref) => {
  var {
    model,
    parent
  } = _ref;
  var widgetName = model.widget;
  if (!widgetName) {
    return $();
  }
  var widgetElement = $("<div>");
  var widgetOptions = model.options || {};
  if (parent) {
    parent._createComponent(widgetElement, widgetName, widgetOptions);
  } else {
    widgetElement[widgetName](widgetOptions);
  }
  return widgetElement;
});
class TemplateManager {
  constructor(createElement, anonymousTemplateName) {
    this._tempTemplates = [];
    this._defaultTemplates = {};
    this._anonymousTemplateName = anonymousTemplateName || ANONYMOUS_TEMPLATE_NAME$4;
    this._createElement = createElement || defaultCreateElement;
    this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }
  static createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function(fn, callback) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (!options.skipImmediate) {
            callback(fn());
          }
          return noop;
        },
        templates: {
          "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
        },
        useDeferUpdateForTemplates: true
      }
    };
  }
  get anonymousTemplateName() {
    return this._anonymousTemplateName;
  }
  addDefaultTemplates(templates) {
    this._defaultTemplates = extend({}, this._defaultTemplates, templates);
  }
  dispose() {
    this._tempTemplates.forEach((tempTemplate) => {
      tempTemplate.template.dispose && tempTemplate.template.dispose();
    });
    this._tempTemplates = [];
  }
  extractTemplates($el) {
    var templates = this._extractTemplates($el);
    var anonymousTemplateMeta = this._extractAnonymousTemplate($el);
    return {
      templates,
      anonymousTemplateMeta
    };
  }
  _extractTemplates($el) {
    var templates = findTemplates($el, TEMPLATE_OPTIONS_NAME);
    var suitableTemplates = suitableTemplatesByName(templates);
    templates.forEach((_ref2) => {
      var {
        element,
        options: {
          name: name2
        }
      } = _ref2;
      if (element === suitableTemplates[name2]) {
        $(element).addClass(TEMPLATE_WRAPPER_CLASS$2).detach();
      } else {
        $(element).remove();
      }
    });
    return Object.keys(suitableTemplates).map((name2) => ({
      name: name2,
      template: this._createTemplate(suitableTemplates[name2])
    }));
  }
  _extractAnonymousTemplate($el) {
    var $anonymousTemplate = $el.contents().detach();
    var $notJunkTemplateContent = $anonymousTemplate.filter((_2, element) => {
      var isTextNode = element.nodeType === TEXT_NODE;
      var isEmptyText = $(element).text().trim().length < 1;
      return !(isTextNode && isEmptyText);
    });
    return $notJunkTemplateContent.length > 0 ? {
      template: this._createTemplate($anonymousTemplate),
      name: this._anonymousTemplateName
    } : {};
  }
  _createTemplateIfNeeded(templateSource) {
    var cachedTemplate = this._tempTemplates.filter((tempTemplate) => tempTemplate.source === templateKey(templateSource))[0];
    if (cachedTemplate) {
      return cachedTemplate.template;
    }
    var template = this._createTemplate(templateSource);
    this._tempTemplates.push({
      template,
      source: templateKey(templateSource)
    });
    return template;
  }
  _createTemplate(templateSource) {
    return this._createElement(validateTemplateSource(templateSource));
  }
  getTemplate(templateSource, templates, _ref3, context2) {
    var {
      isAsyncTemplate,
      skipTemplates
    } = _ref3;
    if (!isFunction$1(templateSource)) {
      return acquireTemplate(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
    }
    return new FunctionTemplate((options) => {
      var templateSourceResult = templateSource.apply(context2, getNormalizedTemplateArgs(options));
      if (!isDefined(templateSourceResult)) {
        return new EmptyTemplate();
      }
      var dispose = false;
      var template = acquireTemplate(templateSourceResult, (templateSource2) => {
        if (templateSource2.nodeType || isRenderer(templateSource2) && !$(templateSource2).is("script")) {
          return new FunctionTemplate(() => templateSource2);
        }
        dispose = true;
        return this._createTemplate(templateSource2);
      }, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
      var result = template.render(options);
      dispose && template.dispose && template.dispose();
      return result;
    });
  }
}
var COMPOSITION_START_EVENT = "compositionstart";
var COMPOSITION_END_EVENT = "compositionend";
var KEYDOWN_EVENT = "keydown";
var NAMESPACE = "KeyboardProcessor";
var KeyboardProcessor = classImpl.inherit({
  _keydown: addNamespace$1(KEYDOWN_EVENT, NAMESPACE),
  _compositionStart: addNamespace$1(COMPOSITION_START_EVENT, NAMESPACE),
  _compositionEnd: addNamespace$1(COMPOSITION_END_EVENT, NAMESPACE),
  ctor: function(options) {
    options = options || {};
    if (options.element) {
      this._element = $(options.element);
    }
    if (options.focusTarget) {
      this._focusTarget = options.focusTarget;
    }
    this._handler = options.handler;
    if (this._element) {
      this._processFunction = (e) => {
        var isNotFocusTarget = this._focusTarget && this._focusTarget !== e.target && inArray(e.target, $(this._focusTarget)) < 0;
        var shouldSkipProcessing = this._isComposingJustFinished && e.which === 229 || this._isComposing || isNotFocusTarget;
        this._isComposingJustFinished = false;
        if (!shouldSkipProcessing) {
          this.process(e);
        }
      };
      this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
      eventsEngine.on(this._element, this._keydown, this._processFunction);
      eventsEngine.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
      eventsEngine.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
  },
  dispose: function() {
    if (this._element) {
      eventsEngine.off(this._element, this._keydown, this._processFunction);
      eventsEngine.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
      eventsEngine.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
    this._element = void 0;
    this._handler = void 0;
  },
  process: function(e) {
    this._handler({
      keyName: normalizeKeyName(e),
      key: e.key,
      code: e.code,
      ctrl: e.ctrlKey,
      location: e.location,
      metaKey: e.metaKey,
      shift: e.shiftKey,
      alt: e.altKey,
      which: e.which,
      originalEvent: e
    });
  },
  toggleProcessing: function(_ref) {
    var {
      type: type2
    } = _ref;
    this._isComposing = type2 === COMPOSITION_START_EVENT;
    this._isComposingJustFinished = !this._isComposing;
  }
});
function addNamespace(event, namespace) {
  return namespace ? addNamespace$1(event, namespace) : event;
}
function executeAction(action, args) {
  return typeof action === "function" ? action(args) : action.execute(args);
}
var active = {
  on: ($el, active2, inactive, opts) => {
    var {
      selector,
      showTimeout,
      hideTimeout,
      namespace
    } = opts;
    eventsEngine.on($el, addNamespace("dxactive", namespace), selector, {
      timeout: showTimeout
    }, (event) => executeAction(active2, {
      event,
      element: event.currentTarget
    }));
    eventsEngine.on($el, addNamespace("dxinactive", namespace), selector, {
      timeout: hideTimeout
    }, (event) => executeAction(inactive, {
      event,
      element: event.currentTarget
    }));
  },
  off: ($el, _ref) => {
    var {
      namespace,
      selector
    } = _ref;
    eventsEngine.off($el, addNamespace("dxactive", namespace), selector);
    eventsEngine.off($el, addNamespace("dxinactive", namespace), selector);
  }
};
var resize = {
  on: function($el, resize2) {
    var {
      namespace
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    eventsEngine.on($el, addNamespace("dxresize", namespace), resize2);
  },
  off: function($el) {
    var {
      namespace
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    eventsEngine.off($el, addNamespace("dxresize", namespace));
  }
};
var hover = {
  on: ($el, start, end, _ref2) => {
    var {
      selector,
      namespace
    } = _ref2;
    eventsEngine.on($el, addNamespace("dxhoverend", namespace), selector, (event) => end(event));
    eventsEngine.on($el, addNamespace("dxhoverstart", namespace), selector, (event) => executeAction(start, {
      element: event.target,
      event
    }));
  },
  off: ($el, _ref3) => {
    var {
      selector,
      namespace
    } = _ref3;
    eventsEngine.off($el, addNamespace("dxhoverstart", namespace), selector);
    eventsEngine.off($el, addNamespace("dxhoverend", namespace), selector);
  }
};
var visibility = {
  on: ($el, shown, hiding, _ref4) => {
    var {
      namespace
    } = _ref4;
    eventsEngine.on($el, addNamespace("dxhiding", namespace), hiding);
    eventsEngine.on($el, addNamespace("dxshown", namespace), shown);
  },
  off: ($el, _ref5) => {
    var {
      namespace
    } = _ref5;
    eventsEngine.off($el, addNamespace("dxhiding", namespace));
    eventsEngine.off($el, addNamespace("dxshown", namespace));
  }
};
var focus = {
  on: ($el, focusIn, focusOut, _ref6) => {
    var {
      namespace,
      isFocusable
    } = _ref6;
    eventsEngine.on($el, addNamespace("focusin", namespace), focusIn);
    eventsEngine.on($el, addNamespace("focusout", namespace), focusOut);
    if (domAdapter.hasDocumentProperty("onbeforeactivate")) {
      eventsEngine.on($el, addNamespace("beforeactivate", namespace), (e) => isFocusable(null, e.target) || e.preventDefault());
    }
  },
  off: ($el, _ref7) => {
    var {
      namespace
    } = _ref7;
    eventsEngine.off($el, addNamespace("focusin", namespace));
    eventsEngine.off($el, addNamespace("focusout", namespace));
    if (domAdapter.hasDocumentProperty("onbeforeactivate")) {
      eventsEngine.off($el, addNamespace("beforeactivate", namespace));
    }
  },
  trigger: ($el) => eventsEngine.trigger($el, "focus")
};
var dxClick = {
  on: function($el, click2) {
    var {
      namespace
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    eventsEngine.on($el, addNamespace("dxclick", namespace), click2);
  },
  off: function($el) {
    var {
      namespace
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    eventsEngine.off($el, addNamespace("dxclick", namespace));
  }
};
var click = {
  on: function($el, click2) {
    var {
      namespace
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    eventsEngine.on($el, addNamespace("click", namespace), click2);
  },
  off: function($el) {
    var {
      namespace
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    eventsEngine.off($el, addNamespace("click", namespace));
  }
};
var index$1 = 0;
var keyboardProcessors = {};
var generateListenerId = () => "keyboardProcessorId".concat(index$1++);
var keyboard = {
  on: (element, focusTarget, handler) => {
    var listenerId = generateListenerId();
    keyboardProcessors[listenerId] = new KeyboardProcessor({
      element,
      focusTarget,
      handler
    });
    return listenerId;
  },
  off: (listenerId) => {
    if (listenerId && keyboardProcessors[listenerId]) {
      keyboardProcessors[listenerId].dispose();
      delete keyboardProcessors[listenerId];
    }
  },
  _getProcessor: (listenerId) => keyboardProcessors[listenerId]
};
var {
  abstract: abstract$5
} = Component;
var DOMComponent = Component.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      width: void 0,
      height: void 0,
      rtlEnabled: configMethod().rtlEnabled,
      elementAttr: {},
      disabled: false,
      integrationOptions: {}
    }, this._useTemplates() ? TemplateManager.createDefaultOptions() : {});
  },
  ctor(element, options) {
    this._customClass = null;
    this._createElement(element);
    attachInstanceToElement(this._$element, this, this._dispose);
    this.callBase(options);
  },
  _createElement(element) {
    this._$element = $(element);
  },
  _getSynchronizableOptionsForCreateComponent: () => ["rtlEnabled", "disabled", "templatesRenderAsynchronously"],
  _visibilityChanged: abstract$5,
  _dimensionChanged: abstract$5,
  _init() {
    this.callBase();
    this._attachWindowResizeCallback();
    this._initTemplateManager();
  },
  _setOptionsByDevice(instanceCustomRules) {
    this.callBase([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []));
  },
  _isInitialOptionValue(name2) {
    var isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name2);
    return !isCustomOption && this.callBase(name2);
  },
  _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      var windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
      resizeCallbacks.add(windowResizeCallBack);
    }
  },
  _isDimensionChangeSupported() {
    return this._dimensionChanged !== abstract$5;
  },
  _renderComponent() {
    this._initMarkup();
    hasWindow$1() && this._render();
  },
  _initMarkup() {
    var {
      rtlEnabled
    } = this.option() || {};
    this._renderElementAttributes();
    this._toggleRTLDirection(rtlEnabled);
    this._renderVisibilityChange();
    this._renderDimensions();
  },
  _render() {
    this._attachVisibilityChangeHandlers();
  },
  _renderElementAttributes() {
    var {
      elementAttr
    } = this.option() || {};
    var attributes = extend({}, elementAttr);
    var classNames = attributes.class;
    delete attributes.class;
    this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames);
    this._customClass = classNames;
  },
  _renderVisibilityChange() {
    if (this._isDimensionChangeSupported()) {
      this._attachDimensionChangeHandlers();
    }
    if (this._isVisibilityChangeSupported()) {
      var $element = this.$element();
      $element.addClass("dx-visibility-change-handler");
    }
  },
  _renderDimensions() {
    var $element = this.$element();
    var element = $element.get(0);
    var width = this._getOptionValue("width", element);
    var height = this._getOptionValue("height", element);
    if (this._isCssUpdateRequired(element, height, width)) {
      $element.css({
        width: width === null ? "" : width,
        height: height === null ? "" : height
      });
    }
  },
  _isCssUpdateRequired: (element, height, width) => !!(isDefined(width) || isDefined(height) || element.style.width || element.style.height),
  _attachDimensionChangeHandlers() {
    var $el = this.$element();
    var namespace = "".concat(this.NAME, "VisibilityChange");
    resize.off($el, {
      namespace
    });
    resize.on($el, () => this._dimensionChanged(), {
      namespace
    });
  },
  _attachVisibilityChangeHandlers() {
    if (this._isVisibilityChangeSupported()) {
      var $el = this.$element();
      var namespace = "".concat(this.NAME, "VisibilityChange");
      this._isHidden = !this._isVisible();
      visibility.off($el, {
        namespace
      });
      visibility.on($el, () => this._checkVisibilityChanged("shown"), () => this._checkVisibilityChanged("hiding"), {
        namespace
      });
    }
  },
  _isVisible() {
    var $element = this.$element();
    return $element.is(":visible");
  },
  _checkVisibilityChanged(action) {
    var isVisible2 = this._isVisible();
    if (isVisible2) {
      if (action === "hiding" && !this._isHidden) {
        this._visibilityChanged(false);
        this._isHidden = true;
      } else if (action === "shown" && this._isHidden) {
        this._isHidden = false;
        this._visibilityChanged(true);
      }
    }
  },
  _isVisibilityChangeSupported() {
    return this._visibilityChanged !== abstract$5 && hasWindow$1();
  },
  _clean: noop,
  _modelByElement() {
    var {
      modelByElement
    } = this.option();
    var $element = this.$element();
    return modelByElement ? modelByElement($element) : void 0;
  },
  _invalidate() {
    if (this._isUpdateAllowed()) {
      throw errors$2.Error("E0007");
    }
    this._requireRefresh = true;
  },
  _refresh() {
    this._clean();
    this._renderComponent();
  },
  _dispose() {
    this._templateManager && this._templateManager.dispose();
    this.callBase();
    this._clean();
    this._detachWindowResizeCallback();
  },
  _detachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      resizeCallbacks.remove(this._windowResizeCallBack);
    }
  },
  _toggleRTLDirection(rtl) {
    var $element = this.$element();
    $element.toggleClass("dx-rtl", rtl);
  },
  _createComponent(element, component) {
    var config2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var synchronizableOptions = grep(this._getSynchronizableOptionsForCreateComponent(), (value2) => !(value2 in config2));
    var {
      integrationOptions
    } = this.option();
    var {
      nestedComponentOptions
    } = this.option();
    nestedComponentOptions = nestedComponentOptions || noop;
    var nestedComponentConfig = extend({
      integrationOptions
    }, nestedComponentOptions(this));
    synchronizableOptions.forEach((optionName) => nestedComponentConfig[optionName] = this.option(optionName));
    this._extendConfig(config2, nestedComponentConfig);
    var instance = void 0;
    if (isString$1(component)) {
      var $element = $(element)[component](config2);
      instance = $element[component]("instance");
    } else if (element) {
      instance = component.getInstance(element);
      if (instance) {
        instance.option(config2);
      } else {
        instance = new component(element, config2);
      }
    }
    if (instance) {
      var optionChangedHandler = (_ref) => {
        var {
          name: name2,
          value: value2
        } = _ref;
        if (inArray(name2, synchronizableOptions) >= 0) {
          instance.option(name2, value2);
        }
      };
      this.on("optionChanged", optionChangedHandler);
      instance.on("disposing", () => this.off("optionChanged", optionChangedHandler));
    }
    return instance;
  },
  _extendConfig(config2, extendConfig) {
    each(extendConfig, (key, value2) => {
      !Object.prototype.hasOwnProperty.call(config2, key) && (config2[key] = value2);
    });
  },
  _defaultActionConfig() {
    var $element = this.$element();
    var context2 = this._modelByElement($element);
    return extend(this.callBase(), {
      context: context2
    });
  },
  _defaultActionArgs() {
    var $element = this.$element();
    var model = this._modelByElement($element);
    var element = this.element();
    return extend(this.callBase(), {
      element,
      model
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case "width":
      case "height":
        this._renderDimensions();
        break;
      case "rtlEnabled":
        this._invalidate();
        break;
      case "elementAttr":
        this._renderElementAttributes();
        break;
      case "disabled":
      case "integrationOptions":
        break;
      default:
        this.callBase(args);
    }
  },
  _removeAttributes(element) {
    var attrs = element.attributes;
    for (var i = attrs.length - 1; i >= 0; i--) {
      var attr = attrs[i];
      if (attr) {
        var {
          name: name2
        } = attr;
        if (!name2.indexOf("aria-") || name2.indexOf("dx-") !== -1 || name2 === "role" || name2 === "style" || name2 === "tabindex") {
          element.removeAttribute(name2);
        }
      }
    }
  },
  _removeClasses(element) {
    element.className = element.className.split(" ").filter((cssClass) => cssClass.lastIndexOf("dx-", 0) !== 0).join(" ");
  },
  _updateDOMComponent(renderRequired) {
    if (renderRequired) {
      this._renderComponent();
    } else if (this._requireRefresh) {
      this._requireRefresh = false;
      this._refresh();
    }
  },
  endUpdate() {
    var renderRequired = this._isInitializingRequired();
    this.callBase();
    this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
  },
  $element() {
    return this._$element;
  },
  element() {
    var $element = this.$element();
    return getPublicElement($element);
  },
  dispose() {
    var element = this.$element().get(0);
    cleanDataRecursive(element, true);
    element.textContent = "";
    this._removeAttributes(element);
    this._removeClasses(element);
  },
  resetOption(optionName) {
    this.callBase(optionName);
    if (optionName === "width" || optionName === "height") {
      var initialOption = this.initialOption(optionName);
      !isDefined(initialOption) && this.$element().css(optionName, "");
    }
  },
  _getAnonymousTemplateName() {
    return;
  },
  _initTemplateManager() {
    if (this._templateManager || !this._useTemplates()) {
      return;
    }
    var {
      integrationOptions = {}
    } = this.option();
    var {
      createTemplate
    } = integrationOptions;
    this._templateManager = new TemplateManager(createTemplate, this._getAnonymousTemplateName());
    this._initTemplates();
  },
  _initTemplates() {
    var {
      templates,
      anonymousTemplateMeta
    } = this._templateManager.extractTemplates(this.$element());
    var anonymousTemplate = this.option("integrationOptions.templates.".concat(anonymousTemplateMeta.name));
    templates.forEach((_ref2) => {
      var {
        name: name2,
        template
      } = _ref2;
      this._options.silent("integrationOptions.templates.".concat(name2), template);
    });
    if (anonymousTemplateMeta.name && !anonymousTemplate) {
      this._options.silent("integrationOptions.templates.".concat(anonymousTemplateMeta.name), anonymousTemplateMeta.template);
      this._options.silent("_hasAnonymousTemplateContent", true);
    }
  },
  _getTemplateByOption(optionName) {
    return this._getTemplate(this.option(optionName));
  },
  _getTemplate(templateSource) {
    var templates = this.option("integrationOptions.templates");
    var isAsyncTemplate = this.option("templatesRenderAsynchronously");
    var skipTemplates = this.option("integrationOptions.skipTemplates");
    return this._templateManager.getTemplate(templateSource, templates, {
      isAsyncTemplate,
      skipTemplates
    }, this);
  },
  _saveTemplate(name2, template) {
    this._setOptionWithoutOptionChange("integrationOptions.templates." + name2, this._templateManager._createTemplate(template));
  },
  _useTemplates: () => true
});
DOMComponent.getInstance = function(element) {
  return getInstanceByElement($(element), this);
};
DOMComponent.defaultOptions = function(rule) {
  this._classCustomRules = this._classCustomRules || [];
  this._classCustomRules.push(rule);
};
var ACTIVE_EVENT_NAME$2 = "dxactive";
var INACTIVE_EVENT_NAME = "dxinactive";
var ACTIVE_TIMEOUT = 30;
var INACTIVE_TIMEOUT = 400;
var FeedbackEvent = classImpl.inherit({
  ctor: function(timeout, fire) {
    this._timeout = timeout;
    this._fire = fire;
  },
  start: function() {
    var that = this;
    this._schedule(function() {
      that.force();
    });
  },
  _schedule: function(fn) {
    this.stop();
    this._timer = setTimeout(fn, this._timeout);
  },
  stop: function() {
    clearTimeout(this._timer);
  },
  force: function() {
    if (this._fired) {
      return;
    }
    this.stop();
    this._fire();
    this._fired = true;
  },
  fired: function() {
    return this._fired;
  }
});
var activeFeedback;
var FeedbackEmitter = Emitter.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._active = new FeedbackEvent(0, noop);
    this._inactive = new FeedbackEvent(0, noop);
  },
  configure: function(data2, eventName) {
    switch (eventName) {
      case ACTIVE_EVENT_NAME$2:
        data2.activeTimeout = data2.timeout;
        break;
      case INACTIVE_EVENT_NAME:
        data2.inactiveTimeout = data2.timeout;
    }
    this.callBase(data2);
  },
  start: function(e) {
    if (activeFeedback) {
      var activeChildExists = contains(this.getElement().get(0), activeFeedback.getElement().get(0));
      var childJustActivated = !activeFeedback._active.fired();
      if (activeChildExists && childJustActivated) {
        this._cancel();
        return;
      }
      activeFeedback._inactive.force();
    }
    activeFeedback = this;
    this._initEvents(e);
    this._active.start();
  },
  _initEvents: function(e) {
    var that = this;
    var eventTarget = this._getEmitterTarget(e);
    var mouseEvent = isMouseEvent(e);
    var isSimulator = devices.isSimulator();
    var deferFeedback = isSimulator || !mouseEvent;
    var activeTimeout = ensureDefined(this.activeTimeout, ACTIVE_TIMEOUT);
    var inactiveTimeout = ensureDefined(this.inactiveTimeout, INACTIVE_TIMEOUT);
    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
      that._fireEvent(ACTIVE_EVENT_NAME$2, e, {
        target: eventTarget
      });
    });
    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
      that._fireEvent(INACTIVE_EVENT_NAME, e, {
        target: eventTarget
      });
      activeFeedback = null;
    });
  },
  cancel: function(e) {
    this.end(e);
  },
  end: function(e) {
    var skipTimers = e.type !== pointer.up;
    if (skipTimers) {
      this._active.stop();
    } else {
      this._active.force();
    }
    this._inactive.start();
    if (skipTimers) {
      this._inactive.force();
    }
  },
  dispose: function() {
    this._active.stop();
    this._inactive.stop();
    if (activeFeedback === this) {
      activeFeedback = null;
    }
    this.callBase();
  },
  lockInactive: function() {
    this._active.force();
    this._inactive.stop();
    activeFeedback = null;
    this._cancel();
    return this._inactive.force.bind(this._inactive);
  }
});
FeedbackEmitter.lock = function(deferred) {
  var lockInactive = activeFeedback ? activeFeedback.lockInactive() : noop;
  deferred.done(lockInactive);
};
registerEmitter({
  emitter: FeedbackEmitter,
  events: [ACTIVE_EVENT_NAME$2, INACTIVE_EVENT_NAME]
});
FeedbackEmitter.lock;
var HOVERSTART_NAMESPACE = "dxHoverStart";
var HOVERSTART = "dxhoverstart";
var POINTERENTER_NAMESPACED_EVENT_NAME = addNamespace$1(pointer.enter, HOVERSTART_NAMESPACE);
var HOVEREND_NAMESPACE = "dxHoverEnd";
var HOVEREND = "dxhoverend";
var POINTERLEAVE_NAMESPACED_EVENT_NAME = addNamespace$1(pointer.leave, HOVEREND_NAMESPACE);
var Hover = classImpl.inherit({
  noBubble: true,
  ctor: function() {
    this._handlerArrayKeyPath = this._eventNamespace + "_HandlerStore";
  },
  setup: function(element) {
    data(element, this._handlerArrayKeyPath, {});
  },
  add: function(element, handleObj) {
    var that = this;
    var handler = function(e) {
      that._handler(e);
    };
    eventsEngine.on(element, this._originalEventName, handleObj.selector, handler);
    data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
  },
  _handler: function(e) {
    if (isTouchEvent(e) || devices.isSimulator()) {
      return;
    }
    fireEvent({
      type: this._eventName,
      originalEvent: e,
      delegateTarget: e.delegateTarget
    });
  },
  remove: function(element, handleObj) {
    var handler = data(element, this._handlerArrayKeyPath)[handleObj.guid];
    eventsEngine.off(element, this._originalEventName, handleObj.selector, handler);
  },
  teardown: function(element) {
    removeData(element, this._handlerArrayKeyPath);
  }
});
var HoverStart = Hover.inherit({
  ctor: function() {
    this._eventNamespace = HOVERSTART_NAMESPACE;
    this._eventName = HOVERSTART;
    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
    this.callBase();
  },
  _handler: function(e) {
    var pointers = e.pointers || [];
    if (!pointers.length) {
      this.callBase(e);
    }
  }
});
var HoverEnd = Hover.inherit({
  ctor: function() {
    this._eventNamespace = HOVEREND_NAMESPACE;
    this._eventName = HOVEREND;
    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
    this.callBase();
  }
});
registerEvent(HOVERSTART, new HoverStart());
registerEvent(HOVEREND, new HoverEnd());
function setAttribute(name2, value2, target) {
  name2 = name2 === "role" || name2 === "id" ? name2 : "aria-".concat(name2);
  value2 = isDefined(value2) ? value2.toString() : null;
  target.attr(name2, value2);
}
var Widget = DOMComponent.inherit({
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  _supportedKeys: () => ({}),
  _getDefaultOptions() {
    return extend(this.callBase(), {
      hoveredElement: null,
      isActive: false,
      disabled: false,
      visible: true,
      hint: void 0,
      activeStateEnabled: false,
      onContentReady: null,
      hoverStateEnabled: false,
      focusStateEnabled: false,
      tabIndex: 0,
      accessKey: void 0,
      onFocusIn: null,
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: false
    });
  },
  _init() {
    this.callBase();
    this._initContentReadyAction();
  },
  _innerWidgetOptionChanged: function(innerWidget, args) {
    var options = Widget.getOptionsFromContainer(args);
    innerWidget && innerWidget.option(options);
    this._options.cache(args.name, options);
  },
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    var syncOptions = () => this._options.silent(optionsContainer, extend({}, innerWidget.option()));
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  },
  _getAriaTarget() {
    return this._focusTarget();
  },
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _initMarkup() {
    var {
      disabled,
      visible: visible2
    } = this.option();
    this.$element().addClass("dx-widget");
    this._toggleDisabledState(disabled);
    this._toggleVisibility(visible2);
    this._renderHint();
    this._isFocusable() && this._renderFocusTarget();
    this.callBase();
  },
  _render() {
    this.callBase();
    this._renderContent();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
    this._toggleIndependentState();
  },
  _renderHint() {
    var {
      hint
    } = this.option();
    this.$element().attr("title", hint || null);
  },
  _renderContent() {
    deferRender(() => !this._disposed ? this._renderContentImpl() : void 0).done(() => !this._disposed ? this._fireContentReadyAction() : void 0);
  },
  _renderContentImpl: noop,
  _fireContentReadyAction: deferRenderer(function() {
    return this._contentReadyAction();
  }),
  _dispose() {
    this._contentReadyAction = null;
    this._detachKeyboardEvents();
    this.callBase();
  },
  _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), false);
  },
  _clean() {
    this._cleanFocusState();
    this._resetActiveState();
    this.callBase();
    this.$element().empty();
  },
  _toggleVisibility(visible2) {
    this.$element().toggleClass("dx-state-invisible", !visible2);
    this.setAria("hidden", !visible2 || void 0);
  },
  _renderFocusState() {
    this._attachKeyboardEvents();
    if (this._isFocusable()) {
      this._renderFocusTarget();
      this._attachFocusEvents();
      this._renderAccessKey();
    }
  },
  _renderAccessKey() {
    var $el = this._focusTarget();
    var {
      accessKey
    } = this.option();
    $el.attr("accesskey", accessKey);
  },
  _isFocusable() {
    var {
      focusStateEnabled,
      disabled
    } = this.option();
    return focusStateEnabled && !disabled;
  },
  _eventBindingTarget() {
    return this.$element();
  },
  _focusTarget() {
    return this._getActiveElement();
  },
  _getActiveElement() {
    var activeElement = this._eventBindingTarget();
    if (this._activeStateUnit) {
      return activeElement.find(this._activeStateUnit).not(".dx-state-disabled");
    }
    return activeElement;
  },
  _renderFocusTarget() {
    var {
      tabIndex
    } = this.option();
    this._focusTarget().attr("tabIndex", tabIndex);
  },
  _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  },
  _refreshFocusEvent() {
    this._detachFocusEvents();
    this._attachFocusEvents();
  },
  _focusEventTarget() {
    return this._focusTarget();
  },
  _focusInHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusIn", {
        beforeExecute: () => this._updateFocusState(event, true),
        excludeValidators: ["readOnly"]
      })({
        event
      });
    }
  },
  _focusOutHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusOut", {
        beforeExecute: () => this._updateFocusState(event, false),
        excludeValidators: ["readOnly", "disabled"]
      })({
        event
      });
    }
  },
  _updateFocusState(_ref, isFocused) {
    var {
      target
    } = _ref;
    if (inArray(target, this._focusTarget()) !== -1) {
      this._toggleFocusClass(isFocused, $(target));
    }
  },
  _toggleFocusClass(isFocused, $element) {
    var $focusTarget = $element && $element.length ? $element : this._focusTarget();
    $focusTarget.toggleClass("dx-state-focused", isFocused);
  },
  _hasFocusClass(element) {
    var $focusTarget = $(element || this._focusTarget());
    return $focusTarget.hasClass("dx-state-focused");
  },
  _isFocused() {
    return this._hasFocusClass();
  },
  _getKeyboardListeners: () => [],
  _attachKeyboardEvents() {
    this._detachKeyboardEvents();
    var {
      focusStateEnabled,
      onKeyboardHandled
    } = this.option();
    var hasChildListeners = this._getKeyboardListeners().length;
    var hasKeyboardEventHandler = !!onKeyboardHandled;
    var shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
    if (shouldAttach) {
      this._keyboardListenerId = keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), (opts) => this._keyboardHandler(opts));
    }
  },
  _keyboardHandler(options, onlyChildProcessing) {
    if (!onlyChildProcessing) {
      var {
        originalEvent,
        keyName,
        which
      } = options;
      var keys2 = this._supportedKeys(originalEvent);
      var func = keys2[keyName] || keys2[which];
      if (func !== void 0) {
        var handler = func.bind(this);
        var result = handler(originalEvent, options);
        if (!result) {
          return false;
        }
      }
    }
    var keyboardListeners = this._getKeyboardListeners();
    var {
      onKeyboardHandled
    } = this.option();
    keyboardListeners.forEach((listener) => listener && listener._keyboardHandler(options));
    onKeyboardHandled && onKeyboardHandled(options);
    return true;
  },
  _refreshFocusState() {
    this._cleanFocusState();
    this._renderFocusState();
  },
  _cleanFocusState() {
    var $element = this._focusTarget();
    $element.removeAttr("tabIndex");
    this._toggleFocusClass(false);
    this._detachFocusEvents();
    this._detachKeyboardEvents();
  },
  _detachKeyboardEvents() {
    keyboard.off(this._keyboardListenerId);
    this._keyboardListenerId = null;
  },
  _attachHoverEvents() {
    var {
      hoverStateEnabled
    } = this.option();
    var selector = this._activeStateUnit;
    var $el = this._eventBindingTarget();
    hover.off($el, {
      selector,
      namespace: "UIFeedback"
    });
    if (hoverStateEnabled) {
      hover.on($el, new Action((_ref2) => {
        var {
          event,
          element
        } = _ref2;
        this._hoverStartHandler(event);
        this.option("hoveredElement", $(element));
      }, {
        excludeValidators: ["readOnly"]
      }), (event) => {
        this.option("hoveredElement", null);
        this._hoverEndHandler(event);
      }, {
        selector,
        namespace: "UIFeedback"
      });
    }
  },
  _attachFeedbackEvents() {
    var {
      activeStateEnabled
    } = this.option();
    var selector = this._activeStateUnit;
    var $el = this._eventBindingTarget();
    active.off($el, {
      namespace: "UIFeedback",
      selector
    });
    if (activeStateEnabled) {
      active.on($el, new Action((_ref3) => {
        var {
          event,
          element
        } = _ref3;
        return this._toggleActiveState($(element), true, event);
      }), new Action((_ref4) => {
        var {
          event,
          element
        } = _ref4;
        return this._toggleActiveState($(element), false, event);
      }, {
        excludeValidators: ["disabled", "readOnly"]
      }), {
        showTimeout: this._feedbackShowTimeout,
        hideTimeout: this._feedbackHideTimeout,
        selector,
        namespace: "UIFeedback"
      });
    }
  },
  _detachFocusEvents() {
    var $el = this._focusEventTarget();
    focus.off($el, {
      namespace: "".concat(this.NAME, "Focus")
    });
  },
  _attachFocusEvents() {
    var $el = this._focusEventTarget();
    focus.on($el, (e) => this._focusInHandler(e), (e) => this._focusOutHandler(e), {
      namespace: "".concat(this.NAME, "Focus"),
      isFocusable: (index2, el) => $(el).is(focusable)
    });
  },
  _hoverStartHandler: noop,
  _hoverEndHandler: noop,
  _toggleActiveState($element, value2) {
    this.option("isActive", value2);
    $element.toggleClass("dx-state-active", value2);
  },
  _updatedHover() {
    var hoveredElement = this._options.silent("hoveredElement");
    this._hover(hoveredElement, hoveredElement);
  },
  _findHoverTarget($el) {
    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
  },
  _hover($el, $previous) {
    var {
      hoverStateEnabled,
      disabled,
      isActive
    } = this.option();
    $previous = this._findHoverTarget($previous);
    $previous && $previous.toggleClass("dx-state-hover", false);
    if ($el && hoverStateEnabled && !disabled && !isActive) {
      var newHoveredElement = this._findHoverTarget($el);
      newHoveredElement && newHoveredElement.toggleClass("dx-state-hover", true);
    }
  },
  _toggleDisabledState(value2) {
    this.$element().toggleClass("dx-state-disabled", Boolean(value2));
    this.setAria("disabled", value2 || void 0);
  },
  _toggleIndependentState() {
    this.$element().toggleClass("dx-state-independent", this.option("ignoreParentReadOnly"));
  },
  _setWidgetOption(widgetName, args) {
    if (!this[widgetName]) {
      return;
    }
    if (isPlainObject(args[0])) {
      each(args[0], (option, value3) => this._setWidgetOption(widgetName, [option, value3]));
      return;
    }
    var optionName = args[0];
    var value2 = args[1];
    if (args.length === 1) {
      value2 = this.option(optionName);
    }
    var widgetOptionMap = this["".concat(widgetName, "OptionMap")];
    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value2);
  },
  _optionChanged(args) {
    var {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "disabled":
        this._toggleDisabledState(value2);
        this._updatedHover();
        this._refreshFocusState();
        break;
      case "hint":
        this._renderHint();
        break;
      case "ignoreParentReadOnly":
        this._toggleIndependentState();
        break;
      case "activeStateEnabled":
        this._attachFeedbackEvents();
        break;
      case "hoverStateEnabled":
        this._attachHoverEvents();
        this._updatedHover();
        break;
      case "tabIndex":
      case "focusStateEnabled":
        this._refreshFocusState();
        break;
      case "onFocusIn":
      case "onFocusOut":
        break;
      case "accessKey":
        this._renderAccessKey();
        break;
      case "hoveredElement":
        this._hover(value2, previousValue);
        break;
      case "isActive":
        this._updatedHover();
        break;
      case "visible":
        this._toggleVisibility(value2);
        if (this._isVisibilityChangeSupported()) {
          this._checkVisibilityChanged(value2 ? "shown" : "hiding");
        }
        break;
      case "onKeyboardHandled":
        this._attachKeyboardEvents();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      default:
        this.callBase(args);
    }
  },
  _isVisible() {
    var {
      visible: visible2
    } = this.option();
    return this.callBase() && visible2;
  },
  beginUpdate() {
    this._ready(false);
    this.callBase();
  },
  endUpdate() {
    this.callBase();
    if (this._initialized) {
      this._ready(true);
    }
  },
  _ready(value2) {
    if (arguments.length === 0) {
      return this._isReady;
    }
    this._isReady = value2;
  },
  setAria() {
    if (!isPlainObject(arguments.length <= 0 ? void 0 : arguments[0])) {
      setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());
    } else {
      var target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();
      each(arguments.length <= 0 ? void 0 : arguments[0], (name2, value2) => setAttribute(name2, value2, target));
    }
  },
  isReady() {
    return this._ready();
  },
  repaint() {
    this._refresh();
  },
  focus() {
    focus.trigger(this._focusTarget());
  },
  registerKeyHandler(key, handler) {
    var currentKeys = this._supportedKeys();
    this._supportedKeys = () => extend(currentKeys, {
      [key]: handler
    });
  }
});
Widget.getOptionsFromContainer = (_ref5) => {
  var {
    name: name2,
    fullName,
    value: value2
  } = _ref5;
  var options = {};
  if (name2 === fullName) {
    options = value2;
  } else {
    var option = fullName.split(".").pop();
    options[option] = value2;
  }
  return options;
};
var DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
var DEFAULT_DATETIME_INTERVAL = ["year", "month", "day", "hour", "minute"];
var isDateType$1 = function(dataType) {
  return dataType === "date" || dataType === "datetime";
};
var getGroupInterval = function(column) {
  var index2;
  var result = [];
  var dateIntervals = ["year", "month", "day", "hour", "minute", "second"];
  var groupInterval = column.headerFilter && column.headerFilter.groupInterval;
  var interval = groupInterval === "quarter" ? "month" : groupInterval;
  if (isDateType$1(column.dataType) && groupInterval !== null) {
    result = column.dataType === "datetime" ? DEFAULT_DATETIME_INTERVAL : DEFAULT_DATE_INTERVAL;
    index2 = inArray(interval, dateIntervals);
    if (index2 >= 0) {
      result = dateIntervals.slice(0, index2);
      result.push(groupInterval);
      return result;
    }
    return result;
  } else if (isDefined(groupInterval)) {
    return Array.isArray(groupInterval) ? groupInterval : [groupInterval];
  }
};
var sharedFiltering = function() {
  var getFilterSelector = function(column, target) {
    var selector = column.dataField || column.selector;
    if (target === "search") {
      selector = column.displayField || column.calculateDisplayValue || selector;
    }
    return selector;
  };
  var getFilterExpressionByRange = function(filterValue, target) {
    var endFilterValue;
    var startFilterExpression;
    var endFilterExpression;
    var selector = getFilterSelector(this, target);
    if (Array.isArray(filterValue) && isDefined(filterValue[0]) && isDefined(filterValue[1])) {
      startFilterExpression = [selector, ">=", filterValue[0]];
      endFilterExpression = [selector, "<=", filterValue[1]];
      if (isDateType$1(this.dataType) && (date = filterValue[1], date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1)) {
        endFilterValue = new Date(filterValue[1].getTime());
        if (this.dataType === "date") {
          endFilterValue.setDate(filterValue[1].getDate() + 1);
        }
        endFilterExpression = [selector, "<", endFilterValue];
      }
      return [startFilterExpression, "and", endFilterExpression];
    }
    var date;
  };
  var getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
    var dateStart;
    var dateEnd;
    var dateInterval;
    var values = function(dateValue) {
      if (isDate(dateValue)) {
        return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()];
      }
      return map(("" + dateValue).split("/"), function(value2, index2) {
        return index2 === 1 ? Number(value2) - 1 : Number(value2);
      });
    }(filterValue);
    var selector = getFilterSelector(this, target);
    if (target === "headerFilter") {
      dateInterval = getGroupInterval(this)[values.length - 1];
    } else if (this.dataType === "datetime") {
      dateInterval = "minute";
    }
    switch (dateInterval) {
      case "year":
        dateStart = new Date(values[0], 0, 1);
        dateEnd = new Date(values[0] + 1, 0, 1);
        break;
      case "month":
        dateStart = new Date(values[0], values[1], 1);
        dateEnd = new Date(values[0], values[1] + 1, 1);
        break;
      case "quarter":
        dateStart = new Date(values[0], 3 * values[1], 1);
        dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
        break;
      case "hour":
        dateStart = new Date(values[0], values[1], values[2], values[3]);
        dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
        break;
      case "minute":
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
        break;
      case "second":
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
        break;
      default:
        dateStart = new Date(values[0], values[1], values[2]);
        dateEnd = new Date(values[0], values[1], values[2] + 1);
    }
    switch (selectedFilterOperation) {
      case "<":
        return [selector, "<", dateStart];
      case "<=":
        return [selector, "<", dateEnd];
      case ">":
        return [selector, ">=", dateEnd];
      case ">=":
        return [selector, ">=", dateStart];
      case "<>":
        return [
          [selector, "<", dateStart],
          "or",
          [selector, ">=", dateEnd]
        ];
      default:
        return [
          [selector, ">=", dateStart],
          "and",
          [selector, "<", dateEnd]
        ];
    }
  };
  var getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
    var selector = getFilterSelector(this, target);
    var groupInterval = getGroupInterval(this);
    if (target === "headerFilter" && groupInterval && isDefined(filterValue)) {
      var values = ("" + filterValue).split("/");
      var value2 = Number(values[values.length - 1]);
      var interval = groupInterval[values.length - 1];
      var startFilterValue = [selector, ">=", value2];
      var endFilterValue = [selector, "<", value2 + interval];
      var condition = [startFilterValue, "and", endFilterValue];
      return condition;
    }
    return [selector, selectedFilterOperation || "=", filterValue];
  };
  return {
    defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
      var column = this;
      var selector = getFilterSelector(column, target);
      var isSearchByDisplayValue = column.calculateDisplayValue && target === "search";
      var dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType;
      var filter = null;
      if ((target === "headerFilter" || target === "filterBuilder") && filterValue === null) {
        filter = [selector, selectedFilterOperation || "=", null];
        if (dataType === "string") {
          filter = [filter, selectedFilterOperation === "=" ? "or" : "and", [selector, selectedFilterOperation || "=", ""]];
        }
      } else if (dataType === "string" && (!column.lookup || isSearchByDisplayValue)) {
        filter = [selector, selectedFilterOperation || "contains", filterValue];
      } else if (selectedFilterOperation === "between") {
        return getFilterExpressionByRange.apply(column, [filterValue, target]);
      } else if (isDateType$1(dataType) && isDefined(filterValue)) {
        return getFilterExpressionForDate.apply(column, arguments);
      } else if (dataType === "number") {
        return getFilterExpressionForNumber.apply(column, arguments);
      } else if (dataType !== "object") {
        filter = [selector, selectedFilterOperation || "=", filterValue];
      }
      return filter;
    },
    getGroupInterval
  };
}();
var getDefaultAlignment = (isRtlEnabled) => {
  var rtlEnabled = isRtlEnabled !== null && isRtlEnabled !== void 0 ? isRtlEnabled : configMethod().rtlEnabled;
  return rtlEnabled ? "right" : "left";
};
var getElementsFromPoint = (x, y) => {
  var document2 = domAdapter.getDocument();
  if (coreBrowserUtils.msie) {
    var result = document2.msElementsFromPoint(x, y);
    if (result) {
      return Array.prototype.slice.call(result);
    }
    return [];
  }
  return document2.elementsFromPoint(x, y);
};
var getBoundingRect = (element) => {
  if (isWindow(element)) {
    return {
      width: element.outerWidth,
      height: element.outerHeight
    };
  }
  var rect;
  try {
    rect = element.getBoundingClientRect();
  } catch (e) {
    rect = {
      width: 0,
      height: 0,
      bottom: 0,
      top: 0,
      left: 0,
      right: 0
    };
  }
  return rect;
};
var promise = hasWindow$1() ? getWindow().Promise : Promise;
if (!promise) {
  promise = function(resolver) {
    var d = new Deferred();
    resolver(d.resolve.bind(this), d.reject.bind(this));
    return d.promise();
  };
  promise.resolve = function(val) {
    return new Deferred().resolve(val).promise();
  };
  promise.reject = function(val) {
    return new Deferred().reject(val).promise();
  };
  promise.all = function(promises) {
    return when.apply(this, promises).then(function() {
      return [].slice.call(arguments);
    });
  };
}
var Promise$3 = promise;
var themeReadyCallback = new Callbacks();
var errors$1 = errorUtils(errors$2.ERROR_MESSAGES, {
  E1001: "Module '{0}'. Controller '{1}' is already registered",
  E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
  E1003: "Module '{0}'. View '{1}' is already registered",
  E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
  E1005: "Public method '{0}' is already registered",
  E1006: "Public method '{0}.{1}' does not exist",
  E1007: "State storing cannot be provided due to the restrictions of the browser",
  E1010: "The template does not contain the TextBox widget",
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
  E1012: "Editing type '{0}' with the name '{1}' is unsupported",
  E1016: "Unexpected type of data source is provided for a lookup column",
  E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
  E1019: "Search mode '{0}' is unavailable",
  E1020: "The type cannot be changed after initialization",
  E1021: "{0} '{1}' you are trying to remove does not exist",
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',
  E1025: "This layout is too complex to render",
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
  E1031: "Unknown subscription in the Scheduler widget: '{0}'",
  E1032: "Unknown start date in an appointment: '{0}'",
  E1033: "Unknown step in the date navigator: '{0}'",
  E1034: "The browser does not implement an API for saving files",
  E1035: "The editor cannot be created because of an internal error: {0}",
  E1037: "Invalid structure of grouped data",
  E1038: "The browser does not support local storages for local web pages",
  E1039: "A cell's position cannot be calculated",
  E1040: "The '{0}' key value is not unique within the data array",
  E1041: "The '{0}' script is referenced after the DevExtreme scripts or not referenced at all",
  E1042: "{0} requires the key field to be specified",
  E1043: "Changes cannot be processed due to the incorrectly set key",
  E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
  E1045: "Editing requires the key field to be specified in the data store",
  E1046: "The '{0}' key field is not found in data objects",
  E1047: 'The "{0}" field is not found in the fields array',
  E1048: 'The "{0}" operation is not found in the filterOperations array',
  E1049: "Column '{0}': filtering is allowed but the 'dataField' or 'name' option is not specified",
  E1050: "The validationRules option does not apply to third-party editors defined in the editCellTemplate",
  E1051: `HtmlEditor's valueType is "{0}", but the {0} converter was not imported.`,
  E1052: '{0} should have the "dataSource" option specified',
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',
  E1054: "All text editor buttons must have names",
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  E1058: 'The "startDayHour" must be earlier than the "endDayHour"',
  E1059: "The following column names are not unique: {0}",
  E1060: "All editable columns must have names",
  W1001: 'The "key" option cannot be modified after initialization',
  W1002: "An item with the key '{0}' does not exist",
  W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
  W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
  W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
  W1006: "The map service returned the following error: '{0}'",
  W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
  W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view",
  W1009: "Searching works only if data is specified using the dataSource option",
  W1010: "The capability to select all items works with source data of plain structure only",
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: "The '{0}' key field is not found in data objects",
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
  W1014: "The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.",
  W1015: 'The "cellDuration" should divide the range from the "startDayHour" to the "endDayHour" into even intervals',
  W1016: "The '{0}' field in the HTML Editor toolbar item configuration was renamed to '{1}'. Please make a corresponding change in your code.",
  W1017: "The 'key' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.",
  W1018: "Infinite scrolling may not work properly with multiple selection. To use these features together, set 'selection.deferred' to true or set 'selection.selectAllMode' to 'page'.",
  W1019: "Filter query string exceeds maximum length limit of {0} characters."
});
var window$f = getWindow();
var ready$3 = readyCallback.add;
var viewPort = value;
var viewPortChanged$1 = changeCallback;
var initDeferred = new Deferred();
var DX_LINK_SELECTOR = "link[rel=dx-theme]";
var THEME_ATTR = "data-theme";
var ACTIVE_ATTR = "data-active";
var DX_HAIRLINES_CLASS = "dx-hairlines";
var ANY_THEME = "any";
var context;
var $activeThemeLink;
var knownThemes;
var currentThemeName;
var pendingThemeName;
var defaultTimeout = 15e3;
var THEME_MARKER_PREFIX = "dx.";
function readThemeMarker() {
  if (!hasWindow$1()) {
    return null;
  }
  var element = $("<div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
  var result;
  try {
    result = window$f.getComputedStyle(element.get(0)).fontFamily;
    if (!result) {
      return null;
    }
    result = result.replace(/["']/g, "");
    if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
      return null;
    }
    return result.substr(THEME_MARKER_PREFIX.length);
  } finally {
    element.remove();
  }
}
function waitForThemeLoad(themeName) {
  var waitStartTime;
  var timerId;
  var intervalCleared = true;
  pendingThemeName = themeName;
  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;
    themeReadyCallback.fire();
    themeReadyCallback.empty();
    initDeferred.resolve();
  }
  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }
      return;
    }
    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function() {
      var isLoaded = isPendingThemeLoaded();
      var isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;
      if (isTimeout) {
        errors$1.log("W0004", pendingThemeName);
      }
      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}
function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }
  var anyThemePending = pendingThemeName === ANY_THEME;
  if (initDeferred.state() === "resolved" && anyThemePending) {
    return true;
  }
  var themeMarker = readThemeMarker();
  if (themeMarker && anyThemePending) {
    return true;
  }
  return themeMarker === pendingThemeName;
}
function processMarkup() {
  var $allThemeLinks = $(DX_LINK_SELECTOR, context);
  if (!$allThemeLinks.length) {
    return;
  }
  knownThemes = {};
  $activeThemeLink = $(parseHTML("<link rel=stylesheet>"), context);
  $allThemeLinks.each(function() {
    var link = $(this, context);
    var fullThemeName = link.attr(THEME_ATTR);
    var url = link.attr("href");
    var isActive = link.attr(ACTIVE_ATTR) === "true";
    knownThemes[fullThemeName] = {
      url,
      isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}
function resolveFullThemeName(desiredThemeName) {
  var desiredThemeParts = desiredThemeName ? desiredThemeName.split(".") : [];
  var result = null;
  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }
    each(knownThemes, function(knownThemeName, themeData) {
      var knownThemeParts = knownThemeName.split(".");
      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }
      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }
      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }
      if (!result || themeData.isActive) {
        result = knownThemeName;
      }
      if (themeData.isActive) {
        return false;
      }
    });
  }
  return result;
}
function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    knownThemes = null;
  }
  context = newContext;
}
function init(options) {
  options = options || {};
  initContext(options.context || domAdapter.getDocument());
  if (!context) {
    return;
  }
  processMarkup();
  currentThemeName = void 0;
  current(options);
}
function current(options) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }
  detachCssClasses(viewPort());
  options = options || {};
  if (typeof options === "string") {
    options = {
      theme: options
    };
  }
  var isAutoInit = options._autoInit;
  var loadCallback = options.loadCallback;
  var currentThemeData;
  currentThemeName = resolveFullThemeName(options.theme || currentThemeName);
  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }
  if (loadCallback) {
    themeReadyCallback.add(loadCallback);
  }
  if (currentThemeData) {
    $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
    if (themeReadyCallback.has() || initDeferred.state() !== "resolved" || options._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else if (isAutoInit) {
    if (hasWindow$1()) {
      waitForThemeLoad(ANY_THEME);
    }
    themeReadyCallback.fire();
    themeReadyCallback.empty();
  } else {
    throw errors$1.Error("E0021", currentThemeName);
  }
  initDeferred.done(() => attachCssClasses(originalViewPort(), currentThemeName));
}
function getCssClasses(themeName) {
  themeName = themeName || current();
  var result = [];
  var themeNameParts = themeName && themeName.split(".");
  if (themeNameParts) {
    result.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
    if (themeNameParts.length > 1) {
      result.push("dx-color-scheme-" + themeNameParts[1] + (isMaterial(themeName) ? "-" + themeNameParts[2] : ""));
    }
  }
  return result;
}
var themeClasses;
function attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(" ");
  $(element).addClass(themeClasses);
  !function() {
    var pixelRatio = hasWindow$1() && window$f.devicePixelRatio;
    if (!pixelRatio || pixelRatio < 2) {
      return;
    }
    var $tester = $("<div>");
    $tester.css("border", ".5px solid transparent");
    $("body").append($tester);
    if ($tester.outerHeight() === 1) {
      $(element).addClass(DX_HAIRLINES_CLASS);
      themeClasses += " " + DX_HAIRLINES_CLASS;
    }
    $tester.remove();
  }();
}
function detachCssClasses(element) {
  $(element).removeClass(themeClasses);
}
function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }
  return new RegExp(themeRegExp).test(themeName);
}
function isMaterial(themeName) {
  return isTheme("material", themeName);
}
function isGeneric(themeName) {
  return isTheme("generic", themeName);
}
function isWebFontLoaded(text, fontWeight) {
  var document2 = domAdapter.getDocument();
  var testElement = document2.createElement("span");
  testElement.style.position = "absolute";
  testElement.style.top = "-9999px";
  testElement.style.left = "-9999px";
  testElement.style.visibility = "hidden";
  testElement.style.fontFamily = "Arial";
  testElement.style.fontSize = "250px";
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document2.body.appendChild(testElement);
  var etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = "Roboto, RobotoFallback, Arial";
  var testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}
function waitWebFont(text, fontWeight) {
  return new Promise$3((resolve) => {
    var clear = () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };
    var intervalId = setInterval(() => {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    }, 15);
    var timeoutId = setTimeout(clear, 2e3);
  });
}
function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });
  if ($(DX_LINK_SELECTOR, context).length) {
    throw errors$1.Error("E0022");
  }
}
if (hasWindow$1()) {
  autoInit();
} else {
  ready$3(autoInit);
}
viewPortChanged$1.add(function(viewPort2, prevViewPort) {
  initDeferred.done(function() {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort2);
  });
});
devices.changed.add(function() {
  init({
    _autoInit: true
  });
});
var navigator$3 = getNavigator();
var LOADINDICATOR_CLASS = "dx-loadindicator";
var LOADINDICATOR_WRAPPER_CLASS = "dx-loadindicator-wrapper";
var LOADINDICATOR_CONTENT_CLASS = "dx-loadindicator-content";
var LOADINDICATOR_ICON_CLASS = "dx-loadindicator-icon";
var LOADINDICATOR_SEGMENT_CLASS = "dx-loadindicator-segment";
var LOADINDICATOR_SEGMENT_INNER_CLASS = "dx-loadindicator-segment-inner";
var LOADINDICATOR_IMAGE_CLASS = "dx-loadindicator-image";
var LoadIndicator = Widget.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      indicatorSrc: "",
      activeStateEnabled: false,
      hoverStateEnabled: false,
      _animatingSegmentCount: 1,
      _animatingSegmentInner: false
    });
  },
  _defaultOptionsRules: function() {
    var themeName = current();
    return this.callBase().concat([{
      device: function() {
        var realDevice2 = devices.real();
        var obsoleteAndroid = realDevice2.platform === "android" && !/chrome/i.test(navigator$3.userAgent);
        return obsoleteAndroid;
      },
      options: {
        viaImage: true
      }
    }, {
      device: function() {
        return isMaterial(themeName);
      },
      options: {
        _animatingSegmentCount: 2,
        _animatingSegmentInner: true
      }
    }, {
      device: function() {
        return isGeneric(themeName);
      },
      options: {
        _animatingSegmentCount: 7
      }
    }]);
  },
  _useTemplates: function() {
    return false;
  },
  _init: function() {
    this.callBase();
    this.$element().addClass(LOADINDICATOR_CLASS);
  },
  _initMarkup: function() {
    this.callBase();
    this._renderWrapper();
    this._renderIndicatorContent();
    this._renderMarkup();
  },
  _renderWrapper: function() {
    this._$wrapper = $("<div>").addClass(LOADINDICATOR_WRAPPER_CLASS);
    this.$element().append(this._$wrapper);
  },
  _renderIndicatorContent: function() {
    this._$content = $("<div>").addClass(LOADINDICATOR_CONTENT_CLASS);
    this._$wrapper.append(this._$content);
  },
  _renderMarkup: function() {
    if (animation() && !this.option("viaImage") && !this.option("indicatorSrc")) {
      this._renderMarkupForAnimation();
    } else {
      this._renderMarkupForImage();
    }
  },
  _renderMarkupForAnimation: function() {
    var animatingSegmentInner = this.option("_animatingSegmentInner");
    this._$indicator = $("<div>").addClass(LOADINDICATOR_ICON_CLASS);
    this._$content.append(this._$indicator);
    for (var i = this.option("_animatingSegmentCount"); i >= 0; --i) {
      var $segment = $("<div>").addClass(LOADINDICATOR_SEGMENT_CLASS).addClass(LOADINDICATOR_SEGMENT_CLASS + i);
      if (animatingSegmentInner) {
        $segment.append($("<div>").addClass(LOADINDICATOR_SEGMENT_INNER_CLASS));
      }
      this._$indicator.append($segment);
    }
  },
  _renderMarkupForImage: function() {
    var indicatorSrc = this.option("indicatorSrc");
    this._$wrapper.addClass(LOADINDICATOR_IMAGE_CLASS);
    if (indicatorSrc) {
      this._$wrapper.css("backgroundImage", "url(" + indicatorSrc + ")");
    }
  },
  _renderDimensions: function() {
    this.callBase();
    this._updateContentSizeForAnimation();
  },
  _updateContentSizeForAnimation: function() {
    if (!this._$indicator) {
      return;
    }
    var width = this.option("width");
    var height = this.option("height");
    if (width || height) {
      width = this.$element().width();
      height = this.$element().height();
      var minDimension = Math.min(height, width);
      this._$wrapper.css({
        height: minDimension,
        width: minDimension,
        fontSize: minDimension
      });
    }
  },
  _clean: function() {
    this.callBase();
    this._removeMarkupForAnimation();
    this._removeMarkupForImage();
  },
  _removeMarkupForAnimation: function() {
    if (!this._$indicator) {
      return;
    }
    this._$indicator.remove();
    delete this._$indicator;
  },
  _removeMarkupForImage: function() {
    this._$wrapper.css("backgroundImage", "none");
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "_animatingSegmentCount":
      case "_animatingSegmentInner":
      case "indicatorSrc":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }
});
registerComponent("dxLoadIndicator", LoadIndicator);
var TRANSLATOR_DATA_KEY = "dxTranslator";
var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
var locate = function($element) {
  $element = $($element);
  var translate = getTranslate($element);
  return {
    left: translate.x,
    top: translate.y
  };
};
function isPercentValue(value2) {
  return type(value2) === "string" && value2[value2.length - 1] === "%";
}
function cacheTranslate($element, translate) {
  if ($element.length) {
    data($element.get(0), TRANSLATOR_DATA_KEY, translate);
  }
}
var clearCache = function($element) {
  if ($element.length) {
    removeData($element.get(0), TRANSLATOR_DATA_KEY);
  }
};
var getTranslateCss = function(translate) {
  translate.x = translate.x || 0;
  translate.y = translate.y || 0;
  var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
  var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
  return "translate(" + xValueString + ", " + yValueString + ")";
};
var getTranslate = function($element) {
  var result = $element.length ? data($element.get(0), TRANSLATOR_DATA_KEY) : null;
  if (!result) {
    var transformValue = $element.css("transform") || getTranslateCss({
      x: 0,
      y: 0
    });
    var matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
    var is3D = matrix && matrix[1];
    if (matrix) {
      matrix = matrix[2].split(",");
      if (is3D === "3d") {
        matrix = matrix.slice(12, 15);
      } else {
        matrix.push(0);
        matrix = matrix.slice(4, 7);
      }
    } else {
      matrix = [0, 0, 0];
    }
    result = {
      x: parseFloat(matrix[0]),
      y: parseFloat(matrix[1]),
      z: parseFloat(matrix[2])
    };
    cacheTranslate($element, result);
  }
  return result;
};
var move = function($element, position2) {
  $element = $($element);
  var left = position2.left;
  var top = position2.top;
  var translate;
  if (left === void 0) {
    translate = getTranslate($element);
    translate.y = top || 0;
  } else if (top === void 0) {
    translate = getTranslate($element);
    translate.x = left || 0;
  } else {
    translate = {
      x: left || 0,
      y: top || 0,
      z: 0
    };
    cacheTranslate($element, translate);
  }
  $element.css({
    transform: getTranslateCss(translate)
  });
  if (isPercentValue(left) || isPercentValue(top)) {
    clearCache($element);
  }
};
var resetPosition = function($element, finishTransition) {
  $element = $($element);
  var originalTransition;
  var stylesConfig = {
    left: 0,
    top: 0,
    transform: "none"
  };
  if (finishTransition) {
    originalTransition = $element.css("transition");
    stylesConfig.transition = "none";
  }
  $element.css(stylesConfig);
  clearCache($element);
  if (finishTransition) {
    $element.get(0).offsetHeight;
    $element.css("transition", originalTransition);
  }
};
var parseTranslate = function(translateString) {
  var result = translateString.match(TRANSLATE_REGEX);
  if (!result || !result[1]) {
    return;
  }
  result = result[1].split(",");
  result = {
    x: parseFloat(result[0]),
    y: parseFloat(result[1]),
    z: parseFloat(result[2])
  };
  return result;
};
var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
var TransitionTimingFuncMap = {
  linear: "cubic-bezier(0, 0, 1, 1)",
  swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
  "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
};
var polynomBezier = function(x1, y1, x2, y2) {
  var Cx = 3 * x1;
  var Bx = 3 * (x2 - x1) - Cx;
  var Ax = 1 - Cx - Bx;
  var Cy = 3 * y1;
  var By = 3 * (y2 - y1) - Cy;
  var Ay = 1 - Cy - By;
  var bezierX = function(t) {
    return t * (Cx + t * (Bx + t * Ax));
  };
  var derivativeX = function(t) {
    return Cx + t * (2 * Bx + 3 * t * Ax);
  };
  return function(t) {
    return function(t2) {
      return t2 * (Cy + t2 * (By + t2 * Ay));
    }(function(t2) {
      var x = t2;
      var i = 0;
      var z;
      while (i < 14) {
        z = bezierX(x) - t2;
        if (Math.abs(z) < 1e-3) {
          break;
        }
        x -= z / derivativeX(x);
        i++;
      }
      return x;
    }(t));
  };
};
var easing = {};
var convertTransitionTimingFuncToEasing = function(cssTransitionEasing) {
  cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
  var coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
  var forceName;
  if (!coeffs) {
    forceName = "linear";
    coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
  }
  coeffs = coeffs.slice(1, 5);
  for (var i = 0; i < coeffs.length; i++) {
    coeffs[i] = parseFloat(coeffs[i]);
  }
  var easingName = forceName || "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
  if (!isFunction$1(easing[easingName])) {
    easing[easingName] = function(x, t, b, c, d) {
      return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
    };
  }
  return easingName;
};
function getEasing(name2) {
  return easing[name2];
}
var window$e = getWindow();
var horzRe = /left|right/;
var vertRe = /top|bottom/;
var collisionRe = /fit|flip|none/;
var scaleRe = /scale(.+)/;
var IS_SAFARI = coreBrowserUtils.safari;
var normalizeAlign = function(raw) {
  var result = {
    h: "center",
    v: "center"
  };
  var pair = splitPair(raw);
  if (pair) {
    each(pair, function() {
      var w = String(this).toLowerCase();
      if (horzRe.test(w)) {
        result.h = w;
      } else if (vertRe.test(w)) {
        result.v = w;
      }
    });
  }
  return result;
};
var normalizeOffset = function(raw) {
  return pairToObject(raw);
};
var normalizeCollision = function(raw) {
  var pair = splitPair(raw);
  var h = String(pair && pair[0]).toLowerCase();
  var v = String(pair && pair[1]).toLowerCase();
  if (!collisionRe.test(h)) {
    h = "none";
  }
  if (!collisionRe.test(v)) {
    v = h;
  }
  return {
    h,
    v
  };
};
var getAlignFactor = function(align) {
  switch (align) {
    case "center":
      return 0.5;
    case "right":
    case "bottom":
      return 1;
    default:
      return 0;
  }
};
var inverseAlign = function(align) {
  switch (align) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    default:
      return align;
  }
};
var calculateOversize = function(data2, bounds) {
  var oversize = 0;
  if (data2.myLocation < bounds.min) {
    oversize += bounds.min - data2.myLocation;
  }
  if (data2.myLocation > bounds.max) {
    oversize += data2.myLocation - bounds.max;
  }
  return oversize;
};
var collisionSide = function(direction, data2, bounds) {
  if (data2.myLocation < bounds.min) {
    return direction === "h" ? "left" : "top";
  }
  if (data2.myLocation > bounds.max) {
    return direction === "h" ? "right" : "bottom";
  }
  return "none";
};
var initMyLocation = function(data2) {
  data2.myLocation = data2.atLocation + getAlignFactor(data2.atAlign) * data2.atSize - getAlignFactor(data2.myAlign) * data2.mySize + data2.offset;
};
var collisionResolvers = {
  fit: function(data2, bounds) {
    var result = false;
    if (data2.myLocation > bounds.max) {
      data2.myLocation = bounds.max;
      result = true;
    }
    if (data2.myLocation < bounds.min) {
      data2.myLocation = bounds.min;
      result = true;
    }
    data2.fit = result;
  },
  flip: function(data2, bounds) {
    data2.flip = false;
    if (data2.myAlign === "center" && data2.atAlign === "center") {
      return;
    }
    if (data2.myLocation < bounds.min || data2.myLocation > bounds.max) {
      var inverseData = extend({}, data2, {
        myAlign: inverseAlign(data2.myAlign),
        atAlign: inverseAlign(data2.atAlign),
        offset: -data2.offset
      });
      initMyLocation(inverseData);
      inverseData.oversize = calculateOversize(inverseData, bounds);
      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data2.oversize > inverseData.oversize) {
        data2.myLocation = inverseData.myLocation;
        data2.oversize = inverseData.oversize;
        data2.flip = true;
      }
    }
  },
  flipfit: function(data2, bounds) {
    this.flip(data2, bounds);
    this.fit(data2, bounds);
  },
  none: function(data2) {
    data2.oversize = 0;
  }
};
var scrollbarWidth;
var calculateScrollbarWidth = function() {
  var $scrollDiv = $("<div>").css({
    width: 100,
    height: 100,
    overflow: "scroll",
    position: "absolute",
    top: -9999
  }).appendTo($("body"));
  var result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
  $scrollDiv.remove();
  scrollbarWidth = result;
};
var defaultPositionResult = {
  h: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  },
  v: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  }
};
var calculatePosition = function(what, options) {
  var $what = $(what);
  var currentOffset = $what.offset();
  var result = extend(true, {}, defaultPositionResult, {
    h: {
      location: currentOffset.left
    },
    v: {
      location: currentOffset.top
    }
  });
  if (!options) {
    return result;
  }
  var my = normalizeAlign(options.my);
  var at = normalizeAlign(options.at);
  var of = $(options.of).length && options.of || window$e;
  var offset2 = normalizeOffset(options.offset);
  var collision = normalizeCollision(options.collision);
  var boundary = options.boundary;
  var boundaryOffset = normalizeOffset(options.boundaryOffset);
  var h = {
    mySize: $what.outerWidth(),
    myAlign: my.h,
    atAlign: at.h,
    offset: offset2.h,
    collision: collision.h,
    boundaryOffset: boundaryOffset.h
  };
  var v = {
    mySize: $what.outerHeight(),
    myAlign: my.v,
    atAlign: at.v,
    offset: offset2.v,
    collision: collision.v,
    boundaryOffset: boundaryOffset.v
  };
  if (of.preventDefault) {
    h.atLocation = of.pageX;
    v.atLocation = of.pageY;
    h.atSize = 0;
    v.atSize = 0;
  } else {
    of = $(of);
    if (isWindow(of[0])) {
      h.atLocation = of.scrollLeft();
      v.atLocation = of.scrollTop();
      if (devices.real().deviceType === "phone" && of[0].visualViewport) {
        h.atLocation = Math.max(h.atLocation, of[0].visualViewport.offsetLeft);
        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
        h.atSize = of[0].visualViewport.width;
        v.atSize = of[0].visualViewport.height;
      } else {
        h.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : of.width();
        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : of.height();
      }
    } else if (of[0].nodeType === 9) {
      h.atLocation = 0;
      v.atLocation = 0;
      h.atSize = of.width();
      v.atSize = of.height();
    } else {
      var ofRect = getBoundingRect(of.get(0));
      var o = getOffsetWithoutScale(of);
      h.atLocation = o.left;
      v.atLocation = o.top;
      h.atSize = Math.max(ofRect.width, of.outerWidth());
      v.atSize = Math.max(ofRect.height, of.outerHeight());
    }
  }
  initMyLocation(h);
  initMyLocation(v);
  var bounds = function() {
    var win = $(window$e);
    var windowWidth = win.width();
    var windowHeight = win.height();
    var left = win.scrollLeft();
    var top = win.scrollTop();
    var documentElement = domAdapter.getDocumentElement();
    var hZoomLevel = touch ? documentElement.clientWidth / windowWidth : 1;
    var vZoomLevel = touch ? documentElement.clientHeight / windowHeight : 1;
    if (scrollbarWidth === void 0) {
      calculateScrollbarWidth();
    }
    var boundaryWidth = windowWidth;
    var boundaryHeight = windowHeight;
    if (boundary) {
      var $boundary = $(boundary);
      var boundaryPosition = $boundary.offset();
      left = boundaryPosition.left;
      top = boundaryPosition.top;
      boundaryWidth = $boundary.width();
      boundaryHeight = $boundary.height();
    }
    return {
      h: {
        min: left + h.boundaryOffset,
        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
      },
      v: {
        min: top + v.boundaryOffset,
        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
      }
    };
  }();
  h.oversize = calculateOversize(h, bounds.h);
  v.oversize = calculateOversize(v, bounds.v);
  h.collisionSide = collisionSide("h", h, bounds.h);
  v.collisionSide = collisionSide("v", v, bounds.v);
  if (collisionResolvers[h.collision]) {
    collisionResolvers[h.collision](h, bounds.h);
  }
  if (collisionResolvers[v.collision]) {
    collisionResolvers[v.collision](v, bounds.v);
  }
  var preciser = function(number) {
    return options.precise ? number : Math.round(number);
  };
  extend(true, result, {
    h: {
      location: preciser(h.myLocation),
      oversize: preciser(h.oversize),
      fit: h.fit,
      flip: h.flip,
      collisionSide: h.collisionSide
    },
    v: {
      location: preciser(v.myLocation),
      oversize: preciser(v.oversize),
      fit: v.fit,
      flip: v.flip,
      collisionSide: v.collisionSide
    },
    precise: options.precise
  });
  return result;
};
var getOffsetWithoutScale = function getOffsetWithoutScale2($startElement) {
  var _currentElement$getAt, _style$match;
  var $currentElement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $startElement;
  var currentElement = $currentElement.get(0);
  if (!currentElement) {
    return $startElement.offset();
  }
  var style = ((_currentElement$getAt = currentElement.getAttribute) === null || _currentElement$getAt === void 0 ? void 0 : _currentElement$getAt.call(currentElement, "style")) || "";
  var scale = (_style$match = style.match(scaleRe)) === null || _style$match === void 0 ? void 0 : _style$match[0];
  var offset2;
  if (scale) {
    currentElement.setAttribute("style", style.replace(scale, ""));
    offset2 = getOffsetWithoutScale2($startElement, $currentElement.parent());
    currentElement.setAttribute("style", style);
  } else {
    offset2 = getOffsetWithoutScale2($startElement, $currentElement.parent());
  }
  return offset2;
};
var position = function(what, options) {
  var $what = $(what);
  if (!options) {
    return $what.offset();
  }
  resetPosition($what, true);
  var offset2 = getOffsetWithoutScale($what);
  var targetPosition = options.h && options.v ? options : calculatePosition($what, options);
  var preciser = function(number) {
    return options.precise ? number : Math.round(number);
  };
  move($what, {
    left: targetPosition.h.location - preciser(offset2.left),
    top: targetPosition.v.location - preciser(offset2.top)
  });
  return targetPosition;
};
var offset = function(element) {
  element = $(element).get(0);
  if (isWindow(element)) {
    return null;
  } else if (element && "pageY" in element && "pageX" in element) {
    return {
      top: element.pageY,
      left: element.pageX
    };
  }
  return $(element).offset();
};
if (!position.inverseAlign) {
  position.inverseAlign = inverseAlign;
}
if (!position.normalizeAlign) {
  position.normalizeAlign = normalizeAlign;
}
var animationPosition = {
  calculateScrollbarWidth,
  calculate: calculatePosition,
  setup: position,
  offset
};
var window$d = getWindow();
var removeEventName = addNamespace$1(removeEvent, "dxFX");
var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
var ANIM_DATA_KEY = "dxAnimData";
var ANIM_QUEUE_KEY = "dxAnimQueue";
var TRANSFORM_PROP = "transform";
var TransitionAnimationStrategy = {
  initAnimation: function($element, config2) {
    $element.css({
      transitionProperty: "none"
    });
    if (typeof config2.from === "string") {
      $element.addClass(config2.from);
    } else {
      setProps($element, config2.from);
    }
    var that = this;
    var deferred = new Deferred();
    var cleanupWhen = config2.cleanupWhen;
    config2.transitionAnimation = {
      deferred,
      finish: function() {
        that._finishTransition($element);
        if (cleanupWhen) {
          when(deferred, cleanupWhen).always(function() {
            that._cleanup($element, config2);
          });
        } else {
          that._cleanup($element, config2);
        }
        deferred.resolveWith($element, [config2, $element]);
      }
    };
    this._completeAnimationCallback($element, config2).done(function() {
      config2.transitionAnimation.finish();
    }).fail(function() {
      deferred.rejectWith($element, [config2, $element]);
    });
    if (!config2.duration) {
      config2.transitionAnimation.finish();
    }
    $element.css("transform");
  },
  animate: function($element, config2) {
    this._startAnimation($element, config2);
    return config2.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function($element, config2) {
    var that = this;
    var startTime = Date.now() + config2.delay;
    var deferred = new Deferred();
    var transitionEndFired = new Deferred();
    var simulatedTransitionEndFired = new Deferred();
    var simulatedEndEventTimer;
    var transitionEndEventFullName = transitionEndEventName() + ".dxFX";
    config2.transitionAnimation.cleanup = function() {
      clearTimeout(simulatedEndEventTimer);
      clearTimeout(waitForJSCompleteTimer);
      eventsEngine.off($element, transitionEndEventFullName);
      eventsEngine.off($element, removeEventName);
    };
    eventsEngine.one($element, transitionEndEventFullName, function() {
      if (Date.now() - startTime >= config2.duration) {
        transitionEndFired.reject();
      }
    });
    eventsEngine.off($element, removeEventName);
    eventsEngine.on($element, removeEventName, function() {
      that.stop($element, config2);
      deferred.reject();
    });
    var waitForJSCompleteTimer = setTimeout(function() {
      simulatedEndEventTimer = setTimeout(function() {
        simulatedTransitionEndFired.reject();
      }, config2.duration + config2.delay + fx._simulatedTransitionEndDelay);
      when(transitionEndFired, simulatedTransitionEndFired).fail(function() {
        deferred.resolve();
      }.bind(this));
    });
    return deferred.promise();
  },
  _startAnimation: function($element, config2) {
    $element.css({
      transitionProperty: "all",
      transitionDelay: config2.delay + "ms",
      transitionDuration: config2.duration + "ms",
      transitionTimingFunction: config2.easing
    });
    if (typeof config2.to === "string") {
      $element[0].className += " " + config2.to;
    } else if (config2.to) {
      setProps($element, config2.to);
    }
  },
  _finishTransition: function($element) {
    $element.css("transition", "none");
  },
  _cleanup: function($element, config2) {
    config2.transitionAnimation.cleanup();
    if (typeof config2.from === "string") {
      $element.removeClass(config2.from);
      $element.removeClass(config2.to);
    }
  },
  stop: function($element, config2, jumpToEnd) {
    if (!config2) {
      return;
    }
    if (jumpToEnd) {
      config2.transitionAnimation.finish();
    } else {
      if (isPlainObject(config2.to)) {
        each(config2.to, function(key) {
          $element.css(key, $element.css(key));
        });
      }
      this._finishTransition($element);
      this._cleanup($element, config2);
    }
  }
};
var FrameAnimationStrategy = {
  initAnimation: function($element, config2) {
    setProps($element, config2.from);
  },
  animate: function($element, config2) {
    var deferred = new Deferred();
    var that = this;
    if (!config2) {
      return deferred.reject().promise();
    }
    each(config2.to, function(prop) {
      if (config2.from[prop] === void 0) {
        config2.from[prop] = that._normalizeValue($element.css(prop));
      }
    });
    if (config2.to[TRANSFORM_PROP]) {
      config2.from[TRANSFORM_PROP] = that._parseTransform(config2.from[TRANSFORM_PROP]);
      config2.to[TRANSFORM_PROP] = that._parseTransform(config2.to[TRANSFORM_PROP]);
    }
    config2.frameAnimation = {
      to: config2.to,
      from: config2.from,
      currentValue: config2.from,
      easing: convertTransitionTimingFuncToEasing(config2.easing),
      duration: config2.duration,
      startTime: new Date().valueOf(),
      finish: function() {
        this.currentValue = this.to;
        this.draw();
        cancelAnimationFrame(config2.frameAnimation.animationFrameId);
        deferred.resolve();
      },
      draw: function() {
        if (config2.draw) {
          config2.draw(this.currentValue);
          return;
        }
        var currentValue = extend({}, this.currentValue);
        if (currentValue[TRANSFORM_PROP]) {
          currentValue[TRANSFORM_PROP] = map(currentValue[TRANSFORM_PROP], function(value2, prop) {
            if (prop === "translate") {
              return getTranslateCss(value2);
            } else if (prop === "scale") {
              return "scale(" + value2 + ")";
            } else if (prop.substr(0, prop.length - 1) === "rotate") {
              return prop + "(" + value2 + "deg)";
            }
          }).join(" ");
        }
        $element.css(currentValue);
      }
    };
    if (config2.delay) {
      config2.frameAnimation.startTime += config2.delay;
      config2.frameAnimation.delayTimeout = setTimeout(function() {
        that._startAnimation($element, config2);
      }, config2.delay);
    } else {
      that._startAnimation($element, config2);
    }
    return deferred.promise();
  },
  _startAnimation: function($element, config2) {
    eventsEngine.off($element, removeEventName);
    eventsEngine.on($element, removeEventName, function() {
      if (config2.frameAnimation) {
        cancelAnimationFrame(config2.frameAnimation.animationFrameId);
      }
    });
    this._animationStep($element, config2);
  },
  _parseTransform: function(transformString) {
    var result = {};
    each(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function(i, part) {
      var translateData = parseTranslate(part);
      var scaleData = part.match(/scale\((.+?)\)/);
      var rotateData = part.match(/(rotate.)\((.+)deg\)/);
      if (translateData) {
        result.translate = translateData;
      }
      if (scaleData && scaleData[1]) {
        result.scale = parseFloat(scaleData[1]);
      }
      if (rotateData && rotateData[1]) {
        result[rotateData[1]] = parseFloat(rotateData[2]);
      }
    });
    return result;
  },
  stop: function($element, config2, jumpToEnd) {
    var frameAnimation = config2 && config2.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    cancelAnimationFrame(frameAnimation.animationFrameId);
    clearTimeout(frameAnimation.delayTimeout);
    if (jumpToEnd) {
      frameAnimation.finish();
    }
    delete config2.frameAnimation;
  },
  _animationStep: function($element, config2) {
    var frameAnimation = config2 && config2.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    var now = new Date().valueOf();
    if (now >= frameAnimation.startTime + frameAnimation.duration) {
      frameAnimation.finish();
      return;
    }
    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
    frameAnimation.draw();
    var that = this;
    frameAnimation.animationFrameId = requestAnimationFrame(function() {
      that._animationStep($element, config2);
    });
  },
  _calcStepValue: function(frameAnimation, currentDuration) {
    return function calcValueRecursively(from, to) {
      var result = Array.isArray(to) ? [] : {};
      each(to, function(propName, endPropValue) {
        if (typeof endPropValue === "string" && parseFloat(endPropValue, 10) === false) {
          return true;
        }
        result[propName] = typeof endPropValue === "object" ? calcValueRecursively(from[propName], endPropValue) : function(propName2) {
          var x = currentDuration / frameAnimation.duration;
          var t = currentDuration;
          var b = 1 * from[propName2];
          var c = to[propName2] - from[propName2];
          var d = frameAnimation.duration;
          return getEasing(frameAnimation.easing)(x, t, b, c, d);
        }(propName);
      });
      return result;
    }(frameAnimation.from, frameAnimation.to);
  },
  _normalizeValue: function(value2) {
    var numericValue = parseFloat(value2, 10);
    if (numericValue === false) {
      return value2;
    }
    return numericValue;
  }
};
var FallbackToNoAnimationStrategy = {
  initAnimation: function() {
  },
  animate: function() {
    return new Deferred().resolve().promise();
  },
  stop: noop,
  isSynchronous: true
};
var getAnimationStrategy = function(config2) {
  config2 = config2 || {};
  var animationStrategies = {
    transition: transition() ? TransitionAnimationStrategy : FrameAnimationStrategy,
    frame: FrameAnimationStrategy,
    noAnimation: FallbackToNoAnimationStrategy
  };
  var strategy2 = config2.strategy || "transition";
  if (config2.type === "css" && !transition()) {
    strategy2 = "noAnimation";
  }
  return animationStrategies[strategy2];
};
var baseConfigValidator = function(config2, animationType, validate, typeMessage) {
  each(["from", "to"], function() {
    if (!validate(config2[this])) {
      throw errors$2.Error("E0010", animationType, this, typeMessage);
    }
  });
};
var isObjectConfigValidator = function(config2, animationType) {
  return baseConfigValidator(config2, animationType, function(target) {
    return isPlainObject(target);
  }, "a plain object");
};
var isStringConfigValidator = function(config2, animationType) {
  return baseConfigValidator(config2, animationType, function(target) {
    return typeof target === "string";
  }, "a string");
};
var CustomAnimationConfigurator = {
  setup: function() {
  }
};
var CssAnimationConfigurator = {
  validateConfig: function(config2) {
    isStringConfigValidator(config2, "css");
  },
  setup: function() {
  }
};
var positionAliases = {
  top: {
    my: "bottom center",
    at: "top center"
  },
  bottom: {
    my: "top center",
    at: "bottom center"
  },
  right: {
    my: "left center",
    at: "right center"
  },
  left: {
    my: "right center",
    at: "left center"
  }
};
var SlideAnimationConfigurator = {
  validateConfig: function(config2) {
    isObjectConfigValidator(config2, "slide");
  },
  setup: function($element, config2) {
    var location = locate($element);
    if (config2.type !== "slide") {
      var positioningConfig = config2.type === "slideIn" ? config2.from : config2.to;
      positioningConfig.position = extend({
        of: window$d
      }, positionAliases[config2.direction]);
      setupPosition($element, positioningConfig);
    }
    this._setUpConfig(location, config2.from);
    this._setUpConfig(location, config2.to);
    clearCache($element);
  },
  _setUpConfig: function(location, config2) {
    config2.left = "left" in config2 ? config2.left : "+=0";
    config2.top = "top" in config2 ? config2.top : "+=0";
    this._initNewPosition(location, config2);
  },
  _initNewPosition: function(location, config2) {
    var position2 = {
      left: config2.left,
      top: config2.top
    };
    delete config2.left;
    delete config2.top;
    var relativeValue = this._getRelativeValue(position2.left);
    if (relativeValue !== void 0) {
      position2.left = relativeValue + location.left;
    } else {
      config2.left = 0;
    }
    relativeValue = this._getRelativeValue(position2.top);
    if (relativeValue !== void 0) {
      position2.top = relativeValue + location.top;
    } else {
      config2.top = 0;
    }
    config2[TRANSFORM_PROP] = getTranslateCss({
      x: position2.left,
      y: position2.top
    });
  },
  _getRelativeValue: function(value2) {
    var relativeValue;
    if (typeof value2 === "string" && (relativeValue = RELATIVE_VALUE_REGEX.exec(value2))) {
      return parseInt(relativeValue[1] + "1") * relativeValue[2];
    }
  }
};
var FadeAnimationConfigurator = {
  setup: function($element, config2) {
    var from = config2.from;
    var fromOpacity = isPlainObject(from) ? config2.skipElementInitialStyles ? 0 : $element.css("opacity") : String(from);
    var toOpacity;
    switch (config2.type) {
      case "fadeIn":
        toOpacity = 1;
        break;
      case "fadeOut":
        toOpacity = 0;
        break;
      default:
        toOpacity = String(config2.to);
    }
    config2.from = {
      visibility: "visible",
      opacity: fromOpacity
    };
    config2.to = {
      opacity: toOpacity
    };
  }
};
var PopAnimationConfigurator = {
  validateConfig: function(config2) {
    isObjectConfigValidator(config2, "pop");
  },
  setup: function($element, config2) {
    var from = config2.from;
    var to = config2.to;
    var fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity");
    var toOpacity = "opacity" in to ? to.opacity : 1;
    var fromScale = "scale" in from ? from.scale : 0;
    var toScale = "scale" in to ? to.scale : 1;
    config2.from = {
      opacity: fromOpacity
    };
    var translate = getTranslate($element);
    config2.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
    config2.to = {
      opacity: toOpacity
    };
    config2.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale);
  },
  _getCssTransform: function(translate, scale) {
    return getTranslateCss(translate) + "scale(" + scale + ")";
  }
};
var animationConfigurators = {
  custom: CustomAnimationConfigurator,
  slide: SlideAnimationConfigurator,
  slideIn: SlideAnimationConfigurator,
  slideOut: SlideAnimationConfigurator,
  fade: FadeAnimationConfigurator,
  fadeIn: FadeAnimationConfigurator,
  fadeOut: FadeAnimationConfigurator,
  pop: PopAnimationConfigurator,
  css: CssAnimationConfigurator
};
var getAnimationConfigurator = function(config2) {
  var result = animationConfigurators[config2.type];
  if (!result) {
    throw errors$2.Error("E0011", config2.type);
  }
  return result;
};
var defaultJSConfig = {
  type: "custom",
  from: {},
  to: {},
  duration: 400,
  start: noop,
  complete: noop,
  easing: "ease",
  delay: 0
};
var defaultCssConfig = {
  duration: 400,
  easing: "ease",
  delay: 0
};
function setupAnimationOnElement() {
  var $element = this.element;
  var config2 = this.config;
  setupPosition($element, config2.from);
  setupPosition($element, config2.to);
  this.configurator.setup($element, config2);
  $element.data(ANIM_DATA_KEY, this);
  this.strategy.initAnimation($element, config2);
  if (config2.start) {
    var element = getPublicElement($element);
    config2.start.apply(this, [element, config2]);
  }
}
var onElementAnimationComplete = function(animation2) {
  var $element = animation2.element;
  var config2 = animation2.config;
  $element.removeData(ANIM_DATA_KEY);
  if (config2.complete) {
    var element = getPublicElement($element);
    config2.complete.apply(this, [element, config2]);
  }
  animation2.deferred.resolveWith(this, [$element, config2]);
};
var startAnimationOnElement = function() {
  var animation2 = this;
  var $element = animation2.element;
  var config2 = animation2.config;
  animation2.isStarted = true;
  return animation2.strategy.animate($element, config2).done(function() {
    onElementAnimationComplete(animation2);
  }).fail(function() {
    animation2.deferred.rejectWith(this, [$element, config2]);
  });
};
var stopAnimationOnElement = function(jumpToEnd) {
  var $element = this.element;
  var config2 = this.config;
  clearTimeout(this.startTimeout);
  if (!this.isStarted) {
    this.start();
  }
  this.strategy.stop($element, config2, jumpToEnd);
};
var scopedRemoveEvent = addNamespace$1(removeEvent, "dxFXStartAnimation");
var subscribeToRemoveEvent = function(animation2) {
  eventsEngine.off(animation2.element, scopedRemoveEvent);
  eventsEngine.on(animation2.element, scopedRemoveEvent, function() {
    fx.stop(animation2.element);
  });
  animation2.deferred.always(function() {
    eventsEngine.off(animation2.element, scopedRemoveEvent);
  });
};
var createAnimation = function(element, initialConfig) {
  var defaultConfig = initialConfig.type === "css" ? defaultCssConfig : defaultJSConfig;
  var config2 = extend(true, {}, defaultConfig, initialConfig);
  var configurator = getAnimationConfigurator(config2);
  var strategy2 = getAnimationStrategy(config2);
  var animation2 = {
    element: $(element),
    config: config2,
    configurator,
    strategy: strategy2,
    isSynchronous: strategy2.isSynchronous,
    setup: setupAnimationOnElement,
    start: startAnimationOnElement,
    stop: stopAnimationOnElement,
    deferred: new Deferred()
  };
  if (isFunction$1(configurator.validateConfig)) {
    configurator.validateConfig(config2);
  }
  subscribeToRemoveEvent(animation2);
  return animation2;
};
var animate$1 = function(element, config2) {
  var $element = $(element);
  if (!$element.length) {
    return new Deferred().resolve().promise();
  }
  var animation2 = createAnimation($element, config2);
  pushInAnimationQueue($element, animation2);
  return animation2.deferred.promise();
};
function pushInAnimationQueue($element, animation2) {
  var queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation2);
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}
function getAnimQueueData($element) {
  return $element.data(ANIM_QUEUE_KEY) || [];
}
function writeAnimQueueData($element, queueData) {
  $element.data(ANIM_QUEUE_KEY, queueData);
}
var destroyAnimQueueData = function($element) {
  $element.removeData(ANIM_QUEUE_KEY);
};
function isAnimating($element) {
  return !!$element.data(ANIM_DATA_KEY);
}
function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);
  if (!queueData.length) {
    return;
  }
  var animation2 = queueData.shift();
  if (queueData.length === 0) {
    destroyAnimQueueData($element);
  }
  executeAnimation(animation2).done(function() {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}
function executeAnimation(animation2) {
  animation2.setup();
  if (animation2.isSynchronous) {
    animation2.start();
  } else {
    animation2.startTimeout = setTimeout(function() {
      animation2.start();
    });
  }
  return animation2.deferred.promise();
}
function setupPosition($element, config2) {
  if (!config2 || !config2.position) {
    return;
  }
  var win = $(window$d);
  var left = 0;
  var top = 0;
  var position2 = animationPosition.calculate($element, config2.position);
  var offset2 = $element.offset();
  var currentPosition = $element.position();
  if (currentPosition.top > offset2.top) {
    top = win.scrollTop();
  }
  if (currentPosition.left > offset2.left) {
    left = win.scrollLeft();
  }
  extend(config2, {
    left: position2.h.location - offset2.left + currentPosition.left - left,
    top: position2.v.location - offset2.top + currentPosition.top - top
  });
  delete config2.position;
}
function setProps($element, props) {
  each(props, function(key, value2) {
    try {
      $element.css(key, isFunction$1(value2) ? value2() : value2);
    } catch (e) {
    }
  });
}
var stop = function(element, jumpToEnd) {
  var $element = $(element);
  var queueData = getAnimQueueData($element);
  each(queueData, function(_2, animation3) {
    animation3.config.delay = 0;
    animation3.config.duration = 0;
    animation3.isSynchronous = true;
  });
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
  var animation2 = $element.data(ANIM_DATA_KEY);
  if (animation2) {
    animation2.stop(jumpToEnd);
  }
  $element.removeData(ANIM_DATA_KEY);
  destroyAnimQueueData($element);
};
var fx = {
  off: false,
  animationTypes: animationConfigurators,
  animate: animate$1,
  createAnimation,
  isAnimating,
  stop,
  _simulatedTransitionEndDelay: 100
};
var sign = function(value2) {
  if (value2 === 0) {
    return 0;
  }
  return value2 / Math.abs(value2);
};
var fitIntoRange = function(value2, minValue, maxValue) {
  var isMinValueUndefined = !minValue && minValue !== 0;
  var isMaxValueUndefined = !maxValue && maxValue !== 0;
  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value2, maxValue) : value2);
  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value2, minValue) : value2);
  return Math.min(Math.max(value2, minValue), maxValue);
};
function getExponent(value2) {
  return Math.abs(parseInt(value2.toExponential().split("e")[1]));
}
function _isEdgeBug() {
  return 3e-4 .toPrecision(3) !== "0.000300";
}
function adjust(value2, interval) {
  var precision = getPrecision(interval || 0) + 2;
  var separatedValue = value2.toString().split(".");
  var sourceValue = value2;
  var absValue = Math.abs(value2);
  var separatedAdjustedValue;
  var isExponentValue = isExponential(value2);
  var integerPart = absValue > 1 ? 10 : 0;
  if (separatedValue.length === 1) {
    return value2;
  }
  if (!isExponentValue) {
    if (isExponential(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }
    value2 = absValue;
    value2 = value2 - Math.floor(value2) + integerPart;
  }
  precision = _isEdgeBug() && getExponent(value2) > 6 || precision > 7 ? 15 : 7;
  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value2.toPrecision(precision)).toString().split(".");
    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(separatedValue[0] + "." + separatedAdjustedValue[1]);
    }
  }
  return parseFloat(sourceValue.toPrecision(precision));
}
function getPrecision(value2) {
  var str = value2.toString();
  if (str.indexOf(".") < 0) {
    return 0;
  }
  var mantissa = str.split(".");
  var positionOfDelimiter = mantissa[1].indexOf("e");
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}
var ready$2 = readyCallback.add;
var abs$1 = Math.abs;
var SLEEP = 0;
var INITED = 1;
var STARTED = 2;
var TOUCH_BOUNDARY$1 = 10;
var IMMEDIATE_TOUCH_BOUNDARY = 0;
var IMMEDIATE_TIMEOUT = 180;
var supportPointerEvents = function() {
  return styleProp("pointer-events");
};
var setGestureCover = callOnce(function() {
  var isDesktop = devices.real().deviceType === "desktop";
  if (!supportPointerEvents() || !isDesktop) {
    return noop;
  }
  var $cover = $("<div>").addClass("dx-gesture-cover").css("pointerEvents", "none");
  eventsEngine.subscribeGlobal($cover, "dxmousewheel", function(e) {
    e.preventDefault();
  });
  ready$2(function() {
    $cover.appendTo("body");
  });
  return function(toggle, cursor) {
    $cover.css("pointerEvents", toggle ? "all" : "none");
    toggle && $cover.css("cursor", cursor);
  };
});
var gestureCover = function(toggle, cursor) {
  var gestureCoverStrategy = setGestureCover();
  gestureCoverStrategy(toggle, cursor);
};
var GestureEmitter = Emitter.inherit({
  gesture: true,
  configure: function(data2) {
    this.getElement().css("msTouchAction", data2.immediate ? "pinch-zoom" : "");
    this.callBase(data2);
  },
  allowInterruptionByMouseWheel: function() {
    return this._stage !== STARTED;
  },
  getDirection: function() {
    return this.direction;
  },
  _cancel: function() {
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
    this._stage = SLEEP;
  },
  start: function(e) {
    if (e._needSkipEvent || needSkipEvent(e)) {
      this._cancel(e);
      return;
    }
    this._startEvent = createEvent(e);
    this._startEventData = eventData(e);
    this._stage = INITED;
    this._init(e);
    this._setupImmediateTimer();
  },
  _setupImmediateTimer: function() {
    clearTimeout(this._immediateTimer);
    this._immediateAccepted = false;
    if (!this.immediate) {
      return;
    }
    this._immediateTimer = setTimeout(function() {
      this._immediateAccepted = true;
    }.bind(this), IMMEDIATE_TIMEOUT);
  },
  move: function(e) {
    if (this._stage === INITED && this._directionConfirmed(e)) {
      this._stage = STARTED;
      this._resetActiveElement();
      this._toggleGestureCover(true);
      this._clearSelection(e);
      this._adjustStartEvent(e);
      this._start(this._startEvent);
      if (this._stage === SLEEP) {
        return;
      }
      this._requestAccept(e);
      this._move(e);
      this._forgetAccept();
    } else if (this._stage === STARTED) {
      this._clearSelection(e);
      this._move(e);
    }
  },
  _directionConfirmed: function(e) {
    var touchBoundary = this._getTouchBoundary(e);
    var delta = eventDelta(this._startEventData, eventData(e));
    var deltaX = abs$1(delta.x);
    var deltaY = abs$1(delta.y);
    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
    var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
    var direction = this.getDirection(e);
    var bothAccepted = direction === "both" && (horizontalMove || verticalMove);
    var horizontalAccepted = direction === "horizontal" && horizontalMove;
    var verticalAccepted = direction === "vertical" && verticalMove;
    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
  },
  _validateMove: function(touchBoundary, mainAxis, crossAxis) {
    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
  },
  _getTouchBoundary: function(e) {
    return this.immediate || isDxMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY$1;
  },
  _adjustStartEvent: function(e) {
    var touchBoundary = this._getTouchBoundary(e);
    var delta = eventDelta(this._startEventData, eventData(e));
    this._startEvent.pageX += sign(delta.x) * touchBoundary;
    this._startEvent.pageY += sign(delta.y) * touchBoundary;
  },
  _resetActiveElement: function() {
    if (devices.real().platform === "ios" && this.getElement().find(":focus").length) {
      resetActiveElement();
    }
  },
  _toggleGestureCover: function(toggle) {
    this._toggleGestureCoverImpl(toggle);
  },
  _toggleGestureCoverImpl: function(toggle) {
    var isStarted = this._stage === STARTED;
    if (isStarted) {
      gestureCover(toggle, this.getElement().css("cursor"));
    }
  },
  _clearSelection: function(e) {
    if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {
      return;
    }
    clearSelection();
  },
  end: function(e) {
    this._toggleGestureCover(false);
    if (this._stage === STARTED) {
      this._end(e);
    } else if (this._stage === INITED) {
      this._stop(e);
    }
    this._stage = SLEEP;
  },
  dispose: function() {
    clearTimeout(this._immediateTimer);
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
  },
  _init: noop,
  _start: noop,
  _move: noop,
  _stop: noop,
  _end: noop
});
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY$1;
GestureEmitter.touchBoundary = function(newBoundary) {
  if (isDefined(newBoundary)) {
    TOUCH_BOUNDARY$1 = newBoundary;
    return;
  }
  return TOUCH_BOUNDARY$1;
};
var DRAG_START_EVENT = "dxdragstart";
var DRAG_EVENT = "dxdrag";
var DRAG_END_EVENT = "dxdragend";
var DRAG_ENTER_EVENT = "dxdragenter";
var DRAG_LEAVE_EVENT = "dxdragleave";
var DROP_EVENT = "dxdrop";
var DX_DRAG_EVENTS_COUNT_KEY = "dxDragEventsCount";
var knownDropTargets = [];
var knownDropTargetSelectors = [];
var knownDropTargetConfigs = [];
var dropTargetRegistration = {
  setup: function(element, data2) {
    var knownDropTarget = inArray(element, knownDropTargets) !== -1;
    if (!knownDropTarget) {
      knownDropTargets.push(element);
      knownDropTargetSelectors.push([]);
      knownDropTargetConfigs.push(data2 || {});
    }
  },
  add: function(element, handleObj) {
    var index2 = inArray(element, knownDropTargets);
    this.updateEventsCounter(element, handleObj.type, 1);
    var selector = handleObj.selector;
    if (inArray(selector, knownDropTargetSelectors[index2]) === -1) {
      knownDropTargetSelectors[index2].push(selector);
    }
  },
  updateEventsCounter: function(element, event, value2) {
    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {
      var eventsCount = data(element, DX_DRAG_EVENTS_COUNT_KEY) || 0;
      data(element, DX_DRAG_EVENTS_COUNT_KEY, Math.max(0, eventsCount + value2));
    }
  },
  remove: function(element, handleObj) {
    this.updateEventsCounter(element, handleObj.type, -1);
  },
  teardown: function(element) {
    var handlersCount = data(element, DX_DRAG_EVENTS_COUNT_KEY);
    if (!handlersCount) {
      var index2 = inArray(element, knownDropTargets);
      knownDropTargets.splice(index2, 1);
      knownDropTargetSelectors.splice(index2, 1);
      knownDropTargetConfigs.splice(index2, 1);
      removeData(element, DX_DRAG_EVENTS_COUNT_KEY);
    }
  }
};
registerEvent(DRAG_ENTER_EVENT, dropTargetRegistration);
registerEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);
registerEvent(DROP_EVENT, dropTargetRegistration);
var getItemDelegatedTargets = function($element) {
  var dropTargetIndex = inArray($element.get(0), knownDropTargets);
  var dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter((selector) => selector);
  var $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
  if (inArray(void 0, knownDropTargetSelectors[dropTargetIndex]) !== -1) {
    $delegatedTargets = $delegatedTargets.add($element);
  }
  return $delegatedTargets;
};
var getItemConfig = function($element) {
  var dropTargetIndex = inArray($element.get(0), knownDropTargets);
  return knownDropTargetConfigs[dropTargetIndex];
};
var getItemPosition = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemPositionFunc) {
    return dropTargetConfig.itemPositionFunc($element);
  } else {
    return $element.offset();
  }
};
var getItemSize = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemSizeFunc) {
    return dropTargetConfig.itemSizeFunc($element);
  }
  return {
    width: $element.get(0).getBoundingClientRect().width,
    height: $element.get(0).getBoundingClientRect().height
  };
};
var DragEmitter = GestureEmitter.inherit({
  ctor: function(element) {
    this.callBase(element);
    this.direction = "both";
  },
  _init: function(e) {
    this._initEvent = e;
  },
  _start: function(e) {
    e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
    this._maxLeftOffset = e.maxLeftOffset;
    this._maxRightOffset = e.maxRightOffset;
    this._maxTopOffset = e.maxTopOffset;
    this._maxBottomOffset = e.maxBottomOffset;
    var dropTargets = wrapToArray(e.targetElements || (e.targetElements === null ? [] : knownDropTargets));
    this._dropTargets = map(dropTargets, function(element) {
      return $(element).get(0);
    });
  },
  _move: function(e) {
    var eventData$1 = eventData(e);
    var dragOffset = this._calculateOffset(eventData$1);
    e = this._fireEvent(DRAG_EVENT, e, {
      offset: dragOffset
    });
    this._processDropTargets(e);
    if (!e._cancelPreventDefault) {
      e.preventDefault();
    }
  },
  _calculateOffset: function(eventData2) {
    return {
      x: this._calculateXOffset(eventData2),
      y: this._calculateYOffset(eventData2)
    };
  },
  _calculateXOffset: function(eventData2) {
    if (this.direction !== "vertical") {
      var offset2 = eventData2.x - this._startEventData.x;
      return this._fitOffset(offset2, this._maxLeftOffset, this._maxRightOffset);
    }
    return 0;
  },
  _calculateYOffset: function(eventData2) {
    if (this.direction !== "horizontal") {
      var offset2 = eventData2.y - this._startEventData.y;
      return this._fitOffset(offset2, this._maxTopOffset, this._maxBottomOffset);
    }
    return 0;
  },
  _fitOffset: function(offset2, minOffset, maxOffset) {
    if (minOffset != null) {
      offset2 = Math.max(offset2, -minOffset);
    }
    if (maxOffset != null) {
      offset2 = Math.min(offset2, maxOffset);
    }
    return offset2;
  },
  _processDropTargets: function(e) {
    var target = this._findDropTarget(e);
    var sameTarget = target === this._currentDropTarget;
    if (!sameTarget) {
      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
      this._currentDropTarget = target;
      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
    }
  },
  _fireDropTargetEvent: function(event, eventName) {
    if (!this._currentDropTarget) {
      return;
    }
    var eventData2 = {
      type: eventName,
      originalEvent: event,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    fireEvent(eventData2);
  },
  _findDropTarget: function(e) {
    var that = this;
    var result;
    each(knownDropTargets, function(_2, target) {
      if (!that._checkDropTargetActive(target)) {
        return;
      }
      var $target = $(target);
      each(getItemDelegatedTargets($target), function(_3, delegatedTarget) {
        var $delegatedTarget = $(delegatedTarget);
        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, $(result), e)) {
          result = delegatedTarget;
        }
      });
    });
    return result;
  },
  _checkDropTargetActive: function(target) {
    var active2 = false;
    each(this._dropTargets, function(_2, activeTarget) {
      active2 = active2 || activeTarget === target || contains(activeTarget, target);
      return !active2;
    });
    return active2;
  },
  _checkDropTarget: function(config2, $target, $prevTarget, e) {
    var isDraggingElement = $target.get(0) === $(e.target).get(0);
    if (isDraggingElement) {
      return false;
    }
    var targetPosition = getItemPosition(config2, $target);
    if (e.pageX < targetPosition.left) {
      return false;
    }
    if (e.pageY < targetPosition.top) {
      return false;
    }
    var targetSize = getItemSize(config2, $target);
    if (e.pageX > targetPosition.left + targetSize.width) {
      return false;
    }
    if (e.pageY > targetPosition.top + targetSize.height) {
      return false;
    }
    if ($prevTarget.length && $prevTarget.closest($target).length) {
      return false;
    }
    if (config2.checkDropTarget && !config2.checkDropTarget($target, e)) {
      return false;
    }
    return $target;
  },
  _end: function(e) {
    var eventData$1 = eventData(e);
    this._fireEvent(DRAG_END_EVENT, e, {
      offset: this._calculateOffset(eventData$1)
    });
    this._fireDropTargetEvent(e, DROP_EVENT);
    delete this._currentDropTarget;
  }
});
registerEmitter({
  emitter: DragEmitter,
  events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
});
var hideCallback = function() {
  var callbacks2 = [];
  return {
    add: function(callback) {
      var indexOfCallback = inArray(callback, callbacks2);
      if (indexOfCallback === -1) {
        callbacks2.push(callback);
      }
    },
    remove: function(callback) {
      var indexOfCallback = inArray(callback, callbacks2);
      if (indexOfCallback !== -1) {
        callbacks2.splice(indexOfCallback, 1);
      }
    },
    fire: function() {
      var callback = callbacks2.pop();
      var result = !!callback;
      if (result) {
        callback();
      }
      return result;
    },
    hasCallback: function() {
      return callbacks2.length > 0;
    }
  };
}();
var RESIZABLE = "dxResizable";
var RESIZABLE_CLASS = "dx-resizable";
var RESIZABLE_RESIZING_CLASS = "dx-resizable-resizing";
var RESIZABLE_HANDLE_CLASS = "dx-resizable-handle";
var RESIZABLE_HANDLE_TOP_CLASS = "dx-resizable-handle-top";
var RESIZABLE_HANDLE_BOTTOM_CLASS = "dx-resizable-handle-bottom";
var RESIZABLE_HANDLE_LEFT_CLASS = "dx-resizable-handle-left";
var RESIZABLE_HANDLE_RIGHT_CLASS = "dx-resizable-handle-right";
var RESIZABLE_HANDLE_CORNER_CLASS = "dx-resizable-handle-corner";
var DRAGSTART_START_EVENT_NAME = addNamespace$1(DRAG_START_EVENT, RESIZABLE);
var DRAGSTART_EVENT_NAME$1 = addNamespace$1(DRAG_EVENT, RESIZABLE);
var DRAGSTART_END_EVENT_NAME = addNamespace$1(DRAG_END_EVENT, RESIZABLE);
var SIDE_BORDER_WIDTH_STYLES$1 = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};
var Resizable = DOMComponent.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      handles: "all",
      step: "1",
      stepPrecision: "simple",
      area: void 0,
      minWidth: 30,
      maxWidth: 1 / 0,
      minHeight: 30,
      maxHeight: 1 / 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      roundStepValue: true
    });
  },
  _init: function() {
    this.callBase();
    this.$element().addClass(RESIZABLE_CLASS);
  },
  _initMarkup: function() {
    this.callBase();
    this._renderHandles();
  },
  _render: function() {
    this.callBase();
    this._renderActions();
  },
  _renderActions: function() {
    this._resizeStartAction = this._createActionByOption("onResizeStart");
    this._resizeEndAction = this._createActionByOption("onResizeEnd");
    this._resizeAction = this._createActionByOption("onResize");
  },
  _renderHandles: function() {
    this._handles = [];
    var handles = this.option("handles");
    if (handles === "none") {
      return;
    }
    var directions = handles === "all" ? ["top", "bottom", "left", "right"] : handles.split(" ");
    each(directions, (index2, handleName) => {
      this._renderHandle(handleName);
    });
    inArray("bottom", directions) + 1 && inArray("right", directions) + 1 && this._renderHandle("corner-bottom-right");
    inArray("bottom", directions) + 1 && inArray("left", directions) + 1 && this._renderHandle("corner-bottom-left");
    inArray("top", directions) + 1 && inArray("right", directions) + 1 && this._renderHandle("corner-top-right");
    inArray("top", directions) + 1 && inArray("left", directions) + 1 && this._renderHandle("corner-top-left");
    this._attachEventHandlers();
  },
  _renderHandle: function(handleName) {
    var $handle = $("<div>").addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + "-" + handleName).appendTo(this.$element());
    this._handles.push($handle);
  },
  _attachEventHandlers: function() {
    if (this.option("disabled")) {
      return;
    }
    var handlers = {};
    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
    handlers[DRAGSTART_EVENT_NAME$1] = this._dragHandler.bind(this);
    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
    this._handles.forEach((handleElement) => {
      eventsEngine.on(handleElement, handlers, {
        direction: "both",
        immediate: true
      });
    });
  },
  _detachEventHandlers: function() {
    this._handles.forEach((handleElement) => {
      eventsEngine.off(handleElement);
    });
  },
  _toggleEventHandlers: function(shouldAttachEvents) {
    shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();
  },
  _dragStartHandler: function(e) {
    var $element = this.$element();
    if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    this._toggleResizingClass(true);
    this._movingSides = this._getMovingSides(e);
    this._elementLocation = locate($element);
    var elementRect = getBoundingRect($element.get(0));
    this._elementSize = {
      width: elementRect.width,
      height: elementRect.height
    };
    this._renderDragOffsets(e);
    this._resizeStartAction({
      event: e,
      width: this._elementSize.width,
      height: this._elementSize.height,
      handles: this._movingSides
    });
    e.targetElements = null;
  },
  _toggleResizingClass: function(value2) {
    this.$element().toggleClass(RESIZABLE_RESIZING_CLASS, value2);
  },
  _renderDragOffsets: function(e) {
    var area = this._getArea();
    if (!area) {
      return;
    }
    var $handle = $(e.target).closest("." + RESIZABLE_HANDLE_CLASS);
    var handleWidth = $handle.outerWidth();
    var handleHeight = $handle.outerHeight();
    var handleOffset = $handle.offset();
    var areaOffset = area.offset;
    var scrollOffset = this._getAreaScrollOffset();
    e.maxLeftOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
    e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
    e.maxTopOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
    e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;
  },
  _getBorderWidth: function($element, direction) {
    if (isWindow($element.get(0))) {
      return 0;
    }
    var borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES$1[direction]);
    return parseInt(borderWidth) || 0;
  },
  _dragHandler: function(e) {
    var $element = this.$element();
    var sides = this._movingSides;
    var location = this._elementLocation;
    var size = this._elementSize;
    var offset2 = this._getOffset(e);
    var width = size.width + offset2.x * (sides.left ? -1 : 1);
    var height = size.height + offset2.y * (sides.top ? -1 : 1);
    if (offset2.x || this.option("stepPrecision") === "strict") {
      this._renderWidth(width);
    }
    if (offset2.y || this.option("stepPrecision") === "strict") {
      this._renderHeight(height);
    }
    var elementRect = getBoundingRect($element.get(0));
    var offsetTop = offset2.y - ((elementRect.height || height) - height);
    var offsetLeft = offset2.x - ((elementRect.width || width) - width);
    move($element, {
      top: location.top + (sides.top ? offsetTop : 0),
      left: location.left + (sides.left ? offsetLeft : 0)
    });
    this._resizeAction({
      event: e,
      width: this.option("width") || width,
      height: this.option("height") || height,
      handles: this._movingSides
    });
    triggerResizeEvent($element);
  },
  _getOffset: function(e) {
    var offset2 = e.offset;
    var steps = pairToObject(this.option("step"), !this.option("roundStepValue"));
    var sides = this._getMovingSides(e);
    var strictPrecision = this.option("stepPrecision") === "strict";
    if (!sides.left && !sides.right) {
      offset2.x = 0;
    }
    if (!sides.top && !sides.bottom) {
      offset2.y = 0;
    }
    return strictPrecision ? this._getStrictOffset(offset2, steps, sides) : this._getSimpleOffset(offset2, steps);
  },
  _getSimpleOffset: function(offset2, steps) {
    return {
      x: offset2.x - offset2.x % steps.h,
      y: offset2.y - offset2.y % steps.v
    };
  },
  _getStrictOffset: function(offset2, steps, sides) {
    var location = this._elementLocation;
    var size = this._elementSize;
    var xPos = sides.left ? location.left : location.left + size.width;
    var yPos = sides.top ? location.top : location.top + size.height;
    var newXShift = (xPos + offset2.x) % steps.h;
    var newYShift = (yPos + offset2.y) % steps.v;
    var sign2 = Math.sign || ((x) => {
      x = +x;
      if (x === 0 || isNaN(x)) {
        return x;
      }
      return x > 0 ? 1 : -1;
    });
    var separatorOffset = (steps2, offset3) => (1 + 0.2 * sign2(offset3)) % 1 * steps2;
    var isSmallOffset = (offset3, steps2) => Math.abs(offset3) < 0.2 * steps2;
    var newOffsetX = offset2.x - newXShift;
    var newOffsetY = offset2.y - newYShift;
    if (newXShift > separatorOffset(steps.h, offset2.x)) {
      newOffsetX += steps.h;
    }
    if (newYShift > separatorOffset(steps.v, offset2.y)) {
      newOffsetY += steps.v;
    }
    return {
      x: (sides.left || sides.right) && !isSmallOffset(offset2.x, steps.h) ? newOffsetX : 0,
      y: (sides.top || sides.bottom) && !isSmallOffset(offset2.y, steps.v) ? newOffsetY : 0
    };
  },
  _getMovingSides: function(e) {
    var $target = $(e.target);
    var hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left");
    var hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right");
    var hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left");
    var hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right");
    return {
      top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,
      left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,
      bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,
      right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass
    };
  },
  _getArea: function() {
    var area = this.option("area");
    if (isFunction$1(area)) {
      area = area.call(this);
    }
    if (isPlainObject(area)) {
      return this._getAreaFromObject(area);
    }
    return this._getAreaFromElement(area);
  },
  _getAreaScrollOffset: function() {
    var area = this.option("area");
    var isElement = !isFunction$1(area) && !isPlainObject(area);
    var scrollOffset = {
      scrollY: 0,
      scrollX: 0
    };
    if (isElement) {
      var areaElement = $(area)[0];
      if (isWindow(areaElement)) {
        scrollOffset.scrollX = areaElement.pageXOffset;
        scrollOffset.scrollY = areaElement.pageYOffset;
      }
    }
    return scrollOffset;
  },
  _getAreaFromObject: function(area) {
    var result = {
      width: area.right - area.left,
      height: area.bottom - area.top,
      offset: {
        left: area.left,
        top: area.top
      }
    };
    this._correctAreaGeometry(result);
    return result;
  },
  _getAreaFromElement: function(area) {
    var $area = $(area);
    var result;
    if ($area.length) {
      result = {
        width: $area.innerWidth(),
        height: $area.innerHeight(),
        offset: extend({
          top: 0,
          left: 0
        }, isWindow($area[0]) ? {} : $area.offset())
      };
      this._correctAreaGeometry(result, $area);
    }
    return result;
  },
  _correctAreaGeometry: function(result, $area) {
    var areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
    var areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
    result.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
    result.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
    result.width -= this.$element().outerWidth() - this.$element().innerWidth();
    result.height -= this.$element().outerHeight() - this.$element().innerHeight();
  },
  _dragEndHandler: function(e) {
    var $element = this.$element();
    this._resizeEndAction({
      event: e,
      width: $element.outerWidth(),
      height: $element.outerHeight(),
      handles: this._movingSides
    });
    this._toggleResizingClass(false);
  },
  _renderWidth: function(width) {
    this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")));
  },
  _renderHeight: function(height) {
    this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")));
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "disabled":
        this._toggleEventHandlers(!args.value);
        this.callBase(args);
        break;
      case "handles":
        this._invalidate();
        break;
      case "minWidth":
      case "maxWidth":
        hasWindow$1() && this._renderWidth(this.$element().outerWidth());
        break;
      case "minHeight":
      case "maxHeight":
        hasWindow$1() && this._renderHeight(this.$element().outerHeight());
        break;
      case "onResize":
      case "onResizeStart":
      case "onResizeEnd":
        this._renderActions();
        break;
      case "area":
      case "stepPrecision":
      case "step":
      case "roundStepValue":
        break;
      default:
        this.callBase(args);
    }
  },
  _clean: function() {
    this.$element().find("." + RESIZABLE_HANDLE_CLASS).remove();
  },
  _useTemplates: function() {
    return false;
  }
});
registerComponent(RESIZABLE, Resizable);
var SWATCH_CONTAINER_CLASS_PREFIX = "dx-swatch-";
var getSwatchContainer$1 = (element) => {
  var $element = $(element);
  var swatchContainer2 = $element.closest('[class^="'.concat(SWATCH_CONTAINER_CLASS_PREFIX, '"], [class*=" ').concat(SWATCH_CONTAINER_CLASS_PREFIX, '"]'));
  var viewport = value();
  if (!swatchContainer2.length) {
    return viewport;
  }
  var swatchClassRegex = new RegExp("(\\s|^)(".concat(SWATCH_CONTAINER_CLASS_PREFIX, ".*?)(\\s|$)"));
  var swatchClass = swatchContainer2[0].className.match(swatchClassRegex)[2];
  var viewportSwatchContainer = viewport.children("." + swatchClass);
  if (!viewportSwatchContainer.length) {
    viewportSwatchContainer = $("<div>").addClass(swatchClass).appendTo(viewport);
  }
  return viewportSwatchContainer;
};
var swatchContainer = {
  getSwatchContainer: getSwatchContainer$1
};
var baseZIndex = 1500;
var zIndexStack = [];
var base = (ZIndex) => {
  baseZIndex = ensureDefined(ZIndex, baseZIndex);
  return baseZIndex;
};
var create = function() {
  var baseIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : baseZIndex;
  var length = zIndexStack.length;
  var index2 = (length ? zIndexStack[length - 1] : baseIndex) + 1;
  zIndexStack.push(index2);
  return index2;
};
var remove$1 = (zIndex) => {
  var position2 = zIndexStack.indexOf(zIndex);
  if (position2 >= 0) {
    zIndexStack.splice(position2, 1);
  }
};
var ready$1 = readyCallback.add;
var window$c = getWindow();
var viewPortChanged = changeCallback;
var OVERLAY_CLASS = "dx-overlay";
var OVERLAY_WRAPPER_CLASS$1 = "dx-overlay-wrapper";
var OVERLAY_CONTENT_CLASS$1 = "dx-overlay-content";
var OVERLAY_SHADER_CLASS = "dx-overlay-shader";
var OVERLAY_MODAL_CLASS = "dx-overlay-modal";
var INNER_OVERLAY_CLASS = "dx-inner-overlay";
var INVISIBLE_STATE_CLASS$2 = "dx-state-invisible";
var ANONYMOUS_TEMPLATE_NAME$3 = "content";
var RTL_DIRECTION_CLASS = "dx-rtl";
var ACTIONS$1 = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioned", "onResizeStart", "onResize", "onResizeEnd"];
var OVERLAY_STACK = [];
var DISABLED_STATE_CLASS$3 = "dx-state-disabled";
var PREVENT_SAFARI_SCROLLING_CLASS = "dx-prevent-safari-scrolling";
var TAB_KEY = "tab";
var POSITION_ALIASES$1 = {
  top: {
    my: "top center",
    at: "top center"
  },
  bottom: {
    my: "bottom center",
    at: "bottom center"
  },
  right: {
    my: "right center",
    at: "right center"
  },
  left: {
    my: "left center",
    at: "left center"
  },
  center: {
    my: "center",
    at: "center"
  },
  "right bottom": {
    my: "right bottom",
    at: "right bottom"
  },
  "right top": {
    my: "right top",
    at: "right top"
  },
  "left bottom": {
    my: "left bottom",
    at: "left bottom"
  },
  "left top": {
    my: "left top",
    at: "left top"
  }
};
var realDevice$1 = devices.real();
var firefoxDesktop = coreBrowserUtils.mozilla && realDevice$1.deviceType === "desktop";
var iOS = realDevice$1.platform === "ios";
var hasSafariAddressBar = coreBrowserUtils.safari && realDevice$1.deviceType !== "desktop";
var forceRepaint = ($element) => {
  if (firefoxDesktop) {
    $element.width();
  }
};
var getElement = (value2) => {
  if (isEvent(value2)) {
    value2 = value2.target;
  }
  return $(value2);
};
ready$1(() => {
  eventsEngine.subscribeGlobal(domAdapter.getDocument(), pointer.down, (e) => {
    for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
        return;
      }
    }
  });
});
var Overlay = Widget.inherit({
  _supportedKeys: function() {
    var move2 = function(top, left, e) {
      if (!this.option("dragEnabled")) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      var allowedOffsets = this._allowedOffsets();
      var offset2 = {
        top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
        left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
      };
      this._changePosition(offset2);
    };
    return extend(this.callBase(), {
      escape: function() {
        this.hide();
      },
      upArrow: move2.bind(this, -5, 0),
      downArrow: move2.bind(this, 5, 0),
      leftArrow: move2.bind(this, 0, -5),
      rightArrow: move2.bind(this, 0, 5)
    });
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      activeStateEnabled: false,
      visible: false,
      deferRendering: true,
      shading: true,
      shadingColor: "",
      position: {
        my: "center",
        at: "center"
      },
      width: function() {
        return 0.8 * $(window$c).width();
      },
      minWidth: null,
      maxWidth: null,
      height: function() {
        return 0.8 * $(window$c).height();
      },
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: "pop",
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: "pop",
          duration: 300,
          to: {
            opacity: 0,
            scale: 0.55
          },
          from: {
            opacity: 1,
            scale: 1
          }
        }
      },
      closeOnOutsideClick: false,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: "content",
      dragEnabled: false,
      resizeEnabled: false,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      innerOverlay: false,
      target: void 0,
      container: void 0,
      hideTopOverlayHandler: () => {
        this.hide();
      },
      closeOnTargetScroll: false,
      onPositioned: null,
      boundaryOffset: {
        h: 0,
        v: 0
      },
      propagateOutsideClick: false,
      ignoreChildEvents: true,
      _checkParentVisibility: true,
      _fixedPosition: false
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function() {
        return !hasWindow$1();
      },
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: false
      }
    }]);
  },
  _setOptionsByReference: function() {
    this.callBase();
    extend(this._optionsByReference, {
      animation: true
    });
  },
  $wrapper: function() {
    return this._$wrapper;
  },
  _eventBindingTarget: function() {
    return this._$content;
  },
  _init: function() {
    this.callBase();
    this._initActions();
    this._initCloseOnOutsideClickHandler();
    this._initTabTerminatorHandler();
    this._$wrapper = $("<div>").addClass(OVERLAY_WRAPPER_CLASS$1);
    this._$content = $("<div>").addClass(OVERLAY_CONTENT_CLASS$1);
    this._initInnerOverlayClass();
    var $element = this.$element();
    this._$wrapper.addClass($element.attr("class"));
    $element.addClass(OVERLAY_CLASS);
    this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
    eventsEngine.on(this._$wrapper, "MSPointerDown", noop);
    eventsEngine.on(this._$wrapper, "focusin", (e) => {
      e.stopPropagation();
    });
    this._toggleViewPortSubscription(true);
    this._initHideTopOverlayHandler(this.option("hideTopOverlayHandler"));
  },
  _initOptions: function(options) {
    this._initTarget(options.target);
    var container = options.container === void 0 ? this.option("container") : options.container;
    this._initContainer(container);
    this.callBase(options);
  },
  _initInnerOverlayClass: function() {
    this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option("innerOverlay"));
  },
  _initTarget: function(target) {
    if (!isDefined(target)) {
      return;
    }
    var options = this.option();
    each(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], (_2, path) => {
      var pathParts = path.split(".");
      var option = options;
      while (option) {
        if (pathParts.length === 1) {
          if (isPlainObject(option)) {
            option[pathParts.shift()] = target;
          }
          break;
        } else {
          option = option[pathParts.shift()];
        }
      }
    });
  },
  _initContainer: function(container) {
    container = container === void 0 ? value() : container;
    var $element = this.$element();
    var $container = $element.closest(container);
    if (!$container.length) {
      $container = $(container).first();
    }
    this._$container = $container.length ? $container : $element.parent();
  },
  _initHideTopOverlayHandler: function(handler) {
    this._hideTopOverlayHandler = handler;
  },
  _initActions: function() {
    this._actions = {};
    each(ACTIONS$1, (_2, action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ["disabled", "readOnly"]
      }) || noop;
    });
  },
  _initCloseOnOutsideClickHandler: function() {
    var that = this;
    this._proxiedDocumentDownHandler = function() {
      return that._documentDownHandler(...arguments);
    };
  },
  _documentDownHandler: function(e) {
    if (this._showAnimationProcessing) {
      this._stopAnimation();
    }
    var closeOnOutsideClick = this.option("closeOnOutsideClick");
    if (isFunction$1(closeOnOutsideClick)) {
      closeOnOutsideClick = closeOnOutsideClick(e);
    }
    var $container = this._$content;
    var isAttachedTarget = $(window$c.document).is(e.target) || contains(window$c.document, e.target);
    var isInnerOverlay = $(e.target).closest("." + INNER_OVERLAY_CLASS).length;
    var outsideClick = isAttachedTarget && !isInnerOverlay && !($container.is(e.target) || contains($container.get(0), e.target));
    if (outsideClick && closeOnOutsideClick) {
      this._outsideClickHandler(e);
    }
    return this.option("propagateOutsideClick");
  },
  _outsideClickHandler(e) {
    if (this.option("shading")) {
      e.preventDefault();
    }
    this.hide();
  },
  _getAnonymousTemplateName: function() {
    return ANONYMOUS_TEMPLATE_NAME$3;
  },
  _initTemplates: function() {
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    this.callBase();
  },
  _isTopOverlay: function() {
    var overlayStack = this._overlayStack();
    for (var i = overlayStack.length - 1; i >= 0; i--) {
      var tabbableElements = overlayStack[i]._findTabbableBounds();
      if (tabbableElements.first || tabbableElements.last) {
        return overlayStack[i] === this;
      }
    }
    return false;
  },
  _overlayStack: function() {
    return OVERLAY_STACK;
  },
  _zIndexInitValue: function() {
    return Overlay.baseZIndex();
  },
  _toggleViewPortSubscription: function(toggle) {
    viewPortChanged.remove(this._viewPortChangeHandle);
    if (toggle) {
      this._viewPortChangeHandle = this._viewPortChangeHandler.bind(this);
      viewPortChanged.add(this._viewPortChangeHandle);
    }
  },
  _viewPortChangeHandler: function() {
    this._initContainer(this.option("container"));
    this._refresh();
  },
  _renderVisibilityAnimate: function(visible2) {
    this._stopAnimation();
    return visible2 ? this._show() : this._hide();
  },
  _normalizePosition: function() {
    var position2 = this.option("position");
    this._position = typeof position2 === "function" ? position2() : position2;
  },
  _getAnimationConfig: function() {
    var animation2 = this.option("animation");
    if (isFunction$1(animation2)) {
      animation2 = animation2.call(this);
    }
    return animation2;
  },
  _show: function() {
    var that = this;
    var deferred = new Deferred();
    this._parentHidden = this._isParentHidden();
    deferred.done(() => {
      delete that._parentHidden;
    });
    if (this._parentHidden) {
      this._isHidden = true;
      return deferred.resolve();
    }
    if (this._currentVisible) {
      return new Deferred().resolve().promise();
    }
    this._currentVisible = true;
    this._isShown = false;
    this._normalizePosition();
    var animation2 = that._getAnimationConfig() || {};
    var showAnimation = this._normalizeAnimation(animation2.show, "to");
    var startShowAnimation = showAnimation && showAnimation.start || noop;
    var completeShowAnimation = showAnimation && showAnimation.complete || noop;
    if (this._isHidingActionCanceled) {
      delete this._isHidingActionCanceled;
      deferred.resolve();
    } else {
      var show = () => {
        this._renderVisibility(true);
        if (this._isShowingActionCanceled) {
          delete this._isShowingActionCanceled;
          deferred.resolve();
          return;
        }
        this._animate(showAnimation, function() {
          if (that.option("focusStateEnabled")) {
            eventsEngine.trigger(that._focusTarget(), "focus");
          }
          completeShowAnimation.apply(this, arguments);
          that._showAnimationProcessing = false;
          that._isShown = true;
          that._actions.onShown();
          that._toggleSafariScrolling(false);
          deferred.resolve();
        }, function() {
          startShowAnimation.apply(this, arguments);
          that._showAnimationProcessing = true;
        });
      };
      if (this.option("templatesRenderAsynchronously")) {
        this._stopShowTimer();
        this._asyncShowTimeout = setTimeout(show);
      } else {
        show();
      }
    }
    return deferred.promise();
  },
  _normalizeAnimation: function(animation2, prop) {
    if (animation2) {
      animation2 = extend({
        type: "slide"
      }, animation2);
      if (animation2[prop] && typeof animation2[prop] === "object") {
        extend(animation2[prop], {
          position: this._position
        });
      }
    }
    return animation2;
  },
  _hide: function() {
    if (!this._currentVisible) {
      return new Deferred().resolve().promise();
    }
    this._currentVisible = false;
    var that = this;
    var deferred = new Deferred();
    var animation2 = that._getAnimationConfig() || {};
    var hideAnimation = this._normalizeAnimation(animation2.hide, "from");
    var startHideAnimation = hideAnimation && hideAnimation.start || noop;
    var completeHideAnimation = hideAnimation && hideAnimation.complete || noop;
    var hidingArgs = {
      cancel: false
    };
    if (this._isShowingActionCanceled) {
      deferred.resolve();
    } else {
      this._actions.onHiding(hidingArgs);
      that._toggleSafariScrolling(true);
      if (hidingArgs.cancel) {
        this._isHidingActionCanceled = true;
        this.option("visible", true);
        deferred.resolve();
      } else {
        this._forceFocusLost();
        this._toggleShading(false);
        this._toggleSubscriptions(false);
        this._stopShowTimer();
        this._animate(hideAnimation, function() {
          var _that$_actions;
          that._$content.css("pointerEvents", "");
          that._renderVisibility(false);
          completeHideAnimation.apply(this, arguments);
          that._hideAnimationProcessing = false;
          (_that$_actions = that._actions) === null || _that$_actions === void 0 ? void 0 : _that$_actions.onHidden();
          deferred.resolve();
        }, function() {
          that._$content.css("pointerEvents", "none");
          startHideAnimation.apply(this, arguments);
          that._hideAnimationProcessing = true;
        });
      }
    }
    return deferred.promise();
  },
  _forceFocusLost: function() {
    var activeElement = domAdapter.getActiveElement();
    var shouldResetActiveElement = !!this._$content.find(activeElement).length;
    if (shouldResetActiveElement) {
      resetActiveElement();
    }
  },
  _animate: function(animation2, completeCallback, startCallback) {
    if (animation2) {
      startCallback = startCallback || animation2.start || noop;
      fx.animate(this._$content, extend({}, animation2, {
        start: startCallback,
        complete: completeCallback
      }));
    } else {
      completeCallback();
    }
  },
  _stopAnimation: function() {
    fx.stop(this._$content, true);
  },
  _renderVisibility: function(visible2) {
    if (visible2 && this._isParentHidden()) {
      return;
    }
    this._currentVisible = visible2;
    this._stopAnimation();
    if (!visible2) {
      triggerHidingEvent(this._$content);
    }
    this._toggleVisibility(visible2);
    this._$content.toggleClass(INVISIBLE_STATE_CLASS$2, !visible2);
    this._updateZIndexStackPosition(visible2);
    if (visible2) {
      this._renderContent();
      var showingArgs = {
        cancel: false
      };
      this._actions.onShowing(showingArgs);
      if (showingArgs.cancel) {
        this._toggleVisibility(false);
        this._$content.toggleClass(INVISIBLE_STATE_CLASS$2, true);
        this._updateZIndexStackPosition(false);
        this._moveFromContainer();
        this._isShowingActionCanceled = true;
        this.option("visible", false);
        return;
      }
      this._moveToContainer();
      this._renderGeometry();
      triggerShownEvent(this._$content);
      triggerResizeEvent(this._$content);
    } else {
      this._moveFromContainer();
    }
    this._toggleShading(visible2);
    this._toggleSubscriptions(visible2);
  },
  _updateZIndexStackPosition: function(pushToStack) {
    var overlayStack = this._overlayStack();
    var index2 = inArray(this, overlayStack);
    if (pushToStack) {
      if (index2 === -1) {
        this._zIndex = create(this._zIndexInitValue());
        overlayStack.push(this);
      }
      this._$wrapper.css("zIndex", this._zIndex);
      this._$content.css("zIndex", this._zIndex);
    } else if (index2 !== -1) {
      overlayStack.splice(index2, 1);
      remove$1(this._zIndex);
    }
  },
  _toggleShading: function(visible2) {
    this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
    this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible2 && this.option("shading"));
    this._$wrapper.css("backgroundColor", this.option("shading") ? this.option("shadingColor") : "");
    this._toggleTabTerminator(visible2 && this.option("shading"));
  },
  _initTabTerminatorHandler: function() {
    var that = this;
    this._proxiedTabTerminatorHandler = function() {
      that._tabKeyHandler(...arguments);
    };
  },
  _toggleTabTerminator: function(enabled) {
    var eventName = addNamespace$1("keydown", this.NAME);
    if (enabled) {
      eventsEngine.on(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    } else {
      eventsEngine.off(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    }
  },
  _findTabbableBounds: function() {
    var $elements = this._$wrapper.find("*");
    var elementsCount = $elements.length - 1;
    var result = {
      first: null,
      last: null
    };
    for (var i = 0; i <= elementsCount; i++) {
      if (!result.first && $elements.eq(i).is(tabbable)) {
        result.first = $elements.eq(i);
      }
      if (!result.last && $elements.eq(elementsCount - i).is(tabbable)) {
        result.last = $elements.eq(elementsCount - i);
      }
      if (result.first && result.last) {
        break;
      }
    }
    return result;
  },
  _tabKeyHandler: function(e) {
    if (normalizeKeyName(e) !== TAB_KEY || !this._isTopOverlay()) {
      return;
    }
    var tabbableElements = this._findTabbableBounds();
    var $firstTabbable = tabbableElements.first;
    var $lastTabbable = tabbableElements.last;
    var isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
    var isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
    var isEmptyTabList = tabbableElements.length === 0;
    var isOutsideTarget = !contains(this._$wrapper.get(0), e.target);
    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
      e.preventDefault();
      var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
      eventsEngine.trigger($focusElement, "focusin");
      eventsEngine.trigger($focusElement, "focus");
    }
  },
  _toggleSubscriptions: function(enabled) {
    if (hasWindow$1()) {
      this._toggleHideTopOverlayCallback(enabled);
      this._toggleParentsScrollSubscription(enabled);
    }
  },
  _toggleHideTopOverlayCallback: function(subscribe) {
    if (!this._hideTopOverlayHandler) {
      return;
    }
    if (subscribe) {
      hideCallback.add(this._hideTopOverlayHandler);
    } else {
      hideCallback.remove(this._hideTopOverlayHandler);
    }
  },
  _toggleParentsScrollSubscription: function(subscribe) {
    if (!this._position) {
      return;
    }
    var target = this._position.of || $();
    var closeOnScroll = this.option("closeOnTargetScroll");
    var $parents = getElement(target).parents();
    var scrollEvent = addNamespace$1("scroll", this.NAME);
    if (devices.real().deviceType === "desktop") {
      $parents = $parents.add(window$c);
    }
    this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || ((e) => {
      this._targetParentsScrollHandler(e);
    });
    eventsEngine.off($().add(this._$prevTargetParents), scrollEvent, this._proxiedTargetParentsScrollHandler);
    if (subscribe && closeOnScroll) {
      eventsEngine.on($parents, scrollEvent, this._proxiedTargetParentsScrollHandler);
      this._$prevTargetParents = $parents;
    }
  },
  _targetParentsScrollHandler: function(e) {
    var closeHandled = false;
    var closeOnScroll = this.option("closeOnTargetScroll");
    if (isFunction$1(closeOnScroll)) {
      closeHandled = closeOnScroll(e);
    }
    if (!closeHandled && !this._showAnimationProcessing) {
      this.hide();
    }
  },
  _render: function() {
    this.callBase();
    this._appendContentToElement();
    this._renderVisibilityAnimate(this.option("visible"));
  },
  _appendContentToElement: function() {
    if (!this._$content.parent().is(this.$element())) {
      this._$content.appendTo(this.$element());
    }
  },
  _renderContent: function() {
    var shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
    var isParentHidden = this.option("visible") && this._isParentHidden();
    if (isParentHidden) {
      this._isHidden = true;
      return;
    }
    if (this._contentAlreadyRendered || shouldDeferRendering) {
      return;
    }
    this._contentAlreadyRendered = true;
    this._appendContentToElement();
    this.callBase();
  },
  _isParentHidden: function() {
    if (!this.option("_checkParentVisibility")) {
      return false;
    }
    if (this._parentHidden !== void 0) {
      return this._parentHidden;
    }
    var $parent = this.$element().parent();
    if ($parent.is(":visible")) {
      return false;
    }
    var isHidden = false;
    $parent.add($parent.parents()).each(function() {
      var $element = $(this);
      if ($element.css("display") === "none") {
        isHidden = true;
        return false;
      }
    });
    return isHidden || !domAdapter.getBody().contains($parent.get(0));
  },
  _renderContentImpl: function() {
    var whenContentRendered = new Deferred();
    var contentTemplateOption = this.option("contentTemplate");
    var contentTemplate = this._getTemplate(contentTemplateOption);
    var transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
    contentTemplate && contentTemplate.render({
      container: getPublicElement(this.$content()),
      noModel: true,
      transclude,
      onRendered: () => {
        whenContentRendered.resolve();
      }
    });
    this._renderDrag();
    this._renderResize();
    this._renderScrollTerminator();
    whenContentRendered.done(() => {
      if (this.option("visible")) {
        this._moveToContainer();
      }
    });
    return whenContentRendered.promise();
  },
  _renderDrag: function() {
    var $dragTarget = this._getDragTarget();
    if (!$dragTarget) {
      return;
    }
    var startEventName = addNamespace$1(DRAG_START_EVENT, this.NAME);
    var updateEventName = addNamespace$1(DRAG_EVENT, this.NAME);
    eventsEngine.off($dragTarget, startEventName);
    eventsEngine.off($dragTarget, updateEventName);
    if (!this.option("dragEnabled")) {
      return;
    }
    eventsEngine.on($dragTarget, startEventName, this._dragStartHandler.bind(this));
    eventsEngine.on($dragTarget, updateEventName, this._dragUpdateHandler.bind(this));
  },
  _renderResize: function() {
    this._resizable = this._createComponent(this._$content, Resizable, {
      handles: this.option("resizeEnabled") ? "all" : "none",
      onResizeEnd: this._resizeEndHandler.bind(this),
      onResize: this._actions.onResize.bind(this),
      onResizeStart: this._actions.onResizeStart.bind(this),
      minHeight: 100,
      minWidth: 100,
      area: this._getDragResizeContainer()
    });
  },
  _resizeEndHandler: function() {
    this._positionChangeHandled = true;
    var width = this._resizable.option("width");
    var height = this._resizable.option("height");
    width && this.option("width", width);
    height && this.option("height", height);
    this._actions.onResizeEnd();
  },
  _renderScrollTerminator: function() {
    var $scrollTerminator = this._$wrapper;
    var terminatorEventName = addNamespace$1(DRAG_EVENT, this.NAME);
    eventsEngine.off($scrollTerminator, terminatorEventName);
    eventsEngine.on($scrollTerminator, terminatorEventName, {
      validate: function() {
        return true;
      },
      getDirection: function() {
        return "both";
      },
      _toggleGestureCover: function(toggle) {
        if (!toggle) {
          this._toggleGestureCoverImpl(toggle);
        }
      },
      _clearSelection: noop,
      isNative: true
    }, (e) => {
      var originalEvent = e.originalEvent.originalEvent;
      var {
        type: type2
      } = originalEvent || {};
      var isWheel = type2 === "wheel";
      var isMouseMove = type2 === "mousemove";
      var isScrollByWheel = isWheel && !isCommandKeyPressed(e);
      e._cancelPreventDefault = true;
      if (originalEvent && e.cancelable !== false && (!isMouseMove && !isWheel || isScrollByWheel)) {
        e.preventDefault();
      }
    });
  },
  _getDragTarget: function() {
    return this.$content();
  },
  _dragStartHandler: function(e) {
    e.targetElements = [];
    this._prevOffset = {
      x: 0,
      y: 0
    };
    var allowedOffsets = this._allowedOffsets();
    e.maxTopOffset = allowedOffsets.top;
    e.maxBottomOffset = allowedOffsets.bottom;
    e.maxLeftOffset = allowedOffsets.left;
    e.maxRightOffset = allowedOffsets.right;
  },
  _getDragResizeContainer: function() {
    var isContainerDefined = originalViewPort().get(0) || this.option("container");
    var $container = !isContainerDefined ? $(window$c) : this._$container;
    return $container;
  },
  _deltaSize: function() {
    var $content = this._$content;
    var $container = this._getDragResizeContainer();
    var contentWidth = $content.outerWidth();
    var contentHeight = $content.outerHeight();
    var containerWidth = $container.outerWidth();
    var containerHeight = $container.outerHeight();
    if (this._isWindow($container)) {
      var document2 = domAdapter.getDocument();
      var fullPageHeight = Math.max($(document2).outerHeight(), containerHeight);
      var fullPageWidth = Math.max($(document2).outerWidth(), containerWidth);
      containerHeight = fullPageHeight;
      containerWidth = fullPageWidth;
    }
    return {
      width: containerWidth - contentWidth,
      height: containerHeight - contentHeight
    };
  },
  _dragUpdateHandler: function(e) {
    var offset2 = e.offset;
    var prevOffset = this._prevOffset;
    var targetOffset = {
      top: offset2.y - prevOffset.y,
      left: offset2.x - prevOffset.x
    };
    this._changePosition(targetOffset);
    this._prevOffset = offset2;
  },
  _changePosition: function(offset2) {
    var position2 = locate(this._$content);
    move(this._$content, {
      left: position2.left + offset2.left,
      top: position2.top + offset2.top
    });
    this._positionChangeHandled = true;
  },
  _allowedOffsets: function() {
    var position2 = locate(this._$content);
    var deltaSize = this._deltaSize();
    var isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0;
    var shaderOffset = this.option("shading") && !this.option("container") && !this._isWindow(this._getContainer()) ? locate(this._$wrapper) : {
      top: 0,
      left: 0
    };
    var boundaryOffset = this.option("boundaryOffset");
    return {
      top: isAllowedDrag ? position2.top + shaderOffset.top + boundaryOffset.v : 0,
      bottom: isAllowedDrag ? -position2.top - shaderOffset.top + deltaSize.height - boundaryOffset.v : 0,
      left: isAllowedDrag ? position2.left + shaderOffset.left + boundaryOffset.h : 0,
      right: isAllowedDrag ? -position2.left - shaderOffset.left + deltaSize.width - boundaryOffset.h : 0
    };
  },
  _moveFromContainer: function() {
    this._$content.appendTo(this.$element());
    this._detachWrapperToContainer();
  },
  _detachWrapperToContainer: function() {
    this._$wrapper.detach();
  },
  _moveToContainer: function() {
    this._attachWrapperToContainer();
    this._$content.appendTo(this._$wrapper);
  },
  _attachWrapperToContainer: function() {
    var $element = this.$element();
    var containerDefined = this.option("container") !== void 0;
    var renderContainer = containerDefined ? this._$container : swatchContainer.getSwatchContainer($element);
    if (renderContainer && renderContainer[0] === $element.parent()[0]) {
      renderContainer = $element;
    }
    this._$wrapper.appendTo(renderContainer);
  },
  _fixHeightAfterSafariAddressBarResizing: function() {
    if (this._isWindow(this._getContainer()) && hasSafariAddressBar) {
      this._$wrapper.css("minHeight", window$c.innerHeight);
    }
  },
  _renderGeometry: function(isDimensionChanged) {
    if (this.option("visible") && hasWindow$1()) {
      this._renderGeometryImpl(isDimensionChanged);
    }
  },
  _renderGeometryImpl: function(isDimensionChanged) {
    this._stopAnimation();
    this._normalizePosition();
    this._renderWrapper();
    this._fixHeightAfterSafariAddressBarResizing();
    this._renderDimensions();
    var resultPosition = this._renderPosition();
    this._actions.onPositioned({
      position: resultPosition
    });
  },
  _fixWrapperPosition: function() {
    this._$wrapper.css("position", this._useFixedPosition() ? "fixed" : "absolute");
  },
  _useFixedPosition: function() {
    return this._shouldFixBodyPosition() || this.option("_fixedPosition");
  },
  _shouldFixBodyPosition: function() {
    var $container = this._getContainer();
    return this._isWindow($container) && (!iOS || this._bodyScrollTop !== void 0);
  },
  _toggleSafariScrolling: function(scrollingEnabled) {
    if (iOS && this._shouldFixBodyPosition()) {
      var body = domAdapter.getBody();
      if (scrollingEnabled) {
        $(body).removeClass(PREVENT_SAFARI_SCROLLING_CLASS);
        window$c.scrollTo(0, this._bodyScrollTop);
        this._bodyScrollTop = void 0;
      } else if (this.option("visible")) {
        this._bodyScrollTop = window$c.pageYOffset;
        $(body).addClass(PREVENT_SAFARI_SCROLLING_CLASS);
      }
    }
  },
  _renderWrapper: function() {
    this._fixWrapperPosition();
    this._renderWrapperDimensions();
    this._renderWrapperPosition();
  },
  _renderWrapperDimensions: function() {
    var wrapperWidth;
    var wrapperHeight;
    var $container = this._getContainer();
    if (!$container) {
      return;
    }
    var isWindow2 = this._isWindow($container);
    wrapperWidth = isWindow2 ? "" : $container.outerWidth(), wrapperHeight = isWindow2 ? "" : $container.outerHeight();
    this._$wrapper.css({
      width: wrapperWidth,
      height: wrapperHeight
    });
  },
  _isWindow: function($element) {
    return !!$element && isWindow($element.get(0));
  },
  _renderWrapperPosition: function() {
    var $container = this._getContainer();
    if ($container) {
      animationPosition.setup(this._$wrapper, {
        my: "top left",
        at: "top left",
        of: $container
      });
    }
  },
  _getContainer: function() {
    var position2 = this._position;
    var container = this.option("container");
    var positionOf = null;
    if (!container && position2) {
      positionOf = isEvent(position2.of) ? window$c : position2.of || window$c;
    }
    return getElement(container || positionOf);
  },
  _renderDimensions: function() {
    var content = this._$content.get(0);
    this._$content.css({
      minWidth: this._getOptionValue("minWidth", content),
      maxWidth: this._getOptionValue("maxWidth", content),
      minHeight: this._getOptionValue("minHeight", content),
      maxHeight: this._getOptionValue("maxHeight", content),
      width: this._getOptionValue("width", content),
      height: this._getOptionValue("height", content)
    });
  },
  _renderPosition: function() {
    if (this._positionChangeHandled) {
      var allowedOffsets = this._allowedOffsets();
      this._changePosition({
        top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),
        left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)
      });
    } else {
      this._renderOverlayBoundaryOffset();
      resetPosition(this._$content);
      var position2 = this._transformStringPosition(this._position, POSITION_ALIASES$1);
      var resultPosition = animationPosition.setup(this._$content, position2);
      forceRepaint(this._$content);
      return resultPosition;
    }
  },
  _transformStringPosition: function(position2, positionAliases2) {
    if (isString$1(position2)) {
      position2 = extend({}, positionAliases2[position2]);
    }
    return position2;
  },
  _renderOverlayBoundaryOffset: function() {
    var boundaryOffset = this.option("boundaryOffset");
    this._$content.css("margin", boundaryOffset.v + "px " + boundaryOffset.h + "px");
  },
  _focusTarget: function() {
    return this._$content;
  },
  _attachKeyboardEvents: function() {
    this._keyboardListenerId = keyboard.on(this._$content, null, (opts) => this._keyboardHandler(opts));
  },
  _keyboardHandler: function(options) {
    var e = options.originalEvent;
    var $target = $(e.target);
    if ($target.is(this._$content) || !this.option("ignoreChildEvents")) {
      this.callBase(...arguments);
    }
  },
  _isVisible: function() {
    return this.option("visible");
  },
  _visibilityChanged: function(visible2) {
    if (visible2) {
      if (this.option("visible")) {
        this._renderVisibilityAnimate(visible2);
      }
    } else {
      this._renderVisibilityAnimate(visible2);
    }
  },
  _dimensionChanged: function() {
    this._renderGeometry(true);
  },
  _clean: function() {
    if (!this._contentAlreadyRendered) {
      this.$content().empty();
    }
    this._renderVisibility(false);
    this._stopShowTimer();
    this._cleanFocusState();
  },
  _stopShowTimer() {
    if (this._asyncShowTimeout) {
      clearTimeout(this._asyncShowTimeout);
    }
    this._asyncShowTimeout = null;
  },
  _dispose: function() {
    fx.stop(this._$content, false);
    clearTimeout(this._deferShowTimer);
    this._toggleViewPortSubscription(false);
    this._toggleSubscriptions(false);
    this._updateZIndexStackPosition(false);
    this._toggleTabTerminator(false);
    this._toggleSafariScrolling(true);
    this._actions = null;
    this.callBase();
    remove$1(this._zIndex);
    this._$wrapper.remove();
    this._$content.remove();
  },
  _toggleDisabledState: function(value2) {
    this.callBase(...arguments);
    this._$content.toggleClass(DISABLED_STATE_CLASS$3, Boolean(value2));
  },
  _toggleRTLDirection: function(rtl) {
    this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl);
  },
  _optionChanged: function(args) {
    var value2 = args.value;
    if (inArray(args.name, ACTIONS$1) > -1) {
      this._initActions();
      return;
    }
    switch (args.name) {
      case "dragEnabled":
        this._renderDrag();
        this._renderGeometry();
        break;
      case "resizeEnabled":
        this._renderResize();
        this._renderGeometry();
        break;
      case "shading":
      case "shadingColor":
        this._toggleShading(this.option("visible"));
        break;
      case "width":
      case "height":
      case "minWidth":
      case "maxWidth":
      case "minHeight":
      case "maxHeight":
      case "boundaryOffset":
        this._renderGeometry();
        break;
      case "position":
        this._positionChangeHandled = false;
        this._renderGeometry();
        break;
      case "visible":
        this._renderVisibilityAnimate(value2).done(() => {
          if (!this._animateDeferred) {
            return;
          }
          this._animateDeferred.resolveWith(this);
        });
        break;
      case "target":
        this._initTarget(value2);
        this._invalidate();
        break;
      case "container":
        this._initContainer(value2);
        this._invalidate();
        break;
      case "innerOverlay":
        this._initInnerOverlayClass();
        break;
      case "deferRendering":
      case "contentTemplate":
        this._contentAlreadyRendered = false;
        this._clean();
        this._invalidate();
        break;
      case "hideTopOverlayHandler":
        this._toggleHideTopOverlayCallback(false);
        this._initHideTopOverlayHandler(args.value);
        this._toggleHideTopOverlayCallback(this.option("visible"));
        break;
      case "closeOnTargetScroll":
        this._toggleParentsScrollSubscription(this.option("visible"));
        break;
      case "closeOnOutsideClick":
      case "animation":
      case "propagateOutsideClick":
        break;
      case "rtlEnabled":
        this._contentAlreadyRendered = false;
        this.callBase(args);
        break;
      case "_fixedPosition":
        this._fixWrapperPosition();
        break;
      default:
        this.callBase(args);
    }
  },
  toggle: function(showing) {
    showing = showing === void 0 ? !this.option("visible") : showing;
    var result = new Deferred();
    if (showing === this.option("visible")) {
      return result.resolveWith(this, [showing]).promise();
    }
    var animateDeferred = new Deferred();
    this._animateDeferred = animateDeferred;
    this.option("visible", showing);
    animateDeferred.promise().done(() => {
      delete this._animateDeferred;
      result.resolveWith(this, [this.option("visible")]);
    });
    return result.promise();
  },
  $content: function() {
    return this._$content;
  },
  show: function() {
    return this.toggle(true);
  },
  hide: function() {
    return this.toggle(false);
  },
  content: function() {
    return getPublicElement(this._$content);
  },
  repaint: function() {
    if (this._contentAlreadyRendered) {
      this._renderGeometry();
      triggerResizeEvent(this._$content);
    } else {
      this.callBase();
    }
  }
});
Overlay.baseZIndex = (zIndex) => base(zIndex);
registerComponent("dxOverlay", Overlay);
var LOADPANEL_CLASS = "dx-loadpanel";
var LOADPANEL_WRAPPER_CLASS = "dx-loadpanel-wrapper";
var LOADPANEL_INDICATOR_CLASS = "dx-loadpanel-indicator";
var LOADPANEL_MESSAGE_CLASS = "dx-loadpanel-message";
var LOADPANEL_CONTENT_CLASS = "dx-loadpanel-content";
var LOADPANEL_CONTENT_WRAPPER_CLASS = "dx-loadpanel-content-wrapper";
var LOADPANEL_PANE_HIDDEN_CLASS = "dx-loadpanel-pane-hidden";
var LoadPanel = Overlay.inherit({
  _supportedKeys: function() {
    return extend(this.callBase(), {
      escape: noop
    });
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      message: messageLocalization.format("Loading"),
      width: 222,
      height: 90,
      animation: null,
      showIndicator: true,
      indicatorSrc: "",
      showPane: true,
      delay: 0,
      templatesRenderAsynchronously: false,
      hideTopOverlayHandler: null,
      resizeEnabled: false,
      focusStateEnabled: false
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: {
        platform: "generic"
      },
      options: {
        shadingColor: "transparent"
      }
    }, {
      device: function() {
        return isMaterial();
      },
      options: {
        message: "",
        width: 60,
        height: 60,
        maxHeight: 60,
        maxWidth: 60
      }
    }]);
  },
  _init: function() {
    this.callBase.apply(this, arguments);
  },
  _render: function() {
    this.callBase();
    this.$element().addClass(LOADPANEL_CLASS);
    this.$wrapper().addClass(LOADPANEL_WRAPPER_CLASS);
  },
  _renderContentImpl: function() {
    this.callBase();
    this.$content().addClass(LOADPANEL_CONTENT_CLASS);
    this._$loadPanelContentWrapper = $("<div>").addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
    this._$loadPanelContentWrapper.appendTo(this.$content());
    this._togglePaneVisible();
    this._cleanPreviousContent();
    this._renderLoadIndicator();
    this._renderMessage();
  },
  _show: function() {
    var delay = this.option("delay");
    if (!delay) {
      return this.callBase();
    }
    var deferred = new Deferred();
    var callBase = this.callBase.bind(this);
    this._clearShowTimeout();
    this._showTimeout = setTimeout(function() {
      callBase().done(function() {
        deferred.resolve();
      });
    }, delay);
    return deferred.promise();
  },
  _hide: function() {
    this._clearShowTimeout();
    return this.callBase();
  },
  _clearShowTimeout: function() {
    clearTimeout(this._showTimeout);
  },
  _renderMessage: function() {
    if (!this._$loadPanelContentWrapper) {
      return;
    }
    var message = this.option("message");
    if (!message) {
      return;
    }
    var $message = $("<div>").addClass(LOADPANEL_MESSAGE_CLASS).text(message);
    this._$loadPanelContentWrapper.append($message);
  },
  _renderLoadIndicator: function() {
    if (!this._$loadPanelContentWrapper || !this.option("showIndicator")) {
      return;
    }
    if (!this._$indicator) {
      this._$indicator = $("<div>").addClass(LOADPANEL_INDICATOR_CLASS).appendTo(this._$loadPanelContentWrapper);
    }
    this._createComponent(this._$indicator, LoadIndicator, {
      indicatorSrc: this.option("indicatorSrc")
    });
  },
  _cleanPreviousContent: function() {
    this.$content().find("." + LOADPANEL_MESSAGE_CLASS).remove();
    this.$content().find("." + LOADPANEL_INDICATOR_CLASS).remove();
    delete this._$indicator;
  },
  _togglePaneVisible: function() {
    this.$content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option("showPane"));
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "delay":
        break;
      case "message":
      case "showIndicator":
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage();
        break;
      case "showPane":
        this._togglePaneVisible();
        break;
      case "indicatorSrc":
        this._renderLoadIndicator();
        break;
      default:
        this.callBase(args);
    }
  },
  _dispose: function() {
    this._clearShowTimeout();
    this.callBase();
  }
});
registerComponent("dxLoadPanel", LoadPanel);
var ready = readyCallback.add;
var XHR_ERROR_UNLOAD = "DEVEXTREME_XHR_ERROR_UNLOAD";
var normalizeBinaryCriterion = function(crit) {
  return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
};
var normalizeSortingInfo$1 = function(info) {
  if (!Array.isArray(info)) {
    info = [info];
  }
  return map(info, function(i) {
    var result = {
      selector: isFunction$1(i) || typeof i === "string" ? i : i.getter || i.field || i.selector,
      desc: !!(i.desc || String(i.dir).charAt(0).toLowerCase() === "d")
    };
    if (i.compare) {
      result.compare = i.compare;
    }
    return result;
  });
};
var errorMessageFromXhr = function() {
  var textStatusMessages = {
    timeout: "Network connection timeout",
    error: "Unspecified network error",
    parsererror: "Unexpected server response"
  };
  var unloading;
  ready(function() {
    var window2 = getWindow();
    domAdapter.listen(window2, "beforeunload", function() {
      unloading = true;
    });
  });
  return function(xhr, textStatus) {
    if (unloading) {
      return XHR_ERROR_UNLOAD;
    }
    if (xhr.status < 400) {
      return function(textStatus2) {
        var result = textStatusMessages[textStatus2];
        if (!result) {
          return textStatus2;
        }
        return result;
      }(textStatus);
    }
    return xhr.statusText;
  };
}();
var aggregators = {
  count: {
    seed: 0,
    step: function(count) {
      return 1 + count;
    }
  },
  sum: {
    seed: 0,
    step: function(sum, item) {
      return sum + item;
    }
  },
  min: {
    step: function(min, item) {
      return item < min ? item : min;
    }
  },
  max: {
    step: function(max, item) {
      return item > max ? item : max;
    }
  },
  avg: {
    seed: [0, 0],
    step: function(pair, value2) {
      return [pair[0] + value2, pair[1] + 1];
    },
    finalize: function(pair) {
      return pair[1] ? pair[0] / pair[1] : NaN;
    }
  }
};
var processRequestResultLock = function() {
  var lockCount = 0;
  var lockDeferred;
  return {
    obtain: function() {
      if (lockCount === 0) {
        lockDeferred = new Deferred();
      }
      lockCount++;
    },
    release: function() {
      lockCount--;
      if (lockCount < 1) {
        lockDeferred.resolve();
      }
    },
    promise: function() {
      var deferred = lockCount === 0 ? new Deferred().resolve() : lockDeferred;
      return deferred.promise();
    },
    reset: function() {
      lockCount = 0;
      if (lockDeferred) {
        lockDeferred.resolve();
      }
    }
  };
}();
function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}
var keysEqual = function(keyExpr, key1, key2) {
  if (Array.isArray(keyExpr)) {
    var names = map(key1, function(v, k) {
      return k;
    });
    var name2;
    for (var i = 0; i < names.length; i++) {
      name2 = names[i];
      if (!equalByValue(key1[name2], key2[name2], 0, false)) {
        return false;
      }
    }
    return true;
  }
  return equalByValue(key1, key2, 0, false);
};
var isUnaryOperation = function(crit) {
  return crit[0] === "!" && Array.isArray(crit[1]);
};
var isGroupOperator = function(value2) {
  return value2 === "and" || value2 === "or";
};
var isGroupCriterion = function(crit) {
  var first = crit[0];
  var second = crit[1];
  if (Array.isArray(first)) {
    return true;
  }
  if (isFunction$1(first)) {
    if (Array.isArray(second) || isFunction$1(second) || isGroupOperator(second)) {
      return true;
    }
  }
  return false;
};
var trivialPromise$1 = function() {
  var d = new Deferred();
  return d.resolve.apply(d, arguments).promise();
};
var rejectedPromise = function() {
  var d = new Deferred();
  return d.reject.apply(d, arguments).promise();
};
function throttle$1(func, timeout) {
  var timeoutId;
  var lastArgs;
  return function() {
    lastArgs = arguments;
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        timeoutId = void 0;
        if (lastArgs) {
          func.call(this, lastArgs);
        }
      }, isFunction$1(timeout) ? timeout() : timeout);
    }
    return timeoutId;
  };
}
function throttleChanges(func, timeout) {
  var cache = [];
  var throttled = throttle$1(function() {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function(changes) {
    if (Array.isArray(changes)) {
      cache.push(...changes);
    }
    return throttled.call(this, cache);
  };
}
var isIE11$1 = coreBrowserUtils.msie && parseInt(coreBrowserUtils.version) <= 11;
var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
var toMilliseconds = function toMilliseconds2(value2) {
  switch (value2) {
    case "millisecond":
      return 1;
    case "second":
      return 1e3 * toMilliseconds2("millisecond");
    case "minute":
      return 60 * toMilliseconds2("second");
    case "hour":
      return 60 * toMilliseconds2("minute");
    case "day":
      return 24 * toMilliseconds2("hour");
    case "week":
      return 7 * toMilliseconds2("day");
    case "month":
      return 30 * toMilliseconds2("day");
    case "quarter":
      return 3 * toMilliseconds2("month");
    case "year":
      return 365 * toMilliseconds2("day");
    default:
      return 0;
  }
};
var getDatesInterval = function(startDate, endDate, intervalUnit) {
  var delta = endDate.getTime() - startDate.getTime();
  var millisecondCount = toMilliseconds(intervalUnit) || 1;
  return Math.floor(delta / millisecondCount);
};
var getNextDateUnit = function(unit, withWeeks) {
  var interval = getDateUnitInterval(unit);
  switch (interval) {
    case "millisecond":
      return "second";
    case "second":
      return "minute";
    case "minute":
      return "hour";
    case "hour":
      return "day";
    case "day":
      return withWeeks ? "week" : "month";
    case "week":
      return "month";
    case "month":
      return "quarter";
    case "quarter":
    case "year":
      return "year";
    default:
      return 0;
  }
};
var convertMillisecondsToDateUnits = function(value2) {
  var i;
  var dateUnitCount;
  var dateUnitInterval;
  var dateUnitIntervals2 = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
  var result = {};
  for (i = dateUnitIntervals2.length - 1; i >= 0; i--) {
    dateUnitInterval = dateUnitIntervals2[i];
    dateUnitCount = Math.floor(value2 / toMilliseconds(dateUnitInterval));
    if (dateUnitCount > 0) {
      result[dateUnitInterval + "s"] = dateUnitCount;
      value2 -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
    }
  }
  return result;
};
var dateToMilliseconds = function(tickInterval) {
  var milliseconds = 0;
  if (isObject$1(tickInterval)) {
    each(tickInterval, function(key, value2) {
      milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value2);
    });
  }
  if (isString$1(tickInterval)) {
    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
  }
  return milliseconds;
};
function convertDateUnitToMilliseconds(dateUnit, count) {
  return toMilliseconds(dateUnit) * count;
}
function getDateUnitInterval(tickInterval) {
  var maxInterval = -1;
  var i;
  if (isString$1(tickInterval)) {
    return tickInterval;
  }
  if (isObject$1(tickInterval)) {
    each(tickInterval, function(key, value2) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value2 && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }
  return "";
}
var tickIntervalToFormatMap = {
  millisecond: "millisecond",
  second: "longtime",
  minute: "shorttime",
  hour: "shorttime",
  day: "day",
  week: "day",
  month: "month",
  quarter: "quarter",
  year: "year"
};
function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || "";
}
var getQuarter = function(month) {
  return Math.floor(month / 3);
};
var getFirstQuarterMonth = function(month) {
  return 3 * getQuarter(month);
};
function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  var oldDate = new Date(date.getTime());
  var firstQuarterMonth;
  var month;
  var dateUnitInterval = getDateUnitInterval(dateInterval);
  switch (dateUnitInterval) {
    case "second":
      date = new Date(1e3 * Math.floor(oldDate.getTime() / 1e3));
      break;
    case "minute":
      date = new Date(6e4 * Math.floor(oldDate.getTime() / 6e4));
      break;
    case "hour":
      date = new Date(36e5 * Math.floor(oldDate.getTime() / 36e5));
      break;
    case "year":
      date.setMonth(0);
    case "month":
      date.setDate(1);
    case "day":
      date.setHours(0, 0, 0, 0);
      break;
    case "week":
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;
    case "quarter":
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }
  }
  if (withCorrection && dateUnitInterval !== "hour" && dateUnitInterval !== "minute" && dateUnitInterval !== "second") {
    fixTimezoneGap(oldDate, date);
  }
  return date;
}
function trimTime(date) {
  return correctDateWithUnitBeginning(date, "day");
}
var setToDayEnd = function(date) {
  var result = trimTime(date);
  result.setDate(result.getDate() + 1);
  return new Date(result.getTime() - 1);
};
var getDatesDifferences = function(date1, date2) {
  var counter = 0;
  var differences = {
    year: date1.getFullYear() !== date2.getFullYear(),
    month: date1.getMonth() !== date2.getMonth(),
    day: date1.getDate() !== date2.getDate(),
    hour: date1.getHours() !== date2.getHours(),
    minute: date1.getMinutes() !== date2.getMinutes(),
    second: date1.getSeconds() !== date2.getSeconds(),
    millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
  };
  each(differences, function(key, value2) {
    if (value2) {
      counter++;
    }
  });
  if (counter === 0 && getTimezonesDifference(date1, date2) !== 0) {
    differences.hour = true;
    counter++;
  }
  differences.count = counter;
  return differences;
};
function addDateInterval(value2, interval, dir) {
  var result = new Date(value2.getTime());
  var intervalObject = isString$1(interval) ? getDateIntervalByString(interval.toLowerCase()) : isNumeric(interval) ? convertMillisecondsToDateUnits(interval) : interval;
  if (intervalObject.years) {
    result.setFullYear(result.getFullYear() + intervalObject.years * dir);
  }
  if (intervalObject.quarters) {
    result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir);
  }
  if (intervalObject.months) {
    result.setMonth(result.getMonth() + intervalObject.months * dir);
  }
  if (intervalObject.weeks) {
    result.setDate(result.getDate() + 7 * intervalObject.weeks * dir);
  }
  if (intervalObject.days) {
    result.setDate(result.getDate() + intervalObject.days * dir);
  }
  if (intervalObject.hours) {
    result.setTime(result.getTime() + 36e5 * intervalObject.hours * dir);
  }
  if (intervalObject.minutes) {
    result.setTime(result.getTime() + 6e4 * intervalObject.minutes * dir);
  }
  if (intervalObject.seconds) {
    result.setTime(result.getTime() + 1e3 * intervalObject.seconds * dir);
  }
  if (intervalObject.milliseconds) {
    result.setTime(result.getTime() + intervalObject.milliseconds * dir);
  }
  return result;
}
var addInterval = function(value2, interval, isNegative) {
  var dir = isNegative ? -1 : 1;
  return isDate(value2) ? addDateInterval(value2, interval, dir) : adjust(value2 + interval * dir, interval);
};
var getSequenceByInterval = function(min, max, interval) {
  var intervals = [];
  var cur;
  intervals.push(isDate(min) ? new Date(min.getTime()) : min);
  cur = min;
  while (cur < max) {
    cur = addInterval(cur, interval);
    intervals.push(cur);
  }
  return intervals;
};
var getViewFirstCellDate = function(viewType, date) {
  if (viewType === "month") {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  }
  if (viewType === "year") {
    return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
  }
  if (viewType === "decade") {
    return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
  }
  if (viewType === "century") {
    return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
  }
};
var getViewLastCellDate = function(viewType, date) {
  if (viewType === "month") {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
  }
  if (viewType === "year") {
    return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
  }
  if (viewType === "decade") {
    return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
  }
  if (viewType === "century") {
    return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
  }
};
var getViewMinBoundaryDate = function(viewType, date) {
  var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  if (viewType === "month") {
    return resultDate;
  }
  resultDate.setMonth(0);
  if (viewType === "year") {
    return resultDate;
  }
  if (viewType === "decade") {
    resultDate.setFullYear(getFirstYearInDecade(date));
  }
  if (viewType === "century") {
    resultDate.setFullYear(getFirstDecadeInCentury(date));
  }
  return resultDate;
};
var getViewMaxBoundaryDate = function(viewType, date) {
  var resultDate = new Date(date);
  resultDate.setDate(getLastMonthDay(date));
  if (viewType === "month") {
    return resultDate;
  }
  resultDate.setMonth(11);
  resultDate.setDate(getLastMonthDay(resultDate));
  if (viewType === "year") {
    return resultDate;
  }
  if (viewType === "decade") {
    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
  }
  if (viewType === "century") {
    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
  }
  return resultDate;
};
function getLastMonthDay(date) {
  var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}
var getViewUp = function(typeView) {
  switch (typeView) {
    case "month":
      return "year";
    case "year":
      return "decade";
    case "decade":
      return "century";
  }
};
var getViewDown = function(typeView) {
  switch (typeView) {
    case "century":
      return "decade";
    case "decade":
      return "year";
    case "year":
      return "month";
  }
};
var getDifferenceInMonth = function(typeView) {
  var difference = 1;
  if (typeView === "year") {
    difference = 12;
  }
  if (typeView === "decade") {
    difference = 120;
  }
  if (typeView === "century") {
    difference = 1200;
  }
  return difference;
};
var getDifferenceInMonthForCells = function(typeView) {
  var difference = 1;
  if (typeView === "decade") {
    difference = 12;
  }
  if (typeView === "century") {
    difference = 120;
  }
  return difference;
};
function getDateIntervalByString(intervalString) {
  var result = {};
  switch (intervalString) {
    case "year":
      result.years = 1;
      break;
    case "month":
      result.months = 1;
      break;
    case "quarter":
      result.months = 3;
      break;
    case "week":
      result.weeks = 1;
      break;
    case "day":
      result.days = 1;
      break;
    case "hour":
      result.hours = 1;
      break;
    case "minute":
      result.minutes = 1;
      break;
    case "second":
      result.seconds = 1;
      break;
    case "millisecond":
      result.milliseconds = 1;
  }
  return result;
}
function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}
function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}
function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}
var sameDecade = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
  var startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
  return date1 && date2 && startDecadeDate1 === startDecadeDate2;
};
var sameCentury = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
  var startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
  return date1 && date2 && startCenturyDate1 === startCenturyDate2;
};
function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}
function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}
var getShortDateFormat = function() {
  return "yyyy/MM/dd";
};
var getFirstMonthDate = function(date) {
  if (!isDefined(date)) {
    return;
  }
  return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
};
var getLastMonthDate = function(date) {
  if (!isDefined(date)) {
    return;
  }
  return createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
};
function getFirstWeekDate(date, firstDayOfWeek) {
  var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
  var result = new Date(date);
  result.setDate(date.getDate() - delta);
  return result;
}
var normalizeDateByWeek = function(date, currentDate) {
  var differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day");
  var resultDate = new Date(date);
  if (differenceInDays >= 6) {
    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
  }
  return resultDate;
};
var dateInRange = function(date, min, max, format2) {
  if (format2 === "date") {
    min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
    max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
    date = date && dateUtils.correctDateWithUnitBeginning(date, "day");
  }
  return normalizeDate(date, min, max) === date;
};
var intervalsOverlap = function(options) {
  var {
    firstMin,
    firstMax,
    secondMin,
    secondMax
  } = options;
  return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
};
var dateTimeFromDecimal = function(number) {
  var hours = Math.floor(number);
  var minutes = number % 1 * 60;
  return {
    hours,
    minutes
  };
};
var roundDateByStartDayHour = function(date, startDayHour) {
  var startTime = this.dateTimeFromDecimal(startDayHour);
  var result = new Date(date);
  if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
    result.setHours(startTime.hours, startTime.minutes, 0, 0);
  }
  return result;
};
function normalizeDate(date, min, max) {
  var normalizedDate = date;
  if (!isDefined(date)) {
    return date;
  }
  if (isDefined(min) && date < min) {
    normalizedDate = min;
  }
  if (isDefined(max) && date > max) {
    normalizedDate = max;
  }
  return normalizedDate;
}
function fixTimezoneGap(oldDate, newDate) {
  if (!isDefined(oldDate)) {
    return;
  }
  var diff = newDate.getHours() - oldDate.getHours();
  if (diff === 0) {
    return;
  }
  var sign2 = diff === 1 || diff === -23 ? -1 : 1;
  var trial = new Date(newDate.getTime() + 36e5 * sign2);
  if (sign2 > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}
var roundToHour = function(date) {
  date.setHours(date.getHours() + 1);
  date.setMinutes(0);
  return date;
};
function getTimezonesDifference(min, max) {
  return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3;
}
var makeDate = function(date) {
  return new Date(date);
};
var getDatesOfInterval = function(startDate, endDate, step) {
  var result = [];
  var currentDate = new Date(startDate.getTime());
  while (currentDate < endDate) {
    result.push(new Date(currentDate.getTime()));
    currentDate = this.addInterval(currentDate, step);
  }
  return result;
};
var createDate = function(date) {
  return new Date(isIE11$1 && isDate(date) ? date.getTime() : date);
};
var createDateWithFullYear = function(year) {
  var result = new Date(...arguments);
  result.setFullYear(year);
  return result;
};
var dateUtils = {
  dateUnitIntervals,
  convertMillisecondsToDateUnits,
  dateToMilliseconds,
  getNextDateUnit,
  convertDateUnitToMilliseconds,
  getDateUnitInterval,
  getDateFormatByTickInterval,
  getDatesDifferences,
  correctDateWithUnitBeginning,
  trimTime,
  setToDayEnd,
  roundDateByStartDayHour,
  dateTimeFromDecimal,
  addDateInterval,
  addInterval,
  getSequenceByInterval,
  getDateIntervalByString,
  sameDate,
  sameMonthAndYear,
  sameMonth: sameMonthAndYear,
  sameYear,
  sameDecade,
  sameCentury,
  getDifferenceInMonth,
  getDifferenceInMonthForCells,
  getFirstYearInDecade,
  getFirstDecadeInCentury,
  getShortDateFormat,
  getViewFirstCellDate,
  getViewLastCellDate,
  getViewDown,
  getViewUp,
  getLastMonthDay,
  getLastMonthDate,
  getFirstMonthDate,
  getFirstWeekDate,
  normalizeDateByWeek,
  getQuarter,
  getFirstQuarterMonth,
  dateInRange,
  intervalsOverlap,
  roundToHour,
  normalizeDate,
  getViewMinBoundaryDate,
  getViewMaxBoundaryDate,
  fixTimezoneGap,
  getTimezonesDifference,
  makeDate,
  getDatesInterval,
  getDatesOfInterval,
  createDate,
  createDateWithFullYear
};
dateUtils.sameView = function(view, date1, date2) {
  return dateUtils[camelize("same " + view)](date1, date2);
};
var DECIMAL_BASE$1 = 10;
function roundByAbs(value2) {
  var valueSign = sign(value2);
  return valueSign * Math.round(Math.abs(value2));
}
function adjustValue(value2, precision) {
  var precisionMultiplier = Math.pow(DECIMAL_BASE$1, precision);
  var roundMultiplier = precisionMultiplier * DECIMAL_BASE$1;
  var intermediateValue = value2 * roundMultiplier / DECIMAL_BASE$1;
  return roundByAbs(intermediateValue) / precisionMultiplier;
}
function toFixed(value2, precision) {
  var valuePrecision = precision || 0;
  var adjustedValue = valuePrecision > 0 ? adjustValue(...arguments) : value2;
  return adjustedValue.toFixed(valuePrecision);
}
var DEFAULT_CONFIG = {
  thousandsSeparator: ",",
  decimalSeparator: "."
};
var ESCAPING_CHAR = "'";
var MAXIMUM_NUMBER_LENGTH = 15;
function getGroupSizes(formatString) {
  return formatString.split(",").slice(1).map(function(str) {
    return str.split("").filter(function(char) {
      return char === "#" || char === "0";
    }).length;
  });
}
function getSignParts(format2) {
  var signParts = format2.split(";");
  if (signParts.length === 1) {
    signParts.push("-" + signParts[0]);
  }
  return signParts;
}
function reverseString(str) {
  return str.toString().split("").reverse().join("");
}
function isPercentFormat(format2) {
  return format2.indexOf("%") !== -1 && !format2.match(/'[^']*%[^']*'/g);
}
function removeStubs(str) {
  return str.replace(/'.+'/g, "");
}
function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  var format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[#]/g, "").length;
}
function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  var format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[0]/g, "").length;
}
function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) {
    return "";
  }
  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }
  while (valuePart.length > minDigitCount && valuePart.slice(-1) === "0") {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }
  while (valuePart.length < minDigitCount) {
    valuePart += "0";
  }
  return valuePart;
}
function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) {
    return valueString;
  }
  var groups = [];
  var index2 = 0;
  while (valueString) {
    var groupSize = groupSizes[index2];
    if (!groupSize) {
      break;
    }
    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);
    if (index2 < groupSizes.length - 1) {
      index2++;
    }
  }
  return groups.join(thousandsSeparator);
}
function formatNumberPart(format2, valueString) {
  return format2.split(ESCAPING_CHAR).map(function(formatPart, escapeIndex) {
    var isEscape = escapeIndex % 2;
    if (!formatPart && isEscape) {
      return ESCAPING_CHAR;
    }
    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join("");
}
function getFloatPointIndex(format2) {
  var isEscape = false;
  for (var index2 = 0; index2 < format2.length; index2++) {
    if (format2[index2] === "'") {
      isEscape = !isEscape;
    }
    if (format2[index2] === "." && !isEscape) {
      return index2;
    }
  }
  return format2.length;
}
function getFormatter$3(format2, config2) {
  config2 = config2 || DEFAULT_CONFIG;
  return function(value2) {
    if (typeof value2 !== "number" || isNaN(value2)) {
      return "";
    }
    var signFormatParts = getSignParts(format2);
    var isPositiveZero = 1 / value2 === 1 / 0;
    var isPositive = value2 > 0 || isPositiveZero;
    var numberFormat = signFormatParts[isPositive ? 0 : 1];
    if (isPercentFormat(numberFormat)) {
      value2 *= 100;
    }
    if (!isPositive) {
      value2 = -value2;
    }
    var floatPointIndex = getFloatPointIndex(numberFormat);
    var floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    var minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    var maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    var minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    var maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config2.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;
    var integerLength = Math.floor(value2).toString().length;
    var floatPrecision = fitIntoRange(maxFloatPrecision, 0, MAXIMUM_NUMBER_LENGTH - integerLength);
    var groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    var valueParts = toFixed(value2, floatPrecision < 0 ? 0 : floatPrecision).split(".");
    var valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    var valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config2.thousandsSeparator);
    var integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    var floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : "";
    var result = integerString + (floatString.match(/\d/) ? config2.decimalSeparator : "") + floatString;
    return result;
  };
}
var currencyLocalization = {
  _formatNumberCore: function(value2, format2, formatConfig) {
    if (format2 === "currency") {
      formatConfig.precision = formatConfig.precision || 0;
      var result = this.format(value2, extend({}, formatConfig, {
        type: "fixedpoint"
      }));
      var currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, "$$$$");
      result = result.replace(/^(\D*)(\d.*)/, "$1" + currencyPart + "$2");
      return result;
    }
    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function() {
    return {
      symbol: "$"
    };
  },
  getOpenXmlCurrencyFormat: function() {
    return "$#,##0{0}_);\\($#,##0{0}\\)";
  }
};
var openXmlCurrencyFormat = (currencySymbol, accountingFormat) => {
  if (!accountingFormat) {
    return;
  }
  var encodedCurrencySymbol = currencySymbol;
  if (typeof currencySymbol === "string") {
    encodedCurrencySymbol = "";
    for (var i = 0; i < currencySymbol.length; i++) {
      if (currencySymbol[i] !== "$") {
        encodedCurrencySymbol += "\\";
      }
      encodedCurrencySymbol += currencySymbol[i];
    }
  }
  var encodeSymbols = {
    ".00": "{0}",
    "'": "\\'",
    "\\(": "\\(",
    "\\)": "\\)",
    " ": "\\ ",
    '"': "&quot;",
    "\\\xA4": encodedCurrencySymbol
  };
  var result = accountingFormat.split(";");
  for (var _i = 0; _i < result.length; _i++) {
    for (var symbol in encodeSymbols) {
      if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
        result[_i] = result[_i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
      }
    }
  }
  return result.length === 2 ? result[0] + "_);" + result[1] : result[0];
};
var accountingFormats = {
  af: "\xA4#,##0.00;(\xA4#,##0.00)",
  "af-NA": "\xA4#,##0.00;(\xA4#,##0.00)",
  agq: "#,##0.00\xA4",
  ak: "\xA4#,##0.00",
  am: "\xA4#,##0.00;(\xA4#,##0.00)",
  ar: "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-AE": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-BH": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-DJ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-DZ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-EG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-EH": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-ER": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-IL": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-IQ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-JO": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-KM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-KW": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-LB": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-LY": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-MA": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-MR": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-OM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-PS": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-QA": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-SA": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-SD": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-SO": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-SS": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-SY": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-TD": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-TN": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ar-YE": "\xA4#,##0.00;(\xA4#,##0.00)",
  as: "\xA4\xA0#,##,##0.00",
  asa: "#,##0.00\xA0\xA4",
  ast: "#,##0.00\xA0\xA4",
  az: "#,##0.00\xA0\xA4",
  "az-Cyrl": "#,##0.00\xA0\xA4",
  "az-Latn": "#,##0.00\xA0\xA4",
  bas: "#,##0.00\xA0\xA4",
  be: "#,##0.00\xA0\xA4",
  bem: "\xA4#,##0.00;(\xA4#,##0.00)",
  bez: "#,##0.00\xA4",
  bg: "0.00\xA0\xA4;(0.00\xA0\xA4)",
  bm: "\xA4#,##0.00;(\xA4#,##0.00)",
  bn: "#,##,##0.00\xA4;(#,##,##0.00\xA4)",
  "bn-IN": "#,##,##0.00\xA4;(#,##,##0.00\xA4)",
  bo: "\xA4\xA0#,##0.00",
  "bo-IN": "\xA4\xA0#,##0.00",
  br: "#,##0.00\xA0\xA4",
  brx: "\xA4\xA0#,##,##0.00",
  bs: "#,##0.00\xA0\xA4",
  "bs-Cyrl": "#,##0.00\xA0\xA4",
  "bs-Latn": "#,##0.00\xA0\xA4",
  ca: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "ca-AD": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "ca-ES-VALENCIA": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "ca-FR": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "ca-IT": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  ccp: "#,##,##0.00\xA4;(#,##,##0.00\xA4)",
  "ccp-IN": "#,##,##0.00\xA4;(#,##,##0.00\xA4)",
  ce: "#,##0.00\xA0\xA4",
  ceb: "\xA4#,##0.00;(\xA4#,##0.00)",
  cgg: "\xA4#,##0.00",
  chr: "\xA4#,##0.00;(\xA4#,##0.00)",
  ckb: "\xA4\xA0#,##0.00",
  "ckb-IR": "\xA4\xA0#,##0.00",
  cs: "#,##0.00\xA0\xA4",
  cy: "\xA4#,##0.00;(\xA4#,##0.00)",
  da: "#,##0.00\xA0\xA4",
  "da-GL": "#,##0.00\xA0\xA4",
  dav: "\xA4#,##0.00;(\xA4#,##0.00)",
  de: "#,##0.00\xA0\xA4",
  "de-AT": "#,##0.00\xA0\xA4",
  "de-BE": "#,##0.00\xA0\xA4",
  "de-CH": "#,##0.00\xA0\xA4",
  "de-IT": "#,##0.00\xA0\xA4",
  "de-LI": "#,##0.00\xA0\xA4",
  "de-LU": "#,##0.00\xA0\xA4",
  dje: "#,##0.00\xA4",
  doi: "\xA4#,##0.00",
  dsb: "#,##0.00\xA0\xA4",
  dua: "#,##0.00\xA0\xA4",
  dyo: "#,##0.00\xA0\xA4",
  dz: "\xA4#,##,##0.00",
  ebu: "\xA4#,##0.00;(\xA4#,##0.00)",
  ee: "\xA4#,##0.00;(\xA4#,##0.00)",
  "ee-TG": "\xA4#,##0.00;(\xA4#,##0.00)",
  el: "#,##0.00\xA0\xA4",
  "el-CY": "#,##0.00\xA0\xA4",
  en: "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-001": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-150": "#,##0.00\xA0\xA4",
  "en-AE": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-AG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-AI": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-AS": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-AT": "\xA4\xA0#,##0.00",
  "en-AU": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-BB": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-BE": "#,##0.00\xA0\xA4",
  "en-BI": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-BM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-BS": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-BW": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-BZ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-CA": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-CC": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-CH": "\xA4\xA0#,##0.00;\xA4-#,##0.00",
  "en-CK": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-CM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-CX": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-CY": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-DE": "#,##0.00\xA0\xA4",
  "en-DG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-DK": "#,##0.00\xA0\xA4",
  "en-DM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-ER": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-FI": "#,##0.00\xA0\xA4",
  "en-FJ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-FK": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-FM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-GB": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-GD": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-GG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-GH": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-GI": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-GM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-GU": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-GY": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-HK": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-IE": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-IL": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-IM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-IN": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-IO": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-JE": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-JM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-KE": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-KI": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-KN": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-KY": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-LC": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-LR": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-LS": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MH": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MO": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MP": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MS": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MT": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MU": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MW": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-MY": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-NA": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-NF": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-NG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-NL": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "en-NR": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-NU": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-NZ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-PG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-PH": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-PK": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-PN": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-PR": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-PW": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-RW": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SB": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SC": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SD": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SE": "#,##0.00\xA0\xA4",
  "en-SG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SH": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SI": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "en-SL": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SS": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SX": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-SZ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-TC": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-TK": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-TO": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-TT": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-TV": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-TZ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-UG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-UM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-US-POSIX": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-VC": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-VG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-VI": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-VU": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-WS": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-ZA": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-ZM": "\xA4#,##0.00;(\xA4#,##0.00)",
  "en-ZW": "\xA4#,##0.00;(\xA4#,##0.00)",
  eo: "\xA4\xA0#,##0.00",
  es: "#,##0.00\xA0\xA4",
  "es-419": "\xA4#,##0.00",
  "es-AR": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "es-BO": "\xA4#,##0.00",
  "es-BR": "\xA4#,##0.00",
  "es-BZ": "\xA4#,##0.00",
  "es-CL": "\xA4#,##0.00",
  "es-CO": "\xA4#,##0.00",
  "es-CR": "\xA4#,##0.00",
  "es-CU": "\xA4#,##0.00",
  "es-DO": "\xA4#,##0.00;(\xA4#,##0.00)",
  "es-EA": "#,##0.00\xA0\xA4",
  "es-EC": "\xA4#,##0.00",
  "es-GQ": "#,##0.00\xA0\xA4",
  "es-GT": "\xA4#,##0.00",
  "es-HN": "\xA4#,##0.00",
  "es-IC": "#,##0.00\xA0\xA4",
  "es-MX": "\xA4#,##0.00",
  "es-NI": "\xA4#,##0.00",
  "es-PA": "\xA4#,##0.00",
  "es-PE": "\xA4#,##0.00",
  "es-PH": "#,##0.00\xA0\xA4",
  "es-PR": "\xA4#,##0.00",
  "es-PY": "\xA4#,##0.00",
  "es-SV": "\xA4#,##0.00",
  "es-US": "\xA4#,##0.00",
  "es-UY": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "es-VE": "\xA4#,##0.00",
  et: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  eu: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  ewo: "#,##0.00\xA0\xA4",
  fa: "\u200E\xA4\xA0#,##0.00;\u200E(\xA4\xA0#,##0.00)",
  "fa-AF": "\xA4\xA0#,##0.00;\u200E(\xA4\xA0#,##0.00)",
  ff: "#,##0.00\xA0\xA4",
  "ff-Adlm": "\xA4\xA0#,##0.00",
  "ff-Adlm-BF": "\xA4\xA0#,##0.00",
  "ff-Adlm-CM": "\xA4\xA0#,##0.00",
  "ff-Adlm-GH": "\xA4\xA0#,##0.00",
  "ff-Adlm-GM": "\xA4\xA0#,##0.00",
  "ff-Adlm-GW": "\xA4\xA0#,##0.00",
  "ff-Adlm-LR": "\xA4\xA0#,##0.00",
  "ff-Adlm-MR": "\xA4\xA0#,##0.00",
  "ff-Adlm-NE": "\xA4\xA0#,##0.00",
  "ff-Adlm-NG": "\xA4\xA0#,##0.00",
  "ff-Adlm-SL": "\xA4\xA0#,##0.00",
  "ff-Adlm-SN": "\xA4\xA0#,##0.00",
  "ff-Latn": "#,##0.00\xA0\xA4",
  "ff-Latn-BF": "#,##0.00\xA0\xA4",
  "ff-Latn-CM": "#,##0.00\xA0\xA4",
  "ff-Latn-GH": "#,##0.00\xA0\xA4",
  "ff-Latn-GM": "#,##0.00\xA0\xA4",
  "ff-Latn-GN": "#,##0.00\xA0\xA4",
  "ff-Latn-GW": "#,##0.00\xA0\xA4",
  "ff-Latn-LR": "#,##0.00\xA0\xA4",
  "ff-Latn-MR": "#,##0.00\xA0\xA4",
  "ff-Latn-NE": "#,##0.00\xA0\xA4",
  "ff-Latn-NG": "#,##0.00\xA0\xA4",
  "ff-Latn-SL": "#,##0.00\xA0\xA4",
  fi: "#,##0.00\xA0\xA4",
  fil: "\xA4#,##0.00;(\xA4#,##0.00)",
  fo: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fo-DK": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  fr: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-BE": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-BF": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-BI": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-BJ": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-BL": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-CA": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-CD": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-CF": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-CG": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-CH": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-CI": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-CM": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-DJ": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-DZ": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-GA": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-GF": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-GN": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-GP": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-GQ": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-HT": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-KM": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-LU": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-MA": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-MC": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-MF": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-MG": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-ML": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-MQ": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-MR": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-MU": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-NC": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-NE": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-PF": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-PM": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-RE": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-RW": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-SC": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-SN": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-SY": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-TD": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-TG": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-TN": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-VU": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-WF": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "fr-YT": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  fur: "\xA4\xA0#,##0.00",
  fy: "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  ga: "\xA4#,##0.00;(\xA4#,##0.00)",
  "ga-GB": "\xA4#,##0.00;(\xA4#,##0.00)",
  gd: "\xA4#,##0.00;(\xA4#,##0.00)",
  gl: "#,##0.00\xA0\xA4",
  gsw: "#,##0.00\xA0\xA4",
  "gsw-FR": "#,##0.00\xA0\xA4",
  "gsw-LI": "#,##0.00\xA0\xA4",
  gu: "\xA4#,##,##0.00;(\xA4#,##,##0.00)",
  guz: "\xA4#,##0.00;(\xA4#,##0.00)",
  gv: "\xA4#,##0.00",
  ha: "\xA4\xA0#,##0.00",
  "ha-GH": "\xA4\xA0#,##0.00",
  "ha-NE": "\xA4\xA0#,##0.00",
  haw: "\xA4#,##0.00;(\xA4#,##0.00)",
  he: "#,##0.00\xA0\xA4",
  hi: "\xA4#,##,##0.00",
  hr: "#,##0.00\xA0\xA4",
  "hr-BA": "#,##0.00\xA0\xA4",
  hsb: "#,##0.00\xA0\xA4",
  hu: "#,##0.00\xA0\xA4",
  hy: "#,##0.00\xA0\xA4",
  ia: "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  id: "\xA4#,##0.00",
  ig: "\xA4#,##0.00;(\xA4#,##0.00)",
  ii: "\xA4\xA0#,##0.00",
  is: "#,##0.00\xA0\xA4",
  it: "#,##0.00\xA0\xA4",
  "it-CH": "#,##0.00\xA0\xA4",
  "it-SM": "#,##0.00\xA0\xA4",
  "it-VA": "#,##0.00\xA0\xA4",
  ja: "\xA4#,##0.00;(\xA4#,##0.00)",
  jgo: "\xA4\xA0#,##0.00",
  jmc: "\xA4#,##0.00",
  jv: "\xA4\xA0#,##0.00",
  ka: "#,##0.00\xA0\xA4",
  kab: "#,##0.00\xA4",
  kam: "\xA4#,##0.00;(\xA4#,##0.00)",
  kde: "\xA4#,##0.00;(\xA4#,##0.00)",
  kea: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  khq: "#,##0.00\xA4",
  ki: "\xA4#,##0.00;(\xA4#,##0.00)",
  kk: "#,##0.00\xA0\xA4",
  kkj: "\xA4\xA0#,##0.00",
  kl: "\xA4#,##0.00;\xA4-#,##0.00",
  kln: "\xA4#,##0.00;(\xA4#,##0.00)",
  km: "#,##0.00\xA4;(#,##0.00\xA4)",
  kn: "\xA4#,##0.00;(\xA4#,##0.00)",
  ko: "\xA4#,##0.00;(\xA4#,##0.00)",
  "ko-KP": "\xA4#,##0.00;(\xA4#,##0.00)",
  kok: "\xA4#,##0.00;(\xA4#,##0.00)",
  ks: "\xA4\xA0#,##,##0.00",
  "ks-Arab": "\xA4\xA0#,##,##0.00",
  ksb: "#,##0.00\xA4",
  ksf: "#,##0.00\xA0\xA4",
  ksh: "#,##0.00\xA0\xA4",
  ku: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  kw: "\xA4#,##0.00",
  ky: "#,##0.00\xA0\xA4",
  lag: "\xA4\xA0#,##0.00",
  lb: "#,##0.00\xA0\xA4",
  lg: "#,##0.00\xA4",
  lkt: "\xA4\xA0#,##0.00",
  ln: "#,##0.00\xA0\xA4",
  "ln-AO": "#,##0.00\xA0\xA4",
  "ln-CF": "#,##0.00\xA0\xA4",
  "ln-CG": "#,##0.00\xA0\xA4",
  lo: "\xA4#,##0.00;\xA4-#,##0.00",
  lrc: "\xA4\xA0#,##0.00",
  "lrc-IQ": "\xA4\xA0#,##0.00",
  lt: "#,##0.00\xA0\xA4",
  lu: "#,##0.00\xA4",
  luo: "#,##0.00\xA4",
  luy: "\xA4#,##0.00;\xA4-\xA0#,##0.00",
  lv: "#,##0.00\xA0\xA4",
  mai: "\xA4\xA0#,##0.00",
  mas: "\xA4#,##0.00;(\xA4#,##0.00)",
  "mas-TZ": "\xA4#,##0.00;(\xA4#,##0.00)",
  mer: "\xA4#,##0.00;(\xA4#,##0.00)",
  mfe: "\xA4\xA0#,##0.00",
  mg: "\xA4#,##0.00",
  mgh: "\xA4\xA0#,##0.00",
  mgo: "\xA4\xA0#,##0.00",
  mi: "\xA4\xA0#,##0.00",
  mk: "#,##0.00\xA0\xA4",
  ml: "\xA4#,##0.00;(\xA4#,##0.00)",
  mn: "\xA4\xA0#,##0.00",
  mni: "\xA4\xA0#,##0.00",
  "mni-Beng": "\xA4\xA0#,##0.00",
  mr: "\xA4#,##0.00;(\xA4#,##0.00)",
  ms: "\xA4#,##0.00;(\xA4#,##0.00)",
  "ms-BN": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ms-ID": "\xA4#,##0.00",
  "ms-SG": "\xA4#,##0.00;(\xA4#,##0.00)",
  mt: "\xA4#,##0.00",
  mua: "\xA4#,##0.00;(\xA4#,##0.00)",
  my: "\xA4\xA0#,##0.00",
  mzn: "\xA4\xA0#,##0.00",
  naq: "\xA4#,##0.00",
  nb: "\xA4\xA0#,##0.00",
  "nb-SJ": "\xA4\xA0#,##0.00",
  nd: "\xA4#,##0.00;(\xA4#,##0.00)",
  nds: "\xA4\xA0#,##0.00",
  "nds-NL": "\xA4\xA0#,##0.00",
  ne: "\xA4\xA0#,##,##0.00",
  "ne-IN": "\xA4\xA0#,##,##0.00",
  nl: "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "nl-AW": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "nl-BE": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "nl-BQ": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "nl-CW": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "nl-SR": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  "nl-SX": "\xA4\xA0#,##0.00;(\xA4\xA0#,##0.00)",
  nmg: "#,##0.00\xA0\xA4",
  nn: "#,##0.00\xA0\xA4",
  nnh: "\xA4\xA0#,##0.00",
  no: "\xA4\xA0#,##0.00",
  nus: "\xA4#,##0.00;(\xA4#,##0.00)",
  nyn: "\xA4#,##0.00",
  om: "\xA4#,##0.00",
  "om-KE": "\xA4#,##0.00",
  or: "\xA4#,##0.00;(\xA4#,##0.00)",
  os: "\xA4\xA0#,##0.00",
  "os-RU": "\xA4\xA0#,##0.00",
  pa: "\xA4\xA0#,##0.00",
  "pa-Arab": "\xA4\xA0#,##0.00",
  "pa-Guru": "\xA4\xA0#,##0.00",
  pcm: "\xA4#,##0.00",
  pl: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  ps: "\xA4#,##0.00;(\xA4#,##0.00)",
  "ps-PK": "\xA4#,##0.00;(\xA4#,##0.00)",
  pt: "\xA4\xA0#,##0.00",
  "pt-AO": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-CH": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-CV": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-GQ": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-GW": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-LU": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-MO": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-MZ": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-PT": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-ST": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "pt-TL": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  qu: "\xA4\xA0#,##0.00",
  "qu-BO": "\xA4\xA0#,##0.00",
  "qu-EC": "\xA4\xA0#,##0.00",
  rm: "#,##0.00\xA0\xA4",
  rn: "#,##0.00\xA4",
  ro: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "ro-MD": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  rof: "\xA4#,##0.00",
  root: "\xA4\xA0#,##0.00",
  ru: "#,##0.00\xA0\xA4",
  "ru-BY": "#,##0.00\xA0\xA4",
  "ru-KG": "#,##0.00\xA0\xA4",
  "ru-KZ": "#,##0.00\xA0\xA4",
  "ru-MD": "#,##0.00\xA0\xA4",
  "ru-UA": "#,##0.00\xA0\xA4",
  rw: "\xA4\xA0#,##0.00",
  rwk: "#,##0.00\xA4",
  sa: "\xA4\xA0#,##0.00",
  sah: "#,##0.00\xA0\xA4",
  saq: "\xA4#,##0.00;(\xA4#,##0.00)",
  sat: "\xA4\xA0#,##0.00",
  "sat-Olck": "\xA4\xA0#,##0.00",
  sbp: "#,##0.00\xA4",
  sd: "\xA4\xA0#,##0.00",
  "sd-Arab": "\xA4\xA0#,##0.00",
  "sd-Deva": "\xA4\xA0#,##0.00",
  se: "#,##0.00\xA0\xA4",
  "se-FI": "#,##0.00\xA0\xA4",
  "se-SE": "#,##0.00\xA0\xA4",
  seh: "#,##0.00\xA4",
  ses: "#,##0.00\xA4",
  sg: "\xA4#,##0.00;\xA4-#,##0.00",
  shi: "#,##0.00\xA4",
  "shi-Latn": "#,##0.00\xA4",
  "shi-Tfng": "#,##0.00\xA4",
  si: "\xA4#,##0.00;(\xA4#,##0.00)",
  sk: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  sl: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  smn: "#,##0.00\xA0\xA4",
  sn: "\xA4#,##0.00;(\xA4#,##0.00)",
  so: "\xA4#,##0.00;(\xA4#,##0.00)",
  "so-DJ": "\xA4#,##0.00;(\xA4#,##0.00)",
  "so-ET": "\xA4#,##0.00;(\xA4#,##0.00)",
  "so-KE": "\xA4#,##0.00;(\xA4#,##0.00)",
  sq: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sq-MK": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sq-XK": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  sr: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sr-Cyrl": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sr-Cyrl-BA": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sr-Cyrl-ME": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sr-Cyrl-XK": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sr-Latn": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sr-Latn-BA": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sr-Latn-ME": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  "sr-Latn-XK": "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  su: "\xA4#,##0.00",
  "su-Latn": "\xA4#,##0.00",
  sv: "#,##0.00\xA0\xA4",
  "sv-AX": "#,##0.00\xA0\xA4",
  "sv-FI": "#,##0.00\xA0\xA4",
  sw: "\xA4\xA0#,##0.00",
  "sw-CD": "\xA4\xA0#,##0.00",
  "sw-KE": "\xA4\xA0#,##0.00",
  "sw-UG": "\xA4\xA0#,##0.00",
  ta: "\xA4#,##0.00;(\xA4#,##0.00)",
  "ta-LK": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ta-MY": "\xA4#,##0.00;(\xA4#,##0.00)",
  "ta-SG": "\xA4#,##0.00;(\xA4#,##0.00)",
  te: "\xA4#,##0.00;(\xA4#,##0.00)",
  teo: "\xA4#,##0.00;(\xA4#,##0.00)",
  "teo-KE": "\xA4#,##0.00;(\xA4#,##0.00)",
  tg: "#,##0.00\xA0\xA4",
  th: "\xA4#,##0.00;(\xA4#,##0.00)",
  ti: "\xA4#,##0.00",
  "ti-ER": "\xA4#,##0.00",
  tk: "#,##0.00\xA0\xA4",
  to: "\xA4\xA0#,##0.00",
  tr: "\xA4#,##0.00;(\xA4#,##0.00)",
  "tr-CY": "\xA4#,##0.00;(\xA4#,##0.00)",
  tt: "#,##0.00\xA0\xA4",
  twq: "#,##0.00\xA4",
  tzm: "#,##0.00\xA0\xA4",
  ug: "\xA4#,##0.00;(\xA4#,##0.00)",
  uk: "#,##0.00\xA0\xA4",
  ur: "\xA4#,##0.00;(\xA4#,##0.00)",
  "ur-IN": "\xA4#,##0.00;(\xA4#,##0.00)",
  uz: "#,##0.00\xA0\xA4",
  "uz-Arab": "\xA4\xA0#,##0.00",
  "uz-Cyrl": "#,##0.00\xA0\xA4",
  "uz-Latn": "#,##0.00\xA0\xA4",
  vai: "\xA4#,##0.00;(\xA4#,##0.00)",
  "vai-Latn": "\xA4#,##0.00;(\xA4#,##0.00)",
  "vai-Vaii": "\xA4#,##0.00;(\xA4#,##0.00)",
  vi: "#,##0.00\xA0\xA4",
  vun: "\xA4#,##0.00",
  wae: "\xA4\xA0#,##0.00",
  wo: "\xA4\xA0#,##0.00",
  xh: "\xA4#,##0.00",
  xog: "#,##0.00\xA0\xA4",
  yav: "#,##0.00\xA0\xA4;(#,##0.00\xA0\xA4)",
  yi: "\xA4\xA0#,##0.00",
  yo: "\xA4#,##0.00;(\xA4#,##0.00)",
  "yo-BJ": "\xA4#,##0.00;(\xA4#,##0.00)",
  yue: "\xA4#,##0.00;(\xA4#,##0.00)",
  "yue-Hans": "\xA4#,##0.00;(\xA4#,##0.00)",
  "yue-Hant": "\xA4#,##0.00;(\xA4#,##0.00)",
  zgh: "#,##0.00\xA4",
  zh: "\xA4#,##0.00;(\xA4#,##0.00)",
  "zh-Hans": "\xA4#,##0.00;(\xA4#,##0.00)",
  "zh-Hans-HK": "\xA4#,##0.00;(\xA4#,##0.00)",
  "zh-Hans-MO": "\xA4#,##0.00;(\xA4#,##0.00)",
  "zh-Hans-SG": "\xA4#,##0.00;(\xA4#,##0.00)",
  "zh-Hant": "\xA4#,##0.00;(\xA4#,##0.00)",
  "zh-Hant-HK": "\xA4#,##0.00;(\xA4#,##0.00)",
  "zh-Hant-MO": "\xA4#,##0.00;(\xA4#,##0.00)",
  zu: "\xA4#,##0.00;(\xA4#,##0.00)"
};
var detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
var formattersCache$1 = {};
var getFormatter$2 = (format2) => {
  var key = core.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache$1[key]) {
    formattersCache$1[key] = new Intl.NumberFormat(core.locale(), format2).format;
  }
  return formattersCache$1[key];
};
var getCurrencyFormatter = (currency) => new Intl.NumberFormat(core.locale(), {
  style: "currency",
  currency
});
var intlNumberLocalization = {
  engine: function() {
    return "intl";
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if (format2 === "exponential") {
      return this.callBase.apply(this, arguments);
    }
    return getFormatter$2(this._normalizeFormatConfig(format2, formatConfig, value2))(value2);
  },
  _normalizeFormatConfig: function(format2, formatConfig, value2) {
    var config2;
    if (format2 === "decimal") {
      config2 = {
        minimumIntegerDigits: formatConfig.precision || void 0,
        useGrouping: false,
        maximumFractionDigits: String(value2).length,
        round: value2 < 0 ? "ceil" : "floor"
      };
    } else {
      config2 = this._getPrecisionConfig(formatConfig.precision);
    }
    if (format2 === "percent") {
      config2.style = "percent";
    } else if (format2 === "currency") {
      config2.style = "currency";
      config2.currency = formatConfig.currency || configMethod().defaultCurrency;
    }
    return config2;
  },
  _getPrecisionConfig: function(precision) {
    var config2;
    if (precision === null) {
      config2 = {
        minimumFractionDigits: 0,
        maximumFractionDigits: 20
      };
    } else {
      config2 = {
        minimumFractionDigits: precision || 0,
        maximumFractionDigits: precision || 0
      };
    }
    return config2;
  },
  format: function(value2, _format) {
    if (typeof value2 !== "number") {
      return value2;
    }
    _format = this._normalizeFormat(_format);
    if (_format.currency === "default") {
      _format.currency = configMethod().defaultCurrency;
    }
    if (!_format || typeof _format !== "function" && !_format.type && !_format.formatter) {
      return getFormatter$2(_format)(value2);
    }
    return this.callBase.apply(this, arguments);
  },
  _getCurrencySymbolInfo: function(currency) {
    var formatter = getCurrencyFormatter(currency);
    return this._extractCurrencySymbolInfo(formatter.format(0));
  },
  _extractCurrencySymbolInfo: function(currencyValueString) {
    var match2 = detectCurrencySymbolRegex.exec(currencyValueString) || [];
    var position2 = match2[1] ? "before" : "after";
    var symbol = match2[1] || match2[4] || "";
    var delimiter = match2[2] || match2[3] || "";
    return {
      position: position2,
      symbol,
      delimiter
    };
  },
  getCurrencySymbol: function(currency) {
    if (!currency) {
      currency = configMethod().defaultCurrency;
    }
    var symbolInfo = this._getCurrencySymbolInfo(currency);
    return {
      symbol: symbolInfo.symbol
    };
  },
  getOpenXmlCurrencyFormat: function(currency) {
    var targetCurrency = currency || configMethod().defaultCurrency;
    var currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
    var closestAccountingFormat = core.getValueByClosestLocale((locale2) => accountingFormats[locale2]);
    return openXmlCurrencyFormat(currencySymbol, closestAccountingFormat);
  }
};
var hasIntl$1 = typeof Intl !== "undefined";
var MAX_LARGE_NUMBER_POWER = 4;
var DECIMAL_BASE = 10;
var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
var LargeNumberFormatPostfixes = {
  1: "K",
  2: "M",
  3: "B",
  4: "T"
};
var LargeNumberFormatPowers = {
  largenumber: "auto",
  thousands: 1,
  millions: 2,
  billions: 3,
  trillions: 4
};
var numberLocalization = injector({
  engine: function() {
    return "base";
  },
  numericFormats: NUMERIC_FORMATS,
  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
  _parseNumberFormatString: function(formatType) {
    var formatObject = {};
    if (!formatType || typeof formatType !== "string") {
      return;
    }
    var formatList = formatType.toLowerCase().split(" ");
    each(formatList, (index2, value2) => {
      if (inArray(value2, NUMERIC_FORMATS) > -1) {
        formatObject.formatType = value2;
      } else if (value2 in LargeNumberFormatPowers) {
        formatObject.power = LargeNumberFormatPowers[value2];
      }
    });
    if (formatObject.power && !formatObject.formatType) {
      formatObject.formatType = "fixedpoint";
    }
    if (formatObject.formatType) {
      return formatObject;
    }
  },
  _calculateNumberPower: function(value2, base2, minPower, maxPower) {
    var number = Math.abs(value2);
    var power = 0;
    if (number > 1) {
      while (number && number >= base2 && (maxPower === void 0 || power < maxPower)) {
        power++;
        number /= base2;
      }
    } else if (number > 0 && number < 1) {
      while (number < 1 && (minPower === void 0 || power > minPower)) {
        power--;
        number *= base2;
      }
    }
    return power;
  },
  _getNumberByPower: function(number, power, base2) {
    var result = number;
    while (power > 0) {
      result /= base2;
      power--;
    }
    while (power < 0) {
      result *= base2;
      power++;
    }
    return result;
  },
  _formatNumber: function(value2, formatObject, formatConfig) {
    if (formatObject.power === "auto") {
      formatObject.power = this._calculateNumberPower(value2, 1e3, 0, MAX_LARGE_NUMBER_POWER);
    }
    if (formatObject.power) {
      value2 = this._getNumberByPower(value2, formatObject.power, 1e3);
    }
    var powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
    var result = this._formatNumberCore(value2, formatObject.formatType, formatConfig);
    result = result.replace(/(\d|.$)(\D*)$/, "$1" + powerPostfix + "$2");
    return result;
  },
  _formatNumberExponential: function(value2, formatConfig) {
    var power = this._calculateNumberPower(value2, DECIMAL_BASE);
    var number = this._getNumberByPower(value2, power, DECIMAL_BASE);
    if (formatConfig.precision === void 0) {
      formatConfig.precision = 1;
    }
    if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {
      power++;
      number /= DECIMAL_BASE;
    }
    var powString = (power >= 0 ? "+" : "") + power.toString();
    return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString;
  },
  _addZeroes: function(value2, precision) {
    var multiplier = Math.pow(10, precision);
    var sign2 = value2 < 0 ? "-" : "";
    value2 = (Math.abs(value2) * multiplier >>> 0) / multiplier;
    var result = value2.toString();
    while (result.length < precision) {
      result = "0" + result;
    }
    return sign2 + result;
  },
  _addGroupSeparators: function(value2) {
    var parts = value2.toString().split(".");
    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, configMethod().thousandsSeparator) + (parts[1] ? configMethod().decimalSeparator + parts[1] : "");
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if (format2 === "exponential") {
      return this._formatNumberExponential(value2, formatConfig);
    }
    if (format2 !== "decimal" && formatConfig.precision !== null) {
      formatConfig.precision = formatConfig.precision || 0;
    }
    if (format2 === "percent") {
      value2 *= 100;
    }
    if (formatConfig.precision !== void 0) {
      if (format2 === "decimal") {
        value2 = this._addZeroes(value2, formatConfig.precision);
      } else {
        value2 = formatConfig.precision === null ? value2.toPrecision() : toFixed(value2, formatConfig.precision);
      }
    }
    if (format2 !== "decimal") {
      value2 = this._addGroupSeparators(value2);
    } else {
      value2 = value2.toString().replace(".", configMethod().decimalSeparator);
    }
    if (format2 === "percent") {
      value2 += "%";
    }
    return value2;
  },
  _normalizeFormat: function(format2) {
    if (!format2) {
      return {};
    }
    if (typeof format2 === "function") {
      return format2;
    }
    if (!isPlainObject(format2)) {
      format2 = {
        type: format2
      };
    }
    return format2;
  },
  _getSeparators: function() {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function() {
    return this.format(1e4, "fixedPoint")[2];
  },
  getDecimalSeparator: function() {
    return this.format(1.2, {
      type: "fixedPoint",
      precision: 1
    })[1];
  },
  convertDigits: function(value2, toStandard) {
    var digits = this.format(90, "decimal");
    if (typeof value2 !== "string" || digits[1] === "0") {
      return value2;
    }
    var fromFirstDigit = toStandard ? digits[1] : "0";
    var toFirstDigit = toStandard ? "0" : digits[1];
    var fromLastDigit = toStandard ? digits[0] : "9";
    var regExp = new RegExp("[" + fromFirstDigit + "-" + fromLastDigit + "]", "g");
    return value2.replace(regExp, (char) => String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0))));
  },
  getNegativeEtalonRegExp: function(format2) {
    var separators = this._getSeparators();
    var digitalRegExp = new RegExp("[0-9" + escapeRegExp(separators.decimalSeparator + separators.thousandsSeparator) + "]+", "g");
    var negativeEtalon = this.format(-1, format2).replace(digitalRegExp, "1");
    ["\\", "(", ")", "[", "]", "*", "+", "$", "^", "?", "|", "{", "}"].forEach((char) => {
      negativeEtalon = negativeEtalon.replace(char, "\\".concat(char));
    });
    negativeEtalon = negativeEtalon.replace(" ", "\\s");
    negativeEtalon = negativeEtalon.replace("1", ".+");
    return new RegExp(negativeEtalon, "g");
  },
  getSign: function(text, format2) {
    if (text.replace(/[^0-9-]/g, "").charAt(0) === "-") {
      return -1;
    }
    if (!format2) {
      return 1;
    }
    var negativeEtalon = this.getNegativeEtalonRegExp(format2);
    return text.match(negativeEtalon) ? -1 : 1;
  },
  format: function(value2, _format) {
    if (typeof value2 !== "number") {
      return value2;
    }
    if (typeof _format === "number") {
      return value2;
    }
    _format = _format && _format.formatter || _format;
    if (typeof _format === "function") {
      return _format(value2);
    }
    _format = this._normalizeFormat(_format);
    if (!_format.type) {
      _format.type = "decimal";
    }
    var numberConfig = this._parseNumberFormatString(_format.type);
    if (!numberConfig) {
      var formatterConfig = this._getSeparators();
      formatterConfig.unlimitedIntegerDigits = _format.unlimitedIntegerDigits;
      return this.convertDigits(getFormatter$3(_format.type, formatterConfig)(value2));
    }
    return this._formatNumber(value2, numberConfig, _format);
  },
  parse: function(text, format2) {
    if (!text) {
      return;
    }
    if (format2 && format2.parser) {
      return format2.parser(text);
    }
    text = this.convertDigits(text, true);
    if (format2 && typeof format2 !== "string") {
      errors$2.log("W0011");
    }
    var decimalSeparator = this.getDecimalSeparator();
    var regExp = new RegExp("[^0-9" + escapeRegExp(decimalSeparator) + "]", "g");
    var cleanedText = text.replace(regExp, "").replace(decimalSeparator, ".").replace(/\.$/g, "");
    if (cleanedText === "." || cleanedText === "") {
      return null;
    }
    if (this._calcSignificantDigits(cleanedText) > 15) {
      return NaN;
    }
    var parsed = +cleanedText * this.getSign(text, format2);
    format2 = this._normalizeFormat(format2);
    var formatConfig = this._parseNumberFormatString(format2.type);
    var power = formatConfig === null || formatConfig === void 0 ? void 0 : formatConfig.power;
    if (power) {
      if (power === "auto") {
        var match2 = text.match(/\d(K|M|B|T)/);
        if (match2) {
          power = find(Object.keys(LargeNumberFormatPostfixes), (power2) => LargeNumberFormatPostfixes[power2] === match2[1]);
        }
      }
      parsed *= Math.pow(10, 3 * power);
    }
    if ((formatConfig === null || formatConfig === void 0 ? void 0 : formatConfig.formatType) === "percent") {
      parsed /= 100;
    }
    return parsed;
  },
  _calcSignificantDigits: function(text) {
    var [integer, fractional] = text.split(".");
    var calcDigitsAfterLeadingZeros = (digits) => {
      var index2 = -1;
      for (var i = 0; i < digits.length; i++) {
        if (digits[i] !== "0") {
          index2 = i;
          break;
        }
      }
      return index2 > -1 ? digits.length - index2 : 0;
    };
    var result = 0;
    if (integer) {
      result += calcDigitsAfterLeadingZeros(integer.split(""));
    }
    if (fractional) {
      result += calcDigitsAfterLeadingZeros(fractional.split("").reverse());
    }
    return result;
  }
});
numberLocalization.inject(currencyLocalization);
if (hasIntl$1) {
  numberLocalization.inject(intlNumberLocalization);
}
function leftPad(text, length) {
  while (text.length < length) {
    text = "0" + text;
  }
  return text;
}
var FORMAT_TYPES$1 = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var LDML_FORMATTERS = {
  y: function(date, count, useUtc) {
    var year = date[useUtc ? "getUTCFullYear" : "getFullYear"]();
    if (count === 2) {
      year %= 100;
    }
    return leftPad(year.toString(), count);
  },
  M: function(date, count, useUtc, dateParts) {
    var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    var formatType = FORMAT_TYPES$1[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "format")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  L: function(date, count, useUtc, dateParts) {
    var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    var formatType = FORMAT_TYPES$1[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "standalone")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  Q: function(date, count, useUtc, dateParts) {
    var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    var quarter = Math.floor(month / 3);
    var formatType = FORMAT_TYPES$1[count];
    if (formatType) {
      return dateParts.getQuarterNames(formatType)[quarter];
    }
    return leftPad((quarter + 1).toString(), Math.min(count, 2));
  },
  E: function(date, count, useUtc, dateParts) {
    var day = date[useUtc ? "getUTCDay" : "getDay"]();
    var formatType = FORMAT_TYPES$1[count < 3 ? 3 : count];
    return dateParts.getDayNames(formatType)[day];
  },
  a: function(date, count, useUtc, dateParts) {
    var hours = date[useUtc ? "getUTCHours" : "getHours"]();
    var period = hours < 12 ? 0 : 1;
    var formatType = FORMAT_TYPES$1[count];
    return dateParts.getPeriodNames(formatType)[period];
  },
  d: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCDate" : "getDate"]().toString(), Math.min(count, 2));
  },
  H: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCHours" : "getHours"]().toString(), Math.min(count, 2));
  },
  h: function(date, count, useUtc) {
    var hours = date[useUtc ? "getUTCHours" : "getHours"]();
    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
  },
  m: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(count, 2));
  },
  s: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(count, 2));
  },
  S: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, count);
  },
  x: function(date, count, useUtc) {
    var timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
    var signPart = timezoneOffset > 0 ? "-" : "+";
    var timezoneOffsetAbs = Math.abs(timezoneOffset);
    var hours = Math.floor(timezoneOffsetAbs / 60);
    var minutes = timezoneOffsetAbs % 60;
    var hoursPart = leftPad(hours.toString(), 2);
    var minutesPart = leftPad(minutes.toString(), 2);
    return signPart + hoursPart + (count >= 3 ? ":" : "") + (count > 1 || minutes ? minutesPart : "");
  },
  X: function(date, count, useUtc) {
    if (useUtc || !date.getTimezoneOffset()) {
      return "Z";
    }
    return LDML_FORMATTERS.x(date, count, useUtc);
  },
  Z: function(date, count, useUtc) {
    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
  }
};
var getFormatter$1 = function(format2, dateParts) {
  return function(date) {
    var charIndex;
    var formatter;
    var char;
    var charCount = 0;
    var isEscaping = false;
    var isCurrentCharEqualsNext;
    var result = "";
    if (!date) {
      return null;
    }
    if (!format2) {
      return date;
    }
    var useUtc = format2[format2.length - 1] === "Z" || format2.slice(-3) === "'Z'";
    for (charIndex = 0; charIndex < format2.length; charIndex++) {
      char = format2[charIndex];
      formatter = LDML_FORMATTERS[char];
      isCurrentCharEqualsNext = char === format2[charIndex + 1];
      charCount++;
      if (!isCurrentCharEqualsNext) {
        if (formatter && !isEscaping) {
          result += formatter(date, charCount, useUtc, dateParts);
        }
        charCount = 0;
      }
      if (char === "'" && !isCurrentCharEqualsNext) {
        isEscaping = !isEscaping;
      } else if (isEscaping || !formatter) {
        result += char;
      }
      if (char === "'" && isCurrentCharEqualsNext) {
        charIndex++;
      }
    }
    return result;
  };
};
var ARABIC_COMMA = "\u060C";
var FORMAT_SEPARATORS = " .,:;/\\<>()-[]" + ARABIC_COMMA;
var AM_PM_PATTERN = ". m.";
var checkDigit = function(char) {
  var code = char && numberLocalization.convertDigits(char, false).charCodeAt(0);
  var zeroCode = numberLocalization.convertDigits("0", false).charCodeAt(0);
  return zeroCode <= code && code < zeroCode + 10;
};
var checkPatternContinue = function(text, patterns, index2, isDigit) {
  var char = text[index2];
  var nextChar = text[index2 + 1];
  if (!isDigit) {
    if (char === "." || char === " " && text.slice(index2 - 1, index2 + 3) === AM_PM_PATTERN) {
      return true;
    }
    if (char === "-" && !checkDigit(nextChar)) {
      return true;
    }
  }
  var isDigitChanged = isDigit && patterns.some((pattern) => text[index2] !== pattern[index2]);
  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);
};
var getPatternStartIndex = function(defaultPattern, index2) {
  if (!checkDigit(defaultPattern[index2])) {
    while (index2 > 0 && !checkDigit(defaultPattern[index2 - 1]) && (defaultPattern[index2 - 1] === "." || FORMAT_SEPARATORS.indexOf(defaultPattern[index2 - 1]) < 0)) {
      index2--;
    }
  }
  return index2;
};
var getDifference = function(defaultPattern, patterns, processedIndexes, isDigit) {
  var i = 0;
  var result = [];
  var patternsFilter = function(pattern) {
    return defaultPattern[i] !== pattern[i] && (isDigit === void 0 || checkDigit(defaultPattern[i]) === isDigit);
  };
  if (!Array.isArray(patterns)) {
    patterns = [patterns];
  }
  for (i = 0; i < defaultPattern.length; i++) {
    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
      i = getPatternStartIndex(defaultPattern, i);
      do {
        isDigit = checkDigit(defaultPattern[i]);
        if (!result.length && !isDigit && checkDigit(patterns[0][i])) {
          break;
        }
        result.push(i);
        processedIndexes.unshift(i);
        i++;
      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));
      break;
    }
  }
  if (result.length === 1 && (defaultPattern[processedIndexes[0] - 1] === "0" || defaultPattern[processedIndexes[0] - 1] === "\u0660")) {
    processedIndexes.unshift(processedIndexes[0] - 1);
  }
  return result;
};
var replaceCharsCore = function(pattern, indexes, char, patternPositions) {
  var baseCharIndex = indexes[0];
  var patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
  indexes.forEach(function(_2, index2) {
    pattern = pattern.substr(0, patternIndex + index2) + (char.length > 1 ? char[index2] : char) + pattern.substr(patternIndex + index2 + 1);
  });
  if (indexes.length === 1) {
    pattern = pattern.replace("0" + char, char + char);
    pattern = pattern.replace("\u0660" + char, char + char);
  }
  return pattern;
};
var replaceChars = function(pattern, indexes, char, patternPositions) {
  var i;
  var index2;
  var patternIndex;
  if (!checkDigit(pattern[indexes[0]] || "0")) {
    var letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
    while (indexes.length > letterCount) {
      index2 = indexes.pop();
      patternIndex = patternPositions[index2];
      patternPositions[index2] = -1;
      for (i = index2 + 1; i < patternPositions.length; i++) {
        patternPositions[i]--;
      }
      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);
    }
    index2 = indexes[indexes.length - 1] + 1, patternIndex = index2 < patternPositions.length ? patternPositions[index2] : index2;
    while (indexes.length < letterCount) {
      indexes.push(indexes[indexes.length - 1] + 1);
      for (i = index2; i < patternPositions.length; i++) {
        patternPositions[i]++;
      }
      pattern = pattern.substr(0, patternIndex) + " " + pattern.substr(patternIndex);
    }
  }
  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
  return pattern;
};
var formatValue$2 = function(value2, formatter) {
  if (Array.isArray(value2)) {
    return value2.map(function(value3) {
      return (formatter(value3) || "").toString();
    });
  }
  return (formatter(value2) || "").toString();
};
var ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;
var escapeChars = function(pattern, defaultPattern, processedIndexes, patternPositions) {
  var escapeIndexes = defaultPattern.split("").map(function(char, index2) {
    if (processedIndexes.indexOf(index2) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || char === "'")) {
      return patternPositions[index2];
    }
    return -1;
  });
  pattern = pattern.split("").map(function(char, index2) {
    var result = char;
    var isCurrentCharEscaped = escapeIndexes.indexOf(index2) >= 0;
    var isPrevCharEscaped = index2 > 0 && escapeIndexes.indexOf(index2 - 1) >= 0;
    var isNextCharEscaped = escapeIndexes.indexOf(index2 + 1) >= 0;
    if (isCurrentCharEscaped) {
      if (!isPrevCharEscaped) {
        result = "'" + result;
      }
      if (!isNextCharEscaped) {
        result += "'";
      }
    }
    return result;
  }).join("");
  return pattern;
};
var getFormat = function(formatter) {
  var processedIndexes = [];
  var defaultPattern = formatValue$2(new Date(2009, 8, 8, 6, 5, 4), formatter);
  var patternPositions = defaultPattern.split("").map(function(_2, index2) {
    return index2;
  });
  var result = defaultPattern;
  var replacedPatterns = {};
  var datePatterns = [{
    date: new Date(2009, 8, 8, 6, 5, 4, 111),
    pattern: "S"
  }, {
    date: new Date(2009, 8, 8, 6, 5, 2),
    pattern: "s"
  }, {
    date: new Date(2009, 8, 8, 6, 2, 4),
    pattern: "m"
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "H",
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 2, 5, 4),
    pattern: "h",
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "a",
    isDigit: false
  }, {
    date: new Date(2009, 8, 1, 6, 5, 4),
    pattern: "d"
  }, {
    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
    pattern: "E"
  }, {
    date: new Date(2009, 9, 6, 6, 5, 4),
    pattern: "M"
  }, {
    date: new Date(1998, 8, 8, 6, 5, 4),
    pattern: "y"
  }];
  if (!result) {
    return;
  }
  datePatterns.forEach(function(test) {
    var diff = getDifference(defaultPattern, formatValue$2(test.date, formatter), processedIndexes, test.isDigit);
    var pattern = test.pattern === "M" && !replacedPatterns.d ? "L" : test.pattern;
    result = replaceChars(result, diff, pattern, patternPositions);
    replacedPatterns[pattern] = diff.length;
  });
  result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);
  if (processedIndexes.length) {
    return result;
  }
};
var FORMAT_TYPES = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var monthRegExpGenerator = function(count, dateParts) {
  if (count > 2) {
    return Object.keys(FORMAT_TYPES).map(function(count2) {
      return ["format", "standalone"].map(function(type2) {
        return dateParts.getMonthNames(FORMAT_TYPES[count2], type2).join("|");
      }).join("|");
    }).join("|");
  }
  return count === 2 ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
};
var PATTERN_REGEXPS = {
  ":": function(count, dateParts) {
    var countSuffix = count > 1 ? "{".concat(count, "}") : "";
    return "\\".concat(dateParts.getTimeSeparator()).concat(countSuffix);
  },
  y: function(count) {
    return count === 2 ? "[0-9]{".concat(count, "}") : "[0-9]+?";
  },
  M: monthRegExpGenerator,
  L: monthRegExpGenerator,
  Q: function(count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], "format").join("|");
    }
    return "0?[1-4]";
  },
  E: function(count, dateParts) {
    return "\\D*";
  },
  a: function(count, dateParts) {
    return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], "format").join("|");
  },
  d: function(count) {
    return count === 2 ? "3[01]|[12][0-9]|0?[1-9]" : "0??[1-9]|[12][0-9]|3[01]";
  },
  H: function(count) {
    return count === 2 ? "2[0-3]|1[0-9]|0?[0-9]" : "0??[0-9]|1[0-9]|2[0-3]";
  },
  h: function(count) {
    return count === 2 ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
  },
  m: function(count) {
    return count === 2 ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  s: function(count) {
    return count === 2 ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  S: function(count) {
    return "[0-9]{1,".concat(count, "}");
  },
  w: function(count) {
    return count === 2 ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  }
};
var parseNumber = Number;
var caseInsensitiveIndexOf = function(array, value2) {
  return array.map((item) => item.toLowerCase()).indexOf(value2.toLowerCase());
};
var monthPatternParser = function(text, count, dateParts) {
  if (count > 2) {
    return ["format", "standalone"].map(function(type2) {
      return Object.keys(FORMAT_TYPES).map(function(count2) {
        var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count2], type2);
        return caseInsensitiveIndexOf(monthNames, text);
      });
    }).reduce(function(a, b) {
      return a.concat(b);
    }).filter(function(index2) {
      return index2 >= 0;
    })[0];
  }
  return parseNumber(text) - 1;
};
var PATTERN_PARSERS = {
  y: function(text, count) {
    var year = parseNumber(text);
    if (count === 2) {
      return year < 30 ? 2e3 + year : 1900 + year;
    }
    return year;
  },
  M: monthPatternParser,
  L: monthPatternParser,
  Q: function(text, count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], "format").indexOf(text);
    }
    return parseNumber(text) - 1;
  },
  E: function(text, count, dateParts) {
    var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], "format");
    return caseInsensitiveIndexOf(dayNames, text);
  },
  a: function(text, count, dateParts) {
    var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], "format");
    return caseInsensitiveIndexOf(periodNames, text);
  },
  d: parseNumber,
  H: parseNumber,
  h: parseNumber,
  m: parseNumber,
  s: parseNumber,
  S: function(text, count) {
    count = Math.max(count, 3);
    text = text.slice(0, 3);
    while (count < 3) {
      text += "0";
      count++;
    }
    return parseNumber(text);
  }
};
var ORDERED_PATTERNS = ["y", "M", "d", "h", "m", "s", "S"];
var PATTERN_SETTERS = {
  y: "setFullYear",
  M: "setMonth",
  L: "setMonth",
  a: function(date, value2, datePartValues) {
    var hours = date.getHours();
    var hourPartValue = datePartValues.h;
    if (hourPartValue !== void 0 && hourPartValue !== hours) {
      hours--;
    }
    if (!value2 && hours === 12) {
      hours = 0;
    } else if (value2 && hours !== 12) {
      hours += 12;
    }
    date.setHours(hours);
  },
  d: "setDate",
  H: "setHours",
  h: "setHours",
  m: "setMinutes",
  s: "setSeconds",
  S: "setMilliseconds"
};
var getSameCharCount = function(text, index2) {
  var char = text[index2];
  if (!char) {
    return 0;
  }
  var count = 0;
  do {
    index2++;
    count++;
  } while (text[index2] === char);
  return count;
};
var createPattern = function(char, count) {
  var result = "";
  for (var i = 0; i < count; i++) {
    result += char;
  }
  return result;
};
var getRegExpInfo = function(format2, dateParts) {
  var regexpText = "";
  var stubText = "";
  var isEscaping;
  var patterns = [];
  var addPreviousStub = function() {
    if (stubText) {
      patterns.push("'".concat(stubText, "'"));
      regexpText += "".concat(escapeRegExp(stubText), ")");
      stubText = "";
    }
  };
  for (var i = 0; i < format2.length; i++) {
    var char = format2[i];
    var isEscapeChar = char === "'";
    var regexpPart = PATTERN_REGEXPS[char];
    if (isEscapeChar) {
      isEscaping = !isEscaping;
      if (format2[i - 1] !== "'") {
        continue;
      }
    }
    if (regexpPart && !isEscaping) {
      var count = getSameCharCount(format2, i);
      var pattern = createPattern(char, count);
      addPreviousStub();
      patterns.push(pattern);
      regexpText += "(".concat(regexpPart(count, dateParts), ")");
      i += count - 1;
    } else {
      if (!stubText) {
        regexpText += "(";
      }
      stubText += char;
    }
  }
  addPreviousStub();
  if (!isPossibleForParsingFormat(patterns)) {
    logger.warn("The following format may be parsed incorrectly: ".concat(format2, "."));
  }
  return {
    patterns,
    regexp: new RegExp("^".concat(regexpText, "$"), "i")
  };
};
var digitFieldSymbols = ["d", "H", "h", "m", "s", "w", "M", "L", "Q"];
var isPossibleForParsingFormat = function(patterns) {
  var isDigitPattern = (pattern) => {
    if (!pattern) {
      return false;
    }
    var char = pattern[0];
    var yearOrFractionalSecond = char === "y" || char === "S";
    var digitFieldSymbol = digitFieldSymbols.indexOf(char) !== -1;
    return yearOrFractionalSecond || digitFieldSymbol && pattern.length < 3;
  };
  var possibleForParsing = true;
  var ambiguousDigitPatternsCount = 0;
  return patterns.every((pattern, index2, patterns2) => {
    if (isDigitPattern(pattern)) {
      if (((pattern2) => pattern2[0] !== "S" && pattern2.length !== 2)(pattern)) {
        possibleForParsing = ++ambiguousDigitPatternsCount < 2;
      }
      if (!isDigitPattern(patterns2[index2 + 1])) {
        ambiguousDigitPatternsCount = 0;
      }
    }
    return possibleForParsing;
  });
};
var setPatternPart = function(date, pattern, text, dateParts, datePartValues) {
  var patternChar = pattern[0];
  var partSetter = PATTERN_SETTERS[patternChar];
  var partParser = PATTERN_PARSERS[patternChar];
  if (partSetter && partParser) {
    var value2 = partParser(text, pattern.length, dateParts);
    datePartValues[pattern] = value2;
    if (date[partSetter]) {
      date[partSetter](value2);
    } else {
      partSetter(date, value2, datePartValues);
    }
  }
};
var setPatternPartFromNow = function(date, pattern, now) {
  var setterName = PATTERN_SETTERS[pattern];
  var getterName = "g" + setterName.substr(1);
  var value2 = now[getterName]();
  date[setterName](value2);
};
var getShortPatterns = function(fullPatterns) {
  return fullPatterns.map(function(pattern) {
    if (pattern[0] === "'") {
      return "";
    } else {
      return pattern[0] === "H" ? "h" : pattern[0];
    }
  });
};
var getMaxOrderedPatternIndex = function(patterns) {
  var indexes = patterns.map(function(pattern) {
    return ORDERED_PATTERNS.indexOf(pattern);
  });
  return Math.max.apply(Math, indexes);
};
var getOrderedFormatPatterns = function(formatPatterns) {
  var otherPatterns = formatPatterns.filter(function(pattern) {
    return ORDERED_PATTERNS.indexOf(pattern) < 0;
  });
  return ORDERED_PATTERNS.concat(otherPatterns);
};
var getParser = function(format2, dateParts) {
  var regExpInfo = getRegExpInfo(format2, dateParts);
  return function(text) {
    var regExpResult = regExpInfo.regexp.exec(text);
    if (regExpResult) {
      var now = new Date();
      var date = new Date(now.getFullYear(), 0, 1);
      var formatPatterns = getShortPatterns(regExpInfo.patterns);
      var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
      var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
      var datePartValues = {};
      orderedFormatPatterns.forEach(function(pattern, index2) {
        if (!pattern || index2 < ORDERED_PATTERNS.length && index2 > maxPatternIndex) {
          return;
        }
        var patternIndex = formatPatterns.indexOf(pattern);
        if (patternIndex >= 0) {
          var regExpPattern = regExpInfo.patterns[patternIndex];
          var regExpText = regExpResult[patternIndex + 1];
          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
        } else {
          setPatternPartFromNow(date, pattern, now);
        }
      });
      return date;
    }
    return null;
  };
};
var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var PERIODS = ["AM", "PM"];
var QUARTERS = ["Q1", "Q2", "Q3", "Q4"];
var cutCaptions = (captions, format2) => {
  var lengthByFormat = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return map(captions, (caption) => caption.substr(0, lengthByFormat[format2]));
};
var defaultDateNames = {
  getMonthNames: function(format2) {
    return cutCaptions(MONTHS, format2);
  },
  getDayNames: function(format2) {
    return cutCaptions(DAYS, format2);
  },
  getQuarterNames: function(format2) {
    return QUARTERS;
  },
  getPeriodNames: function(format2) {
    return PERIODS;
  }
};
var firstDayOfWeekData = {
  "af-NA": 1,
  agq: 1,
  ak: 1,
  ar: 6,
  "ar-EH": 1,
  "ar-ER": 1,
  "ar-KM": 1,
  "ar-LB": 1,
  "ar-MA": 1,
  "ar-MR": 1,
  "ar-PS": 1,
  "ar-SO": 1,
  "ar-SS": 1,
  "ar-TD": 1,
  "ar-TN": 1,
  asa: 1,
  ast: 1,
  az: 1,
  "az-Cyrl": 1,
  bas: 1,
  be: 1,
  bem: 1,
  bez: 1,
  bg: 1,
  bm: 1,
  br: 1,
  bs: 1,
  "bs-Cyrl": 1,
  ca: 1,
  ce: 1,
  cgg: 1,
  ckb: 6,
  cs: 1,
  cy: 1,
  da: 1,
  de: 1,
  dje: 1,
  dsb: 1,
  dua: 1,
  dyo: 1,
  ee: 1,
  el: 1,
  "en-001": 1,
  "en-AE": 6,
  "en-BI": 1,
  "en-MP": 1,
  "en-SD": 6,
  eo: 1,
  es: 1,
  et: 1,
  eu: 1,
  ewo: 1,
  fa: 6,
  ff: 1,
  "ff-Adlm": 1,
  fi: 1,
  fo: 1,
  fr: 1,
  "fr-DJ": 6,
  "fr-DZ": 6,
  "fr-SY": 6,
  fur: 1,
  fy: 1,
  ga: 1,
  gd: 1,
  gl: 1,
  gsw: 1,
  gv: 1,
  ha: 1,
  hr: 1,
  hsb: 1,
  hu: 1,
  hy: 1,
  ia: 1,
  ig: 1,
  is: 1,
  it: 1,
  jgo: 1,
  jmc: 1,
  ka: 1,
  kab: 6,
  kde: 1,
  kea: 1,
  khq: 1,
  kk: 1,
  kkj: 1,
  kl: 1,
  "ko-KP": 1,
  ksb: 1,
  ksf: 1,
  ksh: 1,
  ku: 1,
  kw: 1,
  ky: 1,
  lag: 1,
  lb: 1,
  lg: 1,
  ln: 1,
  lrc: 6,
  lt: 1,
  lu: 1,
  lv: 1,
  "mas-TZ": 1,
  mfe: 1,
  mg: 1,
  mgo: 1,
  mi: 1,
  mk: 1,
  mn: 1,
  ms: 1,
  mua: 1,
  mzn: 6,
  naq: 1,
  nds: 1,
  nl: 1,
  nmg: 1,
  nnh: 1,
  no: 1,
  nus: 1,
  nyn: 1,
  os: 1,
  pcm: 1,
  pl: 1,
  ps: 6,
  "pt-AO": 1,
  "pt-CH": 1,
  "pt-CV": 1,
  "pt-GQ": 1,
  "pt-GW": 1,
  "pt-LU": 1,
  "pt-ST": 1,
  "pt-TL": 1,
  "qu-BO": 1,
  "qu-EC": 1,
  rm: 1,
  rn: 1,
  ro: 1,
  rof: 1,
  ru: 1,
  rw: 1,
  rwk: 1,
  sah: 1,
  sbp: 1,
  se: 1,
  ses: 1,
  sg: 1,
  shi: 1,
  "shi-Latn": 1,
  si: 1,
  sk: 1,
  sl: 1,
  smn: 1,
  so: 1,
  "so-DJ": 6,
  sq: 1,
  sr: 1,
  "sr-Latn": 1,
  sv: 1,
  sw: 1,
  "ta-LK": 1,
  "ta-MY": 1,
  teo: 1,
  tg: 1,
  "ti-ER": 1,
  tk: 1,
  to: 1,
  tr: 1,
  tt: 1,
  twq: 1,
  tzm: 1,
  uk: 1,
  uz: 1,
  "uz-Arab": 6,
  "uz-Cyrl": 1,
  vai: 1,
  "vai-Latn": 1,
  vi: 1,
  vun: 1,
  wae: 1,
  wo: 1,
  xog: 1,
  yav: 1,
  yi: 1,
  yo: 1,
  zgh: 1
};
var SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;
var getIntlFormatter = (format2) => (date) => {
  if (!format2.timeZoneName) {
    var year = date.getFullYear();
    var recognizableAsTwentyCentury = String(year).length < 3;
    var temporaryYearValue = recognizableAsTwentyCentury ? year + 400 : year;
    var utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
    if (recognizableAsTwentyCentury) {
      utcDate.setFullYear(year);
    }
    var utcFormat = extend({
      timeZone: "UTC"
    }, format2);
    return formatDateTime(utcDate, utcFormat);
  }
  return formatDateTime(date, format2);
};
var formattersCache = {};
var getFormatter = (format2) => {
  var key = core.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.DateTimeFormat(core.locale(), format2).format;
  }
  return formattersCache[key];
};
function formatDateTime(date, format2) {
  return getFormatter(format2)(date).replace(SYMBOLS_TO_REMOVE_REGEX, "");
}
var formatNumber = (number) => new Intl.NumberFormat(core.locale()).format(number);
var getAlternativeNumeralsMap = (() => {
  var numeralsMapCache = {};
  return (locale2) => {
    if (!(locale2 in numeralsMapCache)) {
      if (formatNumber(0) === "0") {
        numeralsMapCache[locale2] = false;
        return false;
      }
      numeralsMapCache[locale2] = {};
      for (var i = 0; i < 10; ++i) {
        numeralsMapCache[locale2][formatNumber(i)] = i;
      }
    }
    return numeralsMapCache[locale2];
  };
})();
var normalizeNumerals = (dateString) => {
  var alternativeNumeralsMap = getAlternativeNumeralsMap(core.locale());
  if (!alternativeNumeralsMap) {
    return dateString;
  }
  return dateString.split("").map((sign2) => sign2 in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign2]) : sign2).join("");
};
var removeLeadingZeroes = (str) => str.replace(/(\D)0+(\d)/g, "$1$2");
var dateStringEquals = (actual, expected) => removeLeadingZeroes(actual) === removeLeadingZeroes(expected);
var normalizeMonth = (text) => text.replace("d\u2019", "de ");
var intlFormats = {
  day: {
    day: "numeric"
  },
  dayofweek: {
    weekday: "long"
  },
  longdate: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  longdatelongtime: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  longtime: {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  month: {
    month: "long"
  },
  monthandday: {
    month: "long",
    day: "numeric"
  },
  monthandyear: {
    year: "numeric",
    month: "long"
  },
  shortdate: {},
  shorttime: {
    hour: "numeric",
    minute: "numeric"
  },
  shortyear: {
    year: "2-digit"
  },
  year: {
    year: "numeric"
  }
};
Object.defineProperty(intlFormats, "shortdateshorttime", {
  get: function() {
    var defaultOptions = Intl.DateTimeFormat(core.locale()).resolvedOptions();
    return {
      year: defaultOptions.year,
      month: defaultOptions.month,
      day: defaultOptions.day,
      hour: "numeric",
      minute: "numeric"
    };
  }
});
var getIntlFormat = (format2) => typeof format2 === "string" && intlFormats[format2.toLowerCase()];
var monthNameStrategies = {
  standalone: function(monthIndex, monthFormat) {
    var date = new Date(1999, monthIndex, 13, 1);
    var dateString = getIntlFormatter({
      month: monthFormat
    })(date);
    return dateString;
  },
  format: function(monthIndex, monthFormat) {
    var date = new Date(0, monthIndex, 13, 1);
    var dateString = normalizeMonth(getIntlFormatter({
      day: "numeric",
      month: monthFormat
    })(date));
    var parts = dateString.split(" ").filter((part) => part.indexOf("13") < 0);
    if (parts.length === 1) {
      return parts[0];
    } else if (parts.length === 2) {
      return parts[0].length > parts[1].length ? parts[0] : parts[1];
    }
    return monthNameStrategies.standalone(monthIndex, monthFormat);
  }
};
var intlDateLocalization = {
  engine: function() {
    return "intl";
  },
  getMonthNames: function(format2, type2) {
    var monthFormat = {
      wide: "long",
      abbreviated: "short",
      narrow: "narrow"
    }[format2 || "wide"];
    type2 = type2 === "format" ? type2 : "standalone";
    return Array.apply(null, new Array(12)).map((_2, monthIndex) => monthNameStrategies[type2](monthIndex, monthFormat));
  },
  getDayNames: function(format2) {
    var result = ((format3) => Array.apply(null, new Array(7)).map((_2, dayIndex) => getIntlFormatter({
      weekday: format3
    })(new Date(0, 0, dayIndex))))({
      wide: "long",
      abbreviated: "short",
      short: "narrow",
      narrow: "narrow"
    }[format2 || "wide"]);
    return result;
  },
  getPeriodNames: function() {
    var hour12Formatter = getIntlFormatter({
      hour: "numeric",
      hour12: true
    });
    return [1, 13].map((hours) => {
      var hourNumberText = formatNumber(1);
      var timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);
      if (timeParts.length !== 2) {
        return "";
      }
      var biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
      return biggerPart.trim();
    });
  },
  format: function(date, _format) {
    if (!date) {
      return;
    }
    if (!_format) {
      return date;
    }
    if (typeof _format !== "function" && !_format.formatter) {
      _format = _format.type || _format;
    }
    var intlFormat = getIntlFormat(_format);
    if (intlFormat) {
      return getIntlFormatter(intlFormat)(date);
    }
    var formatType = typeof _format;
    if (_format.formatter || formatType === "function" || formatType === "string") {
      return this.callBase.apply(this, arguments);
    }
    return getIntlFormatter(_format)(date);
  },
  parse: function(dateString, format2) {
    var formatter;
    if (format2 && !format2.parser && typeof dateString === "string") {
      dateString = normalizeMonth(dateString);
      formatter = (date) => normalizeMonth(this.format(date, format2));
    }
    return this.callBase(dateString, formatter || format2);
  },
  _parseDateBySimpleFormat: function(dateString, format2) {
    dateString = normalizeNumerals(dateString);
    var formatParts = this.getFormatParts(format2);
    var dateParts = dateString.split(/\D+/).filter((part) => part.length > 0);
    if (formatParts.length !== dateParts.length) {
      return;
    }
    var dateArgs = this._generateDateArgs(formatParts, dateParts);
    var constructValidDate = (ampmShift) => {
      var parsedDate = ((dateArgs2, ampmShift2) => {
        var hoursShift = ampmShift2 ? 12 : 0;
        return new Date(dateArgs2.year, dateArgs2.month, dateArgs2.day, (dateArgs2.hours + hoursShift) % 24, dateArgs2.minutes, dateArgs2.seconds);
      })(dateArgs, ampmShift);
      if (dateStringEquals(normalizeNumerals(this.format(parsedDate, format2)), dateString)) {
        return parsedDate;
      }
    };
    return constructValidDate(false) || constructValidDate(true);
  },
  _generateDateArgs: function(formatParts, dateParts) {
    var currentDate = new Date();
    var dateArgs = {
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(),
      day: currentDate.getDate(),
      hours: 0,
      minutes: 0,
      seconds: 0
    };
    formatParts.forEach((formatPart, index2) => {
      var datePart = dateParts[index2];
      var parsed = parseInt(datePart, 10);
      if (formatPart === "month") {
        parsed -= 1;
      }
      dateArgs[formatPart] = parsed;
    });
    return dateArgs;
  },
  formatUsesMonthName: function(format2) {
    if (typeof format2 === "object" && !(format2.type || format2.format)) {
      return format2.month === "long";
    }
    return this.callBase.apply(this, arguments);
  },
  formatUsesDayName: function(format2) {
    if (typeof format2 === "object" && !(format2.type || format2.format)) {
      return format2.weekday === "long";
    }
    return this.callBase.apply(this, arguments);
  },
  getTimeSeparator: function() {
    return normalizeNumerals(formatDateTime(new Date(2001, 1, 1, 11, 11), {
      hour: "numeric",
      minute: "numeric",
      hour12: false
    })).replace(/\d/g, "");
  },
  getFormatParts: function(format2) {
    if (typeof format2 === "string") {
      return this.callBase(format2);
    }
    var intlFormat = extend({}, intlFormats[format2.toLowerCase()]);
    var date = new Date(2001, 2, 4, 5, 6, 7);
    var formattedDate = getIntlFormatter(intlFormat)(date);
    formattedDate = normalizeNumerals(formattedDate);
    return [{
      name: "year",
      value: 1
    }, {
      name: "month",
      value: 3
    }, {
      name: "day",
      value: 4
    }, {
      name: "hours",
      value: 5
    }, {
      name: "minutes",
      value: 6
    }, {
      name: "seconds",
      value: 7
    }].map((part) => ({
      name: part.name,
      index: formattedDate.indexOf(part.value)
    })).filter((part) => part.index > -1).sort((a, b) => a.index - b.index).map((part) => part.name);
  }
};
var DEFAULT_DAY_OF_WEEK_INDEX = 0;
var hasIntl = typeof Intl !== "undefined";
var FORMATS_TO_PATTERN_MAP = {
  shortdate: "M/d/y",
  shorttime: "h:mm a",
  longdate: "EEEE, MMMM d, y",
  longtime: "h:mm:ss a",
  monthandday: "MMMM d",
  monthandyear: "MMMM y",
  quarterandyear: "QQQ y",
  day: "d",
  year: "y",
  shortdateshorttime: "M/d/y, h:mm a",
  longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
  month: "LLLL",
  shortyear: "yy",
  dayofweek: "EEEE",
  quarter: "QQQ",
  hour: "HH",
  minute: "mm",
  second: "ss",
  millisecond: "SSS",
  "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
};
var possiblePartPatterns = {
  year: ["y", "yy", "yyyy"],
  day: ["d", "dd"],
  month: ["M", "MM", "MMM", "MMMM"],
  hours: ["H", "HH", "h", "hh", "ah"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  milliseconds: ["S", "SS", "SSS"]
};
var dateLocalization = injector({
  engine: function() {
    return "base";
  },
  _getPatternByFormat: function(format2) {
    return FORMATS_TO_PATTERN_MAP[format2.toLowerCase()];
  },
  _expandPattern: function(pattern) {
    return this._getPatternByFormat(pattern) || pattern;
  },
  formatUsesMonthName: function(format2) {
    return this._expandPattern(format2).indexOf("MMMM") !== -1;
  },
  formatUsesDayName: function(format2) {
    return this._expandPattern(format2).indexOf("EEEE") !== -1;
  },
  getFormatParts: function(format2) {
    var pattern = this._getPatternByFormat(format2) || format2;
    var result = [];
    each(pattern.split(/\W+/), (_2, formatPart) => {
      each(possiblePartPatterns, (partName, possiblePatterns) => {
        if (inArray(formatPart, possiblePatterns) > -1) {
          result.push(partName);
        }
      });
    });
    return result;
  },
  getMonthNames: function(format2) {
    return defaultDateNames.getMonthNames(format2);
  },
  getDayNames: function(format2) {
    return defaultDateNames.getDayNames(format2);
  },
  getQuarterNames: function(format2) {
    return defaultDateNames.getQuarterNames(format2);
  },
  getPeriodNames: function(format2) {
    return defaultDateNames.getPeriodNames(format2);
  },
  getTimeSeparator: function() {
    return ":";
  },
  is24HourFormat: function(format2) {
    var amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
    var pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
    var amTimeFormatted = this.format(amTime, format2);
    var pmTimeFormatted = this.format(pmTime, format2);
    for (var i = 0; i < amTimeFormatted.length; i++) {
      if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
        return !isNaN(parseInt(amTimeFormatted[i]));
      }
    }
  },
  format: function(date, _format) {
    if (!date) {
      return;
    }
    if (!_format) {
      return date;
    }
    var formatter;
    if (typeof _format === "function") {
      formatter = _format;
    } else if (_format.formatter) {
      formatter = _format.formatter;
    } else {
      _format = _format.type || _format;
      if (isString$1(_format)) {
        _format = FORMATS_TO_PATTERN_MAP[_format.toLowerCase()] || _format;
        return numberLocalization.convertDigits(getFormatter$1(_format, this)(date));
      }
    }
    if (!formatter) {
      return;
    }
    return formatter(date);
  },
  parse: function(text, format2) {
    var that = this;
    var ldmlFormat;
    var formatter;
    if (!text) {
      return;
    }
    if (!format2) {
      return this.parse(text, "shortdate");
    }
    if (format2.parser) {
      return format2.parser(text);
    }
    if (typeof format2 === "string" && !FORMATS_TO_PATTERN_MAP[format2.toLowerCase()]) {
      ldmlFormat = format2;
    } else {
      formatter = (value2) => {
        var text2 = that.format(value2, format2);
        return numberLocalization.convertDigits(text2, true);
      };
      try {
        ldmlFormat = getFormat(formatter);
      } catch (e) {
      }
    }
    if (ldmlFormat) {
      text = numberLocalization.convertDigits(text, true);
      return getParser(ldmlFormat, this)(text);
    }
    errors$2.log("W0012");
    var result = new Date(text);
    if (!result || isNaN(result.getTime())) {
      return;
    }
    return result;
  },
  firstDayOfWeekIndex: function() {
    var index2 = core.getValueByClosestLocale((locale2) => firstDayOfWeekData[locale2]);
    return index2 === void 0 ? DEFAULT_DAY_OF_WEEK_INDEX : index2;
  }
});
if (hasIntl) {
  dateLocalization.inject(intlDateLocalization);
}
var formatHelper = injector({
  format: function(value2, _format) {
    var formatIsValid = isString$1(_format) && _format !== "" || isPlainObject(_format) || isFunction$1(_format);
    var valueIsValid = isNumeric(value2) || isDate(value2);
    if (!formatIsValid || !valueIsValid) {
      return isDefined(value2) ? value2.toString() : "";
    }
    if (isFunction$1(_format)) {
      return _format(value2);
    }
    if (isString$1(_format)) {
      _format = {
        type: _format
      };
    }
    if (isNumeric(value2)) {
      return numberLocalization.format(value2, _format);
    }
    if (isDate(value2)) {
      return dateLocalization.format(value2, _format);
    }
  },
  getTimeFormat: function(showSecond) {
    return showSecond ? "longtime" : "shorttime";
  },
  _normalizeFormat: function(format2) {
    if (!Array.isArray(format2)) {
      return format2;
    }
    if (format2.length === 1) {
      return format2[0];
    }
    return function(date) {
      return format2.map(function(formatPart) {
        return dateLocalization.format(date, formatPart);
      }).join(" ");
    };
  },
  getDateFormatByDifferences: function(dateDifferences, intervalFormat) {
    var resultFormat = [];
    var needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);
    if (needSpecialSecondFormatter) {
      resultFormat.push(function(date) {
        return date.getSeconds() + date.getMilliseconds() / 1e3 + "s";
      });
    } else if (dateDifferences.millisecond) {
      resultFormat.push("millisecond");
    }
    if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
      resultFormat.unshift(this.getTimeFormat(dateDifferences.second));
    }
    if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
      if (intervalFormat && intervalFormat === "month") {
        return "monthandyear";
      } else {
        resultFormat.unshift("shortdate");
        return this._normalizeFormat(resultFormat);
      }
    }
    if (dateDifferences.year && dateDifferences.month) {
      return "monthandyear";
    }
    if (dateDifferences.year && dateDifferences.quarter) {
      return "quarterandyear";
    }
    if (dateDifferences.year) {
      return "year";
    }
    if (dateDifferences.quarter) {
      return "quarter";
    }
    if (dateDifferences.month && dateDifferences.day) {
      if (intervalFormat) {
        resultFormat.unshift(function(date) {
          return dateLocalization.getMonthNames("abbreviated")[date.getMonth()] + " " + dateLocalization.format(date, "day");
        });
      } else {
        resultFormat.unshift("monthandday");
      }
      return this._normalizeFormat(resultFormat);
    }
    if (dateDifferences.month) {
      return "month";
    }
    if (dateDifferences.day) {
      if (intervalFormat) {
        resultFormat.unshift("day");
      } else {
        resultFormat.unshift(function(date) {
          return dateLocalization.format(date, "dayofweek") + ", " + dateLocalization.format(date, "day");
        });
      }
      return this._normalizeFormat(resultFormat);
    }
    return this._normalizeFormat(resultFormat);
  },
  getDateFormatByTicks: function(ticks) {
    var maxDiff;
    var currentDiff;
    var i;
    if (ticks.length > 1) {
      maxDiff = dateUtils.getDatesDifferences(ticks[0], ticks[1]);
      for (i = 1; i < ticks.length - 1; i++) {
        currentDiff = dateUtils.getDatesDifferences(ticks[i], ticks[i + 1]);
        if (maxDiff.count < currentDiff.count) {
          maxDiff = currentDiff;
        }
      }
    } else {
      maxDiff = {
        year: true,
        month: true,
        day: true,
        hour: ticks[0].getHours() > 0,
        minute: ticks[0].getMinutes() > 0,
        second: ticks[0].getSeconds() > 0,
        millisecond: ticks[0].getMilliseconds() > 0
      };
    }
    var resultFormat = this.getDateFormatByDifferences(maxDiff);
    return resultFormat;
  },
  getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
    var dateUnitInterval;
    var correctDateDifferences = function(dateDifferences2, tickInterval2, value2) {
      switch (tickInterval2) {
        case "year":
        case "quarter":
          dateDifferences2.month = value2;
        case "month":
          dateDifferences2.day = value2;
        case "week":
        case "day":
          dateDifferences2.hour = value2;
        case "hour":
          dateDifferences2.minute = value2;
        case "minute":
          dateDifferences2.second = value2;
        case "second":
          dateDifferences2.millisecond = value2;
      }
    };
    tickInterval = isString$1(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
    var dateDifferences = dateUtils.getDatesDifferences(startValue, endValue);
    if (startValue !== endValue) {
      !function(differences, minDate, maxDate) {
        if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
          if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
            differences.millisecond = true;
            differences.second = false;
          }
        } else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
          if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
            differences.second = true;
            differences.minute = false;
          }
        } else if (!maxDate.getMinutes() && maxDate.getHours()) {
          if (maxDate.getHours() - minDate.getHours() === 1) {
            differences.minute = true;
            differences.hour = false;
          }
        } else if (!maxDate.getHours() && maxDate.getDate() > 1) {
          if (maxDate.getDate() - minDate.getDate() === 1) {
            differences.hour = true;
            differences.day = false;
          }
        } else if (maxDate.getDate() === 1 && maxDate.getMonth()) {
          if (maxDate.getMonth() - minDate.getMonth() === 1) {
            differences.day = true;
            differences.month = false;
          }
        } else if (!maxDate.getMonth() && maxDate.getFullYear()) {
          if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
            differences.month = true;
            differences.year = false;
          }
        }
      }(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
    }
    dateUnitInterval = dateUtils.getDateUnitInterval(dateDifferences);
    correctDateDifferences(dateDifferences, dateUnitInterval, true);
    dateUnitInterval = dateUtils.getDateUnitInterval(tickInterval || "second");
    correctDateDifferences(dateDifferences, dateUnitInterval, false);
    dateDifferences[{
      week: "day"
    }[dateUnitInterval] || dateUnitInterval] = true;
    var resultFormat = this.getDateFormatByDifferences(dateDifferences);
    return resultFormat;
  }
});
var DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled";
var DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened";
var DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed";
var DATAGRID_EXPAND_CLASS = "dx-datagrid-expand";
var NO_DATA_CLASS = "nodata";
var DATE_INTERVAL_SELECTORS = {
  year: function(value2) {
    return value2 && value2.getFullYear();
  },
  month: function(value2) {
    return value2 && value2.getMonth() + 1;
  },
  day: function(value2) {
    return value2 && value2.getDate();
  },
  quarter: function(value2) {
    return value2 && Math.floor(value2.getMonth() / 3) + 1;
  },
  hour: function(value2) {
    return value2 && value2.getHours();
  },
  minute: function(value2) {
    return value2 && value2.getMinutes();
  },
  second: function(value2) {
    return value2 && value2.getSeconds();
  }
};
var getIntervalSelector = function() {
  var data2 = arguments[1];
  var value2 = this.calculateCellValue(data2);
  if (!isDefined(value2)) {
    return null;
  } else if (isDateType(this.dataType)) {
    var nameIntervalSelector = arguments[0];
    return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value2);
  } else if (this.dataType === "number") {
    var groupInterval = arguments[0];
    return Math.floor(Number(value2) / groupInterval) * groupInterval;
  }
};
var equalSelectors = function(selector1, selector2) {
  if (isFunction$1(selector1) && isFunction$1(selector2)) {
    if (selector1.originalCallback && selector2.originalCallback) {
      return selector1.originalCallback === selector2.originalCallback && selector1.columnIndex === selector2.columnIndex;
    }
  }
  return selector1 === selector2;
};
function isDateType(dataType) {
  return dataType === "date" || dataType === "datetime";
}
var setEmptyText = function($container) {
  $container.get(0).textContent = "\xA0";
};
var normalizeSortingInfo = function(sort2) {
  sort2 = sort2 || [];
  var result = normalizeSortingInfo$1(sort2);
  for (var i = 0; i < sort2.length; i++) {
    if (sort2 && sort2[i] && sort2[i].isExpanded !== void 0) {
      result[i].isExpanded = sort2[i].isExpanded;
    }
    if (sort2 && sort2[i] && sort2[i].groupInterval !== void 0) {
      result[i].groupInterval = sort2[i].groupInterval;
    }
  }
  return result;
};
var formatValue$1 = function(value2, options) {
  var valueText = formatHelper.format(value2, options.format) || value2 && value2.toString() || "";
  var formatObject = {
    value: value2,
    valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
    target: options.target || "row",
    groupInterval: options.groupInterval
  };
  return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText;
};
var getSummaryText = function(summaryItem, summaryTexts) {
  var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + "OtherColumn"] || summaryTexts[summaryItem.summaryType];
  return formatValue$1(summaryItem.value, {
    format: summaryItem.valueFormat,
    getDisplayFormat: function(valueText) {
      return displayFormat ? format(displayFormat, valueText, summaryItem.columnCaption) : valueText;
    },
    customizeText: summaryItem.customizeText
  });
};
var getWidgetInstance = function($element) {
  var editorData = $element.data && $element.data();
  var dxComponents = editorData && editorData.dxComponents;
  var widgetName = dxComponents && dxComponents[0];
  return widgetName && editorData[widgetName];
};
var equalFilterParameters = function equalFilterParameters2(filter1, filter2) {
  if (Array.isArray(filter1) && Array.isArray(filter2)) {
    if (filter1.length !== filter2.length) {
      return false;
    } else {
      for (var i = 0; i < filter1.length; i++) {
        if (!equalFilterParameters2(filter1[i], filter2[i])) {
          return false;
        }
      }
    }
    return true;
  } else if (isFunction$1(filter1) && filter1.columnIndex >= 0 && isFunction$1(filter2) && filter2.columnIndex >= 0) {
    return filter1.columnIndex === filter2.columnIndex && toComparable(filter1.filterValue) === toComparable(filter2.filterValue);
  } else {
    return toComparable(filter1) == toComparable(filter2);
  }
};
var gridCoreUtils = {
  renderNoDataText: function($element) {
    $element = $element || this.element();
    if (!$element) {
      return;
    }
    var noDataClass = this.addWidgetPrefix(NO_DATA_CLASS);
    var noDataElement = $element.find("." + noDataClass).last();
    var isVisible2 = this._dataController.isEmpty();
    var isLoading = this._dataController.isLoading();
    if (!noDataElement.length) {
      noDataElement = $("<span>").addClass(noDataClass).appendTo($element);
    }
    if (isVisible2 && !isLoading) {
      noDataElement.removeClass("dx-hidden").text(this._getNoDataText());
    } else {
      noDataElement.addClass("dx-hidden");
    }
  },
  renderLoadPanel: function($element, $container, isLocalStore) {
    var loadPanelOptions;
    this._loadPanel && this._loadPanel.$element().remove();
    loadPanelOptions = this.option("loadPanel");
    if (loadPanelOptions && (loadPanelOptions.enabled === "auto" ? !isLocalStore : loadPanelOptions.enabled)) {
      loadPanelOptions = extend({
        shading: false,
        message: loadPanelOptions.text,
        position: function() {
          var $window = $(getWindow());
          if ($element.height() > $window.height()) {
            return {
              of: $window,
              boundary: $element,
              collision: "fit"
            };
          }
          return {
            of: $element
          };
        },
        container: $container
      }, loadPanelOptions);
      this._loadPanel = this._createComponent($("<div>").appendTo($container), LoadPanel, loadPanelOptions);
    } else {
      this._loadPanel = null;
    }
  },
  getIndexByKey: function(key, items, keyName) {
    var index2 = -1;
    if (key !== void 0 && Array.isArray(items)) {
      keyName = arguments.length <= 2 ? "key" : keyName;
      for (var i = 0; i < items.length; i++) {
        var item = isDefined(keyName) ? items[i][keyName] : items[i];
        if (equalByValue(key, item)) {
          index2 = i;
          break;
        }
      }
    }
    return index2;
  },
  combineFilters: function(filters, operation) {
    var resultFilter = [];
    operation = operation || "and";
    for (var i = 0; i < filters.length; i++) {
      if (!filters[i]) {
        continue;
      }
      if (resultFilter.length) {
        resultFilter.push(operation);
      }
      resultFilter.push(filters[i]);
    }
    if (resultFilter.length === 1) {
      resultFilter = resultFilter[0];
    }
    if (resultFilter.length) {
      return resultFilter;
    }
  },
  checkChanges: function(changes, changeNames) {
    var changesWithChangeNamesCount = 0;
    for (var i = 0; i < changeNames.length; i++) {
      if (changes[changeNames[i]]) {
        changesWithChangeNamesCount++;
      }
    }
    return changes.length && changes.length === changesWithChangeNamesCount;
  },
  equalFilterParameters,
  proxyMethod: function(instance, methodName, defaultResult) {
    if (!instance[methodName]) {
      instance[methodName] = function() {
        var dataSource = this._dataSource;
        return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;
      };
    }
  },
  formatValue: formatValue$1,
  getFormatOptionsByColumn: function(column, target) {
    return {
      format: column.format,
      getDisplayFormat: column.getDisplayFormat,
      customizeText: column.customizeText,
      target,
      trueText: column.trueText,
      falseText: column.falseText
    };
  },
  getDisplayValue: function(column, value2, data2, rowType) {
    if (column.displayValueMap && column.displayValueMap[value2] !== void 0) {
      return column.displayValueMap[value2];
    } else if (column.calculateDisplayValue && data2 && rowType !== "group") {
      return column.calculateDisplayValue(data2);
    } else if (column.lookup && !(rowType === "group" && (column.calculateGroupValue || column.calculateDisplayValue))) {
      return column.lookup.calculateCellValue(value2);
    }
    return value2;
  },
  getGroupRowSummaryText: function(summaryItems, summaryTexts) {
    var result = "(";
    for (var i = 0; i < summaryItems.length; i++) {
      var summaryItem = summaryItems[i];
      result += (i > 0 ? ", " : "") + getSummaryText(summaryItem, summaryTexts);
    }
    return result + ")";
  },
  getSummaryText,
  normalizeSortingInfo,
  getFormatByDataType: function(dataType) {
    switch (dataType) {
      case "date":
        return "shortDate";
      case "datetime":
        return "shortDateShortTime";
    }
  },
  getHeaderFilterGroupParameters: function(column, remoteGrouping) {
    var result = [];
    var dataField = column.dataField || column.name;
    var groupInterval = sharedFiltering.getGroupInterval(column);
    if (groupInterval) {
      each(groupInterval, function(index2, interval) {
        result.push(remoteGrouping ? {
          selector: dataField,
          groupInterval: interval,
          isExpanded: index2 < groupInterval.length - 1
        } : getIntervalSelector.bind(column, interval));
      });
      return result;
    }
    if (remoteGrouping) {
      result = [{
        selector: dataField,
        isExpanded: false
      }];
    } else {
      result = function(data2) {
        var result2 = column.calculateCellValue(data2);
        if (result2 === void 0 || result2 === "") {
          result2 = null;
        }
        return result2;
      };
      if (column.sortingMethod) {
        result = [{
          selector: result,
          compare: column.sortingMethod.bind(column)
        }];
      }
    }
    return result;
  },
  equalSortParameters(sortParameters1, sortParameters2, ignoreIsExpanded) {
    sortParameters1 = normalizeSortingInfo(sortParameters1);
    sortParameters2 = normalizeSortingInfo(sortParameters2);
    if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {
      if (sortParameters1.length !== sortParameters2.length) {
        return false;
      } else {
        for (var i = 0; i < sortParameters1.length; i++) {
          if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
            return false;
          }
        }
      }
      return true;
    } else {
      return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length);
    }
  },
  getPointsByColumns: function(items, pointCreated, isVertical, startColumnIndex) {
    var cellsLength = items.length;
    var notCreatePoint = false;
    var item;
    var offset2;
    var columnIndex = startColumnIndex || 0;
    var result = [];
    var rtlEnabled;
    for (var i = 0; i <= cellsLength; i++) {
      if (i < cellsLength) {
        item = items.eq(i);
        offset2 = item.offset();
        rtlEnabled = item.css("direction") === "rtl";
      }
      var point = {
        index: columnIndex,
        x: offset2 ? offset2.left + (!isVertical && rtlEnabled ^ i === cellsLength ? getBoundingRect(item[0]).width : 0) : 0,
        y: offset2 ? offset2.top + (isVertical && i === cellsLength ? getBoundingRect(item[0]).height : 0) : 0,
        columnIndex
      };
      if (!isVertical && i > 0) {
        var prevItemOffset = items.eq(i - 1).offset();
        if (prevItemOffset.top < point.y) {
          point.y = prevItemOffset.top;
        }
      }
      if (pointCreated) {
        notCreatePoint = pointCreated(point);
      }
      if (!notCreatePoint) {
        result.push(point);
      }
      columnIndex++;
    }
    return result;
  },
  getExpandCellTemplate: function() {
    return {
      allowRenderToDetachedContainer: true,
      render: function(container, options) {
        var $container = $(container);
        if (isDefined(options.value) && !(options.data && options.data.isContinuation) && !options.row.isNewRow) {
          var rowsView = options.component.getView("rowsView");
          $container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
          $("<div>").addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo($container);
          rowsView.setAria("label", options.value ? rowsView.localize("dxDataGrid-ariaCollapse") : rowsView.localize("dxDataGrid-ariaExpand"), $container);
        } else {
          setEmptyText($container);
        }
      }
    };
  },
  setEmptyText,
  isDateType,
  getSelectionRange: function(focusedElement) {
    try {
      if (focusedElement) {
        return {
          selectionStart: focusedElement.selectionStart,
          selectionEnd: focusedElement.selectionEnd
        };
      }
    } catch (e) {
    }
    return {};
  },
  setSelectionRange: function(focusedElement, selectionRange) {
    try {
      if (focusedElement && focusedElement.setSelectionRange) {
        focusedElement.setSelectionRange(selectionRange.selectionStart, selectionRange.selectionEnd);
      }
    } catch (e) {
    }
  },
  focusAndSelectElement: function(component, $element) {
    eventsEngine.trigger($element, "focus");
    var isSelectTextOnEditingStart = component.option("editing.selectTextOnEditStart");
    var keyboardController = component.getController("keyboardNavigation");
    var isEditingNavigationMode = keyboardController && keyboardController._isFastEditingStarted();
    var element = $element.get(0);
    if (isSelectTextOnEditingStart && !isEditingNavigationMode && $element.is(".dx-texteditor-input") && !$element.is("[readonly]")) {
      var editor = getWidgetInstance($element.closest(".dx-texteditor"));
      when(editor && editor._loadItemDeferred).done(function() {
        element.select();
      });
    }
  },
  getWidgetInstance,
  getLastResizableColumnIndex: function(columns, resultWidths) {
    var hasResizableColumns = columns.some((column2) => column2 && !column2.command && !column2.fixed && column2.allowResizing !== false);
    var lastColumnIndex;
    for (lastColumnIndex = columns.length - 1; columns[lastColumnIndex]; lastColumnIndex--) {
      var column = columns[lastColumnIndex];
      var width = resultWidths && resultWidths[lastColumnIndex];
      var allowResizing = !hasResizableColumns || column.allowResizing !== false;
      if (!column.command && !column.fixed && width !== "adaptiveHidden" && allowResizing) {
        break;
      }
    }
    return lastColumnIndex;
  },
  isElementInCurrentGrid: function(controller, $element) {
    if ($element && $element.length) {
      var $grid = $element.closest("." + controller.getWidgetContainerClass()).parent();
      return $grid.is(controller.component.$element());
    }
    return false;
  }
};
var window$b = getWindow();
var nativeXMLHttpRequest = {
  getXhr: function() {
    return new window$b.XMLHttpRequest();
  }
};
var httpRequest = injector(nativeXMLHttpRequest);
var window$a = getWindow();
var SUCCESS = "success";
var ERROR = "error";
var TIMEOUT = "timeout";
var NO_CONTENT = "nocontent";
var PARSER_ERROR = "parsererror";
var isStatusSuccess = function(status) {
  return 200 <= status && status < 300;
};
var hasContent = function(status) {
  return status !== 204;
};
var paramsConvert = function(params) {
  var result = [];
  for (var name2 in params) {
    var value2 = params[name2];
    if (value2 === void 0) {
      continue;
    }
    if (value2 === null) {
      value2 = "";
    }
    if (typeof value2 === "function") {
      value2 = value2();
    }
    result.push(encodeURIComponent(name2) + "=" + encodeURIComponent(value2));
  }
  return result.join("&");
};
var createScript = function(options) {
  var script = domAdapter.createElement("script");
  for (var name2 in options) {
    script[name2] = options[name2];
  }
  return script;
};
var removeScript = function(scriptNode) {
  scriptNode.parentNode.removeChild(scriptNode);
};
var appendToHead = function(element) {
  return domAdapter.getHead().appendChild(element);
};
var evalScript = function(code) {
  var script = createScript({
    text: code
  });
  appendToHead(script);
  removeScript(script);
};
var evalCrossDomainScript = function(url) {
  var script = createScript({
    src: url
  });
  return new Promise$3(function(resolve, reject) {
    var events = {
      load: resolve,
      error: reject
    };
    var loadHandler = function(e) {
      events[e.type]();
      removeScript(script);
    };
    for (var event in events) {
      domAdapter.listen(script, event, loadHandler);
    }
    appendToHead(script);
  });
};
var getAcceptHeader = function(options) {
  var dataType = options.dataType || "*";
  var scriptAccept = "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript";
  var accepts = {
    "*": "*/*",
    text: "text/plain",
    html: "text/html",
    xml: "application/xml, text/xml",
    json: "application/json, text/javascript",
    jsonp: scriptAccept,
    script: scriptAccept
  };
  extendFromObject(accepts, options.accepts, true);
  return accepts[dataType] ? accepts[dataType] + (dataType !== "*" ? ", */*; q=0.01" : "") : accepts["*"];
};
var getContentTypeHeader = function(options) {
  var defaultContentType;
  if (options.data && !options.upload && getMethod(options) !== "GET") {
    defaultContentType = "application/x-www-form-urlencoded;charset=utf-8";
  }
  return options.contentType || defaultContentType;
};
var getDataFromResponse = function(xhr) {
  return xhr.responseType && xhr.responseType !== "text" || typeof xhr.responseText !== "string" ? xhr.response : xhr.responseText;
};
var postProcess = function(deferred, xhr, dataType) {
  var data2 = getDataFromResponse(xhr);
  switch (dataType) {
    case "jsonp":
      evalScript(data2);
      break;
    case "script":
      evalScript(data2);
      deferred.resolve(data2, SUCCESS, xhr);
      break;
    case "json":
      try {
        deferred.resolve(JSON.parse(data2), SUCCESS, xhr);
      } catch (e) {
        deferred.reject(xhr, PARSER_ERROR, e);
      }
      break;
    default:
      deferred.resolve(data2, SUCCESS, xhr);
  }
};
var isCrossDomain = function(url) {
  if (!hasWindow$1()) {
    return true;
  }
  var crossDomain = false;
  var originAnchor = domAdapter.createElement("a");
  var urlAnchor = domAdapter.createElement("a");
  originAnchor.href = window$a.location.href;
  try {
    urlAnchor.href = url;
    urlAnchor.href = urlAnchor.href;
    crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
  } catch (e) {
    crossDomain = true;
  }
  return crossDomain;
};
var setHttpTimeout = function(timeout, xhr) {
  return timeout && setTimeout(function() {
    xhr.customStatus = TIMEOUT;
    xhr.abort();
  }, timeout);
};
var getJsonpOptions = function(options) {
  if (options.dataType === "jsonp") {
    var random = Math.random().toString().replace(/\D/g, "");
    var callbackName = options.jsonpCallback || "dxCallback" + Date.now() + "_" + random;
    var callbackParameter = options.jsonp || "callback";
    options.data = options.data || {};
    options.data[callbackParameter] = callbackName;
    return callbackName;
  }
};
var getRequestOptions = function(options, headers) {
  var params = options.data;
  var paramsAlreadyString = typeof params === "string";
  var url = options.url || window$a.location.href;
  if (!paramsAlreadyString && !options.cache) {
    params = params || {};
    params._ = Date.now();
  }
  if (params && !options.upload) {
    if (!paramsAlreadyString) {
      params = paramsConvert(params);
    }
    if (getMethod(options) === "GET") {
      if (params !== "") {
        url += (url.indexOf("?") > -1 ? "&" : "?") + params;
      }
      params = null;
    } else if (headers["Content-Type"] && headers["Content-Type"].indexOf("application/x-www-form-urlencoded") > -1) {
      params = params.replace(/%20/g, "+");
    }
  }
  return {
    url,
    parameters: params
  };
};
function getMethod(options) {
  return (options.method || "GET").toUpperCase();
}
var getRequestHeaders = function(options) {
  var headers = options.headers || {};
  headers["Content-Type"] = headers["Content-Type"] || getContentTypeHeader(options);
  headers.Accept = headers.Accept || getAcceptHeader(options);
  if (!options.crossDomain && !headers["X-Requested-With"]) {
    headers["X-Requested-With"] = "XMLHttpRequest";
  }
  return headers;
};
var sendRequest$1 = function(options) {
  var xhr = httpRequest.getXhr();
  var d = new Deferred();
  var result = d.promise();
  var async = isDefined(options.async) ? options.async : true;
  var dataType = options.dataType;
  var timeout = options.timeout || 0;
  var timeoutId;
  options.crossDomain = isCrossDomain(options.url);
  var needScriptEvaluation = dataType === "jsonp" || dataType === "script";
  if (options.cache === void 0) {
    options.cache = !needScriptEvaluation;
  }
  var callbackName = getJsonpOptions(options);
  var headers = getRequestHeaders(options);
  var requestOptions = getRequestOptions(options, headers);
  var url = requestOptions.url;
  var parameters = requestOptions.parameters;
  if (callbackName) {
    window$a[callbackName] = function(data2) {
      d.resolve(data2, SUCCESS, xhr);
    };
  }
  if (options.crossDomain && needScriptEvaluation) {
    evalCrossDomainScript(url).then(function() {
      if (dataType === "jsonp") {
        return;
      }
      d.resolve(null, SUCCESS, xhr);
    }, function() {
      d.reject(xhr, ERROR);
    });
    return result;
  }
  if (options.crossDomain && !("withCredentials" in xhr)) {
    d.reject(xhr, ERROR);
    return result;
  }
  xhr.open(getMethod(options), url, async, options.username, options.password);
  if (async) {
    xhr.timeout = timeout;
    timeoutId = setHttpTimeout(timeout, xhr);
  }
  xhr.onreadystatechange = function(e) {
    if (xhr.readyState === 4) {
      clearTimeout(timeoutId);
      if (isStatusSuccess(xhr.status)) {
        if (hasContent(xhr.status)) {
          postProcess(d, xhr, dataType);
        } else {
          d.resolve(null, NO_CONTENT, xhr);
        }
      } else {
        d.reject(xhr, xhr.customStatus || ERROR);
      }
    }
  };
  if (options.upload) {
    xhr.upload.onprogress = options.upload.onprogress;
    xhr.upload.onloadstart = options.upload.onloadstart;
    xhr.upload.onabort = options.upload.onabort;
  }
  if (options.xhrFields) {
    for (var field in options.xhrFields) {
      xhr[field] = options.xhrFields[field];
    }
  }
  if (options.responseType === "arraybuffer") {
    xhr.responseType = options.responseType;
  }
  for (var name2 in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name2) && isDefined(headers[name2])) {
      xhr.setRequestHeader(name2, headers[name2]);
    }
  }
  if (options.beforeSend) {
    options.beforeSend(xhr);
  }
  xhr.send(parameters);
  result.abort = function() {
    xhr.abort();
  };
  return result;
};
var ajax = injector({
  sendRequest: sendRequest$1
});
var errors = errorUtils(errors$2.ERROR_MESSAGES, {
  E4000: "[DevExpress.data]: {0}",
  E4001: "Unknown aggregating function is detected: '{0}'",
  E4002: "Unsupported OData protocol version is used",
  E4003: "Unknown filter operation is used: {0}",
  E4004: "The thenby() method is called before the sortby() method",
  E4005: "Store requires a key expression for this operation",
  E4006: "ArrayStore 'data' option must be an array",
  E4007: "Compound keys cannot be auto-generated",
  E4008: "Attempt to insert an item with a duplicated key",
  E4009: "Data item cannot be found",
  E4010: "CustomStore does not support creating queries",
  E4011: "Custom Store method is not implemented or is not a function: {0}",
  E4012: "Custom Store method returns an invalid value: {0}",
  E4013: "Local Store requires the 'name' configuration option is specified",
  E4014: "Unknown data type is specified for ODataStore: {0}",
  E4015: "Unknown entity name or alias is used: {0}",
  E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
  E4017: "Keys cannot be modified",
  E4018: "The server has returned a non-numeric value in a response to an item count request",
  E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
  E4020: "Unknown store type is detected: {0}",
  E4021: "The server response does not provide the totalCount value",
  E4022: "The server response does not provide the groupCount value",
  E4023: "Could not parse the following XML: {0}",
  E4024: "String function {0} cannot be used with the data field {1} of type {2}.",
  W4000: "Data returned from the server has an incorrect structure",
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
  W4002: "Data loading has failed for some cells due to the following error: {0}"
});
var errorHandler = null;
var handleError = function(error) {
  var _errorHandler;
  (_errorHandler = errorHandler) === null || _errorHandler === void 0 ? void 0 : _errorHandler(error);
};
function hasKey(target, keyOrKeys) {
  var key;
  var keys2 = typeof keyOrKeys === "string" ? keyOrKeys.split() : keyOrKeys.slice();
  while (keys2.length) {
    key = keys2.shift();
    if (key in target) {
      return true;
    }
  }
  return false;
}
function findItems(keyInfo, items, key, groupCount) {
  var childItems;
  var result;
  if (groupCount) {
    for (var i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result = findItems(keyInfo, childItems || [], key, groupCount - 1);
      if (result) {
        return result;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}
function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }
  return items;
}
function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    var dataByKeyMap = {};
    var arrayLength = array.length;
    for (var i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }
    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}
function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}
function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
  return true;
}
function setDataByKeyMapValue(array, key, data2) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data2;
    array._dataByKeyMapLength += data2 ? 1 : -1;
  }
}
function cloneInstance(instance) {
  var result = instance ? Object.create(Object.getPrototypeOf(instance)) : {};
  var instanceWithoutPrototype = extendFromObject({}, instance);
  for (var name2 in instanceWithoutPrototype) {
    var prop = instanceWithoutPrototype[name2];
    if (isObject$1(prop) && !isPlainObject(prop)) {
      instanceWithoutPrototype[name2] = cloneInstance(prop);
    }
  }
  deepExtendArraySafe(result, instanceWithoutPrototype, true, true);
  return result;
}
function createObjectWithChanges(target, changes) {
  var result = cloneInstance(target);
  return deepExtendArraySafe(result, changes, true, true);
}
function applyBatch(_ref) {
  var {
    keyInfo,
    data: data2,
    changes,
    groupCount,
    useInsertIndex,
    immutable,
    disableCache,
    logError
  } = _ref;
  var resultItems = immutable === true ? [...data2] : data2;
  changes.forEach((item) => {
    var items = item.type === "insert" ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);
    switch (item.type) {
      case "update":
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;
      case "insert":
        insert(keyInfo, items, item.data, useInsertIndex && isDefined(item.index) ? item.index : -1, true, logError);
        break;
      case "remove":
        remove(keyInfo, items, item.key, true, logError);
    }
  });
  return resultItems;
}
function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? rejectedPromise(errors.Error(errorCode)) : logError && errors.log(errorCode);
}
function update(keyInfo, array, key, data2, isBatch, immutable, logError) {
  var target;
  var keyExpr = keyInfo.key();
  if (keyExpr) {
    if (hasKey(data2, keyExpr) && !keysEqual(keyExpr, key, keyInfo.keyOf(data2))) {
      return getErrorResult(isBatch, logError, "E4017");
    }
    target = getCacheValue(array, key);
    if (!target) {
      var index2 = indexByKey(keyInfo, array, key);
      if (index2 < 0) {
        return getErrorResult(isBatch, logError, "E4009");
      }
      target = array[index2];
      if (immutable === true && isDefined(target)) {
        var newTarget = createObjectWithChanges(target, data2);
        array[index2] = newTarget;
        return !isBatch && trivialPromise$1(newTarget, key);
      }
    }
  } else {
    target = key;
  }
  deepExtendArraySafe(target, data2, true);
  if (!isBatch) {
    if (configMethod().useLegacyStoreResult) {
      return trivialPromise$1(key, data2);
    } else {
      return trivialPromise$1(target, key);
    }
  }
}
function insert(keyInfo, array, data2, index2, isBatch, logError) {
  var keyValue;
  var keyExpr = keyInfo.key();
  var obj = isPlainObject(data2) ? extend({}, data2) : data2;
  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);
    if (keyValue === void 0 || typeof keyValue === "object" && isEmptyObject(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw errors.Error("E4007");
      }
      keyValue = obj[keyExpr] = String(new Guid());
    } else if (array[indexByKey(keyInfo, array, keyValue)] !== void 0) {
      return getErrorResult(isBatch, logError, "E4008");
    }
  } else {
    keyValue = obj;
  }
  if (index2 >= 0) {
    array.splice(index2, 0, obj);
  } else {
    array.push(obj);
  }
  setDataByKeyMapValue(array, keyValue, obj);
  if (!isBatch) {
    return trivialPromise$1(configMethod().useLegacyStoreResult ? data2 : obj, keyValue);
  }
}
function remove(keyInfo, array, key, isBatch, logError) {
  var index2 = indexByKey(keyInfo, array, key);
  if (index2 > -1) {
    array.splice(index2, 1);
    setDataByKeyMapValue(array, key, null);
  }
  if (!isBatch) {
    return trivialPromise$1(key);
  } else if (index2 < 0) {
    return getErrorResult(isBatch, logError, "E4009");
  }
}
function indexByKey(keyInfo, array, key) {
  var keyExpr = keyInfo.key();
  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }
  for (var i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if (keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }
  return -1;
}
var Iterator = classImpl.inherit({
  toArray: function() {
    var result = [];
    this.reset();
    while (this.next()) {
      result.push(this.current());
    }
    return result;
  },
  countable: function() {
    return false;
  }
});
var ArrayIterator = Iterator.inherit({
  ctor: function(array) {
    this.array = array;
    this.index = -1;
  },
  next: function() {
    if (this.index + 1 < this.array.length) {
      this.index++;
      return true;
    }
    return false;
  },
  current: function() {
    return this.array[this.index];
  },
  reset: function() {
    this.index = -1;
  },
  toArray: function() {
    return this.array.slice(0);
  },
  countable: function() {
    return true;
  },
  count: function() {
    return this.array.length;
  }
});
var WrappedIterator = Iterator.inherit({
  ctor: function(iter) {
    this.iter = iter;
  },
  next: function() {
    return this.iter.next();
  },
  current: function() {
    return this.iter.current();
  },
  reset: function() {
    return this.iter.reset();
  }
});
var MapIterator = WrappedIterator.inherit({
  ctor: function(iter, mapper) {
    this.callBase(iter);
    this.index = -1;
    this.mapper = mapper;
  },
  current: function() {
    return this.mapper(this.callBase(), this.index);
  },
  next: function() {
    var hasNext = this.callBase();
    if (hasNext) {
      this.index++;
    }
    return hasNext;
  }
});
var defaultCompare = function(xValue, yValue) {
  xValue = toComparable(xValue);
  yValue = toComparable(yValue);
  if (xValue === null && yValue !== null) {
    return -1;
  }
  if (xValue !== null && yValue === null) {
    return 1;
  }
  if (xValue === void 0 && yValue !== void 0) {
    return 1;
  }
  if (xValue !== void 0 && yValue === void 0) {
    return -1;
  }
  if (xValue < yValue) {
    return -1;
  }
  if (xValue > yValue) {
    return 1;
  }
  return 0;
};
var SortIterator = Iterator.inherit({
  ctor: function(iter, getter, desc, compare2) {
    if (!(iter instanceof MapIterator)) {
      iter = new MapIterator(iter, this._wrap);
    }
    this.iter = iter;
    this.rules = [{
      getter,
      desc,
      compare: compare2
    }];
  },
  thenBy: function(getter, desc, compare2) {
    var result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare2);
    if (!this.sortedIter) {
      result.rules = this.rules.concat(result.rules);
    }
    return result;
  },
  next: function() {
    this._ensureSorted();
    return this.sortedIter.next();
  },
  current: function() {
    this._ensureSorted();
    return this.sortedIter.current();
  },
  reset: function() {
    delete this.sortedIter;
  },
  countable: function() {
    return this.sortedIter || this.iter.countable();
  },
  count: function() {
    if (this.sortedIter) {
      return this.sortedIter.count();
    }
    return this.iter.count();
  },
  _ensureSorted: function() {
    var that = this;
    if (that.sortedIter) {
      return;
    }
    each(that.rules, function() {
      this.getter = compileGetter(this.getter);
    });
    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
      return that._compare(x, y);
    })), that._unwrap);
  },
  _wrap: function(record, index2) {
    return {
      index: index2,
      value: record
    };
  },
  _unwrap: function(wrappedItem) {
    return wrappedItem.value;
  },
  _compare: function(x, y) {
    var xIndex = x.index;
    var yIndex = y.index;
    x = x.value;
    y = y.value;
    if (x === y) {
      return xIndex - yIndex;
    }
    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
      var rule = this.rules[i];
      var xValue = rule.getter(x);
      var yValue = rule.getter(y);
      var compare2 = rule.compare || defaultCompare;
      var compareResult = compare2(xValue, yValue);
      if (compareResult) {
        return rule.desc ? -compareResult : compareResult;
      }
    }
    return xIndex - yIndex;
  }
});
var compileCriteria = function() {
  var toString = function(value2) {
    return isDefined(value2) ? value2.toString() : "";
  };
  function compileEquals(getter, value2, negate) {
    return function(obj) {
      obj = toComparable(getter(obj));
      var result = function(value3) {
        return value3 === "" || value3 === 0 || value3 === false;
      }(value2) ? obj === value2 : obj == value2;
      if (negate) {
        result = !result;
      }
      return result;
    };
  }
  return function(crit) {
    if (isFunction$1(crit)) {
      return crit;
    }
    if (isGroupCriterion(crit)) {
      return function(crit2) {
        var ops = [];
        var isConjunctiveOperator$1 = false;
        var isConjunctiveNextOperator = false;
        each(crit2, function() {
          if (Array.isArray(this) || isFunction$1(this)) {
            if (ops.length > 1 && isConjunctiveOperator$1 !== isConjunctiveNextOperator) {
              throw new errors.Error("E4019");
            }
            ops.push(compileCriteria(this));
            isConjunctiveOperator$1 = isConjunctiveNextOperator;
            isConjunctiveNextOperator = true;
          } else {
            isConjunctiveNextOperator = isConjunctiveOperator(this);
          }
        });
        return function(d) {
          var result = isConjunctiveOperator$1;
          for (var i = 0; i < ops.length; i++) {
            if (ops[i](d) !== isConjunctiveOperator$1) {
              result = !isConjunctiveOperator$1;
              break;
            }
          }
          return result;
        };
      }(crit);
    }
    if (isUnaryOperation(crit)) {
      return function(crit2) {
        var op = crit2[0];
        var criteria = compileCriteria(crit2[1]);
        if (op === "!") {
          return function(obj) {
            return !criteria(obj);
          };
        }
        throw errors.Error("E4003", op);
      }(crit);
    }
    return function(crit2) {
      crit2 = normalizeBinaryCriterion(crit2);
      var getter = compileGetter(crit2[0]);
      var op = crit2[1];
      var value2 = crit2[2];
      value2 = toComparable(value2);
      switch (op.toLowerCase()) {
        case "=":
          return compileEquals(getter, value2);
        case "<>":
          return compileEquals(getter, value2, true);
        case ">":
          return function(obj) {
            return toComparable(getter(obj)) > value2;
          };
        case "<":
          return function(obj) {
            return toComparable(getter(obj)) < value2;
          };
        case ">=":
          return function(obj) {
            return toComparable(getter(obj)) >= value2;
          };
        case "<=":
          return function(obj) {
            return toComparable(getter(obj)) <= value2;
          };
        case "startswith":
          return function(obj) {
            return toComparable(toString(getter(obj))).indexOf(value2) === 0;
          };
        case "endswith":
          return function(obj) {
            var getterValue = toComparable(toString(getter(obj)));
            var searchValue = toString(value2);
            if (getterValue.length < searchValue.length) {
              return false;
            }
            var index2 = getterValue.lastIndexOf(value2);
            return index2 !== -1 && index2 === getterValue.length - value2.length;
          };
        case "contains":
          return function(obj) {
            return toComparable(toString(getter(obj))).indexOf(value2) > -1;
          };
        case "notcontains":
          return function(obj) {
            return toComparable(toString(getter(obj))).indexOf(value2) === -1;
          };
      }
      throw errors.Error("E4003", op);
    }(crit);
  };
}();
var FilterIterator = WrappedIterator.inherit({
  ctor: function(iter, criteria) {
    this.callBase(iter);
    this.criteria = compileCriteria(criteria);
  },
  next: function() {
    while (this.iter.next()) {
      if (this.criteria(this.current())) {
        return true;
      }
    }
    return false;
  }
});
var GroupIterator = Iterator.inherit({
  ctor: function(iter, getter) {
    this.iter = iter;
    this.getter = getter;
  },
  next: function() {
    this._ensureGrouped();
    return this.groupedIter.next();
  },
  current: function() {
    this._ensureGrouped();
    return this.groupedIter.current();
  },
  reset: function() {
    delete this.groupedIter;
  },
  countable: function() {
    return !!this.groupedIter;
  },
  count: function() {
    return this.groupedIter.count();
  },
  _ensureGrouped: function() {
    if (this.groupedIter) {
      return;
    }
    var hash = {};
    var keys2 = [];
    var iter = this.iter;
    var getter = compileGetter(this.getter);
    iter.reset();
    while (iter.next()) {
      var current2 = iter.current();
      var key = getter(current2);
      if (key in hash) {
        hash[key].push(current2);
      } else {
        hash[key] = [current2];
        keys2.push(key);
      }
    }
    this.groupedIter = new ArrayIterator(map(keys2, function(key2) {
      return {
        key: key2,
        items: hash[key2]
      };
    }));
  }
});
var SelectIterator = WrappedIterator.inherit({
  ctor: function(iter, getter) {
    this.callBase(iter);
    this.getter = compileGetter(getter);
  },
  current: function() {
    return this.getter(this.callBase());
  },
  countable: function() {
    return this.iter.countable();
  },
  count: function() {
    return this.iter.count();
  }
});
var SliceIterator = WrappedIterator.inherit({
  ctor: function(iter, skip, take) {
    this.callBase(iter);
    this.skip = Math.max(0, skip);
    this.take = Math.max(0, take);
    this.pos = 0;
  },
  next: function() {
    if (this.pos >= this.skip + this.take) {
      return false;
    }
    while (this.pos < this.skip && this.iter.next()) {
      this.pos++;
    }
    this.pos++;
    return this.iter.next();
  },
  reset: function() {
    this.callBase();
    this.pos = 0;
  },
  countable: function() {
    return this.iter.countable();
  },
  count: function() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
});
var arrayQueryImpl = function arrayQueryImpl2(iter, queryOptions) {
  queryOptions = queryOptions || {};
  if (!(iter instanceof Iterator)) {
    iter = new ArrayIterator(iter);
  }
  var handleError$1 = function(error) {
    var handler = queryOptions.errorHandler;
    if (handler) {
      handler(error);
    }
    handleError(error);
  };
  var aggregateCore = function(aggregator) {
    var d = new Deferred().fail(handleError$1);
    var seed;
    var step = aggregator.step;
    var finalize = aggregator.finalize;
    try {
      iter.reset();
      if ("seed" in aggregator) {
        seed = aggregator.seed;
      } else {
        seed = iter.next() ? iter.current() : NaN;
      }
      var accumulator = seed;
      while (iter.next()) {
        accumulator = step(accumulator, iter.current());
      }
      d.resolve(finalize ? finalize(accumulator) : accumulator);
    } catch (x) {
      d.reject(x);
    }
    return d.promise();
  };
  var standardAggregate = function(name2) {
    return aggregateCore(aggregators[name2]);
  };
  var select = function(getter) {
    if (!isFunction$1(getter) && !Array.isArray(getter)) {
      getter = [].slice.call(arguments);
    }
    return chainQuery(new SelectIterator(iter, getter));
  };
  var selectProp = function(name2) {
    return select(compileGetter(name2));
  };
  function chainQuery(iter2) {
    return arrayQueryImpl2(iter2, queryOptions);
  }
  return {
    toArray: function() {
      return iter.toArray();
    },
    enumerate: function() {
      var d = new Deferred().fail(handleError$1);
      try {
        d.resolve(iter.toArray());
      } catch (x) {
        d.reject(x);
      }
      return d.promise();
    },
    sortBy: function(getter, desc, compare2) {
      return chainQuery(new SortIterator(iter, getter, desc, compare2));
    },
    thenBy: function(getter, desc, compare2) {
      if (iter instanceof SortIterator) {
        return chainQuery(iter.thenBy(getter, desc, compare2));
      }
      throw errors.Error("E4004");
    },
    filter: function(criteria) {
      if (!Array.isArray(criteria)) {
        criteria = [].slice.call(arguments);
      }
      return chainQuery(new FilterIterator(iter, criteria));
    },
    slice: function(skip, take) {
      if (take === void 0) {
        take = Number.MAX_VALUE;
      }
      return chainQuery(new SliceIterator(iter, skip, take));
    },
    select,
    groupBy: function(getter) {
      return chainQuery(new GroupIterator(iter, getter));
    },
    aggregate: function(seed, step, finalize) {
      if (arguments.length < 2) {
        return aggregateCore({
          step: arguments[0]
        });
      }
      return aggregateCore({
        seed,
        step,
        finalize
      });
    },
    count: function() {
      if (iter.countable()) {
        var d = new Deferred().fail(handleError$1);
        try {
          d.resolve(iter.count());
        } catch (x) {
          d.reject(x);
        }
        return d.promise();
      }
      return standardAggregate("count");
    },
    sum: function(getter) {
      if (getter) {
        return selectProp(getter).sum();
      }
      return standardAggregate("sum");
    },
    min: function(getter) {
      if (getter) {
        return selectProp(getter).min();
      }
      return standardAggregate("min");
    },
    max: function(getter) {
      if (getter) {
        return selectProp(getter).max();
      }
      return standardAggregate("max");
    },
    avg: function(getter) {
      if (getter) {
        return selectProp(getter).avg();
      }
      return standardAggregate("avg");
    }
  };
};
function multiLevelGroup(query2, groupInfo) {
  query2 = query2.groupBy(groupInfo[0].selector);
  if (groupInfo.length > 1) {
    query2 = query2.select(function(g) {
      return extend({}, g, {
        items: multiLevelGroup(arrayQueryImpl(g.items), groupInfo.slice(1)).toArray()
      });
    });
  }
  return query2;
}
function arrangeSortingInfo(groupInfo, sortInfo) {
  var filteredGroup = [];
  each(groupInfo, function(_2, group) {
    var collision = grep(sortInfo, function(sort2) {
      return group.selector === sort2.selector;
    });
    if (collision.length < 1) {
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}
function queryByOptions$1(query2, options, isCountQuery) {
  options = options || {};
  var filter = options.filter;
  if (filter) {
    query2 = query2.filter(filter);
  }
  if (isCountQuery) {
    return query2;
  }
  var sort2 = options.sort;
  var select = options.select;
  var group = options.group;
  var skip = options.skip;
  var take = options.take;
  if (group) {
    group = normalizeSortingInfo$1(group);
    group.keepInitialKeyOrder = !!options.group.keepInitialKeyOrder;
  }
  if (sort2 || group) {
    sort2 = normalizeSortingInfo$1(sort2 || []);
    if (group && !group.keepInitialKeyOrder) {
      sort2 = arrangeSortingInfo(group, sort2);
    }
    each(sort2, function(index2) {
      query2 = query2[index2 ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare);
    });
  }
  if (select) {
    query2 = query2.select(select);
  }
  if (group) {
    query2 = multiLevelGroup(query2, group);
  }
  if (take || skip) {
    query2 = query2.slice(skip || 0, take);
  }
  return query2;
}
var storeHelper = {
  multiLevelGroup,
  arrangeSortingInfo,
  queryByOptions: queryByOptions$1
};
var abstract$4 = classImpl.abstract;
var queryByOptions = storeHelper.queryByOptions;
var storeImpl = {};
var Store = classImpl.inherit({
  ctor: function(options) {
    var that = this;
    options = options || {};
    this._eventsStrategy = new EventsStrategy(this);
    each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onPush", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_2, optionName) {
      if (optionName in options) {
        that.on(optionName.slice(2).toLowerCase(), options[optionName]);
      }
    });
    this._key = options.key;
    this._errorHandler = options.errorHandler;
    this._useDefaultSearch = true;
  },
  _customLoadOptions: function() {
    return null;
  },
  key: function() {
    return this._key;
  },
  keyOf: function(obj) {
    if (!this._keyGetter) {
      this._keyGetter = compileGetter(this.key());
    }
    return this._keyGetter(obj);
  },
  _requireKey: function() {
    if (!this.key()) {
      throw errors.Error("E4005");
    }
  },
  load: function(options) {
    var that = this;
    options = options || {};
    this._eventsStrategy.fireEvent("loading", [options]);
    return this._withLock(this._loadImpl(options)).done(function(result) {
      that._eventsStrategy.fireEvent("loaded", [result, options]);
    });
  },
  _loadImpl: function(options) {
    return queryByOptions(this.createQuery(options), options).enumerate();
  },
  _withLock: function(task) {
    var result = new Deferred();
    task.done(function() {
      var that = this;
      var args = arguments;
      processRequestResultLock.promise().done(function() {
        result.resolveWith(that, args);
      });
    }).fail(function() {
      result.rejectWith(this, arguments);
    });
    return result;
  },
  createQuery: abstract$4,
  totalCount: function(options) {
    return this._totalCountImpl(options);
  },
  _totalCountImpl: function(options) {
    return queryByOptions(this.createQuery(options), options, true).count();
  },
  byKey: function(key, extraOptions) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
  },
  _byKeyImpl: abstract$4,
  insert: function(values) {
    var that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("inserting", [values]);
    return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
      that._eventsStrategy.fireEvent("inserted", [callbackValues, callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _insertImpl: abstract$4,
  update: function(key, values) {
    var that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("updating", [key, values]);
    return that._addFailHandlers(that._updateImpl(key, values).done(function() {
      that._eventsStrategy.fireEvent("updated", [key, values]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _updateImpl: abstract$4,
  push: function(changes) {
    var beforePushArgs = {
      changes,
      waitFor: []
    };
    this._eventsStrategy.fireEvent("beforePush", [beforePushArgs]);
    when(...beforePushArgs.waitFor).done(() => {
      this._pushImpl(changes);
      this._eventsStrategy.fireEvent("push", [changes]);
    });
  },
  _pushImpl: noop,
  remove: function(key) {
    var that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("removing", [key]);
    return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
      that._eventsStrategy.fireEvent("removed", [callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _removeImpl: abstract$4,
  _addFailHandlers: function(deferred) {
    return deferred.fail(this._errorHandler).fail(handleError);
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
Store.create = function(alias, options) {
  if (!(alias in storeImpl)) {
    throw errors.Error("E4020", alias);
  }
  return new storeImpl[alias](options);
};
Store.registerClass = function(type2, alias) {
  if (alias) {
    storeImpl[alias] = type2;
  }
  return type2;
};
Store.inherit = function(inheritor) {
  return function(members, alias) {
    var type2 = inheritor.apply(this, [members]);
    Store.registerClass(type2, alias);
    return type2;
  };
}(Store.inherit);
var TOTAL_COUNT = "totalCount";
var LOAD = "load";
var BY_KEY = "byKey";
var INSERT = "insert";
var UPDATE = "update";
var REMOVE = "remove";
function isPromise(obj) {
  return obj && isFunction$1(obj.then);
}
function trivialPromise(value2) {
  return new Deferred().resolve(value2).promise();
}
function ensureRequiredFuncOption(name2, obj) {
  if (!isFunction$1(obj)) {
    throw errors.Error("E4011", name2);
  }
}
function throwInvalidUserFuncResult(name2) {
  throw errors.Error("E4012", name2);
}
function createUserFuncFailureHandler(pendingDeferred) {
  function errorMessageFromXhr$1(promiseArguments) {
    var xhr = promiseArguments[0];
    var textStatus = promiseArguments[1];
    if (!xhr || !xhr.getResponseHeader) {
      return null;
    }
    return errorMessageFromXhr(xhr, textStatus);
  }
  return function(arg) {
    var error;
    if (arg instanceof Error) {
      error = arg;
    } else {
      error = new Error(errorMessageFromXhr$1(arguments) || arg && String(arg) || "Unknown error");
    }
    if (error.message !== XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error);
    }
  };
}
function invokeUserLoad(store, options) {
  var userFunc = store._loadFunc;
  var userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options]);
  if (Array.isArray(userResult)) {
    userResult = trivialPromise(userResult);
  } else if (userResult === null || userResult === void 0) {
    userResult = trivialPromise([]);
  } else if (!isPromise(userResult)) {
    throwInvalidUserFuncResult(LOAD);
  }
  return fromPromise(userResult);
}
function invokeUserTotalCountFunc(store, options) {
  var userFunc = store._totalCountFunc;
  var userResult;
  if (!isFunction$1(userFunc)) {
    throw errors.Error("E4021");
  }
  userResult = userFunc.apply(store, [options]);
  if (!isPromise(userResult)) {
    userResult = Number(userResult);
    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }
    userResult = trivialPromise(userResult);
  }
  return fromPromise(userResult);
}
function invokeUserByKeyFunc(store, key, extraOptions) {
  var userFunc = store._byKeyFunc;
  var userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);
  if (!isPromise(userResult)) {
    userResult = trivialPromise(userResult);
  }
  return fromPromise(userResult);
}
function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    var loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }
    loadPromise.always(function() {
      delete store.__rawDataPromise;
    }).done(function(rawData) {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }
      continuation(rawData);
    }).fail(createUserFuncFailureHandler(pendingDeferred));
  }
}
function runRawLoadWithQuery(pendingDeferred, store, options, countOnly) {
  options = options || {};
  var userFuncOptions = {};
  if ("userData" in options) {
    userFuncOptions.userData = options.userData;
  }
  runRawLoad(pendingDeferred, store, userFuncOptions, function(rawData) {
    var rawDataQuery = arrayQueryImpl(rawData, {
      errorHandler: store._errorHandler
    });
    var itemsQuery;
    var totalCountQuery;
    var waitList = [];
    var items;
    var totalCount;
    if (!countOnly) {
      itemsQuery = storeHelper.queryByOptions(rawDataQuery, options);
      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        waitList.push(itemsQuery.enumerate().done(function(asyncResult) {
          items = asyncResult;
        }));
      }
    }
    if (options.requireTotalCount || countOnly) {
      totalCountQuery = storeHelper.queryByOptions(rawDataQuery, options, true);
      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        waitList.push(totalCountQuery.count().done(function(asyncResult) {
          totalCount = asyncResult;
        }));
      }
    }
    when.apply($, waitList).done(function() {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail(function(x) {
      pendingDeferred.reject(x);
    });
  });
}
function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, function(rawData) {
    var keyExpr = store.key();
    var item;
    for (var i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];
      if (keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }
    pendingDeferred.reject(errors.Error("E4009"));
  });
}
var CustomStore = Store.inherit({
  ctor: function(options) {
    options = options || {};
    this.callBase(options);
    this._useDefaultSearch = !!options.useDefaultSearch || options.loadMode === "raw";
    this._loadMode = options.loadMode;
    this._cacheRawData = options.cacheRawData !== false;
    this._loadFunc = options[LOAD];
    this._totalCountFunc = options[TOTAL_COUNT];
    this._byKeyFunc = options[BY_KEY];
    this._insertFunc = options[INSERT];
    this._updateFunc = options[UPDATE];
    this._removeFunc = options[REMOVE];
  },
  createQuery: function() {
    throw errors.Error("E4010");
  },
  clearRawDataCache: function() {
    delete this.__rawData;
  },
  _totalCountImpl: function(options) {
    var d = new Deferred();
    if (this._loadMode === "raw" && !this._totalCountFunc) {
      runRawLoadWithQuery(d, this, options, true);
    } else {
      invokeUserTotalCountFunc(this, options).done(function(count) {
        d.resolve(Number(count));
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _pushImpl: function(changes) {
    if (this.__rawData) {
      applyBatch({
        keyInfo: this,
        data: this.__rawData,
        changes
      });
    }
  },
  _loadImpl: function(options) {
    var d = new Deferred();
    if (this._loadMode === "raw") {
      runRawLoadWithQuery(d, this, options, false);
    } else {
      invokeUserLoad(this, options).done(function(data2, extra) {
        d.resolve(data2, extra);
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _byKeyImpl: function(key, extraOptions) {
    var d = new Deferred();
    if (this._byKeyViaLoad()) {
      this._requireKey();
      runRawLoadWithKey(d, this, key);
    } else {
      invokeUserByKeyFunc(this, key, extraOptions).done(function(obj) {
        d.resolve(obj);
      }).fail(createUserFuncFailureHandler(d));
    }
    return d.promise();
  },
  _byKeyViaLoad: function() {
    return this._loadMode === "raw" && !this._byKeyFunc;
  },
  _insertImpl: function(values) {
    var that = this;
    var userFunc = that._insertFunc;
    var userResult;
    var d = new Deferred();
    ensureRequiredFuncOption(INSERT, userFunc);
    userResult = userFunc.apply(that, [values]);
    if (!isPromise(userResult)) {
      userResult = trivialPromise(userResult);
    }
    fromPromise(userResult).done(function(serverResponse) {
      if (configMethod().useLegacyStoreResult) {
        d.resolve(values, serverResponse);
      } else {
        d.resolve(serverResponse || values, that.keyOf(serverResponse));
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _updateImpl: function(key, values) {
    var userFunc = this._updateFunc;
    var userResult;
    var d = new Deferred();
    ensureRequiredFuncOption(UPDATE, userFunc);
    userResult = userFunc.apply(this, [key, values]);
    if (!isPromise(userResult)) {
      userResult = trivialPromise(userResult);
    }
    fromPromise(userResult).done(function(serverResponse) {
      if (configMethod().useLegacyStoreResult) {
        d.resolve(key, values);
      } else {
        d.resolve(serverResponse || values, key);
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _removeImpl: function(key) {
    var userFunc = this._removeFunc;
    var userResult;
    var d = new Deferred();
    ensureRequiredFuncOption(REMOVE, userFunc);
    userResult = userFunc.apply(this, [key]);
    if (!isPromise(userResult)) {
      userResult = trivialPromise();
    }
    fromPromise(userResult).done(function() {
      d.resolve(key);
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  }
});
function createQueue(discardPendingTasks) {
  var _tasks = [];
  var _busy = false;
  function exec() {
    while (_tasks.length) {
      _busy = true;
      var task = _tasks.shift();
      var result = task();
      if (result === void 0) {
        continue;
      }
      if (result.then) {
        when(result).always(exec);
        return;
      }
      throw errors$2.Error("E0015");
    }
    _busy = false;
  }
  return {
    add: function(task, removeTaskCallback) {
      if (!discardPendingTasks) {
        _tasks.push(task);
      } else {
        if (_tasks[0] && removeTaskCallback) {
          removeTaskCallback(_tasks[0]);
        }
        _tasks = [task];
      }
      if (!_busy) {
        exec();
      }
    },
    busy: function() {
      return _busy;
    }
  };
}
createQueue().add;
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var queryAdapters = {};
var remoteQueryImpl = function remoteQueryImpl2(url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};
  var createTask = function(name2, args) {
    return {
      name: name2,
      args
    };
  };
  var exec = function(executorTask) {
    var d = new Deferred();
    var _adapterFactory;
    var _adapter;
    var _taskQueue;
    var _currentTask;
    var _mergedSortArgs;
    var rejectWithNotify = function(error) {
      var handler = queryOptions.errorHandler;
      if (handler) {
        handler(error);
      }
      handleError(error);
      d.reject(error);
    };
    function mergeSortTask(task) {
      switch (task.name) {
        case "sortBy":
          _mergedSortArgs = [task.args];
          return true;
        case "thenBy":
          if (!_mergedSortArgs) {
            throw errors.Error("E4004");
          }
          _mergedSortArgs.push(task.args);
          return true;
      }
      return false;
    }
    try {
      _adapterFactory = queryOptions.adapter;
      if (!isFunction$1(_adapterFactory)) {
        _adapterFactory = queryAdapters[_adapterFactory];
      }
      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      var optimize = _adapter.optimize;
      if (optimize) {
        optimize(_taskQueue);
      }
      while (_taskQueue.length) {
        _currentTask = _taskQueue[0];
        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
            _mergedSortArgs = null;
            continue;
          }
          if (String(_currentTask.name) !== "enumerate") {
            if (!_adapter[_currentTask.name] || _adapter[_currentTask.name].apply(_adapter, _currentTask.args) === false) {
              break;
            }
          }
        }
        _taskQueue.shift();
      }
      !function() {
        var head = _taskQueue[0];
        var unmergedTasks = [];
        if (head && head.name === "multiSort") {
          _taskQueue.shift();
          each(head.args[0], function() {
            unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this));
          });
        }
        _taskQueue = unmergedTasks.concat(_taskQueue);
      }();
      _adapter.exec(url).done(function(result, extra) {
        if (!_taskQueue.length) {
          d.resolve(result, extra);
        } else {
          var clientChain = arrayQueryImpl(result, {
            errorHandler: queryOptions.errorHandler
          });
          each(_taskQueue, function() {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          });
          clientChain.done(d.resolve).fail(d.reject);
        }
      }).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }
    return d.promise();
  };
  var query2 = {};
  each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
    var name2 = String(this);
    query2[name2] = function() {
      return remoteQueryImpl2(url, queryOptions, tasks.concat(createTask(name2, arguments)));
    };
  });
  each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
    var name2 = String(this);
    query2[name2] = function() {
      return exec.call(this, createTask(name2, arguments));
    };
  });
  return query2;
};
var queryImpl = {
  array: arrayQueryImpl,
  remote: remoteQueryImpl
};
var query = function() {
  var impl = Array.isArray(arguments[0]) ? "array" : "remote";
  return queryImpl[impl].apply(this, arguments);
};
var ArrayStore = Store.inherit({
  ctor: function(options) {
    if (Array.isArray(options)) {
      options = {
        data: options
      };
    } else {
      options = options || {};
    }
    this.callBase(options);
    var initialArray = options.data;
    if (initialArray && !Array.isArray(initialArray)) {
      throw errors.Error("E4006");
    }
    this._array = initialArray || [];
  },
  createQuery: function() {
    return query(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl: function(key) {
    var index2 = indexByKey(this, this._array, key);
    if (index2 === -1) {
      return rejectedPromise(errors.Error("E4009"));
    }
    return trivialPromise$1(this._array[index2]);
  },
  _insertImpl: function(values) {
    return insert(this, this._array, values);
  },
  _pushImpl: function(changes) {
    applyBatch({
      keyInfo: this,
      data: this._array,
      changes
    });
  },
  _updateImpl: function(key, values) {
    return update(this, this._array, key, values);
  },
  _removeImpl: function(key) {
    return remove(this, this._array, key);
  },
  clear: function() {
    this._eventsStrategy.fireEvent("modifying");
    this._array = [];
    this._eventsStrategy.fireEvent("modified");
  }
}, "array");
var _excluded = ["items"];
var CANCELED_TOKEN = "canceled";
var isPending = (deferred) => deferred.state() === "pending";
var normalizeStoreLoadOptionAccessorArguments = (originalArguments) => {
  switch (originalArguments.length) {
    case 0:
      return;
    case 1:
      return originalArguments[0];
  }
  return [].slice.call(originalArguments);
};
var mapGroup = (group, level, mapper) => map(group, (item) => {
  var restItem = _objectWithoutPropertiesLoose(item, _excluded);
  return _extends({}, restItem, {
    items: mapRecursive(item.items, level - 1, mapper)
  });
});
var mapRecursive = (items, level, mapper) => {
  if (!Array.isArray(items)) {
    return items;
  }
  return level ? mapGroup(items, level, mapper) : map(items, mapper);
};
var mapDataRespectingGrouping = (items, mapper, groupInfo) => {
  var level = groupInfo ? normalizeSortingInfo$1(groupInfo).length : 0;
  return mapRecursive(items, level, mapper);
};
var normalizeLoadResult = (data2, extra) => {
  var _data;
  if ((_data = data2) !== null && _data !== void 0 && _data.data) {
    extra = data2;
    data2 = data2.data;
  }
  if (!Array.isArray(data2)) {
    data2 = [data2];
  }
  return {
    data: data2,
    extra
  };
};
var createCustomStoreFromLoadFunc = (options) => {
  var storeConfig = {};
  each(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
    storeConfig[this] = options[this];
    delete options[this];
  });
  return new CustomStore(storeConfig);
};
var createStoreFromConfig = (storeConfig) => {
  var alias = storeConfig.type;
  delete storeConfig.type;
  return Store.create(alias, storeConfig);
};
var createCustomStoreFromUrl = (url, normalizationOptions) => new CustomStore({
  load: () => ajax.sendRequest({
    url,
    dataType: "json"
  }),
  loadMode: normalizationOptions === null || normalizationOptions === void 0 ? void 0 : normalizationOptions.fromUrlLoadMode
});
var normalizeDataSourceOptions = (options, normalizationOptions) => {
  var store;
  if (typeof options === "string") {
    options = {
      paginate: false,
      store: createCustomStoreFromUrl(options, normalizationOptions)
    };
  }
  if (options === void 0) {
    options = [];
  }
  if (Array.isArray(options) || options instanceof Store) {
    options = {
      store: options
    };
  } else {
    options = extend({}, options);
  }
  if (options.store === void 0) {
    options.store = [];
  }
  store = options.store;
  if ("load" in options) {
    store = createCustomStoreFromLoadFunc(options);
  } else if (Array.isArray(store)) {
    store = new ArrayStore(store);
  } else if (isPlainObject(store)) {
    store = createStoreFromConfig(extend({}, store));
  }
  options.store = store;
  return options;
};
class OperationManager {
  constructor() {
    this._counter = -1;
    this._deferreds = {};
  }
  add(deferred) {
    this._counter++;
    this._deferreds[this._counter] = deferred;
    return this._counter;
  }
  remove(operationId) {
    return delete this._deferreds[operationId];
  }
  cancel(operationId) {
    if (operationId in this._deferreds) {
      this._deferreds[operationId].reject(CANCELED_TOKEN);
      return true;
    }
    return false;
  }
  cancelAll() {
    while (this._counter > -1) {
      this.cancel(this._counter);
      this._counter--;
    }
  }
}
var DataSource = classImpl.inherit({
  ctor(options) {
    var _options$reshapeOnPus;
    options = normalizeDataSourceOptions(options);
    this._eventsStrategy = new EventsStrategy(this, {
      syncStrategy: true
    });
    this._store = options.store;
    this._changedTime = 0;
    var needThrottling = options.pushAggregationTimeout !== 0;
    if (needThrottling) {
      var throttlingTimeout = options.pushAggregationTimeout === void 0 ? () => 5 * this._changedTime : options.pushAggregationTimeout;
      var pushDeferred;
      var lastPushWaiters;
      var throttlingPushHandler = throttleChanges((changes) => {
        pushDeferred.resolve();
        var storePushPending = when(...lastPushWaiters);
        storePushPending.done(() => this._onPush(changes));
        lastPushWaiters = void 0;
        pushDeferred = void 0;
      }, throttlingTimeout);
      this._onPushHandler = (args) => {
        this._aggregationTimeoutId = throttlingPushHandler(args.changes);
        if (!pushDeferred) {
          pushDeferred = new Deferred();
        }
        lastPushWaiters = args.waitFor;
        args.waitFor.push(pushDeferred.promise());
      };
      this._store.on("beforePush", this._onPushHandler);
    } else {
      this._onPushHandler = (changes) => this._onPush(changes);
      this._store.on("push", this._onPushHandler);
    }
    this._storeLoadOptions = this._extractLoadOptions(options);
    this._mapFunc = options.map;
    this._postProcessFunc = options.postProcess;
    this._pageIndex = options.pageIndex !== void 0 ? options.pageIndex : 0;
    this._pageSize = options.pageSize !== void 0 ? options.pageSize : 20;
    this._loadingCount = 0;
    this._loadQueue = this._createLoadQueue();
    this._searchValue = "searchValue" in options ? options.searchValue : null;
    this._searchOperation = options.searchOperation || "contains";
    this._searchExpr = options.searchExpr;
    this._paginate = options.paginate;
    this._reshapeOnPush = (_options$reshapeOnPus = options.reshapeOnPush) !== null && _options$reshapeOnPus !== void 0 ? _options$reshapeOnPus : false;
    each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], (_2, optionName) => {
      if (optionName in options) {
        this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName]);
      }
    });
    this._operationManager = new OperationManager();
    this._init();
  },
  _init() {
    this._items = [];
    this._userData = {};
    this._totalCount = -1;
    this._isLoaded = false;
    if (!isDefined(this._paginate)) {
      this._paginate = !this.group();
    }
    this._isLastPage = !this._paginate;
  },
  dispose() {
    var _this$_delayedLoadTas;
    this._store.off("beforePush", this._onPushHandler);
    this._store.off("push", this._onPushHandler);
    this._eventsStrategy.dispose();
    clearTimeout(this._aggregationTimeoutId);
    delete this._store;
    (_this$_delayedLoadTas = this._delayedLoadTask) === null || _this$_delayedLoadTas === void 0 ? void 0 : _this$_delayedLoadTas.abort();
    this._operationManager.cancelAll();
    this._disposed = true;
  },
  _extractLoadOptions(options) {
    var result = {};
    var names = ["sort", "filter", "select", "group", "requireTotalCount"];
    var customNames = this._store._customLoadOptions();
    if (customNames) {
      names = names.concat(customNames);
    }
    each(names, function() {
      result[this] = options[this];
    });
    return result;
  },
  loadOptions() {
    return this._storeLoadOptions;
  },
  items() {
    return this._items;
  },
  pageIndex(newIndex) {
    if (!isNumeric(newIndex)) {
      return this._pageIndex;
    }
    this._pageIndex = newIndex;
    this._isLastPage = !this._paginate;
  },
  paginate(value2) {
    if (!isBoolean(value2)) {
      return this._paginate;
    }
    if (this._paginate !== value2) {
      this._paginate = value2;
      this.pageIndex(0);
    }
  },
  pageSize(value2) {
    if (!isNumeric(value2)) {
      return this._pageSize;
    }
    this._pageSize = value2;
  },
  isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor(optionName) {
    return (args) => {
      var normalizedArgs = normalizeStoreLoadOptionAccessorArguments(args);
      if (normalizedArgs === void 0) {
        return this._storeLoadOptions[optionName];
      }
      this._storeLoadOptions[optionName] = normalizedArgs;
    };
  },
  sort() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.generateStoreLoadOptionAccessor("sort")(args);
  },
  filter() {
    var newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
    if (newFilter === void 0) {
      return this._storeLoadOptions.filter;
    }
    this._storeLoadOptions.filter = newFilter;
    this.pageIndex(0);
  },
  group() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.generateStoreLoadOptionAccessor("group")(args);
  },
  select() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.generateStoreLoadOptionAccessor("select")(args);
  },
  requireTotalCount(value2) {
    if (!isBoolean(value2)) {
      return this._storeLoadOptions.requireTotalCount;
    }
    this._storeLoadOptions.requireTotalCount = value2;
  },
  searchValue(value2) {
    if (arguments.length < 1) {
      return this._searchValue;
    }
    this._searchValue = value2;
    this.pageIndex(0);
  },
  searchOperation(op) {
    if (!isString$1(op)) {
      return this._searchOperation;
    }
    this._searchOperation = op;
    this.pageIndex(0);
  },
  searchExpr(expr) {
    var argc = arguments.length;
    if (argc === 0) {
      return this._searchExpr;
    }
    if (argc > 1) {
      expr = [].slice.call(arguments);
    }
    this._searchExpr = expr;
    this.pageIndex(0);
  },
  store() {
    return this._store;
  },
  key() {
    var _this$_store;
    return (_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.key();
  },
  totalCount() {
    return this._totalCount;
  },
  isLoaded() {
    return this._isLoaded;
  },
  isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue: () => createQueue(),
  _changeLoadingCount(increment) {
    var oldLoading = this.isLoading();
    this._loadingCount += increment;
    var newLoading = this.isLoading();
    if (oldLoading ^ newLoading) {
      this._eventsStrategy.fireEvent("loadingChanged", [newLoading]);
    }
  },
  _scheduleLoadCallbacks(deferred) {
    this.beginLoading();
    deferred.always(() => {
      this.endLoading();
    });
  },
  _scheduleFailCallbacks(deferred) {
    var _this = this;
    deferred.fail(function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (args[0] === CANCELED_TOKEN) {
        return;
      }
      _this._eventsStrategy.fireEvent("loadError", args);
    });
  },
  _fireChanged(args) {
    var date = new Date();
    this._eventsStrategy.fireEvent("changed", args);
    this._changedTime = new Date() - date;
  },
  _scheduleChangedCallbacks(deferred) {
    deferred.done(() => this._fireChanged());
  },
  loadSingle(propName, propValue) {
    var d = new Deferred();
    var key = this.key();
    var store = this._store;
    var options = this._createStoreLoadOptions();
    this._scheduleFailCallbacks(d);
    if (arguments.length < 2) {
      propValue = propName;
      propName = key;
    }
    delete options.skip;
    delete options.group;
    delete options.refresh;
    delete options.pageIndex;
    delete options.searchString;
    (() => {
      if (propName === key || store instanceof CustomStore && !store._byKeyViaLoad()) {
        return store.byKey(propValue, options);
      }
      options.take = 1;
      options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
      return store.load(options);
    })().fail(d.reject).done((data2) => {
      if (!isDefined(data2) || isEmpty(data2)) {
        d.reject(new errors.Error("E4009"));
      } else {
        if (!Array.isArray(data2)) {
          data2 = [data2];
        }
        d.resolve(this._applyMapFunction(data2)[0]);
      }
    });
    return d.promise();
  },
  load() {
    var d = new Deferred();
    var loadTask = () => {
      if (this._disposed) {
        return;
      }
      if (!isPending(d)) {
        return;
      }
      return this._loadFromStore(loadOperation, d);
    };
    this._scheduleLoadCallbacks(d);
    this._scheduleFailCallbacks(d);
    this._scheduleChangedCallbacks(d);
    var loadOperation = this._createLoadOperation(d);
    this._eventsStrategy.fireEvent("customizeStoreLoadOptions", [loadOperation]);
    this._loadQueue.add(() => {
      if (typeof loadOperation.delay === "number") {
        this._delayedLoadTask = executeAsync(loadTask, loadOperation.delay);
      } else {
        loadTask();
      }
      return d.promise();
    });
    return d.promise({
      operationId: loadOperation.operationId
    });
  },
  _onPush(changes) {
    if (this._reshapeOnPush) {
      this.load();
    } else {
      this._eventsStrategy.fireEvent("changing", [{
        changes
      }]);
      var group = this.group();
      var items = this.items();
      var groupLevel = 0;
      var dataSourceChanges = this.paginate() || group ? changes.filter((item) => item.type === "update") : changes;
      if (group) {
        groupLevel = Array.isArray(group) ? group.length : 1;
      }
      if (this._mapFunc) {
        dataSourceChanges.forEach((item) => {
          if (item.type === "insert") {
            item.data = this._mapFunc(item.data);
          }
        });
      }
      applyBatch({
        keyInfo: this.store(),
        data: items,
        changes: dataSourceChanges,
        groupCount: groupLevel,
        useInsertIndex: true
      });
      this._fireChanged([{
        changes
      }]);
    }
  },
  _createLoadOperation(deferred) {
    var operationId = this._operationManager.add(deferred);
    var storeLoadOptions = this._createStoreLoadOptions();
    deferred.always(() => this._operationManager.remove(operationId));
    return {
      operationId,
      storeLoadOptions
    };
  },
  reload() {
    var store = this.store();
    if (store instanceof CustomStore) {
      store.clearRawDataCache();
    }
    this._init();
    return this.load();
  },
  cancel(operationId) {
    return this._operationManager.cancel(operationId);
  },
  cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions(storeLoadOptions) {
    if (this._disposed) {
      return;
    }
    if (this.store()._useDefaultSearch) {
      this._addSearchFilter(storeLoadOptions);
    } else {
      storeLoadOptions.searchOperation = this._searchOperation;
      storeLoadOptions.searchValue = this._searchValue;
      storeLoadOptions.searchExpr = this._searchExpr;
    }
  },
  _createStoreLoadOptions() {
    var result = extend({}, this._storeLoadOptions);
    this._addSearchOptions(result);
    if (this._paginate) {
      if (this._pageSize) {
        result.skip = this._pageIndex * this._pageSize;
        result.take = this._pageSize;
      }
    }
    result.userData = this._userData;
    return result;
  },
  _addSearchFilter(storeLoadOptions) {
    var value2 = this._searchValue;
    var op = this._searchOperation;
    var selector = this._searchExpr;
    var searchFilter = [];
    if (!value2) {
      return;
    }
    if (!selector) {
      selector = "this";
    }
    if (!Array.isArray(selector)) {
      selector = [selector];
    }
    each(selector, function(i, item) {
      if (searchFilter.length) {
        searchFilter.push("or");
      }
      searchFilter.push([item, op, value2]);
    });
    if (storeLoadOptions.filter) {
      storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
    } else {
      storeLoadOptions.filter = searchFilter;
    }
  },
  _loadFromStore(loadOptions, pendingDeferred) {
    var handleSuccess = (data2, extra) => {
      if (this._disposed) {
        return;
      }
      if (!isPending(pendingDeferred)) {
        return;
      }
      var loadResult = extend(normalizeLoadResult(data2, extra), loadOptions);
      this._eventsStrategy.fireEvent("customizeLoadResult", [loadResult]);
      when(loadResult.data).done((data3) => {
        loadResult.data = data3;
        this._processStoreLoadResult(loadResult, pendingDeferred);
      }).fail(pendingDeferred.reject);
    };
    if (loadOptions.data) {
      return new Deferred().resolve(loadOptions.data).done(handleSuccess);
    }
    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
  },
  _processStoreLoadResult(loadResult, pendingDeferred) {
    var data2 = loadResult.data;
    var extra = loadResult.extra;
    var storeLoadOptions = loadResult.storeLoadOptions;
    var resolvePendingDeferred = () => {
      this._isLoaded = true;
      this._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
      return pendingDeferred.resolve(data2, extra);
    };
    if (this._disposed) {
      return;
    }
    data2 = this._applyPostProcessFunction(this._applyMapFunction(data2));
    if (!isPlainObject(extra)) {
      extra = {};
    }
    this._items = data2;
    if (!data2.length || !this._paginate || this._pageSize && data2.length < this._pageSize) {
      this._isLastPage = true;
    }
    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
      (() => {
        this.store().totalCount(storeLoadOptions).done(function(count) {
          extra.totalCount = count;
          resolvePendingDeferred();
        }).fail(pendingDeferred.reject);
      })();
    } else {
      resolvePendingDeferred();
    }
  },
  _applyMapFunction(data2) {
    if (this._mapFunc) {
      return mapDataRespectingGrouping(data2, this._mapFunc, this.group());
    }
    return data2;
  },
  _applyPostProcessFunction(data2) {
    if (this._postProcessFunc) {
      return this._postProcessFunc(data2);
    }
    return data2;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
var setFieldProperty = function(field, property, value2, isInitialization) {
  var initProperties = field._initProperties = field._initProperties || {};
  var initValue = isInitialization ? value2 : field[property];
  if (!Object.prototype.hasOwnProperty.call(initProperties, property) || isInitialization) {
    initProperties[property] = initValue;
  }
  field[property] = value2;
};
function sendRequest(options) {
  return ajax.sendRequest(options);
}
var foreachTreeAsyncDate = new Date();
function createForeachTreeFunc(isAsync) {
  return function foreachTreeFunc(items, callback, parentAtFirst, members, index2, isChildrenProcessing) {
    members = members || [];
    items = items || [];
    var i;
    var deferred;
    index2 = index2 || 0;
    function createForeachTreeAsyncHandler(deferred2, i2, isChildrenProcessing2) {
      when(foreachTreeFunc(items, callback, parentAtFirst, members, i2, isChildrenProcessing2)).done(deferred2.resolve);
    }
    for (i = index2; i < items.length; i++) {
      if (isAsync && i > index2 && i % 1e4 === 0 && new Date() - foreachTreeAsyncDate >= 300) {
        foreachTreeAsyncDate = new Date();
        deferred = new Deferred();
        setTimeout(createForeachTreeAsyncHandler(deferred, i, false), 0);
        return deferred;
      }
      var item = items[i];
      if (!isChildrenProcessing) {
        members.unshift(item);
        if (parentAtFirst && callback(members, i) === false) {
          return;
        }
        if (item.children) {
          var childrenDeferred = foreachTreeFunc(item.children, callback, parentAtFirst, members);
          if (isAsync && childrenDeferred) {
            deferred = new Deferred();
            childrenDeferred.done(createForeachTreeAsyncHandler(deferred, i, true));
            return deferred;
          }
        }
      }
      isChildrenProcessing = false;
      if (!parentAtFirst && callback(members, i) === false) {
        return;
      }
      members.shift();
      if (items[i] !== item) {
        i--;
      }
    }
  };
}
var foreachTree = createForeachTreeFunc(false);
var foreachTreeAsync = createForeachTreeFunc(true);
function findField(fields, id) {
  if (fields && isDefined(id)) {
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      if (field.name === id || field.caption === id || field.dataField === id || field.index === id) {
        return i;
      }
    }
  }
  return -1;
}
function formatValue(value2, options) {
  var _a, _b;
  var valueText = value2 === value2 && formatHelper.format(value2, options.format);
  var formatObject = {
    value: value2,
    valueText: valueText || ""
  };
  var text = options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText;
  if (((_a = text == null ? void 0 : text.trim) == null ? void 0 : _a.call(text).length) === 0) {
    text = (_b = options.emptyPlaceHolder) != null ? _b : "";
  }
  return text;
}
function getCompareFunction(valueSelector) {
  return function(a, b) {
    var result = 0;
    var valueA = valueSelector(a);
    var valueB = valueSelector(b);
    var aIsDefined = isDefined(valueA);
    var bIsDefined = isDefined(valueB);
    if (aIsDefined && bIsDefined) {
      if (valueA > valueB) {
        result = 1;
      } else if (valueA < valueB) {
        result = -1;
      }
    }
    if (aIsDefined && !bIsDefined) {
      result = 1;
    }
    if (!aIsDefined && bIsDefined) {
      result = -1;
    }
    return result;
  };
}
function createPath(items) {
  var result = [];
  for (var i = items.length - 1; i >= 0; i--) {
    result.push(items[i].key || items[i].value);
  }
  return result;
}
function foreachDataLevel(data2, callback, index2, childrenField) {
  index2 = index2 || 0;
  childrenField = childrenField || "children";
  if (data2.length) {
    callback(data2, index2);
  }
  for (var i = 0; i < data2.length; i++) {
    var item = data2[i];
    if (item[childrenField] && item[childrenField].length) {
      foreachDataLevel(item[childrenField], callback, index2 + 1, childrenField);
    }
  }
}
function mergeArraysByMaxValue(values1, values2) {
  var result = [];
  for (var i = 0; i < values1.length; i++) {
    result.push(Math.max(values1[i] || 0, values2[i] || 0));
  }
  return result;
}
function getExpandedLevel$1(options, axisName) {
  var dimensions = options[axisName];
  var expandLevel = 0;
  var expandedPaths = (axisName === "columns" ? options.columnExpandedPaths : options.rowExpandedPaths) || [];
  if (options.headerName === axisName) {
    expandLevel = options.path.length;
  } else if (options.headerName && options.headerName !== axisName && options.oppositePath) {
    expandLevel = options.oppositePath.length;
  } else {
    each(expandedPaths, function(_2, path) {
      expandLevel = Math.max(expandLevel, path.length);
    });
  }
  while (dimensions[expandLevel + 1] && dimensions[expandLevel].expanded) {
    expandLevel++;
  }
  return expandLevel;
}
function createGroupFields(item) {
  return map(["year", "quarter", "month"], function(value2, index2) {
    return extend({}, item, {
      groupInterval: value2,
      groupIndex: index2
    });
  });
}
function parseFields(dataSource, fieldsList, path, fieldsDataType) {
  var result = [];
  Object.keys(fieldsList || []).forEach(function(field) {
    if (field && field.indexOf("__") === 0) {
      return;
    }
    var dataIndex = 1;
    var currentPath = path.length ? path + "." + field : field;
    var dataType = fieldsDataType[currentPath];
    var getter = compileGetter(currentPath);
    var value2 = fieldsList[field];
    var items;
    while (!isDefined(value2) && dataSource[dataIndex]) {
      value2 = getter(dataSource[dataIndex]);
      dataIndex++;
    }
    if (!dataType && isDefined(value2)) {
      dataType = type(value2);
    }
    items = [{
      dataField: currentPath,
      dataType,
      groupName: dataType === "date" ? field : void 0,
      groupInterval: void 0,
      displayFolder: path
    }];
    if (dataType === "date") {
      items = items.concat(createGroupFields(items[0]));
    } else if (dataType === "object") {
      items = parseFields(dataSource, value2, currentPath, fieldsDataType);
    }
    result.push.apply(result, items);
  });
  return result;
}
function discoverObjectFields(items, fields) {
  var fieldsDataType = getFieldsDataType(fields);
  return parseFields(items, items[0], "", fieldsDataType);
}
function getFieldsDataType(fields) {
  var result = {};
  each(fields, function(_2, field) {
    result[field.dataField] = result[field.dataField] || field.dataType;
  });
  return result;
}
var DATE_INTERVAL_FORMATS = {
  month: function(value2) {
    return dateLocalization.getMonthNames()[value2 - 1];
  },
  quarter: function(value2) {
    return dateLocalization.format(new Date(2e3, 3 * value2 - 1), "quarter");
  },
  dayOfWeek: function(value2) {
    return dateLocalization.getDayNames()[value2];
  }
};
function setDefaultFieldValueFormatting(field) {
  if (field.dataType === "date") {
    if (!field.format) {
      setFieldProperty(field, "format", DATE_INTERVAL_FORMATS[field.groupInterval]);
    }
  } else if (field.dataType === "number") {
    var groupInterval = isNumeric(field.groupInterval) && field.groupInterval > 0 && field.groupInterval;
    if (groupInterval && !field.customizeText) {
      setFieldProperty(field, "customizeText", function(formatObject) {
        var secondValue = formatObject.value + groupInterval;
        var secondValueText = formatHelper.format(secondValue, field.format);
        return formatObject.valueText && secondValueText ? formatObject.valueText + " - " + secondValueText : "";
      });
    }
  }
}
function getFiltersByPath(fields, path) {
  var result = [];
  path = path || [];
  for (var i = 0; i < path.length; i++) {
    result.push(extend({}, fields[i], {
      groupIndex: null,
      groupName: null,
      filterType: "include",
      filterValues: [path[i]]
    }));
  }
  return result;
}
var storeDrillDownMixin = {
  createDrillDownDataSource: function(descriptions, params) {
    var items = this.getDrillDownItems(descriptions, params);
    function createCustomStoreMethod(methodName) {
      return function(options) {
        var d;
        {
          d = new Deferred();
          when(items).done(function(data2) {
            var arrayStore = new ArrayStore(data2);
            arrayStore[methodName](options).done(d.resolve).fail(d.reject);
          }).fail(d.reject);
        }
        return d;
      };
    }
    var dataSource = new DataSource({
      load: createCustomStoreMethod("load"),
      totalCount: createCustomStoreMethod("totalCount"),
      key: this.key()
    });
    return dataSource;
  }
};
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var NEW_SCROLLING_MODE$1 = "scrolling.newMode";
var needTwoPagesLoading = (that) => that.option("scrolling.loadTwoPagesOnStart") || that._controller.isVirtual() || that._controller.getViewportItemIndex() > 0;
var getBeginPageIndex = (that) => that._cache.length ? that._cache[0].pageIndex : -1;
var getEndPageIndex = (that) => that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1;
var fireChanged = (that, changed, args) => {
  that._isChangedFiring = true;
  changed(args);
  that._isChangedFiring = false;
};
var processDelayChanged = (that, changed, args) => {
  if (that._isDelayChanged) {
    that._isDelayChanged = false;
    fireChanged(that, changed, args);
    return true;
  }
};
var getViewportPageCount = (that) => {
  var pageSize = that._dataOptions.pageSize();
  var preventPreload = that.option("scrolling.preventPreload");
  if (preventPreload) {
    return 0;
  }
  var realViewportSize = that._controller.viewportSize();
  if (that._controller.isVirtualMode() && that.option("scrolling.removeInvisiblePages")) {
    realViewportSize = 0;
    var viewportSize = that._controller.viewportSize() * that._controller.viewportItemSize();
    var offset2 = that._controller.getContentOffset();
    var position2 = that._controller.getViewportPosition();
    var virtualItemsCount = that._controller.virtualItemsCount();
    var totalItemsCount = that._dataOptions.totalItemsCount();
    for (var itemIndex = virtualItemsCount.begin; itemIndex < totalItemsCount; itemIndex++) {
      if (offset2 >= position2 + viewportSize) {
        break;
      }
      var itemSize = that._controller.getItemSizes()[itemIndex] || that._controller.viewportItemSize();
      offset2 += itemSize;
      if (offset2 >= position2) {
        realViewportSize++;
      }
    }
  }
  return pageSize && realViewportSize > 0 ? Math.ceil(realViewportSize / pageSize) : 1;
};
var getPreloadPageCount = (that, previous) => {
  var preloadEnabled = that.option("scrolling.preloadEnabled");
  var pageCount = getViewportPageCount(that);
  var isAppendMode = that._controller.isAppendMode();
  if (pageCount) {
    if (previous) {
      pageCount = preloadEnabled ? 1 : 0;
    } else {
      if (preloadEnabled) {
        pageCount++;
      }
      if (isAppendMode || !needTwoPagesLoading(that)) {
        pageCount--;
      }
    }
  }
  return pageCount;
};
var getPageIndexForLoad = (that) => {
  var result = -1;
  var beginPageIndex = getBeginPageIndex(that);
  var dataOptions = that._dataOptions;
  if (beginPageIndex < 0) {
    result = that._pageIndex;
  } else if (!that._cache[that._pageIndex - beginPageIndex]) {
    result = that._pageIndex;
  } else if (beginPageIndex >= 0 && that._controller.viewportSize() >= 0) {
    if (beginPageIndex > 0) {
      var needToLoadPageBeforeLast = getEndPageIndex(that) + 1 === dataOptions.pageCount() && that._cache.length < getPreloadPageCount(that) + 1;
      var needToLoadPrevPage = needToLoadPageBeforeLast || that._pageIndex === beginPageIndex && getPreloadPageCount(that, true);
      if (needToLoadPrevPage) {
        result = beginPageIndex - 1;
      }
    }
    if (result < 0) {
      var needToLoadNextPage = beginPageIndex + that._cache.length <= that._pageIndex + getPreloadPageCount(that);
      if (needToLoadNextPage) {
        result = beginPageIndex + that._cache.length;
      }
    }
  }
  if (that._loadingPageIndexes[result]) {
    result = -1;
  }
  return result;
};
var loadCore = (that, pageIndex) => {
  var dataOptions = that._dataOptions;
  if (pageIndex === that.pageIndex() || !dataOptions.isLoading() && pageIndex < dataOptions.pageCount() || !dataOptions.hasKnownLastPage() && pageIndex === dataOptions.pageCount()) {
    dataOptions.pageIndex(pageIndex);
    that._loadingPageIndexes[pageIndex] = true;
    return when(dataOptions.load()).always(() => {
      that._loadingPageIndexes[pageIndex] = false;
    });
  }
};
var processChanged = (that, changed, changeType, isDelayChanged, removeCacheItem) => {
  var dataOptions = that._dataOptions;
  var items = dataOptions.items().slice();
  var change = isObject$1(changeType) ? changeType : void 0;
  var isPrepend = changeType === "prepend";
  var viewportItems = dataOptions.viewportItems();
  if (changeType && isString$1(changeType) && !that._isDelayChanged) {
    change = {
      changeType,
      items
    };
    if (removeCacheItem) {
      change.removeCount = removeCacheItem.itemsCount;
      if (change.removeCount && dataOptions.correctCount) {
        change.removeCount = dataOptions.correctCount(viewportItems, change.removeCount, isPrepend);
      }
    }
  }
  var removeItemCount = removeCacheItem ? removeCacheItem.itemsLength : 0;
  if (removeItemCount && dataOptions.correctCount) {
    removeItemCount = dataOptions.correctCount(viewportItems, removeItemCount, isPrepend);
  }
  if (changeType === "append") {
    viewportItems.push.apply(viewportItems, items);
    if (removeCacheItem) {
      viewportItems.splice(0, removeItemCount);
    }
  } else if (isPrepend) {
    viewportItems.unshift.apply(viewportItems, items);
    if (removeCacheItem) {
      viewportItems.splice(-removeItemCount);
    }
  } else {
    that._dataOptions.viewportItems(items);
  }
  dataOptions.updateLoading();
  that._lastPageIndex = that.pageIndex();
  that._isDelayChanged = isDelayChanged;
  if (!isDelayChanged) {
    fireChanged(that, changed, change);
  }
};
class VirtualDataLoader {
  constructor(controller, dataOptions) {
    this._controller = controller;
    this._dataOptions = dataOptions;
    this._pageIndex = this._lastPageIndex = dataOptions.pageIndex();
    this._cache = [];
    this._loadingPageIndexes = {};
  }
  option() {
    return this._controller.option.apply(this._controller, arguments);
  }
  viewportItemIndexChanged(itemIndex) {
    var pageSize = this._dataOptions.pageSize();
    var pageCount = this._dataOptions.pageCount();
    var virtualMode = this._controller.isVirtualMode();
    var appendMode = this._controller.isAppendMode();
    var totalItemsCount = this._dataOptions.totalItemsCount();
    var newPageIndex;
    if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
      var viewportSize = this._controller.viewportSize();
      if (viewportSize && itemIndex + viewportSize >= totalItemsCount && !this._controller.isVirtual()) {
        if (this._dataOptions.hasKnownLastPage()) {
          newPageIndex = pageCount - 1;
          var lastPageSize = totalItemsCount % pageSize;
          if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < viewportSize) {
            newPageIndex--;
          }
        } else {
          newPageIndex = pageCount;
        }
      } else {
        newPageIndex = Math.floor(itemIndex / pageSize);
        var maxPageIndex = pageCount - 1;
        newPageIndex = Math.max(newPageIndex, 0);
        newPageIndex = Math.min(newPageIndex, maxPageIndex);
      }
      this.pageIndex(newPageIndex);
      return this.load();
    }
  }
  pageIndex(pageIndex) {
    var isVirtualMode = this._controller.isVirtualMode();
    var isAppendMode = this._controller.isAppendMode();
    if (!this.option(NEW_SCROLLING_MODE$1) && (isVirtualMode || isAppendMode)) {
      if (pageIndex !== void 0) {
        this._pageIndex = pageIndex;
      }
      return this._pageIndex;
    } else {
      return this._dataOptions.pageIndex(pageIndex);
    }
  }
  beginPageIndex(defaultPageIndex) {
    var beginPageIndex = getBeginPageIndex(this);
    if (beginPageIndex < 0) {
      beginPageIndex = defaultPageIndex !== void 0 ? defaultPageIndex : this.pageIndex();
    }
    return beginPageIndex;
  }
  endPageIndex() {
    var endPageIndex = getEndPageIndex(this);
    return endPageIndex > 0 ? endPageIndex : this._lastPageIndex;
  }
  pageSize() {
    return this._dataOptions.pageSize();
  }
  load() {
    var dataOptions = this._dataOptions;
    var result;
    var isVirtualMode = this._controller.isVirtualMode();
    var isAppendMode = this._controller.isAppendMode();
    if (!this.option(NEW_SCROLLING_MODE$1) && (isVirtualMode || isAppendMode)) {
      var pageIndexForLoad = getPageIndexForLoad(this);
      if (pageIndexForLoad >= 0) {
        var loadResult = loadCore(this, pageIndexForLoad);
        if (loadResult) {
          result = new Deferred();
          loadResult.done(() => {
            var delayDeferred = this._delayDeferred;
            if (delayDeferred) {
              delayDeferred.done(result.resolve).fail(result.reject);
            } else {
              result.resolve();
            }
          }).fail(result.reject);
          dataOptions.updateLoading();
        }
      }
    } else {
      result = dataOptions.load();
    }
    if (!result && this._lastPageIndex !== this.pageIndex()) {
      this._dataOptions.onChanged({
        changeType: "pageIndex"
      });
    }
    return result || new Deferred().resolve();
  }
  loadIfNeed() {
    var isVirtualMode = this._controller.isVirtualMode();
    var isAppendMode = this._controller.isAppendMode();
    if ((isVirtualMode || isAppendMode) && !this._dataOptions.isLoading() && (!this._isChangedFiring || this._controller.isVirtual())) {
      var position2 = this._controller.getViewportPosition();
      if (position2 > 0) {
        this._controller._setViewportPositionCore(position2);
      } else {
        this.load();
      }
    }
  }
  handleDataChanged(callBase, e) {
    var dataOptions = this._dataOptions;
    var lastCacheLength = this._cache.length;
    var changeType;
    var removeInvisiblePages;
    var isVirtualMode = this._controller.isVirtualMode();
    var isAppendMode = this._controller.isAppendMode();
    if (e && e.changes) {
      fireChanged(this, callBase, e);
    } else if (!this.option(NEW_SCROLLING_MODE$1) && (isVirtualMode || isAppendMode)) {
      var beginPageIndex = getBeginPageIndex(this);
      if (beginPageIndex >= 0) {
        if (isVirtualMode && beginPageIndex + this._cache.length !== dataOptions.pageIndex() && beginPageIndex - 1 !== dataOptions.pageIndex()) {
          lastCacheLength = 0;
          this._cache = [];
        }
        if (isAppendMode) {
          if (dataOptions.pageIndex() === 0) {
            this._cache = [];
          } else if (dataOptions.pageIndex() < getEndPageIndex(this)) {
            fireChanged(this, callBase, {
              changeType: "append",
              items: []
            });
            return;
          }
        }
      }
      var cacheItem = {
        pageIndex: dataOptions.pageIndex(),
        itemsLength: dataOptions.items(true).length,
        itemsCount: this.itemsCount(true)
      };
      if (this.option("scrolling.removeInvisiblePages") && isVirtualMode) {
        removeInvisiblePages = this._cache.length > Math.max(getPreloadPageCount(this) + (this.option("scrolling.preloadEnabled") ? 1 : 0), 2);
      } else {
        processDelayChanged(this, callBase, {
          isDelayed: true
        });
      }
      var removeCacheItem;
      if (beginPageIndex === dataOptions.pageIndex() + 1) {
        if (removeInvisiblePages) {
          removeCacheItem = this._cache.pop();
        }
        changeType = "prepend";
        this._cache.unshift(cacheItem);
      } else {
        if (removeInvisiblePages) {
          removeCacheItem = this._cache.shift();
        }
        changeType = "append";
        this._cache.push(cacheItem);
      }
      var isDelayChanged = isVirtualMode && lastCacheLength === 0 && needTwoPagesLoading(this);
      processChanged(this, callBase, this._cache.length > 1 ? changeType : void 0, isDelayChanged, removeCacheItem);
      this._delayDeferred = this.load().done(() => {
        if (processDelayChanged(this, callBase)) {
          this.load();
        }
      });
    } else {
      processChanged(this, callBase, e);
    }
  }
  getDelayDeferred() {
    return this._delayDeferred;
  }
  itemsCount(isBase) {
    var itemsCount = 0;
    var isVirtualMode = this._controller.isVirtualMode();
    if (!isBase && isVirtualMode) {
      this._cache.forEach((cacheItem) => {
        itemsCount += cacheItem.itemsCount;
      });
    } else {
      itemsCount = this._dataOptions.itemsCount();
    }
    return itemsCount;
  }
  virtualItemsCount() {
    var pageIndex = getBeginPageIndex(this);
    if (pageIndex < 0) {
      pageIndex = this._dataOptions.pageIndex();
    }
    var beginItemsCount = pageIndex * this._dataOptions.pageSize();
    var itemsCount = this._cache.length * this._dataOptions.pageSize();
    var endItemsCount = Math.max(0, this._dataOptions.totalItemsCount() - itemsCount - beginItemsCount);
    return {
      begin: beginItemsCount,
      end: endItemsCount
    };
  }
  reset() {
    this._loadingPageIndexes = {};
    this._cache = [];
  }
}
var SCROLLING_MODE_INFINITE = "infinite";
var SCROLLING_MODE_VIRTUAL = "virtual";
var NEW_SCROLLING_MODE = "scrolling.newMode";
var _isVirtualMode = (that) => that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL || that._isVirtual;
var _isAppendMode = (that) => that.option("scrolling.mode") === SCROLLING_MODE_INFINITE && !that._isVirtual;
var getPixelRatio = (window2) => window2.devicePixelRatio || 1;
function getContentHeightLimit(browser) {
  if (browser.msie) {
    return 4e6;
  } else if (browser.mozilla) {
    return 8e6;
  }
  return 15e6 / getPixelRatio(getWindow());
}
function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {
  var $scrollElement;
  var scrollToArray = [];
  var disposeArray = [];
  $targetElement = $targetElement || $element;
  function getElementOffset(scrollable) {
    var $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;
    var scrollableOffset = animationPosition.offset($scrollableElement);
    if (!scrollableOffset) {
      return $element.offset().top;
    }
    return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top);
  }
  var widgetScrollStrategy = {
    on: function(scrollable, eventName, handler) {
      scrollable.on("scroll", handler);
    },
    off: function(scrollable, eventName, handler) {
      scrollable.off("scroll", handler);
    }
  };
  function subscribeToScrollEvents($scrollElement2) {
    var isDocument = $scrollElement2.get(0).nodeName === "#document";
    var scrollable = $scrollElement2.data("dxScrollable");
    var eventsStrategy = widgetScrollStrategy;
    if (!scrollable) {
      scrollable = isDocument && $(getWindow()) || $scrollElement2.css("overflowY") === "auto" && $scrollElement2;
      eventsStrategy = eventsEngine;
      if (!scrollable) {
        return;
      }
    }
    var handler = function(scrollable2) {
      return function() {
        var scrollTop = scrollable2.scrollTop() - getElementOffset(scrollable2);
        scrollTop = scrollTop > 0 ? scrollTop : 0;
        scrollChangedHandler(scrollTop);
      };
    }(scrollable);
    eventsStrategy.on(scrollable, "scroll", handler);
    scrollToArray.push(function(pos) {
      var topOffset = getElementOffset(scrollable);
      var scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
      if (pos - topOffset >= 0) {
        scrollable[scrollMethod](pos + topOffset);
      }
    });
    disposeArray.push(function() {
      eventsStrategy.off(scrollable, "scroll", handler);
    });
  }
  for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = $scrollElement.parent()) {
    subscribeToScrollEvents($scrollElement);
  }
  return {
    scrollTo: function(pos) {
      each(scrollToArray, function(_2, scrollTo) {
        scrollTo(pos);
      });
    },
    dispose: function() {
      each(disposeArray, function(_2, dispose) {
        dispose();
      });
    }
  };
}
var VirtualScrollController = classImpl.inherit(function() {
  var members = {
    ctor: function(component, dataOptions, isVirtual) {
      this._dataOptions = dataOptions;
      this.component = component;
      this._viewportSize = 0;
      this._viewportItemSize = 20;
      this._viewportItemIndex = 0;
      this._contentSize = 0;
      this._itemSizes = {};
      this._sizeRatio = 1;
      this._isVirtual = isVirtual;
      this.positionChanged = Callbacks();
      this._dataLoader = new VirtualDataLoader(this, this._dataOptions);
    },
    getItemSizes: function() {
      return this._itemSizes;
    },
    option: function() {
      return this.component.option.apply(this.component, arguments);
    },
    isVirtual: function() {
      return this._isVirtual;
    },
    virtualItemsCount: function() {
      if (_isVirtualMode(this)) {
        var totalItemsCount = this._dataOptions.totalItemsCount();
        if (this.option(NEW_SCROLLING_MODE) && totalItemsCount !== -1) {
          var viewportParams = this.getViewportParams();
          var endItemsCount = totalItemsCount - (viewportParams.skip + viewportParams.take);
          return {
            begin: viewportParams.skip,
            end: endItemsCount
          };
        }
        return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);
      }
    },
    setViewportPosition: function(position2) {
      var result = new Deferred();
      var scrollingTimeout = Math.min(this.option("scrolling.timeout") || 0, this._dataOptions.changingDuration());
      if (scrollingTimeout < this.option("scrolling.renderingThreshold")) {
        scrollingTimeout = this.option("scrolling.minTimeout") || 0;
      }
      clearTimeout(this._scrollTimeoutID);
      if (scrollingTimeout > 0) {
        this._scrollTimeoutID = setTimeout(() => {
          this._setViewportPositionCore(position2);
          result.resolve();
        }, scrollingTimeout);
      } else {
        this._setViewportPositionCore(position2);
        result.resolve();
      }
      return result.promise();
    },
    getViewportPosition: function() {
      return this._position || 0;
    },
    getItemIndexByPosition: function() {
      var position2 = this._position;
      var defaultItemSize = this.getItemSize();
      var offset2 = 0;
      var itemOffset = 0;
      var itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);
      for (var i = 0; i < itemOffsetsWithSize.length && offset2 < position2; i++) {
        var itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);
        var itemOffsetDiff = (position2 - offset2) / defaultItemSize;
        if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {
          itemOffset += itemOffsetDiff;
          break;
        } else {
          itemOffsetDiff = itemOffsetWithSize - itemOffset;
          offset2 += itemOffsetDiff * defaultItemSize;
          itemOffset += itemOffsetDiff;
        }
        var itemSize = this._itemSizes[itemOffsetWithSize];
        offset2 += itemSize;
        itemOffset += offset2 < position2 ? 1 : (position2 - offset2 + itemSize) / itemSize;
      }
      return Math.round(50 * itemOffset) / 50;
    },
    _setViewportPositionCore: function(position2) {
      this._position = position2;
      var itemIndex = this.getItemIndexByPosition();
      var result = this.setViewportItemIndex(itemIndex);
      this.positionChanged.fire();
      return result;
    },
    setContentItemSizes: function(sizes) {
      var virtualItemsCount = this.virtualItemsCount();
      this._contentSize = sizes.reduce((a, b) => a + b, 0);
      if (virtualItemsCount) {
        sizes.forEach((size, index2) => {
          this._itemSizes[virtualItemsCount.begin + index2] = size;
        });
        var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;
        var contentHeightLimit = getContentHeightLimit(coreBrowserUtils);
        if (virtualContentSize > contentHeightLimit) {
          this._sizeRatio = contentHeightLimit / virtualContentSize;
        } else {
          this._sizeRatio = 1;
        }
      }
    },
    getItemSize: function() {
      return this._viewportItemSize * this._sizeRatio;
    },
    getItemOffset: function(itemIndex, isEnd) {
      var virtualItemsCount = this.virtualItemsCount();
      var itemCount = itemIndex;
      if (!virtualItemsCount) {
        return 0;
      }
      var offset2 = 0;
      var totalItemsCount = this._dataOptions.totalItemsCount();
      Object.keys(this._itemSizes).forEach((currentItemIndex) => {
        if (!itemCount) {
          return;
        }
        if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {
          offset2 += this._itemSizes[currentItemIndex];
          itemCount--;
        }
      });
      return Math.floor(offset2 + itemCount * this._viewportItemSize * this._sizeRatio);
    },
    getContentOffset: function(type2) {
      var isEnd = type2 === "end";
      var virtualItemsCount = this.virtualItemsCount();
      if (!virtualItemsCount) {
        return 0;
      }
      return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd);
    },
    getVirtualContentSize: function() {
      var virtualItemsCount = this.virtualItemsCount();
      return virtualItemsCount ? this.getContentOffset("begin") + this.getContentOffset("end") + this._contentSize : 0;
    },
    getViewportItemIndex: function() {
      return this._viewportItemIndex;
    },
    setViewportItemIndex: function(itemIndex) {
      this._viewportItemIndex = itemIndex;
      if (this.option(NEW_SCROLLING_MODE)) {
        return;
      }
      return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);
    },
    viewportItemSize: function(size) {
      if (size !== void 0) {
        this._viewportItemSize = size;
      }
      return this._viewportItemSize;
    },
    viewportSize: function(size) {
      if (size !== void 0) {
        this._viewportSize = size;
      }
      return this._viewportSize;
    },
    reset: function(isRefresh) {
      this._dataLoader.reset();
      if (!isRefresh) {
        this._itemSizes = {};
      }
    },
    subscribeToWindowScrollEvents: function($element) {
      this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, (scrollTop) => {
        if (this.viewportItemSize()) {
          this.setViewportPosition(scrollTop);
        }
      });
    },
    dispose: function() {
      clearTimeout(this._scrollTimeoutID);
      this._windowScroll && this._windowScroll.dispose();
      this._windowScroll = null;
    },
    scrollTo: function(pos) {
      this._windowScroll && this._windowScroll.scrollTo(pos);
    },
    isVirtualMode: function() {
      return _isVirtualMode(this);
    },
    isAppendMode: function() {
      return _isAppendMode(this);
    },
    getViewportParams: function() {
      var topIndex = this._viewportItemIndex;
      var bottomIndex = this._viewportSize + topIndex;
      var maxGap = this.pageSize();
      var minGap = this.option("scrolling.minGap");
      var virtualMode = this.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL;
      var skip = Math.floor(Math.max(0, topIndex - minGap) / maxGap) * maxGap;
      var take = Math.ceil((bottomIndex + minGap) / maxGap) * maxGap - skip;
      if (virtualMode) {
        var remainedItems = this._dataOptions.totalItemsCount() - skip;
        take = Math.min(take, remainedItems);
      }
      return {
        skip,
        take
      };
    }
  };
  ["pageIndex", "beginPageIndex", "endPageIndex", "pageSize", "load", "loadIfNeed", "handleDataChanged", "itemsCount", "getDelayDeferred"].forEach(function(name2) {
    members[name2] = function() {
      return this._dataLoader[name2].apply(this._dataLoader, arguments);
    };
  });
  return members;
}());
function foreachColumnInfo(info, callback, rowIndex, offsets, columnCount, lastProcessedIndexes) {
  rowIndex = rowIndex || 0;
  offsets = offsets || [];
  lastProcessedIndexes = lastProcessedIndexes || [];
  offsets[rowIndex] = offsets[rowIndex] || 0;
  var row = info[rowIndex];
  var startIndex = lastProcessedIndexes[rowIndex] + 1 || 0;
  var processedColumnCount = 0;
  var colIndex;
  if (!row) {
    return;
  }
  for (colIndex = startIndex; colIndex < row.length; colIndex++) {
    var cell = row[colIndex];
    var visibleIndex = colIndex + offsets[rowIndex];
    var colspan = cell.colspan || 1;
    foreachColumnInfo(info, callback, rowIndex + (cell.rowspan || 1), offsets, colspan, lastProcessedIndexes);
    offsets[rowIndex] += colspan - 1;
    processedColumnCount += colspan;
    if (cell.rowspan) {
      for (var i = rowIndex + 1; i < rowIndex + cell.rowspan; i++) {
        offsets[i] = offsets[i] || 0;
        offsets[i] += cell.colspan || 1;
      }
    }
    if (callback(cell, visibleIndex, rowIndex, colIndex) === false) {
      break;
    }
    if (columnCount !== void 0 && processedColumnCount >= columnCount) {
      break;
    }
  }
  lastProcessedIndexes[rowIndex] = colIndex;
}
function createColumnsInfo(info, startIndex, endIndex) {
  var newInfo = [];
  foreachColumnInfo(info, function(columnInfo, visibleIndex, rowIndex) {
    var cell = columnInfo;
    var colspan;
    var cellColspan = cell.colspan || 1;
    var isVisible2 = visibleIndex + cellColspan - 1 >= startIndex && visibleIndex < endIndex;
    newInfo[rowIndex] = newInfo[rowIndex] || [];
    if (isVisible2) {
      if (visibleIndex < startIndex) {
        colspan = cellColspan - (startIndex - visibleIndex);
        visibleIndex = startIndex;
      } else {
        colspan = cellColspan;
      }
      if (visibleIndex + colspan > endIndex) {
        colspan = endIndex - visibleIndex;
      }
      if (colspan !== cellColspan) {
        cell = extend({}, cell, {
          colspan
        });
      }
      newInfo[rowIndex].push(cell);
    } else if (visibleIndex > endIndex) {
      return false;
    }
  });
  for (var i = 0; i < newInfo.length; i++) {
    newInfo[i] = newInfo[i] || [];
  }
  return newInfo;
}
var WIDGET_WITH_LEGACY_CONTAINER_NAME = "dxDataGrid";
var ModuleItem = classImpl.inherit({
  _endUpdateCore: function() {
  },
  ctor: function(component) {
    var that = this;
    that._updateLockCount = 0;
    that.component = component;
    that._actions = {};
    that._actionConfigs = {};
    each(this.callbackNames() || [], function(index2, name2) {
      var flags = that.callbackFlags(name2) || {};
      flags.unique = true, flags.syncStrategy = true;
      that[this] = Callbacks(flags);
    });
  },
  init: function() {
  },
  callbackNames: function() {
  },
  callbackFlags: function() {
  },
  publicMethods: function() {
  },
  beginUpdate: function() {
    this._updateLockCount++;
  },
  endUpdate: function() {
    if (this._updateLockCount > 0) {
      this._updateLockCount--;
      if (!this._updateLockCount) {
        this._endUpdateCore();
      }
    }
  },
  option: function(name2) {
    var component = this.component;
    var optionCache = component._optionCache;
    if (arguments.length === 1 && optionCache) {
      if (!(name2 in optionCache)) {
        optionCache[name2] = component.option(name2);
      }
      return optionCache[name2];
    }
    return component.option.apply(component, arguments);
  },
  _silentOption: function(name2, value2) {
    var component = this.component;
    var optionCache = component._optionCache;
    if (optionCache) {
      optionCache[name2] = value2;
    }
    return component._setOptionWithoutOptionChange(name2, value2);
  },
  localize: function(name2) {
    var optionCache = this.component._optionCache;
    if (optionCache) {
      if (!(name2 in optionCache)) {
        optionCache[name2] = messageLocalization.format(name2);
      }
      return optionCache[name2];
    }
    return messageLocalization.format(name2);
  },
  on: function() {
    return this.component.on.apply(this.component, arguments);
  },
  off: function() {
    return this.component.off.apply(this.component, arguments);
  },
  optionChanged: function(args) {
    if (args.name in this._actions) {
      this.createAction(args.name, this._actionConfigs[args.name]);
      args.handled = true;
    }
  },
  getAction: function(actionName) {
    return this._actions[actionName];
  },
  setAria: function(name2, value2, $target) {
    var target = $target.get(0);
    var prefix = name2 !== "role" && name2 !== "id" ? "aria-" : "";
    if (target.setAttribute) {
      target.setAttribute(prefix + name2, value2);
    } else {
      $target.attr(prefix + name2, value2);
    }
  },
  _createComponent: function() {
    return this.component._createComponent.apply(this.component, arguments);
  },
  getController: function(name2) {
    return this.component._controllers[name2];
  },
  createAction: function(actionName, config2) {
    if (isFunction$1(actionName)) {
      var action = this.component._createAction(actionName.bind(this), config2);
      return function(e) {
        action({
          event: e
        });
      };
    } else {
      this._actions[actionName] = this.component._createActionByOption(actionName, config2);
      this._actionConfigs[actionName] = config2;
    }
  },
  executeAction: function(actionName, options) {
    var action = this._actions[actionName];
    return action && action(options);
  },
  dispose: function() {
    var that = this;
    each(that.callbackNames() || [], function() {
      that[this].empty();
    });
  },
  addWidgetPrefix: function(className) {
    var componentName = this.component.NAME;
    return "dx-" + componentName.slice(2).toLowerCase() + (className ? "-" + className : "");
  },
  getWidgetContainerClass: function() {
    var containerName = this.component.NAME === WIDGET_WITH_LEGACY_CONTAINER_NAME ? null : "container";
    return this.addWidgetPrefix(containerName);
  }
});
var Controller = ModuleItem;
var ViewController = Controller.inherit({
  getView: function(name2) {
    return this.component._views[name2];
  },
  getViews: function() {
    return this.component._views;
  }
});
var View = ModuleItem.inherit({
  _isReady: function() {
    return this.component.isReady();
  },
  _endUpdateCore: function() {
    this.callBase();
    if (!this._isReady() && this._requireReady) {
      this._requireRender = false;
      this.component._requireResize = false;
    }
    if (this._requireRender) {
      this._requireRender = false;
      this.render(this._$parent);
    }
  },
  _invalidate: function(requireResize, requireReady) {
    this._requireRender = true;
    this.component._requireResize = hasWindow$1() && (this.component._requireResize || requireResize);
    this._requireReady = this._requireReady || requireReady;
  },
  _renderCore: function() {
  },
  _resizeCore: function() {
  },
  _parentElement: function() {
    return this._$parent;
  },
  ctor: function(component) {
    this.callBase(component);
    this.renderCompleted = Callbacks();
    this.resizeCompleted = Callbacks();
  },
  element: function() {
    return this._$element;
  },
  getElementHeight: function() {
    var $element = this.element();
    if (!$element) {
      return 0;
    }
    var marginTop = parseFloat($element.css("marginTop")) || 0;
    var marginBottom = parseFloat($element.css("marginBottom")) || 0;
    var offsetHeight = $element.get(0).offsetHeight;
    return offsetHeight + marginTop + marginBottom;
  },
  isVisible: function() {
    return true;
  },
  getTemplate: function(name2) {
    return this.component._getTemplate(name2);
  },
  render: function($parent, options) {
    var $element = this._$element;
    var isVisible2 = this.isVisible();
    if (!$element && !$parent) {
      return;
    }
    this._requireReady = false;
    if (!$element) {
      $element = this._$element = $("<div>").appendTo($parent);
      this._$parent = $parent;
    }
    $element.toggleClass("dx-hidden", !isVisible2);
    if (isVisible2) {
      this.component._optionCache = {};
      this._renderCore(options);
      this.component._optionCache = void 0;
      this.renderCompleted.fire(options);
    }
  },
  resize: function() {
    this.isResizing = true;
    this._resizeCore();
    this.resizeCompleted.fire();
    this.isResizing = false;
  },
  focus: function() {
    eventsEngine.trigger(this.element(), "focus");
  }
});
var MODULES_ORDER_MAX_INDEX = 1e6;
var processModules = function(that, componentClass) {
  var modules2 = componentClass.modules;
  var modulesOrder = componentClass.modulesOrder;
  var controllerTypes = componentClass.controllerTypes || {};
  var viewTypes = componentClass.viewTypes || {};
  if (!componentClass.controllerTypes) {
    if (modulesOrder) {
      modules2.sort(function(module1, module2) {
        var orderIndex1 = inArray(module1.name, modulesOrder);
        var orderIndex2 = inArray(module2.name, modulesOrder);
        if (orderIndex1 < 0) {
          orderIndex1 = MODULES_ORDER_MAX_INDEX;
        }
        if (orderIndex2 < 0) {
          orderIndex2 = MODULES_ORDER_MAX_INDEX;
        }
        return orderIndex1 - orderIndex2;
      });
    }
    each(modules2, function() {
      var controllers = this.controllers;
      var moduleName = this.name;
      var views = this.views;
      controllers && each(controllers, function(name2, type2) {
        if (controllerTypes[name2]) {
          throw errors$1.Error("E1001", moduleName, name2);
        } else if (!(type2 && type2.subclassOf && type2.subclassOf(Controller))) {
          type2.subclassOf(Controller);
          throw errors$1.Error("E1002", moduleName, name2);
        }
        controllerTypes[name2] = type2;
      });
      views && each(views, function(name2, type2) {
        if (viewTypes[name2]) {
          throw errors$1.Error("E1003", moduleName, name2);
        } else if (!(type2 && type2.subclassOf && type2.subclassOf(View))) {
          throw errors$1.Error("E1004", moduleName, name2);
        }
        viewTypes[name2] = type2;
      });
    });
    each(modules2, function() {
      var extenders = this.extenders;
      if (extenders) {
        extenders.controllers && each(extenders.controllers, function(name2, extender) {
          if (controllerTypes[name2]) {
            controllerTypes[name2] = controllerTypes[name2].inherit(extender);
          }
        });
        extenders.views && each(extenders.views, function(name2, extender) {
          if (viewTypes[name2]) {
            viewTypes[name2] = viewTypes[name2].inherit(extender);
          }
        });
      }
    });
    componentClass.controllerTypes = controllerTypes;
    componentClass.viewTypes = viewTypes;
  }
  var createModuleItems = function(moduleTypes) {
    var moduleItems = {};
    each(moduleTypes, function(name2, moduleType) {
      var moduleItem = new moduleType(that);
      moduleItem.name = name2;
      !function(that2, name3, moduleItem2) {
        var publicMethods = moduleItem2.publicMethods();
        if (publicMethods) {
          each(publicMethods, function(index2, methodName) {
            if (moduleItem2[methodName]) {
              if (!that2[methodName]) {
                that2[methodName] = function() {
                  return moduleItem2[methodName].apply(moduleItem2, arguments);
                };
              } else {
                throw errors$1.Error("E1005", methodName);
              }
            } else {
              throw errors$1.Error("E1006", name3, methodName);
            }
          });
        }
      }(that, name2, moduleItem);
      moduleItems[name2] = moduleItem;
    });
    return moduleItems;
  };
  that._controllers = createModuleItems(controllerTypes);
  that._views = createModuleItems(viewTypes);
};
var callModuleItemsMethod = function(that, methodName, args) {
  args = args || [];
  if (that._controllers) {
    each(that._controllers, function() {
      this[methodName] && this[methodName].apply(this, args);
    });
  }
  if (that._views) {
    each(that._views, function() {
      this[methodName] && this[methodName].apply(this, args);
    });
  }
};
var modules = {
  modules: [],
  View,
  ViewController,
  Controller,
  registerModule: function(name2, module2) {
    var modules2 = this.modules;
    for (var i = 0; i < modules2.length; i++) {
      if (modules2[i].name === name2) {
        return;
      }
    }
    module2.name = name2;
    modules2.push(module2);
    delete this.controllerTypes;
    delete this.viewTypes;
  },
  registerModulesOrder: function(moduleNames) {
    this.modulesOrder = moduleNames;
  },
  unregisterModule: function(name2) {
    this.modules = grep(this.modules, function(module2) {
      return module2.name !== name2;
    });
    delete this.controllerTypes;
    delete this.viewTypes;
  },
  processModules,
  callModuleItemsMethod
};
var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
var parseDates = function parseDates2(state) {
  if (!state) {
    return;
  }
  each(state, function(key, value2) {
    if (isPlainObject(value2) || Array.isArray(value2)) {
      parseDates2(value2);
    } else if (typeof value2 === "string") {
      var date = DATE_REGEX.exec(value2);
      if (date) {
        state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]));
      }
    }
  });
};
var StateStoringController = modules.ViewController.inherit(function() {
  var getStorage = function(options) {
    var storage = options.type === "sessionStorage" ? getSessionStorage() : getWindow().localStorage;
    if (!storage) {
      if (getWindow().location.protocol === "file:" && coreBrowserUtils.msie) {
        throw new Error("E1038");
      } else {
        throw new Error("E1007");
      }
    }
    return storage;
  };
  var getUniqueStorageKey = function(options) {
    return isDefined(options.storageKey) ? options.storageKey : "storage";
  };
  return {
    _loadState: function() {
      var options = this.option("stateStoring");
      if (options.type === "custom") {
        return options.customLoad && options.customLoad();
      }
      try {
        return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)));
      } catch (e) {
        errors$1.log(e.message);
      }
    },
    _saveState: function(state) {
      var options = this.option("stateStoring");
      if (options.type === "custom") {
        options.customSave && options.customSave(state);
        return;
      }
      try {
        getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state));
      } catch (e) {
        errors$1.log(e.message);
      }
    },
    publicMethods: function() {
      return ["state"];
    },
    isEnabled: function() {
      return this.option("stateStoring.enabled");
    },
    init: function() {
      var that = this;
      that._state = {};
      that._isLoaded = false;
      that._isLoading = false;
      that._windowUnloadHandler = function() {
        if (that._savingTimeoutID !== void 0) {
          that._saveState(that.state());
        }
      };
      eventsEngine.on(getWindow(), "unload", that._windowUnloadHandler);
      return that;
    },
    isLoaded: function() {
      return this._isLoaded;
    },
    isLoading: function() {
      return this._isLoading;
    },
    load: function() {
      this._isLoading = true;
      var loadResult = fromPromise(this._loadState());
      loadResult.always(() => {
        this._isLoaded = true;
        this._isLoading = false;
      }).done((state) => {
        this.state(state);
      });
      return loadResult;
    },
    state: function(_state) {
      var that = this;
      if (!arguments.length) {
        return extend(true, {}, that._state);
      } else {
        that._state = extend({}, _state);
        parseDates(that._state);
      }
    },
    save: function() {
      var that = this;
      clearTimeout(that._savingTimeoutID);
      that._savingTimeoutID = setTimeout(function() {
        that._saveState(that.state());
        that._savingTimeoutID = void 0;
      }, that.option("stateStoring.savingTimeout"));
    },
    optionChanged: function(args) {
      switch (args.name) {
        case "stateStoring":
          if (this.isEnabled() && !this.isLoading()) {
            this.load();
          }
          args.handled = true;
          break;
        default:
          this.callBase(args);
      }
    },
    dispose: function() {
      clearTimeout(this._savingTimeoutID);
      eventsEngine.off(getWindow(), "unload", this._windowUnloadHandler);
    }
  };
}());
var NUMBER_SERIALIZATION_FORMAT = "number";
var DATE_SERIALIZATION_FORMAT = "yyyy/MM/dd";
var DATETIME_SERIALIZATION_FORMAT = "yyyy/MM/dd HH:mm:ss";
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];
var DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
var MILLISECOND_LENGHT = 3;
var isIE11 = coreBrowserUtils.msie && parseInt(coreBrowserUtils.version) <= 11;
var dateParser = function(text, skipISO8601Parsing) {
  var result;
  if (isString$1(text) && !skipISO8601Parsing) {
    result = parseISO8601String(text);
  }
  return result || parseDate(text);
};
function getTimePart(part) {
  return +part || 0;
}
function parseDate(text) {
  var isDefaultSerializationFormat = getDateSerializationFormat(text) === DATE_SERIALIZATION_FORMAT;
  var parsedValue = !isDate(text) && Date.parse(text);
  if ((!parsedValue || isIE11) && isDefaultSerializationFormat) {
    var parts = text.match(DATE_SERIALIZATION_PATTERN);
    if (parts) {
      var newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }
  return isNumeric(parsedValue) ? new Date(parsedValue) : text;
}
function parseISO8601String(text) {
  var parts = text.match(ISO8601_PATTERN);
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }
    return;
  }
  var year = parts[1];
  var month = --parts[3];
  var day = parts[5];
  var timeZoneHour = 0;
  var timeZoneMinute = 0;
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);
  if (parts[13] === "-") {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }
  var hour = getTimePart(parts[6]) - timeZoneHour;
  var minute = getTimePart(parts[8]) - timeZoneMinute;
  var second = getTimePart(parts[10]);
  var millisecond = function(part) {
    part = part || "";
    return getTimePart(part) * Math.pow(10, MILLISECOND_LENGHT - part.length);
  }(parts[11]);
  if (parts[12]) {
    return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
  }
  return new Date(year, month, day, hour, minute, second, millisecond);
}
var getIso8601Format = function(text, useUtc) {
  var parts = text.match(ISO8601_PATTERN);
  var result = "";
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return parts[3] ? "HH:mm:ss" : "HH:mm";
    }
    return;
  }
  for (var i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
    if (parts[i]) {
      result += ISO8601_PATTERN_PARTS[i] || parts[i];
    }
  }
  if (parts[12] === "Z") {
    result += "'Z'";
  }
  if (parts[14]) {
    if (parts[15]) {
      result += "xxx";
    } else if (parts[16]) {
      result += "xx";
    } else {
      result += "x";
    }
  }
  return result;
};
var deserializeDate = function(value2) {
  if (typeof value2 === "number") {
    return new Date(value2);
  }
  return dateParser(value2, !configMethod().forceIsoDateParsing);
};
var serializeDate = function(value2, serializationFormat) {
  if (!serializationFormat) {
    return value2;
  }
  if (!isDate(value2)) {
    return null;
  }
  if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
    return value2 && value2.valueOf ? value2.valueOf() : null;
  }
  return getFormatter$1(serializationFormat, defaultDateNames)(value2);
};
var getDateSerializationFormat = function(value2) {
  if (typeof value2 === "number") {
    return NUMBER_SERIALIZATION_FORMAT;
  } else if (isString$1(value2)) {
    var format2;
    if (configMethod().forceIsoDateParsing) {
      format2 = getIso8601Format(value2);
    }
    if (format2) {
      return format2;
    } else if (value2.indexOf(":") >= 0) {
      return DATETIME_SERIALIZATION_FORMAT;
    } else {
      return DATE_SERIALIZATION_FORMAT;
    }
  } else if (value2) {
    return null;
  }
};
var dateSerialization = {
  dateParser,
  deserializeDate,
  serializeDate,
  getDateSerializationFormat
};
var PATH_DELIMETER = "/./";
var LocalStore = classImpl.inherit(function() {
  var DATE_INTERVAL_SELECTORS2 = {
    year: function(date) {
      return date && date.getFullYear();
    },
    quarter: function(date) {
      return date && Math.floor(date.getMonth() / 3) + 1;
    },
    month: function(date) {
      return date && date.getMonth() + 1;
    },
    day: function(date) {
      return date && date.getDate();
    },
    dayOfWeek: function(date) {
      return date && date.getDay();
    }
  };
  function getDataSelector(dataField) {
    return dataField.indexOf(".") !== -1 ? compileGetter(dataField) : function(data2) {
      return data2[dataField];
    };
  }
  function getDateValue(dataSelector) {
    return function(data2) {
      var value2 = dataSelector(data2);
      if (value2 && !(value2 instanceof Date)) {
        value2 = dateSerialization.deserializeDate(value2);
      }
      return value2;
    };
  }
  function prepareFields2(fields) {
    each(fields || [], function(_2, field) {
      var fieldSelector;
      var intervalSelector;
      var dataField = field.dataField;
      var groupInterval;
      var levels = field.levels;
      var dataSelector;
      if (!field.selector) {
        if (!dataField) {
          dataSelector = function(data2) {
            return data2;
          };
        } else {
          dataSelector = getDataSelector(dataField);
        }
        if (levels) {
          prepareFields2(levels);
        }
        if (field.dataType === "date") {
          intervalSelector = DATE_INTERVAL_SELECTORS2[field.groupInterval];
          var valueSelector = getDateValue(dataSelector);
          fieldSelector = function(data2) {
            var value2 = valueSelector(data2);
            return intervalSelector ? intervalSelector(value2) : value2;
          };
        } else if (field.dataType === "number") {
          groupInterval = isNumeric(field.groupInterval) && field.groupInterval > 0 && field.groupInterval;
          fieldSelector = function(data2) {
            var value2 = dataSelector(data2);
            if (isString$1(value2)) {
              value2 = Number(value2);
            }
            return groupInterval ? Math.floor(value2 / groupInterval) * groupInterval : value2;
          };
        } else {
          fieldSelector = dataSelector;
        }
        setDefaultFieldValueFormatting(field);
        setFieldProperty(field, "selector", fieldSelector);
      }
    });
  }
  function generateHierarchyItems(data2, loadOptions, headers, headerName) {
    var result = [0];
    var expandIndex = loadOptions.headerName === headerName ? loadOptions.path.length : 0;
    var expandedPaths = headerName === "rows" ? loadOptions.rowExpandedPaths : loadOptions.columnExpandedPaths;
    var options = {
      data: data2,
      childrenHash: headers[headerName + "Hash"],
      dimensions: loadOptions[headerName],
      expandedPathsHash: loadOptions.headerName !== headerName && expandedPaths && expandedPaths.hash
    };
    !function fillHierarchyItemIndexesCore(indexes, options2, children, expandIndex2, pathHash) {
      var dimension = options2.dimensions[expandIndex2];
      var expandedPathsHash = options2.expandedPathsHash;
      var dimensionValue;
      var hierarchyItem;
      if (dimension) {
        dimensionValue = dimension.selector(options2.data);
        pathHash = pathHash !== void 0 ? pathHash + PATH_DELIMETER + dimensionValue : dimensionValue + "";
        hierarchyItem = function(value2, hierarchyItems, pathHash2, childrenHash) {
          var hierarchyItem2 = childrenHash[pathHash2];
          if (!hierarchyItem2) {
            hierarchyItem2 = {
              value: value2,
              index: childrenHash.length++
            };
            childrenHash[pathHash2] = hierarchyItem2;
            hierarchyItems.push(hierarchyItem2);
          }
          return hierarchyItem2;
        }(dimensionValue, children, pathHash, options2.childrenHash);
        indexes.push(hierarchyItem.index);
        if (expandedPathsHash && expandedPathsHash[pathHash] || dimension.expanded) {
          if (!hierarchyItem.children) {
            hierarchyItem.children = [];
          }
          fillHierarchyItemIndexesCore(indexes, options2, hierarchyItem.children, expandIndex2 + 1, pathHash);
        }
      }
    }(result, options, headers[headerName], expandIndex);
    return result;
  }
  function generateAggregationCells(data2, cells, headers, options) {
    var cellSet = [];
    var x;
    var y;
    var rowIndex;
    var columnIndex;
    var rowIndexes = generateHierarchyItems(data2, options, headers, "rows");
    var columnIndexes = generateHierarchyItems(data2, options, headers, "columns");
    for (y = 0; y < rowIndexes.length; y++) {
      rowIndex = rowIndexes[y];
      cells[rowIndex] = cells[rowIndex] || [];
      for (x = 0; x < columnIndexes.length; x++) {
        columnIndex = columnIndexes[x];
        cellSet.push(cells[rowIndex][columnIndex] = cells[rowIndex][columnIndex] || []);
      }
    }
    return cellSet;
  }
  function fillHashExpandedPath(expandedPaths) {
    if (expandedPaths) {
      var hash = expandedPaths.hash = {};
      expandedPaths.forEach(function(path) {
        var pathValue = path.map(function(value2) {
          return value2 + "";
        }).join(PATH_DELIMETER);
        hash[pathValue] = true;
      });
    }
  }
  function prepareLoadOption(options) {
    options.rows = options.rows || [];
    options.columns = options.columns || [];
    options.filters = options.filters || [];
    fillHashExpandedPath(options.columnExpandedPaths);
    fillHashExpandedPath(options.rowExpandedPaths);
    prepareFields2(options.columns);
    prepareFields2(options.rows);
    prepareFields2(options.values);
    prepareFields2(options.filters);
  }
  function getAggregator(field) {
    if (field.summaryType === "custom") {
      field.calculateCustomSummary = field.calculateCustomSummary || noop;
      return {
        seed: function() {
          var options = {
            summaryProcess: "start",
            totalValue: void 0
          };
          field.calculateCustomSummary(options);
          return options;
        },
        step: function(options, value2) {
          options.summaryProcess = "calculate";
          options.value = value2;
          field.calculateCustomSummary(options);
          return options;
        },
        finalize: function(options) {
          options.summaryProcess = "finalize";
          delete options.value;
          field.calculateCustomSummary(options);
          return options.totalValue;
        }
      };
    }
    return aggregators[field.summaryType] || aggregators.count;
  }
  function aggregationStep(measures, aggregationCells, data2) {
    for (var aggregatorIndex = 0; aggregatorIndex < measures.length; aggregatorIndex++) {
      var cellField = measures[aggregatorIndex];
      var cellValue = cellField.selector(data2);
      var aggregator = getAggregator(cellField);
      var isAggregatorSeedFunction = typeof aggregator.seed === "function";
      for (var cellSetIndex = 0; cellSetIndex < aggregationCells.length; cellSetIndex++) {
        var cell = aggregationCells[cellSetIndex];
        if (cell.length <= aggregatorIndex) {
          cell[aggregatorIndex] = isAggregatorSeedFunction ? aggregator.seed() : aggregator.seed;
        }
        if (cell[aggregatorIndex] === void 0) {
          cell[aggregatorIndex] = cellValue;
        } else if (isDefined(cellValue)) {
          cell[aggregatorIndex] = aggregator.step(cell[aggregatorIndex], cellValue);
        }
      }
    }
  }
  function areValuesEqual(filterValue, fieldValue) {
    var valueOfFilter = filterValue && filterValue.valueOf();
    var valueOfField = fieldValue && fieldValue.valueOf();
    if (Array.isArray(filterValue)) {
      fieldValue = fieldValue || [];
      for (var i = 0; i < filterValue.length; i++) {
        valueOfFilter = filterValue[i] && filterValue[i].valueOf();
        valueOfField = fieldValue[i] && fieldValue[i].valueOf();
        if (valueOfFilter !== valueOfField) {
          return false;
        }
      }
      return true;
    } else {
      return valueOfFilter === valueOfField;
    }
  }
  function createDimensionFilters(dimension) {
    var filters = [];
    each(dimension, function(_2, field) {
      var filterValues = field.filterValues || [];
      var groupName = field.groupName;
      if (groupName && isNumeric(field.groupIndex)) {
        return;
      }
      filterValues.length && filters.push(function(dataItem) {
        var value2 = field.levels ? function(levels, data2) {
          var value3 = [];
          each(levels, function(_3, field2) {
            value3.push(field2.selector(data2));
          });
          return value3;
        }(field.levels, dataItem) : field.selector(dataItem);
        var result = false;
        for (var i = 0; i < filterValues.length; i++) {
          if (areValuesEqual(filterValues[i], value2)) {
            result = true;
            break;
          }
        }
        return field.filterType === "exclude" ? !result : result;
      });
    });
    return filters;
  }
  function createFilter(options) {
    var filters = createDimensionFilters(options.rows).concat(createDimensionFilters(options.columns)).concat(createDimensionFilters(options.filters));
    var expandedDimensions = options[options.headerName];
    var path = options.path;
    if (expandedDimensions) {
      filters.push(function(dataItem) {
        var expandValue;
        for (var i = 0; i < path.length; i++) {
          expandValue = expandedDimensions[i].selector(dataItem);
          if (toComparable(expandValue, true) !== toComparable(path[i], true)) {
            return false;
          }
        }
        return true;
      });
    }
    return function(dataItem) {
      for (var i = 0; i < filters.length; i++) {
        if (!filters[i](dataItem)) {
          return false;
        }
      }
      return true;
    };
  }
  function loadCore2(items, options, notifyProgress) {
    var headers = {
      columns: [],
      rows: [],
      columnsHash: {
        length: 1
      },
      rowsHash: {
        length: 1
      }
    };
    var values = [];
    var aggregationCells;
    var data2;
    var d = new Deferred();
    var i = 0;
    var filter = createFilter(options);
    !function processData() {
      var t = new Date();
      var startIndex = i;
      for (; i < items.length; i++) {
        if (i > startIndex && i % 1e4 === 0) {
          if (new Date() - t >= 300) {
            notifyProgress(i / items.length);
            setTimeout(processData, 0);
            return;
          }
        }
        data2 = items[i];
        if (filter(data2)) {
          aggregationCells = generateAggregationCells(data2, values, headers, options);
          aggregationStep(options.values, aggregationCells, data2);
        }
      }
      measures = options.values, cells = values, void each(measures, function(aggregatorIndex, cellField) {
        var aggregator = getAggregator(cellField);
        if (aggregator.finalize) {
          each(cells, function(_2, row) {
            each(row, function(_3, cell) {
              if (cell && cell[aggregatorIndex] !== void 0) {
                cell[aggregatorIndex] = aggregator.finalize(cell[aggregatorIndex]);
              }
            });
          });
        }
      });
      var measures, cells;
      notifyProgress(1);
      d.resolve({
        rows: headers.rows,
        columns: headers.columns,
        values,
        grandTotalRowIndex: 0,
        grandTotalColumnIndex: 0
      });
    }();
    return d;
  }
  function filterDataSource(dataSource, fieldSelectors) {
    var filter = dataSource.filter();
    if (dataSource.store() instanceof CustomStore && filter) {
      filter = processFilter(filter, fieldSelectors);
      return query(dataSource.items()).filter(filter).toArray();
    }
    return dataSource.items();
  }
  function loadDataSource(dataSource, fieldSelectors, reload) {
    var d = new Deferred();
    var customizeStoreLoadOptionsHandler = function(options) {
      if (dataSource.store() instanceof ArrayStore) {
        options.storeLoadOptions.filter = processFilter(options.storeLoadOptions.filter, fieldSelectors);
      }
    };
    dataSource.on("customizeStoreLoadOptions", customizeStoreLoadOptionsHandler);
    if (!dataSource.isLoaded() || reload) {
      var loadDeferred = reload ? dataSource.load() : dataSource.reload();
      when(loadDeferred).done(function() {
        loadDataSource(dataSource, fieldSelectors).done(function() {
          d.resolve(filterDataSource(dataSource, fieldSelectors));
        }).fail(d.reject);
      }).fail(d.reject);
    } else {
      d.resolve(filterDataSource(dataSource, fieldSelectors));
    }
    return d.always(function() {
      dataSource.off("customizeStoreLoadOptions", customizeStoreLoadOptionsHandler);
    });
  }
  function fillSelectorsByFields(selectors, fields) {
    fields.forEach(function(field) {
      if (field.dataField && field.dataType === "date") {
        var valueSelector = getDateValue(getDataSelector(field.dataField));
        selectors[field.dataField] = function(data2) {
          return valueSelector(data2);
        };
      }
    });
  }
  function getFieldSelectors(options) {
    var selectors = {};
    if (Array.isArray(options)) {
      fillSelectorsByFields(selectors, options);
    } else if (options) {
      ["rows", "columns", "filters"].forEach(function(area) {
        options[area] && fillSelectorsByFields(selectors, options[area]);
      });
    }
    return selectors;
  }
  function processFilter(filter, fieldSelectors) {
    if (!Array.isArray(filter)) {
      return filter;
    }
    filter = filter.slice(0);
    if (isString$1(filter[0]) && (filter[1] instanceof Date || filter[2] instanceof Date)) {
      filter[0] = fieldSelectors[filter[0]];
    }
    for (var i = 0; i < filter.length; i++) {
      filter[i] = processFilter(filter[i], fieldSelectors);
    }
    return filter;
  }
  return {
    ctor: function(options) {
      this._progressChanged = options.onProgressChanged || noop;
      this._dataSource = new DataSource(options);
      this._dataSource.paginate(false);
    },
    getFields: function(fields) {
      var dataSource = this._dataSource;
      var d = new Deferred();
      loadDataSource(dataSource, getFieldSelectors(fields)).done(function(data2) {
        d.resolve(discoverObjectFields(data2, fields));
      }).fail(d.reject);
      return d;
    },
    key: function() {
      return this._dataSource.key();
    },
    load: function(options) {
      var that = this;
      var dataSource = that._dataSource;
      var d = new Deferred();
      prepareLoadOption(options);
      loadDataSource(dataSource, getFieldSelectors(options), options.reload).done(function(data2) {
        when(loadCore2(data2, options, that._progressChanged)).done(d.resolve);
      }).fail(d.reject);
      return d;
    },
    filter: function() {
      var dataSource = this._dataSource;
      return dataSource.filter.apply(dataSource, arguments);
    },
    supportPaging: function() {
      return false;
    },
    getDrillDownItems: function(loadOptions, params) {
      loadOptions = loadOptions || {};
      params = params || {};
      prepareLoadOption(loadOptions);
      var drillDownItems = [];
      var items = this._dataSource.items();
      var item;
      var maxRowCount = params.maxRowCount;
      var customColumns = params.customColumns;
      var filter = createFilter(loadOptions);
      var pathFilter = createFilter({
        rows: getFiltersByPath(loadOptions.rows, params.rowPath),
        columns: getFiltersByPath(loadOptions.columns, params.columnPath),
        filters: []
      });
      for (var i = 0; i < items.length; i++) {
        if (pathFilter(items[i]) && filter(items[i])) {
          if (customColumns) {
            item = {};
            for (var j = 0; j < customColumns.length; j++) {
              item[customColumns[j]] = items[i][customColumns[j]];
            }
          } else {
            item = items[i];
          }
          drillDownItems.push(item);
        }
        if (maxRowCount > 0 && drillDownItems.length === maxRowCount) {
          break;
        }
      }
      return drillDownItems;
    }
  };
}()).include(storeDrillDownMixin);
var forEachGroup = function forEachGroup2(data2, callback, level) {
  data2 = data2 || [];
  level = level || 0;
  for (var i = 0; i < data2.length; i++) {
    var group = data2[i];
    callback(group, level);
    if (group && group.items && group.items.length) {
      forEachGroup2(group.items, callback, level + 1);
    }
  }
};
function createGroupingOptions(dimensionOptions, useSortOrder) {
  var groupingOptions = [];
  each(dimensionOptions, function(index2, dimensionOption) {
    groupingOptions.push({
      selector: dimensionOption.dataField,
      groupInterval: dimensionOption.groupInterval,
      desc: useSortOrder && dimensionOption.sortOrder === "desc",
      isExpanded: index2 < dimensionOptions.length - 1
    });
  });
  return groupingOptions;
}
function getFieldFilterSelector(field) {
  var selector = field.dataField;
  var groupInterval = field.groupInterval;
  if (field.dataType === "date" && typeof groupInterval === "string") {
    if (groupInterval.toLowerCase() === "quarter") {
      groupInterval = "Month";
    }
    selector = selector + "." + capitalizeFirstLetter(groupInterval);
  }
  return selector;
}
function getIntervalFilterExpression(selector, numericInterval, numericValue, isExcludedFilterType) {
  var startFilterValue = [selector, isExcludedFilterType ? "<" : ">=", numericValue];
  var endFilterValue = [selector, isExcludedFilterType ? ">=" : "<", numericValue + numericInterval];
  return [startFilterValue, isExcludedFilterType ? "or" : "and", endFilterValue];
}
function getFilterExpressionForFilterValue(field, filterValue) {
  var selector = getFieldFilterSelector(field);
  var isExcludedFilterType = field.filterType === "exclude";
  var expression = [selector, isExcludedFilterType ? "<>" : "=", filterValue];
  if (isDefined(field.groupInterval)) {
    if (typeof field.groupInterval === "string" && field.groupInterval.toLowerCase() === "quarter") {
      expression = getIntervalFilterExpression(selector, 3, 3 * (filterValue - 1) + 1, isExcludedFilterType);
    } else if (typeof field.groupInterval === "number" && field.dataType !== "date") {
      expression = getIntervalFilterExpression(selector, field.groupInterval, filterValue, isExcludedFilterType);
    }
  }
  return expression;
}
function createFieldFilterExpressions(field, operation) {
  var fieldFilterExpressions = [];
  if (field.searchValue) {
    return [field.dataField, "contains", field.searchValue];
  }
  if (field.filterType === "exclude") {
    operation = operation || "and";
  } else {
    operation = operation || "or";
  }
  each(field.filterValues, function(index2, filterValue) {
    var currentExpression = [];
    if (Array.isArray(filterValue)) {
      var parseLevelsRecursive = field.levels && field.levels.length;
      if (parseLevelsRecursive) {
        currentExpression = createFieldFilterExpressions({
          filterValues: filterValue,
          filterType: field.filterType,
          levels: field.levels
        }, "and");
      }
    } else {
      var currentField = field.levels ? field.levels[index2] : field;
      currentExpression = getFilterExpressionForFilterValue(currentField, filterValue);
    }
    if (!currentExpression.length) {
      return;
    }
    if (fieldFilterExpressions.length) {
      fieldFilterExpressions.push(operation);
    }
    fieldFilterExpressions.push(currentExpression);
  });
  return fieldFilterExpressions;
}
function createFilterExpressions(fields) {
  var filterExpressions = [];
  each(fields, function(_2, field) {
    var fieldExpressions = createFieldFilterExpressions(field);
    if (!fieldExpressions.length) {
      return [];
    }
    if (filterExpressions.length) {
      filterExpressions.push("and");
    }
    filterExpressions.push(fieldExpressions);
  });
  if (filterExpressions.length === 1) {
    filterExpressions = filterExpressions[0];
  }
  return filterExpressions;
}
function mergeFilters(filter1, filter2) {
  var mergedFilter;
  var notEmpty = function(filter) {
    return filter && filter.length;
  };
  if (notEmpty(filter1) && notEmpty(filter2)) {
    mergedFilter = [filter1, "and", filter2];
  } else {
    mergedFilter = notEmpty(filter1) ? filter1 : filter2;
  }
  return mergedFilter;
}
function createLoadOptions(options, externalFilterExpr, hasRows) {
  var filterExpressions = createFilterExpressions(options.filters);
  var groupingOptions = createGroupingOptions(options.rows, options.rowTake).concat(createGroupingOptions(options.columns, options.columnTake));
  var loadOptions = {
    groupSummary: [],
    totalSummary: [],
    group: groupingOptions.length ? groupingOptions : void 0,
    take: groupingOptions.length ? void 0 : 1
  };
  if (options.rows.length && options.rowTake) {
    loadOptions.skip = options.rowSkip;
    loadOptions.take = options.rowTake;
    loadOptions.requireGroupCount = true;
  } else if (options.columns.length && options.columnTake && !hasRows) {
    loadOptions.skip = options.columnSkip;
    loadOptions.take = options.columnTake;
    loadOptions.requireGroupCount = true;
  }
  if (externalFilterExpr) {
    filterExpressions = mergeFilters(filterExpressions, externalFilterExpr);
  }
  if (filterExpressions.length) {
    loadOptions.filter = filterExpressions;
  }
  each(options.values, function(_2, value2) {
    var summaryOption = {
      selector: value2.dataField,
      summaryType: value2.summaryType || "count"
    };
    loadOptions.groupSummary.push(summaryOption);
    options.includeTotalSummary && loadOptions.totalSummary.push(summaryOption);
  });
  return loadOptions;
}
function setValue(valuesArray, value2, rowIndex, columnIndex, dataIndex) {
  valuesArray[rowIndex] = valuesArray[rowIndex] || [];
  valuesArray[rowIndex][columnIndex] = valuesArray[rowIndex][columnIndex] || [];
  if (!isDefined(valuesArray[rowIndex][columnIndex][dataIndex])) {
    valuesArray[rowIndex][columnIndex][dataIndex] = value2;
  }
}
function parseValue(value2, field) {
  if (field && field.dataType === "number" && isString$1(value2)) {
    return Number(value2);
  }
  if (field && field.dataType === "date" && !field.groupInterval && !(value2 instanceof Date)) {
    return dateSerialization.deserializeDate(value2);
  }
  return value2;
}
function parseResult(data2, total, descriptions, result) {
  var rowPath = [];
  var columnPath = [];
  var rowHash = result.rowHash;
  var columnHash = result.columnHash;
  if (total && total.summary) {
    each(total.summary, function(index2, summary) {
      setValue(result.values, summary, result.grandTotalRowIndex, result.grandTotalColumnIndex, index2);
    });
  }
  if (total && total.groupCount >= 0) {
    var skip = descriptions.rows.length ? descriptions.rowSkip : descriptions.columnSkip;
    data2 = [...Array(skip)].concat(data2);
    data2.length = total.groupCount;
  }
  function getItem(dataItem, dimensionName, path, level, field) {
    var dimensionHash = result[dimensionName + "Hash"];
    var parentItem;
    var parentItemChildren;
    var item;
    var pathValue = path.slice(0, level + 1).join("/");
    var parentPathValue;
    if (dimensionHash[pathValue] !== void 0) {
      item = dimensionHash[pathValue];
    } else {
      item = {
        value: parseValue(dataItem.key, field),
        index: result[dimensionName + "Index"]++,
        displayText: dataItem.displayText
      };
      parentPathValue = path.slice(0, level).join("/");
      if (level > 0 && dimensionHash[parentPathValue] !== void 0) {
        parentItem = dimensionHash[parentPathValue];
        parentItemChildren = parentItem.children = parentItem.children || [];
      } else {
        parentItemChildren = result[dimensionName + "s"];
      }
      parentItemChildren.push(item);
      dimensionHash[pathValue] = item;
    }
    return item;
  }
  forEachGroup(data2, function(item, level) {
    var rowLevel = level >= descriptions.rows.length ? descriptions.rows.length : level;
    var columnLevel = level >= descriptions.rows.length ? level - descriptions.rows.length : 0;
    var columnItem;
    var rowItem;
    if (level >= descriptions.rows.length && columnLevel >= descriptions.columns.length) {
      return;
    }
    if (level < descriptions.rows.length) {
      columnPath = [];
    }
    if (level >= descriptions.rows.length) {
      if (item) {
        columnPath[columnLevel] = item.key + "";
        columnItem = getItem(item, "column", columnPath, columnLevel, descriptions.columns[columnLevel]);
        rowItem = rowHash[rowPath.slice(0, rowLevel + 1).join("/")];
      } else {
        result.columns.push({});
      }
    } else if (item) {
      rowPath[rowLevel] = item.key + "";
      rowItem = getItem(item, "row", rowPath, rowLevel, descriptions.rows[rowLevel]);
      columnItem = columnHash[columnPath.slice(0, columnLevel + 1).join("/")];
    } else {
      result.rows.push({});
    }
    var currentRowIndex = rowItem && rowItem.index || result.grandTotalRowIndex;
    var currentColumnIndex = columnItem && columnItem.index || result.grandTotalColumnIndex;
    each(item && item.summary || [], function(i, summary) {
      setValue(result.values, summary, currentRowIndex, currentColumnIndex, i);
    });
  });
  return result;
}
function getFiltersForDimension(fields) {
  return (fields || []).filter((f) => f.filterValues && f.filterValues.length || f.searchValue);
}
function getExpandedIndex(options, axis) {
  if (options.headerName) {
    if (axis === options.headerName) {
      return options.path.length;
    } else if (options.oppositePath) {
      return options.oppositePath.length;
    }
  }
  return 0;
}
function getFiltersForExpandedDimension(options) {
  return getFiltersByPath(options[options.headerName], options.path).concat(getFiltersByPath(options[options.headerName === "rows" ? "columns" : "rows"], options.oppositePath || []));
}
function getExpandedPathSliceFilter(options, dimensionName, level, firstCollapsedFieldIndex) {
  var result = [];
  var startSliceIndex = level > firstCollapsedFieldIndex ? 0 : firstCollapsedFieldIndex;
  var fields = options.headerName !== dimensionName ? options[dimensionName].slice(startSliceIndex, level) : [];
  var paths = dimensionName === "rows" ? options.rowExpandedPaths : options.columnExpandedPaths;
  each(fields, function(index2, field) {
    var filterValues = [];
    each(paths, function(_2, path) {
      path = path.slice(startSliceIndex, level);
      if (index2 < path.length) {
        var filterValue = path[index2];
        if (filterValues.indexOf(filterValue) === -1) {
          filterValues.push(filterValue);
        }
      }
    });
    if (filterValues.length) {
      result.push(extend({}, field, {
        filterType: "include",
        filterValues
      }));
    }
  });
  return result;
}
function getGrandTotalRequest(options, dimensionName, expandedIndex, expandedLevel, commonFilters, firstCollapsedFieldIndex) {
  var expandedPaths = (dimensionName === "columns" ? options.columnExpandedPaths : options.rowExpandedPaths) || [];
  var oppositeDimensionName = dimensionName === "columns" ? "rows" : "columns";
  var fields = options[dimensionName];
  var result = [];
  var newOptions;
  if (expandedPaths.length) {
    for (var i = expandedIndex; i < expandedLevel + 1; i++) {
      newOptions = {
        filters: commonFilters.concat(getExpandedPathSliceFilter(options, dimensionName, i, firstCollapsedFieldIndex))
      };
      newOptions[dimensionName] = fields.slice(expandedIndex, i + 1);
      newOptions[oppositeDimensionName] = [];
      result.push(extend({}, options, newOptions));
    }
  } else {
    newOptions = {
      filters: commonFilters
    };
    newOptions[dimensionName] = fields.slice(expandedIndex, expandedLevel + 1);
    newOptions[oppositeDimensionName] = [];
    result.push(extend({}, options, newOptions));
  }
  result[0].includeTotalSummary = true;
  return result;
}
function getFirstCollapsedIndex(fields) {
  var firstCollapsedIndex = 0;
  each(fields, function(index2, field) {
    if (!field.expanded) {
      firstCollapsedIndex = index2;
      return false;
    }
  });
  return firstCollapsedIndex;
}
function getRequestsData(options) {
  var rowExpandedLevel = getExpandedLevel$1(options, "rows");
  var columnExpandedLevel = getExpandedLevel$1(options, "columns");
  var filters = options.filters || [];
  var columnExpandedIndex = getExpandedIndex(options, "columns");
  var firstCollapsedColumnIndex = getFirstCollapsedIndex(options.columns);
  var firstCollapsedRowIndex = getFirstCollapsedIndex(options.rows);
  var rowExpandedIndex = getExpandedIndex(options, "rows");
  var data2 = [];
  filters = filters.concat(getFiltersForDimension(options.rows)).concat(getFiltersForDimension(options.columns)).concat(getFiltersForExpandedDimension(options));
  var columnTotalsOptions = getGrandTotalRequest(options, "columns", columnExpandedIndex, columnExpandedLevel, filters, firstCollapsedColumnIndex);
  if (options.rows.length && options.columns.length) {
    if (options.headerName !== "rows") {
      data2 = data2.concat(columnTotalsOptions);
    }
    for (var i = rowExpandedIndex; i < rowExpandedLevel + 1; i++) {
      var rows = options.rows.slice(rowExpandedIndex, i + 1);
      var rowFilterByExpandedPaths = getExpandedPathSliceFilter(options, "rows", i, firstCollapsedRowIndex);
      for (var j = columnExpandedIndex; j < columnExpandedLevel + 1; j++) {
        var preparedOptions = extend({}, options, {
          columns: options.columns.slice(columnExpandedIndex, j + 1),
          rows,
          filters: filters.concat(getExpandedPathSliceFilter(options, "columns", j, firstCollapsedColumnIndex)).concat(rowFilterByExpandedPaths)
        });
        data2.push(preparedOptions);
      }
    }
  } else {
    data2 = options.columns.length ? columnTotalsOptions : getGrandTotalRequest(options, "rows", rowExpandedIndex, rowExpandedLevel, filters, firstCollapsedRowIndex);
  }
  return data2;
}
function prepareFields(fields) {
  each(fields || [], function(_2, field) {
    var levels = field.levels;
    if (levels) {
      prepareFields(levels);
    }
    setDefaultFieldValueFormatting(field);
  });
}
var RemoteStore = classImpl.inherit({
  ctor: function(options) {
    this._dataSource = new DataSource(options);
    this._store = this._dataSource.store();
  },
  getFields: function(fields) {
    var d = new Deferred();
    this._store.load({
      skip: 0,
      take: 20
    }).done(function(data2) {
      var normalizedArguments = normalizeLoadResult(data2);
      d.resolve(discoverObjectFields(normalizedArguments.data, fields));
    }).fail(d.reject);
    return d;
  },
  key: function() {
    return this._store.key();
  },
  load: function(options) {
    var that = this;
    var d = new Deferred();
    var result = {
      rows: [],
      columns: [],
      values: [],
      grandTotalRowIndex: 0,
      grandTotalColumnIndex: 0,
      rowHash: {},
      columnHash: {},
      rowIndex: 1,
      columnIndex: 1
    };
    var requestsData = getRequestsData(options);
    var deferreds = [];
    prepareFields(options.rows);
    prepareFields(options.columns);
    prepareFields(options.filters);
    each(requestsData, function(_2, dataItem) {
      deferreds.push(that._store.load(createLoadOptions(dataItem, that.filter(), options.rows.length)));
    });
    when.apply(null, deferreds).done(function() {
      var args = deferreds.length > 1 ? arguments : [arguments];
      each(args, function(index2, argument) {
        var normalizedArguments = normalizeLoadResult(argument[0], argument[1]);
        parseResult(normalizedArguments.data, normalizedArguments.extra, requestsData[index2], result);
      });
      d.resolve({
        rows: result.rows,
        columns: result.columns,
        values: result.values,
        grandTotalRowIndex: result.grandTotalRowIndex,
        grandTotalColumnIndex: result.grandTotalColumnIndex
      });
    }).fail(d.reject);
    return d;
  },
  filter: function() {
    return this._dataSource.filter.apply(this._dataSource, arguments);
  },
  supportPaging: function() {
    return false;
  },
  createDrillDownDataSource: function(loadOptions, params) {
    loadOptions = loadOptions || {};
    params = params || {};
    var store = this._store;
    var filters = getFiltersByPath(loadOptions.rows, params.rowPath).concat(getFiltersByPath(loadOptions.columns, params.columnPath)).concat(getFiltersForDimension(loadOptions.rows)).concat(loadOptions.filters || []).concat(getFiltersForDimension(loadOptions.columns));
    var filterExp = createFilterExpressions(filters);
    return new DataSource({
      load: function(loadOptions2) {
        return store.load(extend({}, loadOptions2, {
          filter: mergeFilters(filterExp, loadOptions2.filter),
          select: params.customColumns
        }));
      }
    });
  }
});
function sort(loadOptions, dataSource, getAscOrder) {
  sortDimension(dataSource, loadOptions, "rows", getAscOrder);
  sortDimension(dataSource, loadOptions, "columns", getAscOrder);
}
function sortDimension(dataSource, loadOptions, dimensionName, getAscOrder) {
  var fields = loadOptions[dimensionName] || [];
  var baseIndex = loadOptions.headerName === dimensionName ? loadOptions.path.length : 0;
  var sortingMethodByLevel = [];
  foreachDataLevel(dataSource[dimensionName], function(item, index2) {
    var field = fields[index2] || {};
    var sortingMethod = sortingMethodByLevel[index2] = sortingMethodByLevel[index2] || getSortingMethod(field, dataSource, loadOptions, dimensionName, getAscOrder);
    item.sort(sortingMethod);
  }, baseIndex);
}
function getSortingMethod(field, dataSource, loadOptions, dimensionName, getAscOrder) {
  var sortOrder = getAscOrder ? "asc" : field.sortOrder;
  var sortBy = getMemberForSortBy(field.sortBy, getAscOrder);
  var defaultCompare2 = field.sortingMethod ? function(a, b) {
    return field.sortingMethod(a, b);
  } : getCompareFunction(function(item) {
    return item[sortBy];
  });
  var summaryValueSelector = !getAscOrder && getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName);
  var summaryCompare = summaryValueSelector && getCompareFunction(summaryValueSelector);
  return function(a, b) {
    var result = summaryCompare && summaryCompare(a, b) || defaultCompare2(a, b);
    return sortOrder === "desc" ? -result : result;
  };
}
function getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName) {
  var values = dataSource.values;
  var sortBySummaryFieldIndex = findField(loadOptions.values, field.sortBySummaryField);
  var areRows = dimensionName === "rows";
  var sortByDimension = areRows ? dataSource.columns : dataSource.rows;
  var grandTotalIndex = areRows ? dataSource.grandTotalRowIndex : dataSource.grandTotalColumnIndex;
  var sortBySummaryPath = field.sortBySummaryPath || [];
  var sliceIndex = sortBySummaryPath.length ? getSliceIndex(sortByDimension, sortBySummaryPath) : grandTotalIndex;
  if (values && values.length && sortBySummaryFieldIndex >= 0 && isDefined(sliceIndex)) {
    return function(field2) {
      var rowIndex = areRows ? field2.index : sliceIndex;
      var columnIndex = areRows ? sliceIndex : field2.index;
      var value2 = ((values[rowIndex] || [
        []
      ])[columnIndex] || [])[sortBySummaryFieldIndex];
      return isDefined(value2) ? value2 : null;
    };
  }
}
function getMemberForSortBy(sortBy, getAscOrder) {
  var member = "text";
  if (sortBy === "none") {
    member = "index";
  } else if (getAscOrder || sortBy !== "displayText") {
    member = "value";
  }
  return member;
}
function getSliceIndex(items, path) {
  var index2 = null;
  var pathValue = (path || []).join(".");
  if (pathValue.length) {
    foreachTree(items, function(items2) {
      var item = items2[0];
      var itemPath = createPath(items2).join(".");
      var textPath = map(items2, function(item2) {
        return item2.text;
      }).reverse().join(".");
      if (pathValue === itemPath || item.key && textPath === pathValue) {
        index2 = items2[0].index;
        return false;
      }
    });
  }
  return index2;
}
var LANGUAGE_CODES = {
  ar: 1,
  bg: 2,
  ca: 3,
  "zh-Hans": 4,
  cs: 5,
  da: 6,
  de: 7,
  el: 8,
  en: 9,
  es: 10,
  fi: 11,
  fr: 12,
  he: 13,
  hu: 14,
  is: 15,
  it: 16,
  ja: 17,
  ko: 18,
  nl: 19,
  no: 20,
  pl: 21,
  pt: 22,
  rm: 23,
  ro: 24,
  ru: 25,
  hr: 26,
  sk: 27,
  sq: 28,
  sv: 29,
  th: 30,
  tr: 31,
  ur: 32,
  id: 33,
  uk: 34,
  be: 35,
  sl: 36,
  et: 37,
  lv: 38,
  lt: 39,
  tg: 40,
  fa: 41,
  vi: 42,
  hy: 43,
  az: 44,
  eu: 45,
  hsb: 46,
  mk: 47,
  tn: 50,
  xh: 52,
  zu: 53,
  af: 54,
  ka: 55,
  fo: 56,
  hi: 57,
  mt: 58,
  se: 59,
  ga: 60,
  ms: 62,
  kk: 63,
  ky: 64,
  sw: 65,
  tk: 66,
  uz: 67,
  tt: 68,
  bn: 69,
  pa: 70,
  gu: 71,
  or: 72,
  ta: 73,
  te: 74,
  kn: 75,
  ml: 76,
  as: 77,
  mr: 78,
  sa: 79,
  mn: 80,
  bo: 81,
  cy: 82,
  km: 83,
  lo: 84,
  gl: 86,
  kok: 87,
  syr: 90,
  si: 91,
  iu: 93,
  am: 94,
  tzm: 95,
  ne: 97,
  fy: 98,
  ps: 99,
  fil: 100,
  dv: 101,
  ha: 104,
  yo: 106,
  quz: 107,
  nso: 108,
  ba: 109,
  lb: 110,
  kl: 111,
  ig: 112,
  ii: 120,
  arn: 122,
  moh: 124,
  br: 126,
  ug: 128,
  mi: 129,
  oc: 130,
  co: 131,
  gsw: 132,
  sah: 133,
  qut: 134,
  rw: 135,
  wo: 136,
  prs: 140,
  gd: 145,
  "ar-SA": 1025,
  "bg-BG": 1026,
  "ca-ES": 1027,
  "zh-TW": 1028,
  "cs-CZ": 1029,
  "da-DK": 1030,
  "de-DE": 1031,
  "el-GR": 1032,
  "en-US": 1033,
  "fi-FI": 1035,
  "fr-FR": 1036,
  "he-IL": 1037,
  "hu-HU": 1038,
  "is-IS": 1039,
  "it-IT": 1040,
  "ja-JP": 1041,
  "ko-KR": 1042,
  "nl-NL": 1043,
  "nb-NO": 1044,
  "pl-PL": 1045,
  "pt-BR": 1046,
  "rm-CH": 1047,
  "ro-RO": 1048,
  "ru-RU": 1049,
  "hr-HR": 1050,
  "sk-SK": 1051,
  "sq-AL": 1052,
  "sv-SE": 1053,
  "th-TH": 1054,
  "tr-TR": 1055,
  "ur-PK": 1056,
  "id-ID": 1057,
  "uk-UA": 1058,
  "be-BY": 1059,
  "sl-SI": 1060,
  "et-EE": 1061,
  "lv-LV": 1062,
  "lt-LT": 1063,
  "tg-Cyrl-TJ": 1064,
  "fa-IR": 1065,
  "vi-VN": 1066,
  "hy-AM": 1067,
  "az-Latn-AZ": 1068,
  "eu-ES": 1069,
  "hsb-DE": 1070,
  "mk-MK": 1071,
  "tn-ZA": 1074,
  "xh-ZA": 1076,
  "zu-ZA": 1077,
  "af-ZA": 1078,
  "ka-GE": 1079,
  "fo-FO": 1080,
  "hi-IN": 1081,
  "mt-MT": 1082,
  "se-NO": 1083,
  "ms-MY": 1086,
  "kk-KZ": 1087,
  "ky-KG": 1088,
  "sw-KE": 1089,
  "tk-TM": 1090,
  "uz-Latn-UZ": 1091,
  "tt-RU": 1092,
  "bn-IN": 1093,
  "pa-IN": 1094,
  "gu-IN": 1095,
  "or-IN": 1096,
  "ta-IN": 1097,
  "te-IN": 1098,
  "kn-IN": 1099,
  "ml-IN": 1100,
  "as-IN": 1101,
  "mr-IN": 1102,
  "sa-IN": 1103,
  "mn-MN": 1104,
  "bo-CN": 1105,
  "cy-GB": 1106,
  "km-KH": 1107,
  "lo-LA": 1108,
  "gl-ES": 1110,
  "kok-IN": 1111,
  "syr-SY": 1114,
  "si-LK": 1115,
  "iu-Cans-CA": 1117,
  "am-ET": 1118,
  "ne-NP": 1121,
  "fy-NL": 1122,
  "ps-AF": 1123,
  "fil-PH": 1124,
  "dv-MV": 1125,
  "ha-Latn-NG": 1128,
  "yo-NG": 1130,
  "quz-BO": 1131,
  "nso-ZA": 1132,
  "ba-RU": 1133,
  "lb-LU": 1134,
  "kl-GL": 1135,
  "ig-NG": 1136,
  "ii-CN": 1144,
  "arn-CL": 1146,
  "moh-CA": 1148,
  "br-FR": 1150,
  "ug-CN": 1152,
  "mi-NZ": 1153,
  "oc-FR": 1154,
  "co-FR": 1155,
  "gsw-FR": 1156,
  "sah-RU": 1157,
  "qut-GT": 1158,
  "rw-RW": 1159,
  "wo-SN": 1160,
  "prs-AF": 1164,
  "gd-GB": 1169,
  "ar-IQ": 2049,
  "zh-CN": 2052,
  "de-CH": 2055,
  "en-GB": 2057,
  "es-MX": 2058,
  "fr-BE": 2060,
  "it-CH": 2064,
  "nl-BE": 2067,
  "nn-NO": 2068,
  "pt-PT": 2070,
  "sr-Latn-CS": 2074,
  "sv-FI": 2077,
  "az-Cyrl-AZ": 2092,
  "dsb-DE": 2094,
  "se-SE": 2107,
  "ga-IE": 2108,
  "ms-BN": 2110,
  "uz-Cyrl-UZ": 2115,
  "bn-BD": 2117,
  "mn-Mong-CN": 2128,
  "iu-Latn-CA": 2141,
  "tzm-Latn-DZ": 2143,
  "quz-EC": 2155,
  "ar-EG": 3073,
  "zh-HK": 3076,
  "de-AT": 3079,
  "en-AU": 3081,
  "es-ES": 3082,
  "fr-CA": 3084,
  "sr-Cyrl-CS": 3098,
  "se-FI": 3131,
  "quz-PE": 3179,
  "ar-LY": 4097,
  "zh-SG": 4100,
  "de-LU": 4103,
  "en-CA": 4105,
  "es-GT": 4106,
  "fr-CH": 4108,
  "hr-BA": 4122,
  "smj-NO": 4155,
  "ar-DZ": 5121,
  "zh-MO": 5124,
  "de-LI": 5127,
  "en-NZ": 5129,
  "es-CR": 5130,
  "fr-LU": 5132,
  "bs-Latn-BA": 5146,
  "smj-SE": 5179,
  "ar-MA": 6145,
  "en-IE": 6153,
  "es-PA": 6154,
  "fr-MC": 6156,
  "sr-Latn-BA": 6170,
  "sma-NO": 6203,
  "ar-TN": 7169,
  "en-ZA": 7177,
  "es-DO": 7178,
  "sr-Cyrl-BA": 7194,
  "sma-SE": 7227,
  "ar-OM": 8193,
  "en-JM": 8201,
  "es-VE": 8202,
  "bs-Cyrl-BA": 8218,
  "sms-FI": 8251,
  "ar-YE": 9217,
  "en-029": 9225,
  "es-CO": 9226,
  "sr-Latn-RS": 9242,
  "smn-FI": 9275,
  "ar-SY": 10241,
  "en-BZ": 10249,
  "es-PE": 10250,
  "sr-Cyrl-RS": 10266,
  "ar-JO": 11265,
  "en-TT": 11273,
  "es-AR": 11274,
  "sr-Latn-ME": 11290,
  "ar-LB": 12289,
  "en-ZW": 12297,
  "es-EC": 12298,
  "sr-Cyrl-ME": 12314,
  "ar-KW": 13313,
  "en-PH": 13321,
  "es-CL": 13322,
  "ar-AE": 14337,
  "es-UY": 14346,
  "ar-BH": 15361,
  "es-PY": 15370,
  "ar-QA": 16385,
  "en-IN": 16393,
  "es-BO": 16394,
  "en-MY": 17417,
  "es-SV": 17418,
  "en-SG": 18441,
  "es-HN": 18442,
  "es-NI": 19466,
  "es-PR": 20490,
  "es-US": 21514,
  "bs-Cyrl": 25626,
  "bs-Latn": 26650,
  "sr-Cyrl": 27674,
  "sr-Latn": 28698,
  smn: 28731,
  "az-Cyrl": 29740,
  sms: 29755,
  zh: 30724,
  nn: 30740,
  bs: 30746,
  "az-Latn": 30764,
  sma: 30779,
  "uz-Cyrl": 30787,
  "mn-Cyrl": 30800,
  "iu-Cans": 30813,
  "zh-Hant": 31748,
  nb: 31764,
  sr: 31770,
  "tg-Cyrl": 31784,
  dsb: 31790,
  smj: 31803,
  "uz-Latn": 31811,
  "mn-Mong": 31824,
  "iu-Latn": 31837,
  "tzm-Latn": 31839,
  "ha-Latn": 31848
};
function getLanguageId() {
  return LANGUAGE_CODES[core.locale()];
}
var window$9 = getWindow();
var XmlaStore = classImpl.inherit(function() {
  var discover = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Body><Discover xmlns="urn:schemas-microsoft-com:xml-analysis"><RequestType>{2}</RequestType><Restrictions><RestrictionList><CATALOG_NAME>{0}</CATALOG_NAME><CUBE_NAME>{1}</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>{0}</Catalog>{3}</PropertyList></Properties></Discover></Body></Envelope>';
  var mdx = "SELECT {2} FROM {0} {1} CELL PROPERTIES VALUE, FORMAT_STRING, LANGUAGE, BACK_COLOR, FORE_COLOR, FONT_FLAGS";
  function execXMLA(requestOptions, data2) {
    var deferred = new Deferred();
    var beforeSend = requestOptions.beforeSend;
    var ajaxSettings = {
      url: requestOptions.url,
      dataType: "text",
      data: data2,
      headers: {
        "Content-Type": "text/xml"
      },
      xhrFields: {},
      method: "POST"
    };
    if (isFunction$1(beforeSend)) {
      beforeSend(ajaxSettings);
    }
    sendRequest(ajaxSettings).fail(function() {
      deferred.reject(arguments);
    }).done(function(text) {
      var parser = new window$9.DOMParser();
      var xml;
      try {
        try {
          xml = parser.parseFromString(text, "text/xml");
        } catch (e) {
          xml = void 0;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length || xml.childNodes.length === 0) {
          throw new errors.Error("E4023", text);
        }
      } catch (e) {
        deferred.reject({
          statusText: e.message,
          stack: e.stack,
          responseText: text
        });
      }
      deferred.resolve(xml);
    });
    return deferred;
  }
  function getLocaleIdProperty() {
    var languageId = getLanguageId();
    if (languageId !== void 0) {
      return format("<LocaleIdentifier>{0}</LocaleIdentifier>", languageId);
    }
    return "";
  }
  function getAllMember(dimension) {
    return (dimension.hierarchyName || dimension.dataField) + ".[All]";
  }
  function getAllMembers(field) {
    var result = field.dataField + ".allMembers";
    var searchValue = field.searchValue;
    if (searchValue) {
      searchValue = searchValue.replace(/'/g, "''");
      result = "Filter(" + result + ", instr(" + field.dataField + ".currentmember.member_caption,'" + searchValue + "') > 0)";
    }
    return result;
  }
  function crossJoinElements(elements) {
    var elementsString = elements.join(",");
    return elements.length > 1 ? format("CrossJoin({0})", elementsString) : elementsString;
  }
  function generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, take) {
    var crossJoinArgs = [];
    var dimensions = options[axisName];
    var arg;
    var prevDimension;
    var member;
    for (var i = expandIndex; i <= expandLevel; i++) {
      var field = dimensions[i];
      var dataField = field.dataField;
      var prevHierarchyName = dimensions[i - 1] && dimensions[i - 1].hierarchyName;
      var hierarchyName = field.hierarchyName;
      var isLastDimensionInGroup = !hierarchyName || !dimensions[i + 1] || dimensions[i + 1].hierarchyName !== hierarchyName;
      var expandAllIndex = path.length + expandAllCount + expandIndex;
      arg = null;
      if (i < path.length) {
        if (isLastDimensionInGroup) {
          arg = "(" + dataField + "." + preparePathValue(path[i], dataField) + ")";
        }
      } else if (i <= expandAllIndex) {
        if (i === 0 && expandAllCount === 0) {
          var allMember = getAllMember(dimensions[expandIndex]);
          if (!hierarchyName) {
            arg = getAllMembers(dimensions[expandIndex]);
          } else {
            arg = allMember + "," + dimensions[expandIndex].dataField;
          }
        } else if (hierarchyName) {
          member = preparePathValue(slicePath[slicePath.length - 1]);
          if (isLastDimensionInGroup || i === expandAllIndex) {
            if (prevHierarchyName === hierarchyName) {
              if (slicePath.length) {
                prevDimension = dimensions[slicePath.length - 1];
              }
              if (!prevDimension || prevDimension.hierarchyName !== hierarchyName) {
                prevDimension = dimensions[i - 1];
                member = "";
              }
              arg = (level = prevDimension.dataField, levelMember = member, nextLevel = dataField, memberExpression = void 0, memberExpression = levelMember ? levelMember : level, "Descendants({" + memberExpression + "}, " + nextLevel + ", SELF_AND_BEFORE)");
            } else {
              arg = getAllMembers(field);
            }
          }
        } else {
          arg = getAllMembers(field);
        }
      } else {
        var isFirstDimensionInGroup = !hierarchyName || prevHierarchyName !== hierarchyName;
        if (isFirstDimensionInGroup) {
          arg = "(" + getAllMember(field) + ")";
        }
      }
      if (arg) {
        arg = format("{{0}}", arg);
        if (take) {
          var sortBy = (field.hierarchyName || field.dataField) + (field.sortBy === "displayText" ? ".MEMBER_CAPTION" : ".MEMBER_VALUE");
          arg = format("Order({0}, {1}, {2})", arg, sortBy, field.sortOrder === "desc" ? "DESC" : "ASC");
        }
        crossJoinArgs.push(arg);
      }
    }
    var level, levelMember, nextLevel, memberExpression;
    return crossJoinElements(crossJoinArgs);
  }
  function fillCrossJoins(crossJoins, path, expandLevel, expandIndex, slicePath, options, axisName, cellsString, take, totalsOnly) {
    var expandAllCount = -1;
    var dimensions = options[axisName];
    var dimensionIndex;
    do {
      expandAllCount++;
      dimensionIndex = path.length + expandAllCount + expandIndex;
      var crossJoin = generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, take);
      if (!take && !totalsOnly) {
        crossJoin = format("NonEmpty({0}, {1})", crossJoin, cellsString);
      }
      crossJoins.push(crossJoin);
    } while (dimensions[dimensionIndex] && dimensions[dimensionIndex + 1] && dimensions[dimensionIndex].expanded);
  }
  function declare(expression, withArray, name2, type2) {
    name2 = name2 || "[DX_Set_" + withArray.length + "]";
    type2 = type2 || "set";
    withArray.push(format("{0} {1} as {2}", type2, name2, expression));
    return name2;
  }
  function generateAxisMdx(options, axisName, cells, withArray, parseOptions) {
    var dimensions = options[axisName];
    var crossJoins = [];
    var path = [];
    var expandedPaths = [];
    var expandIndex = 0;
    var expandLevel = 0;
    var result = [];
    var cellsString = format("{{0}}", cells.join(","));
    if (dimensions && dimensions.length) {
      if (options.headerName === axisName) {
        path = options.path;
        expandIndex = path.length;
      } else if (options.headerName && options.oppositePath) {
        path = options.oppositePath;
        expandIndex = path.length;
      } else {
        expandedPaths = (axisName === "columns" ? options.columnExpandedPaths : options.rowExpandedPaths) || expandedPaths;
      }
      expandLevel = getExpandedLevel$1(options, axisName);
      fillCrossJoins(crossJoins, [], expandLevel, expandIndex, path, options, axisName, cellsString, axisName === "rows" ? options.rowTake : options.columnTake, options.totalsOnly);
      each(expandedPaths, function(_2, expandedPath) {
        fillCrossJoins(crossJoins, expandedPath, expandLevel, expandIndex, expandedPath, options, axisName, cellsString);
      });
      for (var i = expandLevel; i >= path.length; i--) {
        if (dimensions[i].hierarchyName) {
          parseOptions.visibleLevels[dimensions[i].hierarchyName] = parseOptions.visibleLevels[dimensions[i].hierarchyName] || [];
          parseOptions.visibleLevels[dimensions[i].hierarchyName].push(dimensions[i].dataField);
        }
      }
    }
    if (crossJoins.length) {
      var expression = (elements = crossJoins, elementsString = elements.join(","), elements.length > 1 ? "Union(" + elementsString + ")" : elementsString);
      if (axisName === "rows" && options.rowTake) {
        expression = format("Subset({0}, {1}, {2})", expression, options.rowSkip > 0 ? options.rowSkip + 1 : 0, options.rowSkip > 0 ? options.rowTake : options.rowTake + 1);
      }
      if (axisName === "columns" && options.columnTake) {
        expression = format("Subset({0}, {1}, {2})", expression, options.columnSkip > 0 ? options.columnSkip + 1 : 0, options.columnSkip > 0 ? options.columnTake : options.columnTake + 1);
      }
      var axisSet = "[DX_".concat(axisName, "]");
      result.push(declare(expression, withArray, axisSet));
      if (options.totalsOnly) {
        result.push(declare("COUNT(".concat(axisSet, ")"), withArray, "[DX_".concat(axisName, "_count]"), "member"));
      }
    }
    var elements, elementsString;
    if (axisName === "columns" && cells.length && !options.skipValues) {
      result.push(cellsString);
    }
    return format("{0} DIMENSION PROPERTIES PARENT_UNIQUE_NAME,HIERARCHY_UNIQUE_NAME, MEMBER_VALUE ON {1}", crossJoinElements(result), axisName);
  }
  function generateAxisFieldsFilter(fields) {
    var filterMembers = [];
    each(fields, function(_2, field) {
      var dataField = field.dataField;
      var filterExpression = [];
      var filterValues = field.filterValues || [];
      var filterStringExpression;
      if (field.hierarchyName && isNumeric(field.groupIndex)) {
        return;
      }
      each(filterValues, function(_3, filterValue) {
        var filterMdx = dataField + "." + preparePathValue(Array.isArray(filterValue) ? filterValue[filterValue.length - 1] : filterValue, dataField);
        if (field.filterType === "exclude") {
          filterExpression.push(filterMdx + ".parent");
          filterMdx = "Descendants(" + filterMdx + ")";
        }
        filterExpression.push(filterMdx);
      });
      if (filterValues.length) {
        filterStringExpression = format("{{0}}", filterExpression.join(","));
        if (field.filterType === "exclude") {
          filterStringExpression = "Except(" + getAllMembers(field) + "," + filterStringExpression + ")";
        }
        filterMembers.push(filterStringExpression);
      }
    });
    return filterMembers.length ? crossJoinElements(filterMembers) : "";
  }
  function generateFrom(columnsFilter, rowsFilter, filter, cubeName) {
    var from = "[" + cubeName + "]";
    each([columnsFilter, rowsFilter, filter], function(_2, filter2) {
      if (filter2) {
        from = format("(SELECT {0} FROM {1})", filter2 + "on 0", from);
      }
    });
    return from;
  }
  function generateMdxCore(axisStrings, withArray, columns, rows, filters, slice, cubeName) {
    var options = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : {};
    var mdxString = "";
    var withString = (withArray.length ? "with " + withArray.join(" ") : "") + " ";
    if (axisStrings.length) {
      var select;
      if (options.totalsOnly) {
        var countMembers = [];
        if (rows.length) {
          countMembers.push("[DX_rows_count]");
        }
        if (columns.length) {
          countMembers.push("[DX_columns_count]");
        }
        select = "{".concat(countMembers.join(","), "} on columns");
      } else {
        select = axisStrings.join(",");
      }
      mdxString = withString + format(mdx, generateFrom(generateAxisFieldsFilter(columns), generateAxisFieldsFilter(rows), generateAxisFieldsFilter(filters || []), cubeName), slice.length ? format("WHERE ({0})", slice.join(",")) : "", select);
    }
    return mdxString;
  }
  function prepareDataFields(withArray, valueFields) {
    return map(valueFields, function(cell) {
      if (isString$1(cell.expression)) {
        declare(cell.expression, withArray, cell.dataField, "member");
      }
      return cell.dataField;
    });
  }
  function addSlices(slices, options, headerName, path) {
    each(path, function(index2, value2) {
      var dimension = options[headerName][index2];
      if (!dimension.hierarchyName || dimension.hierarchyName !== options[headerName][index2 + 1].hierarchyName) {
        slices.push(dimension.dataField + "." + preparePathValue(value2, dimension.dataField));
      }
    });
  }
  function generateMDX(options, cubeName, parseOptions) {
    var columns = options.columns || [];
    var rows = options.rows || [];
    var values = options.values && options.values.length ? options.values : [{
      dataField: "[Measures]"
    }];
    var slice = [];
    var withArray = [];
    var axisStrings = [];
    var dataFields = prepareDataFields(withArray, values);
    parseOptions.measureCount = options.skipValues ? 1 : values.length;
    parseOptions.visibleLevels = {};
    if (options.headerName && options.path) {
      addSlices(slice, options, options.headerName, options.path);
    }
    if (options.headerName && options.oppositePath) {
      addSlices(slice, options, options.headerName === "rows" ? "columns" : "rows", options.oppositePath);
    }
    if (columns.length || dataFields.length) {
      axisStrings.push(generateAxisMdx(options, "columns", dataFields, withArray, parseOptions));
    }
    if (rows.length) {
      axisStrings.push(generateAxisMdx(options, "rows", dataFields, withArray, parseOptions));
    }
    return generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName, options);
  }
  function createDrillDownAxisSlice(slice, fields, path) {
    each(path, function(index2, value2) {
      var field = fields[index2];
      if (field.hierarchyName && (fields[index2 + 1] || {}).hierarchyName === field.hierarchyName) {
        return;
      }
      slice.push(field.dataField + "." + preparePathValue(value2, field.dataField));
    });
  }
  function getNumber(str) {
    return parseInt(str, 10);
  }
  function getFirstChildText(node, childTagName) {
    return getNodeText(function(node2, tagName) {
      return (node2.getElementsByTagName(tagName) || [])[0];
    }(node, childTagName));
  }
  function getNodeText(node) {
    return node && (node.textContent || node.text || node.innerHTML) || "";
  }
  function parseCells(xml, axes, measureCount) {
    var cells = [];
    var cell = [];
    var index2 = 0;
    var cellsOriginal = [];
    var cellElements = xml.getElementsByTagName("Cell");
    var errorDictionary = {};
    for (var i = 0; i < cellElements.length; i++) {
      var xmlCell = cellElements[i];
      var valueElement = xmlCell.getElementsByTagName("Value")[0];
      var errorElements = valueElement && valueElement.getElementsByTagName("Error") || [];
      var text = errorElements.length === 0 ? getNodeText(valueElement) : "#N/A";
      var value2 = parseFloat(text);
      var _isNumeric = text - value2 + 1 > 0;
      var cellOrdinal = getNumber(xmlCell.getAttribute("CellOrdinal"));
      if (errorElements.length) {
        errorDictionary[getNodeText(errorElements[0].getElementsByTagName("ErrorCode")[0])] = getNodeText(errorElements[0].getElementsByTagName("Description")[0]);
      }
      cellsOriginal[cellOrdinal] = {
        value: _isNumeric ? value2 : text || null
      };
    }
    each(axes[1], function() {
      var row = [];
      cells.push(row);
      each(axes[0], function() {
        var measureIndex = index2 % measureCount;
        if (measureIndex === 0) {
          cell = [];
          row.push(cell);
        }
        cell.push(cellsOriginal[index2] ? cellsOriginal[index2].value : null);
        index2++;
      });
    });
    Object.keys(errorDictionary).forEach(function(key) {
      errors.log("W4002", errorDictionary[key]);
    });
    return cells;
  }
  function preparePathValue(pathValue, dataField) {
    if (pathValue) {
      pathValue = isString$1(pathValue) && pathValue.indexOf("&") !== -1 ? pathValue : "[" + pathValue + "]";
      if (dataField && pathValue.indexOf(dataField + ".") === 0) {
        pathValue = pathValue.slice(dataField.length + 1, pathValue.length);
      }
    }
    return pathValue;
  }
  function getItem(hash, name2, member, index2) {
    var item = hash[name2];
    if (!item) {
      item = {};
      hash[name2] = item;
    }
    if (!isDefined(item.value) && member) {
      item.text = member.caption;
      item.value = member.value;
      item.key = name2 ? name2 : "";
      item.levelName = member.levelName;
      item.hierarchyName = member.hierarchyName;
      item.parentName = member.parentName;
      item.index = index2;
      item.level = member.level;
    }
    return item;
  }
  function getVisibleChildren(item, visibleLevels) {
    var result = [];
    var children = item.children && (item.children.length ? item.children : Object.keys(item.children.grandTotalHash || {}).reduce((result2, name2) => result2.concat(item.children.grandTotalHash[name2].children), []));
    var firstChild = children && children[0];
    if (firstChild && (visibleLevels[firstChild.hierarchyName] && inArray(firstChild.levelName, visibleLevels[firstChild.hierarchyName]) !== -1 || !visibleLevels[firstChild.hierarchyName] || firstChild.level === 0)) {
      var newChildren = children.filter((child) => child.hierarchyName === firstChild.hierarchyName);
      newChildren.grandTotalHash = children.grandTotalHash;
      return newChildren;
    } else if (firstChild) {
      for (var i = 0; i < children.length; i++) {
        if (children[i].hierarchyName === firstChild.hierarchyName) {
          result.push.apply(result, getVisibleChildren(children[i], visibleLevels));
        }
      }
    }
    return result;
  }
  function fillDataSourceAxes(dataSourceAxis, axisTuples, measureCount, visibleLevels) {
    var result = [];
    each(axisTuples, function(tupleIndex, members) {
      var parentItem2 = {
        children: result
      };
      var dataIndex = isDefined(measureCount) ? Math.floor(tupleIndex / measureCount) : tupleIndex;
      each(members, function(_2, member) {
        parentItem2 = function(dataIndex2, member2, parentItem3) {
          var children = parentItem3.children = parentItem3.children || [];
          var hash = children.hash = children.hash || {};
          var grandTotalHash = children.grandTotalHash = children.grandTotalHash || {};
          if (member2.parentName) {
            parentItem3 = getItem(hash, member2.parentName);
            children = parentItem3.children = parentItem3.children || [];
          }
          var currentItem = getItem(hash, member2.name, member2, dataIndex2);
          if (member2.hasValue && !currentItem.added) {
            currentItem.index = dataIndex2;
            currentItem.added = true;
            children.push(currentItem);
          }
          if ((!parentItem3.value || !parentItem3.parentName) && member2.parentName) {
            grandTotalHash[member2.parentName] = parentItem3;
          } else if (grandTotalHash[parentItem3.name]) {
            delete grandTotalHash[member2.parentName];
          }
          return currentItem;
        }(dataIndex, member, parentItem2);
      });
    });
    var parentItem = {
      children: result
    };
    parentItem.children = getVisibleChildren(parentItem, visibleLevels);
    var grandTotalIndex = function(parentItem2, visibleLevels2) {
      var grandTotalIndex2;
      if (parentItem2.children.length === 1 && parentItem2.children[0].parentName === "") {
        grandTotalIndex2 = parentItem2.children[0].index;
        var grandTotalHash = parentItem2.children.grandTotalHash;
        parentItem2.children = parentItem2.children[0].children || [];
        parentItem2.children.grandTotalHash = grandTotalHash;
        parentItem2.children = getVisibleChildren(parentItem2, visibleLevels2);
      } else if (parentItem2.children.length === 0) {
        grandTotalIndex2 = 0;
      }
      return grandTotalIndex2;
    }(parentItem, visibleLevels);
    foreachTree(parentItem.children, function(items) {
      var item = items[0];
      var children = getVisibleChildren(item, visibleLevels);
      if (children.length) {
        item.children = children;
      } else {
        delete item.children;
      }
      delete item.levelName;
      delete item.hierarchyName;
      delete item.added;
      delete item.parentName;
      delete item.level;
    }, true);
    each(parentItem.children || [], function(_2, e) {
      dataSourceAxis.push(e);
    });
    return grandTotalIndex;
  }
  function checkError(xml) {
    var faultElementNS = xml.getElementsByTagName("soap:Fault");
    var faultElement = xml.getElementsByTagName("Fault");
    var errorElement = $([].slice.call(faultElement.length ? faultElement : faultElementNS)).find("Error");
    if (errorElement.length) {
      var description = errorElement.attr("Description");
      var error = new errors.Error("E4000", description);
      errors.log("E4000", description);
      return error;
    }
    return null;
  }
  function parseResult2(xml, parseOptions) {
    var dataSource = {
      columns: [],
      rows: []
    };
    var measureCount = parseOptions.measureCount;
    var axes = function(xml2, skipValues) {
      var axes2 = [];
      each(xml2.getElementsByTagName("Axis"), function(_2, axisElement) {
        var name2 = axisElement.getAttribute("name");
        var axis = [];
        var index2 = 0;
        if (name2.indexOf("Axis") === 0 && isNumeric(getNumber(name2.substr(4)))) {
          axes2.push(axis);
          each(axisElement.getElementsByTagName("Tuple"), function(_3, tupleElement) {
            var tupleMembers = tupleElement.childNodes;
            var levelSum = 0;
            var members = [];
            var membersCount = skipValues ? tupleMembers.length : tupleMembers.length - 1;
            var isAxisWithMeasure = axes2.length === 1;
            if (isAxisWithMeasure) {
              membersCount--;
            }
            axis.push(members);
            for (var i = membersCount; i >= 0; i--) {
              var tuple = tupleMembers[i];
              var level = getNumber(getFirstChildText(tuple, "LNum"));
              members[i] = {
                caption: getFirstChildText(tuple, "Caption"),
                value: (valueText = getFirstChildText(tuple, "MEMBER_VALUE"), isNumeric(valueText) ? parseFloat(valueText) : valueText),
                level,
                index: index2++,
                hasValue: !levelSum && (!!level || i === 0),
                name: getFirstChildText(tuple, "UName"),
                hierarchyName: tupleMembers[i].getAttribute("Hierarchy"),
                parentName: getFirstChildText(tuple, "PARENT_UNIQUE_NAME"),
                levelName: getFirstChildText(tuple, "LName")
              };
              levelSum += level;
            }
            var valueText;
          });
        }
      });
      while (axes2.length < 2) {
        axes2.push([
          [{
            level: 0
          }]
        ]);
      }
      return axes2;
    }(xml, parseOptions.skipValues);
    dataSource.grandTotalColumnIndex = fillDataSourceAxes(dataSource.columns, axes[0], measureCount, parseOptions.visibleLevels);
    dataSource.grandTotalRowIndex = fillDataSourceAxes(dataSource.rows, axes[1], void 0, parseOptions.visibleLevels);
    dataSource.values = parseCells(xml, axes, measureCount);
    return dataSource;
  }
  function parseDiscoverRowSet(xml, schema, dimensions, translatedDisplayFolders) {
    var result = [];
    var isMeasure = schema === "MEASURE";
    var displayFolderField = isMeasure ? "MEASUREGROUP_NAME" : schema + "_DISPLAY_FOLDER";
    each(xml.getElementsByTagName("row"), function(_2, row) {
      var hierarchyName = schema === "LEVEL" ? getFirstChildText(row, "HIERARCHY_UNIQUE_NAME") : void 0;
      var levelNumber = getFirstChildText(row, "LEVEL_NUMBER");
      var displayFolder = getFirstChildText(row, displayFolderField);
      if (isMeasure) {
        displayFolder = translatedDisplayFolders[displayFolder] || displayFolder;
      }
      if ((levelNumber !== "0" || getFirstChildText(row, schema + "_IS_VISIBLE") !== "true") && getFirstChildText(row, "DIMENSION_TYPE") !== "2") {
        var dimension = isMeasure ? "DX_MEASURES" : getFirstChildText(row, "DIMENSION_UNIQUE_NAME");
        var dataField = getFirstChildText(row, schema + "_UNIQUE_NAME");
        result.push({
          dimension: dimensions.names[dimension] || dimension,
          groupIndex: levelNumber ? getNumber(levelNumber) - 1 : void 0,
          dataField,
          caption: getFirstChildText(row, schema + "_CAPTION"),
          hierarchyName,
          groupName: hierarchyName,
          displayFolder,
          isMeasure,
          isDefault: !!dimensions.defaultHierarchies[dataField]
        });
      }
    });
    return result;
  }
  function parseStringWithUnicodeSymbols(str) {
    str = str.replace(/_x(....)_/g, function(whole, group1) {
      return String.fromCharCode(parseInt(group1, 16));
    });
    var stringArray = str.match(/\[.+?\]/gi);
    if (stringArray && stringArray.length) {
      str = stringArray[stringArray.length - 1];
    }
    return str.replace(/\[/gi, "").replace(/\]/gi, "").replace(/\$/gi, "").replace(/\./gi, " ");
  }
  function sendQuery(storeOptions, mdxString) {
    mdxString = $("<div>").text(mdxString).html();
    return execXMLA(storeOptions, format('<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Body><Execute xmlns="urn:schemas-microsoft-com:xml-analysis"><Command><Statement>{0}</Statement></Command><Properties><PropertyList><Catalog>{1}</Catalog><ShowHiddenCubes>True</ShowHiddenCubes><SspropInitAppName>Microsoft SQL Server Management Studio</SspropInitAppName><Timeout>3600</Timeout>{2}</PropertyList></Properties></Execute></Body></Envelope>', mdxString, storeOptions.catalog, getLocaleIdProperty()));
  }
  return {
    ctor: function(options) {
      this._options = options;
    },
    getFields: function() {
      var options = this._options;
      var catalog = options.catalog;
      var cube = options.cube;
      var localeIdProperty = getLocaleIdProperty();
      var dimensionsRequest = execXMLA(options, format(discover, catalog, cube, "MDSCHEMA_DIMENSIONS", localeIdProperty));
      var measuresRequest = execXMLA(options, format(discover, catalog, cube, "MDSCHEMA_MEASURES", localeIdProperty));
      var hierarchiesRequest = execXMLA(options, format(discover, catalog, cube, "MDSCHEMA_HIERARCHIES", localeIdProperty));
      var levelsRequest = execXMLA(options, format(discover, catalog, cube, "MDSCHEMA_LEVELS", localeIdProperty));
      var result = new Deferred();
      when(dimensionsRequest, measuresRequest, hierarchiesRequest, levelsRequest).then(function(dimensionsResponse, measuresResponse, hierarchiesResponse, levelsResponse) {
        execXMLA(options, format(discover, catalog, cube, "MDSCHEMA_MEASUREGROUPS", localeIdProperty)).done(function(measureGroupsResponse) {
          var dimensions = function(xml) {
            var result2 = {
              names: {},
              defaultHierarchies: {}
            };
            each($(xml).find("row"), function() {
              var $row = $(this);
              var type2 = $row.children("DIMENSION_TYPE").text();
              var dimensionName = type2 === "2" ? "DX_MEASURES" : $row.children("DIMENSION_UNIQUE_NAME").text();
              result2.names[dimensionName] = $row.children("DIMENSION_CAPTION").text();
              result2.defaultHierarchies[$row.children("DEFAULT_HIERARCHY").text()] = true;
            });
            return result2;
          }(dimensionsResponse);
          var hierarchies = parseDiscoverRowSet(hierarchiesResponse, "HIERARCHY", dimensions);
          var levels = parseDiscoverRowSet(levelsResponse, "LEVEL", dimensions);
          var measureGroups = function(xml) {
            var measureGroups2 = {};
            each(xml.getElementsByTagName("row"), function(_2, row) {
              measureGroups2[getFirstChildText(row, "MEASUREGROUP_NAME")] = getFirstChildText(row, "MEASUREGROUP_CAPTION");
            });
            return measureGroups2;
          }(measureGroupsResponse);
          var fields = parseDiscoverRowSet(measuresResponse, "MEASURE", dimensions, measureGroups).concat(hierarchies);
          var levelsByHierarchy = {};
          each(levels, function(_2, level) {
            levelsByHierarchy[level.hierarchyName] = levelsByHierarchy[level.hierarchyName] || [];
            levelsByHierarchy[level.hierarchyName].push(level);
          });
          each(hierarchies, function(_2, hierarchy) {
            if (levelsByHierarchy[hierarchy.dataField] && levelsByHierarchy[hierarchy.dataField].length > 1) {
              hierarchy.groupName = hierarchy.hierarchyName = hierarchy.dataField;
              fields.push.apply(fields, levelsByHierarchy[hierarchy.hierarchyName]);
            }
          });
          result.resolve(fields);
        }).fail(result.reject);
      }).fail(result.reject);
      return result;
    },
    load: function(options) {
      var result = new Deferred();
      var storeOptions = this._options;
      var parseOptions = {
        skipValues: options.skipValues
      };
      var mdxString = generateMDX(options, storeOptions.cube, parseOptions);
      var rowCountMdx;
      if (options.rowSkip || options.rowTake || options.columnTake || options.columnSkip) {
        rowCountMdx = generateMDX(extend({}, options, {
          totalsOnly: true,
          rowSkip: null,
          rowTake: null,
          columnSkip: null,
          columnTake: null
        }), storeOptions.cube, {});
      }
      var load = () => {
        if (mdxString) {
          when(sendQuery(storeOptions, mdxString), rowCountMdx && sendQuery(storeOptions, rowCountMdx)).done(function(executeXml, rowCountXml) {
            var error = checkError(executeXml) || rowCountXml && checkError(rowCountXml);
            if (!error) {
              var response = parseResult2(executeXml, parseOptions);
              if (rowCountXml) {
                !function(data2, options2, totalCountXml) {
                  var columnOptions = options2.columns || [];
                  var rowOptions = options2.rows || [];
                  if (columnOptions.length)
                    ;
                  if (rowOptions.length)
                    ;
                  var cells = parseCells(totalCountXml, [
                    [{}],
                    [{}, {}]
                  ], 1);
                  if (!columnOptions.length && rowOptions.length) {
                    data2.rowCount = Math.max(cells[0][0][0] - 1, 0);
                  }
                  if (!rowOptions.length && columnOptions.length) {
                    data2.columnCount = Math.max(cells[0][0][0] - 1, 0);
                  }
                  if (rowOptions.length && columnOptions.length) {
                    data2.rowCount = Math.max(cells[0][0][0] - 1, 0);
                    data2.columnCount = Math.max(cells[1][0][0] - 1, 0);
                  }
                  if (data2.rowCount !== void 0 && options2.rowTake) {
                    data2.rows = [...Array(options2.rowSkip)].concat(data2.rows);
                    data2.rows.length = data2.rowCount;
                    for (var i = 0; i < data2.rows.length; i++) {
                      data2.rows[i] = data2.rows[i] || {};
                    }
                  }
                  if (data2.columnCount !== void 0 && options2.columnTake) {
                    data2.columns = [...Array(options2.columnSkip)].concat(data2.columns);
                    data2.columns.length = data2.columnCount;
                    for (var _i = 0; _i < data2.columns.length; _i++) {
                      data2.columns[_i] = data2.columns[_i] || {};
                    }
                  }
                }(response, options, rowCountXml);
              }
              result.resolve(response);
            } else {
              result.reject(error);
            }
          }).fail(result.reject);
        } else {
          result.resolve({
            columns: [],
            rows: [],
            values: [],
            grandTotalColumnIndex: 0,
            grandTotalRowIndex: 0
          });
        }
      };
      if (options.delay) {
        setTimeout(load, options.delay);
      } else {
        load();
      }
      return result;
    },
    supportPaging: function() {
      return true;
    },
    getDrillDownItems: function(options, params) {
      var result = new Deferred();
      var storeOptions = this._options;
      var mdxString = function(options2, cubeName, params2) {
        var columns = options2.columns || [];
        var rows = options2.rows || [];
        var values = options2.values && options2.values.length ? options2.values : [{
          dataField: "[Measures]"
        }];
        var slice = [];
        var withArray = [];
        var axisStrings = [];
        var dataFields = prepareDataFields(withArray, values);
        var maxRowCount = params2.maxRowCount;
        var customColumns = params2.customColumns || [];
        var customColumnsString = customColumns.length > 0 ? " return " + customColumns.join(",") : "";
        createDrillDownAxisSlice(slice, columns, params2.columnPath || []);
        createDrillDownAxisSlice(slice, rows, params2.rowPath || []);
        if (columns.length || dataFields.length) {
          axisStrings.push([(dataFields[params2.dataIndex] || dataFields[0]) + " on 0"]);
        }
        var coreMDX = generateMdxCore(axisStrings, withArray, columns, rows, options2.filters, slice, cubeName);
        return coreMDX ? "drillthrough" + (maxRowCount > 0 ? " maxrows " + maxRowCount : "") + coreMDX + customColumnsString : coreMDX;
      }(options, storeOptions.cube, params);
      if (mdxString) {
        when(sendQuery(storeOptions, mdxString)).done(function(executeXml) {
          var error = checkError(executeXml);
          if (!error) {
            result.resolve(function(xml) {
              var rows = xml.getElementsByTagName("row");
              var result2 = [];
              var columnNames = {};
              for (var i = 0; i < rows.length; i++) {
                var children = rows[i].childNodes;
                var item = {};
                for (var j = 0; j < children.length; j++) {
                  var tagName = children[j].tagName;
                  var name2 = columnNames[tagName] = columnNames[tagName] || parseStringWithUnicodeSymbols(tagName);
                  item[name2] = getNodeText(children[j]);
                }
                result2.push(item);
              }
              return result2;
            }(executeXml));
          } else {
            result.reject(error);
          }
        }).fail(result.reject);
      } else {
        result.resolve([]);
      }
      return result;
    },
    key: noop,
    filter: noop
  };
}()).include(storeDrillDownMixin);
var COLUMN = "column";
var ROW = "row";
var NULL = null;
var calculatePercentValue = function(value2, totalValue) {
  var result = value2 / totalValue;
  if (!isDefined(value2) || isNaN(result)) {
    result = NULL;
  }
  return result;
};
var _percentOfGrandTotal = function(e, dimension) {
  return calculatePercentValue(e.value(), e.grandTotal(dimension).value());
};
var percentOfParent = function(e, dimension) {
  var parent = e.parent(dimension);
  var parentValue = parent ? parent.value() : e.value();
  return calculatePercentValue(e.value(), parentValue);
};
var createAbsoluteVariationExp = function(allowCrossGroup) {
  return function(e) {
    var prevCell = e.prev(COLUMN, allowCrossGroup);
    var prevValue = prevCell && prevCell.value();
    if (isDefined(prevValue) && isDefined(e.value())) {
      return e.value() - prevValue;
    }
    return NULL;
  };
};
var createPercentVariationExp = function(allowCrossGroup) {
  var absoluteExp = createAbsoluteVariationExp(allowCrossGroup);
  return function(e) {
    var absVar = absoluteExp(e);
    var prevCell = e.prev(COLUMN, allowCrossGroup);
    var prevValue = prevCell && prevCell.value();
    return absVar !== NULL && prevValue ? absVar / prevValue : NULL;
  };
};
var summaryDictionary = {
  percentOfColumnTotal: function(e) {
    return percentOfParent(e, ROW);
  },
  percentOfRowTotal: function(e) {
    return percentOfParent(e, COLUMN);
  },
  percentOfColumnGrandTotal: function(e) {
    return _percentOfGrandTotal(e, ROW);
  },
  percentOfRowGrandTotal: function(e) {
    return _percentOfGrandTotal(e, COLUMN);
  },
  percentOfGrandTotal: function(e) {
    return _percentOfGrandTotal(e);
  }
};
var getPrevCellCrossGroup = function getPrevCellCrossGroup2(cell, direction) {
  if (!cell || !cell.parent(direction)) {
    return;
  }
  var prevCell = cell.prev(direction);
  if (!prevCell) {
    prevCell = getPrevCellCrossGroup2(cell.parent(direction), direction);
  }
  return prevCell;
};
var createRunningTotalExpr = function(field) {
  if (!field.runningTotal) {
    return;
  }
  var direction = field.runningTotal === COLUMN ? ROW : COLUMN;
  return function(e) {
    var prevCell = field.allowCrossGroupCalculation ? getPrevCellCrossGroup(e, direction) : e.prev(direction, false);
    var value2 = e.value(true);
    var prevValue = prevCell && prevCell.value(true);
    if (isDefined(prevValue) && isDefined(value2)) {
      value2 = prevValue + value2;
    } else if (isDefined(prevValue)) {
      value2 = prevValue;
    }
    return value2;
  };
};
function createCache() {
  return {
    fields: {},
    positions: {}
  };
}
function getFieldPos(descriptions, field, cache) {
  var fieldParams = {
    index: -1
  };
  if (!isObject$1(field)) {
    if (cache.fields[field]) {
      field = cache[field];
    } else {
      var allFields = descriptions.columns.concat(descriptions.rows).concat(descriptions.values);
      var fieldIndex = findField(allFields, field);
      field = cache[field] = allFields[fieldIndex];
    }
  }
  if (field) {
    var area = field.area || "data";
    fieldParams = cache.positions[field.index] = cache.positions[field.index] || {
      area,
      index: inArray(field, descriptions[area === "data" ? "values" : area + "s"])
    };
  }
  return fieldParams;
}
function getPathFieldName(dimension) {
  return dimension === ROW ? "_rowPath" : "_columnPath";
}
var SummaryCell = function(columnPath, rowPath, data2, descriptions, fieldIndex, fieldsCache) {
  this._columnPath = columnPath;
  this._rowPath = rowPath;
  this._fieldIndex = fieldIndex;
  this._fieldsCache = fieldsCache || createCache();
  this._data = data2;
  this._descriptions = descriptions;
  var cell = data2.values && data2.values[rowPath[0].index] && data2.values[rowPath[0].index][columnPath[0].index];
  if (cell) {
    cell.originalCell = cell.originalCell || cell.slice();
    cell.postProcessedFlags = cell.postProcessedFlags || [];
    this._cell = cell;
  }
};
SummaryCell.prototype = extend(SummaryCell.prototype, {
  _getPath: function(dimension) {
    return this[getPathFieldName(dimension)];
  },
  _getDimension: function(dimension) {
    dimension = dimension === ROW ? "rows" : "columns";
    return this._descriptions[dimension];
  },
  _createCell: function(config2) {
    return new SummaryCell(config2._columnPath || this._columnPath, config2._rowPath || this._rowPath, this._data, this._descriptions, this._fieldIndex);
  },
  parent: function(direction) {
    var path = this._getPath(direction).slice();
    var config2 = {};
    path.shift();
    if (path.length) {
      config2[getPathFieldName(direction)] = path;
      return this._createCell(config2);
    }
    return NULL;
  },
  children: function(direction) {
    var path = this._getPath(direction).slice();
    var item = path[0];
    var result = [];
    var cellConfig = {};
    if (item.children) {
      for (var i = 0; i < item.children.length; i++) {
        cellConfig[getPathFieldName(direction)] = [item.children[i]].concat(path.slice());
        result.push(this._createCell(cellConfig));
      }
    }
    return result;
  },
  grandTotal: function(direction) {
    var config2 = {};
    var rowPath = this._rowPath;
    var columnPath = this._columnPath;
    var dimensionPath = this._getPath(direction);
    var pathFieldName = getPathFieldName(direction);
    if (!direction) {
      config2._rowPath = [rowPath[rowPath.length - 1]];
      config2._columnPath = [columnPath[columnPath.length - 1]];
    } else {
      config2[pathFieldName] = [dimensionPath[dimensionPath.length - 1]];
    }
    return this._createCell(config2);
  },
  next: function(direction, allowCrossGroup) {
    var currentPath = this._getPath(direction);
    var item = currentPath[0];
    var parent = this.parent(direction);
    var siblings;
    if (parent) {
      var index2 = inArray(item, currentPath[1].children);
      siblings = parent.children(direction);
      if (siblings[index2 + 1]) {
        return siblings[index2 + 1];
      }
    }
    if (allowCrossGroup && parent) {
      do {
        parent = parent.next(direction, allowCrossGroup);
        siblings = parent ? parent.children(direction) : [];
      } while (parent && !siblings.length);
      return siblings[0] || NULL;
    }
    return NULL;
  },
  prev: function(direction, allowCrossGroup) {
    var currentPath = this._getPath(direction);
    var item = currentPath[0];
    var parent = this.parent(direction);
    var siblings;
    if (parent) {
      var index2 = inArray(item, currentPath[1].children);
      siblings = parent.children(direction);
      if (siblings[index2 - 1]) {
        return siblings[index2 - 1];
      }
    }
    if (allowCrossGroup && parent) {
      do {
        parent = parent.prev(direction, allowCrossGroup);
        siblings = parent ? parent.children(direction) : [];
      } while (parent && !siblings.length);
      return siblings[siblings.length - 1] || NULL;
    }
    return NULL;
  },
  cell: function() {
    return this._cell;
  },
  field: function(area) {
    if (area === "data") {
      return this._descriptions.values[this._fieldIndex];
    }
    var path = this._getPath(area);
    var descriptions = this._getDimension(area);
    var field = descriptions[path.length - 2];
    return field || NULL;
  },
  child: function(direction, fieldValue) {
    var children = this.children(direction);
    for (var i = 0; i < children.length; i++) {
      var childLevelField = childLevelField || children[i].field(direction);
      if (children[i].value(childLevelField) === fieldValue) {
        return children[i];
      }
    }
    return NULL;
  },
  slice: function(field, value2) {
    var config2 = {};
    var fieldPos = getFieldPos(this._descriptions, field, this._fieldsCache);
    var area = fieldPos.area;
    var fieldIndex = fieldPos.index;
    var sliceCell = NULL;
    if (area === ROW || area === COLUMN) {
      var path = this._getPath(area).slice();
      var level = fieldIndex !== -1 && path.length - 2 - fieldIndex;
      if (path[level]) {
        [][path.length - 1] = path[path.length - 1];
        for (var i = level; i >= 0; i--) {
          if (path[i + 1]) {
            var childItems = path[i + 1].children || [];
            var currentValue = i === level ? value2 : path[i].value;
            path[i] = void 0;
            for (var childIndex = 0; childIndex < childItems.length; childIndex++) {
              if (childItems[childIndex].value === currentValue) {
                path[i] = childItems[childIndex];
                break;
              }
            }
          }
          if (path[i] === void 0) {
            return sliceCell;
          }
        }
        config2[getPathFieldName(area)] = path;
        sliceCell = this._createCell(config2);
      }
    }
    return sliceCell;
  },
  value: function(arg1, arg2) {
    var cell = this._cell;
    var fieldIndex = this._fieldIndex;
    var fistArgIsBoolean = arg1 === true || arg1 === false;
    var field = !fistArgIsBoolean ? arg1 : NULL;
    var needCalculatedValue = fistArgIsBoolean && arg1 || arg2;
    if (isDefined(field)) {
      var fieldPos = getFieldPos(this._descriptions, field, this._fieldsCache);
      fieldIndex = fieldPos.index;
      if (fieldPos.area !== "data") {
        var path = this._getPath(fieldPos.area);
        var level = fieldIndex !== -1 && path.length - 2 - fieldIndex;
        return path[level] && path[level].value;
      }
    }
    if (cell && cell.originalCell) {
      return needCalculatedValue ? cell[fieldIndex] : cell.originalCell[fieldIndex];
    }
    return NULL;
  },
  isPostProcessed(field) {
    var fieldIndex = this._fieldIndex;
    if (isDefined(field)) {
      var fieldPos = getFieldPos(this._descriptions, field, this._fieldsCache);
      fieldIndex = fieldPos.index;
      if (fieldPos.area !== "data") {
        return false;
      }
    }
    return !!(this._cell && this._cell.postProcessedFlags[fieldIndex]);
  }
});
function getExpression(field) {
  var summaryDisplayMode = field.summaryDisplayMode;
  var crossGroupCalculation = field.allowCrossGroupCalculation;
  var expression = NULL;
  if (isFunction$1(field.calculateSummaryValue)) {
    expression = field.calculateSummaryValue;
  } else if (summaryDisplayMode) {
    if (summaryDisplayMode === "absoluteVariation") {
      expression = createAbsoluteVariationExp(crossGroupCalculation);
    } else if (summaryDisplayMode === "percentVariation") {
      expression = createPercentVariationExp(crossGroupCalculation);
    } else {
      expression = summaryDictionary[summaryDisplayMode];
    }
    if (expression && !field.format && summaryDisplayMode.indexOf("percent") !== -1) {
      setFieldProperty(field, "format", "percent");
    }
  }
  return expression;
}
function processDataCell$1(data2, rowIndex, columnIndex, isRunningTotalCalculation) {
  var values = data2.values[rowIndex][columnIndex] = data2.values[rowIndex][columnIndex] || [];
  var originalCell = values.originalCell;
  if (!originalCell) {
    return;
  }
  if (values.allowResetting || !isRunningTotalCalculation) {
    data2.values[rowIndex][columnIndex] = originalCell.slice();
  }
  data2.values[rowIndex][columnIndex].allowResetting = isRunningTotalCalculation;
}
function applyDisplaySummaryMode(descriptions, data2) {
  var expressions = [];
  var columnElements = [{
    index: data2.grandTotalColumnIndex,
    children: data2.columns
  }];
  var rowElements = [{
    index: data2.grandTotalRowIndex,
    children: data2.rows
  }];
  var valueFields = descriptions.values;
  var fieldsCache = createCache();
  data2.values = data2.values || [];
  foreachTree(columnElements, (columnPath) => {
    columnPath[0].isEmpty = [];
  }, false);
  foreachTree(rowElements, function(rowPath) {
    var rowItem = rowPath[0];
    rowItem.isEmpty = [];
    data2.values[rowItem.index] = data2.values[rowItem.index] || [];
    foreachTree(columnElements, function(columnPath) {
      var columnItem = columnPath[0];
      var isEmptyCell;
      processDataCell$1(data2, rowItem.index, columnItem.index, false);
      for (var i = 0; i < valueFields.length; i++) {
        var field = valueFields[i];
        var expression = expressions[i] = expressions[i] === void 0 ? getExpression(field) : expressions[i];
        isEmptyCell = false;
        if (expression) {
          var expressionArg = new SummaryCell(columnPath, rowPath, data2, descriptions, i, fieldsCache);
          var cell = expressionArg.cell();
          var value2 = cell[i] = expression(expressionArg);
          cell.postProcessedFlags[i] = true;
          isEmptyCell = value2 === null || value2 === void 0;
        }
        if (columnItem.isEmpty[i] === void 0) {
          columnItem.isEmpty[i] = true;
        }
        if (rowItem.isEmpty[i] === void 0) {
          rowItem.isEmpty[i] = true;
        }
        if (!isEmptyCell) {
          rowItem.isEmpty[i] = columnItem.isEmpty[i] = false;
        }
      }
    }, false);
  }, false);
  data2.isEmptyGrandTotalRow = rowElements[0].isEmpty;
  data2.isEmptyGrandTotalColumn = columnElements[0].isEmpty;
}
function applyRunningTotal(descriptions, data2) {
  var expressions = [];
  var columnElements = [{
    index: data2.grandTotalColumnIndex,
    children: data2.columns
  }];
  var rowElements = [{
    index: data2.grandTotalRowIndex,
    children: data2.rows
  }];
  var valueFields = descriptions.values;
  var fieldsCache = createCache();
  data2.values = data2.values || [];
  foreachTree(rowElements, function(rowPath) {
    var rowItem = rowPath[0];
    data2.values[rowItem.index] = data2.values[rowItem.index] || [];
    foreachTree(columnElements, function(columnPath) {
      var columnItem = columnPath[0];
      processDataCell$1(data2, rowItem.index, columnItem.index, true);
      for (var i = 0; i < valueFields.length; i++) {
        var field = valueFields[i];
        var expression = expressions[i] = expressions[i] === void 0 ? createRunningTotalExpr(field) : expressions[i];
        if (expression) {
          var expressionArg = new SummaryCell(columnPath, rowPath, data2, descriptions, i, fieldsCache);
          var cell = expressionArg.cell();
          cell[i] = expression(expressionArg);
          cell.postProcessedFlags[i] = true;
        }
      }
    }, false);
  }, false);
}
function createMockSummaryCell(descriptions, fields, indices) {
  var summaryCell = new SummaryCell([], [], {}, descriptions, 0);
  summaryCell.value = function(fieldId) {
    if (isDefined(fieldId)) {
      var index2 = findField(fields, fieldId);
      var field = fields[index2];
      if (!indices[index2] && field && !isDefined(field.area)) {
        descriptions.values.push(field);
        indices[index2] = true;
      }
    }
  };
  summaryCell.grandTotal = function() {
    return this;
  };
  summaryCell.children = function() {
    return [];
  };
  return summaryCell;
}
var DESCRIPTION_NAME_BY_AREA = {
  row: "rows",
  column: "columns",
  data: "values",
  filter: "filters"
};
var STATE_PROPERTIES = ["area", "areaIndex", "sortOrder", "filterType", "filterValues", "sortBy", "sortBySummaryField", "sortBySummaryPath", "expanded", "summaryType", "summaryDisplayMode"];
var CALCULATED_PROPERTIES = ["format", "selector", "customizeText", "caption"];
var ALL_CALCULATED_PROPERTIES = CALCULATED_PROPERTIES.concat(["allowSorting", "allowSortingBySummary", "allowFiltering", "allowExpandAll"]);
function createCaption(field) {
  var caption = field.dataField || field.groupName || "";
  var summaryType = (field.summaryType || "").toLowerCase();
  if (isString$1(field.groupInterval)) {
    caption += "_" + field.groupInterval;
  }
  if (summaryType && summaryType !== "custom") {
    summaryType = summaryType.replace(/^./, summaryType[0].toUpperCase());
    if (caption.length) {
      summaryType = " (" + summaryType + ")";
    }
  } else {
    summaryType = "";
  }
  return titleize(caption) + summaryType;
}
function resetFieldState(field, properties) {
  var initialProperties = field._initProperties || {};
  each(properties, function(_2, prop) {
    if (Object.prototype.hasOwnProperty.call(initialProperties, prop)) {
      field[prop] = initialProperties[prop];
    }
  });
}
function updateCalculatedFieldProperties(field, calculatedProperties) {
  resetFieldState(field, calculatedProperties);
  if (!isDefined(field.caption)) {
    setFieldProperty(field, "caption", createCaption(field));
  }
}
function areExpressionsUsed(dataFields) {
  return dataFields.some(function(field) {
    return field.summaryDisplayMode || field.calculateSummaryValue;
  });
}
function isRunningTotalUsed(dataFields) {
  return dataFields.some(function(field) {
    return !!field.runningTotal;
  });
}
function isDataExists(data2) {
  return data2.rows.length || data2.columns.length || data2.values.length;
}
var PivotGridDataSource = classImpl.inherit(function() {
  var findHeaderItem = function(headerItems, path) {
    if (headerItems._cacheByPath) {
      return headerItems._cacheByPath[path.join(".")] || null;
    }
  };
  var getHeaderItemsLastIndex = function getHeaderItemsLastIndex2(headerItems, grandTotalIndex) {
    var i;
    var lastIndex = -1;
    var headerItem;
    if (headerItems) {
      for (i = 0; i < headerItems.length; i++) {
        headerItem = headerItems[i];
        if (headerItem.index !== void 0) {
          lastIndex = Math.max(lastIndex, headerItem.index);
        }
        if (headerItem.children) {
          lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex2(headerItem.children));
        } else if (headerItem.collapsedChildren) {
          lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex2(headerItem.collapsedChildren));
        }
      }
    }
    if (isDefined(grandTotalIndex)) {
      lastIndex = Math.max(lastIndex, grandTotalIndex);
    }
    return lastIndex;
  };
  var updateHeaderItemChildren = function(headerItems, headerItem, children, grandTotalIndex) {
    var applyingHeaderItemsCount = getHeaderItemsLastIndex(children) + 1;
    var emptyIndex = getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1;
    var index2;
    var applyingItemIndexesToCurrent = [];
    var needIndexUpdate = false;
    var d = new Deferred();
    if (headerItem.children && headerItem.children.length === children.length) {
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.index !== void 0) {
          if (headerItem.children[i].index === void 0) {
            child.index = applyingItemIndexesToCurrent[child.index] = emptyIndex++;
            headerItem.children[i] = child;
          } else {
            applyingItemIndexesToCurrent[child.index] = headerItem.children[i].index;
          }
        }
      }
    } else {
      needIndexUpdate = true;
      for (index2 = 0; index2 < applyingHeaderItemsCount; index2++) {
        applyingItemIndexesToCurrent[index2] = emptyIndex++;
      }
      headerItem.children = children;
    }
    when(foreachTreeAsync(headerItem.children, function(items) {
      if (needIndexUpdate) {
        items[0].index = applyingItemIndexesToCurrent[items[0].index];
      }
    })).done(function() {
      d.resolve(applyingItemIndexesToCurrent);
    });
    return d;
  };
  var updateHeaderItems = function(headerItems, newHeaderItems, grandTotalIndex) {
    var d = new Deferred();
    var emptyIndex = grandTotalIndex >= 0 && getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1;
    var applyingItemIndexesToCurrent = [];
    when(foreachTreeAsync(headerItems, function(items) {
      delete items[0].collapsedChildren;
    })).done(function() {
      when(foreachTreeAsync(newHeaderItems, function(newItems, index2) {
        var newItem = newItems[0];
        if (newItem.index >= 0) {
          var headerItem = findHeaderItem(headerItems, createPath(newItems));
          if (headerItem && headerItem.index >= 0) {
            applyingItemIndexesToCurrent[newItem.index] = headerItem.index;
          } else if (emptyIndex) {
            var path = createPath(newItems.slice(1));
            headerItem = findHeaderItem(headerItems, path);
            var parentItems = path.length ? headerItem && headerItem.children : headerItems;
            if (parentItems) {
              parentItems[index2] = newItem;
              newItem.index = applyingItemIndexesToCurrent[newItem.index] = emptyIndex++;
            }
          }
        }
      })).done(function() {
        d.resolve(applyingItemIndexesToCurrent);
      });
    });
    return d;
  };
  var updateDataSourceCells = function(dataSource, newDataSourceCells, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {
    var newRowIndex;
    var newColumnIndex;
    var newRowCells;
    var newCell;
    var rowIndex;
    var columnIndex;
    var dataSourceCells = dataSource.values;
    if (newDataSourceCells) {
      for (newRowIndex = 0; newRowIndex <= newDataSourceCells.length; newRowIndex++) {
        newRowCells = newDataSourceCells[newRowIndex];
        rowIndex = newRowItemIndexesToCurrent[newRowIndex];
        if (!isDefined(rowIndex)) {
          rowIndex = dataSource.grandTotalRowIndex;
        }
        if (newRowCells && isDefined(rowIndex)) {
          if (!dataSourceCells[rowIndex]) {
            dataSourceCells[rowIndex] = [];
          }
          for (newColumnIndex = 0; newColumnIndex <= newRowCells.length; newColumnIndex++) {
            newCell = newRowCells[newColumnIndex];
            columnIndex = newColumnItemIndexesToCurrent[newColumnIndex];
            if (!isDefined(columnIndex)) {
              columnIndex = dataSource.grandTotalColumnIndex;
            }
            if (isDefined(newCell) && isDefined(columnIndex)) {
              dataSourceCells[rowIndex][columnIndex] = newCell;
            }
          }
        }
      }
    }
  };
  function createLocalOrRemoteStore(dataSourceOptions, notifyProgress) {
    var StoreConstructor = dataSourceOptions.remoteOperations || dataSourceOptions.paginate ? RemoteStore : LocalStore;
    return new StoreConstructor(extend(normalizeDataSourceOptions(dataSourceOptions), {
      onChanged: null,
      onLoadingChanged: null,
      onProgressChanged: notifyProgress
    }));
  }
  function getExpandedPaths(dataSource, loadOptions, dimensionName, prevLoadOptions) {
    var result = [];
    var fields = loadOptions && loadOptions[dimensionName] || [];
    var prevFields = prevLoadOptions && prevLoadOptions[dimensionName] || [];
    foreachTree(dataSource[dimensionName], function(items) {
      var item = items[0];
      var path = createPath(items);
      if (item.children && fields[path.length - 1] && !fields[path.length - 1].expanded) {
        if (path.length < fields.length && (!prevLoadOptions || function(fields2, prevFields2, count) {
          for (var i = 0; i < count; i++) {
            if (!fields2[i] || !prevFields2[i] || fields2[i].index !== prevFields2[i].index) {
              return false;
            }
          }
          return true;
        }(fields, prevFields, path.length))) {
          result.push(path.slice());
        }
      }
    }, true);
    return result;
  }
  function setFieldProperties(field, srcField, skipInitPropertySave, properties) {
    if (srcField) {
      each(properties, function(_2, name2) {
        if (skipInitPropertySave) {
          field[name2] = srcField[name2];
        } else {
          if ((name2 === "summaryType" || name2 === "summaryDisplayMode") && srcField[name2] === void 0) {
            return;
          }
          setFieldProperty(field, name2, srcField[name2]);
        }
      });
    } else {
      resetFieldState(field, properties);
    }
    return field;
  }
  function getFieldsState(fields, properties) {
    var result = [];
    each(fields, function(_2, field) {
      result.push(setFieldProperties({
        dataField: field.dataField,
        name: field.name
      }, field, true, properties));
    });
    return result;
  }
  function getFieldStateId(field) {
    if (field.name) {
      return field.name;
    }
    return field.dataField + "";
  }
  function getFieldsById(fields, id) {
    var result = [];
    each(fields || [], function(_2, field) {
      if (getFieldStateId(field) === id) {
        result.push(field);
      }
    });
    return result;
  }
  function setFieldsState(stateFields, fields) {
    stateFields = stateFields || [];
    var fieldsById = {};
    var id;
    each(fields, function(_2, field) {
      id = getFieldStateId(field);
      if (!fieldsById[id]) {
        fieldsById[id] = getFieldsById(fields, getFieldStateId(field));
      }
    });
    each(fieldsById, function(id2, fields2) {
      !function(stateFields2, fields3) {
        stateFields2 = stateFields2 || [];
        each(fields3, function(index2, field) {
          setFieldProperties(field, stateFields2[index2], false, STATE_PROPERTIES);
          updateCalculatedFieldProperties(field, CALCULATED_PROPERTIES);
        });
        return fields3;
      }(getFieldsById(stateFields, id2), fields2);
    });
    return fields;
  }
  function sortFieldsByAreaIndex(fields) {
    fields.sort(function(field1, field2) {
      return field1.areaIndex - field2.areaIndex || field1.groupIndex - field2.groupIndex;
    });
  }
  function getFieldId(field, retrieveFieldsOptionValue) {
    var groupName = field.groupName || "";
    return (field.dataField || groupName) + (field.groupInterval ? groupName + field.groupInterval : "NOGROUP") + (retrieveFieldsOptionValue ? "" : groupName);
  }
  function mergeFields(fields, storeFields, retrieveFieldsOptionValue) {
    var result = [];
    var fieldsDictionary = {};
    var removedFields = {};
    var dataTypes = getFieldsDataType(fields);
    if (storeFields) {
      each(storeFields, function(_2, field) {
        fieldsDictionary[getFieldId(field, retrieveFieldsOptionValue)] = field;
      });
      each(fields, function(_2, field) {
        var fieldKey = getFieldId(field, retrieveFieldsOptionValue);
        var storeField = fieldsDictionary[fieldKey] || removedFields[fieldKey];
        var mergedField;
        if (storeField) {
          if (storeField._initProperties) {
            resetFieldState(storeField, ALL_CALCULATED_PROPERTIES);
          }
          mergedField = extend({}, storeField, field, {
            _initProperties: null
          });
        } else {
          fieldsDictionary[fieldKey] = mergedField = field;
        }
        extend(mergedField, {
          dataType: dataTypes[field.dataField]
        });
        delete fieldsDictionary[fieldKey];
        removedFields[fieldKey] = storeField;
        result.push(mergedField);
      });
      if (retrieveFieldsOptionValue) {
        each(fieldsDictionary, function(_2, field) {
          result.push(field);
        });
      }
    } else {
      result = fields;
    }
    result.push.apply(result, []);
    !function(fields2) {
      fields2.forEach((field) => {
        if (field.groupName && field.groupInterval && field.groupIndex === void 0) {
          var maxGroupIndex = fields2.filter((f) => f.groupName === field.groupName && isNumeric(f.groupIndex)).map((f) => f.groupIndex).reduce((prev, current2) => Math.max(prev, current2), -1);
          field.groupIndex = maxGroupIndex + 1;
        }
      });
    }(result);
    return result;
  }
  function getFields(that) {
    var result = new Deferred();
    var store = that._store;
    var storeFields = store && store.getFields(that._fields);
    var mergedFields;
    when(storeFields).done(function(storeFields2) {
      that._storeFields = storeFields2;
      mergedFields = mergeFields(that._fields, storeFields2, that._retrieveFields);
      result.resolve(mergedFields);
    }).fail(result.reject);
    return result;
  }
  function formatHeaderItems(data2, loadOptions, headerName) {
    return foreachTreeAsync(data2[headerName], function(items) {
      var item = items[0];
      item.text = item.text || formatValue(item.value, loadOptions[headerName][createPath(items).length - 1]);
    });
  }
  function formatHeaders(loadOptions, data2) {
    return when(formatHeaderItems(data2, loadOptions, "columns"), formatHeaderItems(data2, loadOptions, "rows"));
  }
  function updateCache(headerItems) {
    var d = new Deferred();
    var cacheByPath = {};
    when(foreachTreeAsync(headerItems, function(items) {
      var path = createPath(items).join(".");
      cacheByPath[path] = items[0];
    })).done(d.resolve);
    headerItems._cacheByPath = cacheByPath;
    return d;
  }
  function _getAreaFields(fields, area) {
    var areaFields = [];
    each(fields, function() {
      if (function(field, area2) {
        var canAddFieldInArea = area2 === "data" || field.visible !== false;
        return field.area === area2 && !isDefined(field.groupIndex) && canAddFieldInArea;
      }(this, area)) {
        areaFields.push(this);
      }
    });
    return areaFields;
  }
  return {
    ctor: function(options) {
      options = options || {};
      this._eventsStrategy = new EventsStrategy(this);
      var that = this;
      var store = function(dataSourceOptions, notifyProgress) {
        var store2;
        var storeOptions;
        if (isPlainObject(dataSourceOptions) && dataSourceOptions.load) {
          store2 = createLocalOrRemoteStore(dataSourceOptions, notifyProgress);
        } else {
          if (dataSourceOptions && !dataSourceOptions.store) {
            dataSourceOptions = {
              store: dataSourceOptions
            };
          }
          storeOptions = dataSourceOptions.store;
          if (storeOptions.type === "xmla") {
            store2 = new XmlaStore(storeOptions);
          } else if (isPlainObject(storeOptions) && storeOptions.type || storeOptions instanceof Store || Array.isArray(storeOptions)) {
            store2 = createLocalOrRemoteStore(dataSourceOptions, notifyProgress);
          } else if (storeOptions instanceof classImpl) {
            store2 = storeOptions;
          }
        }
        return store2;
      }(options, function(progress) {
        that._eventsStrategy.fireEvent("progressChanged", [progress]);
      });
      that._store = store;
      that._paginate = !!options.paginate;
      that._pageSize = options.pageSize || 40;
      that._data = {
        rows: [],
        columns: [],
        values: []
      };
      that._loadingCount = 0;
      that._isFieldsModified = false;
      each(["changed", "loadError", "loadingChanged", "progressChanged", "fieldsPrepared", "expandValueChanging"], function(_2, eventName) {
        var optionName = "on" + eventName[0].toUpperCase() + eventName.slice(1);
        if (Object.prototype.hasOwnProperty.call(options, optionName)) {
          this.on(eventName, options[optionName]);
        }
      }.bind(this));
      that._retrieveFields = isDefined(options.retrieveFields) ? options.retrieveFields : true;
      that._fields = options.fields || [];
      that._descriptions = options.descriptions ? extend(that._createDescriptions(), options.descriptions) : void 0;
      if (!store) {
        extend(true, that._data, options.store || options);
      }
    },
    getData: function() {
      return this._data;
    },
    getAreaFields: function(area, collectGroups) {
      var areaFields = [];
      var descriptions;
      if (collectGroups || area === "data") {
        areaFields = _getAreaFields(this._fields, area);
        sortFieldsByAreaIndex(areaFields);
      } else {
        descriptions = this._descriptions || {};
        areaFields = descriptions[DESCRIPTION_NAME_BY_AREA[area]] || [];
      }
      return areaFields;
    },
    fields: function(_fields) {
      if (_fields) {
        this._fields = mergeFields(_fields, this._storeFields, this._retrieveFields);
        this._fieldsPrepared(this._fields);
      }
      return this._fields;
    },
    field: function(id, options) {
      var fields = this._fields;
      var field = fields && fields[isNumeric(id) ? id : findField(fields, id)];
      var levels;
      if (field && options) {
        each(options, function(optionName, optionValue) {
          var isInitialization = inArray(optionName, STATE_PROPERTIES) < 0;
          setFieldProperty(field, optionName, optionValue, isInitialization);
          if (optionName === "sortOrder") {
            levels = field.levels || [];
            for (var i = 0; i < levels.length; i++) {
              levels[i][optionName] = optionValue;
            }
          }
        });
        updateCalculatedFieldProperties(field, CALCULATED_PROPERTIES);
        this._descriptions = this._createDescriptions(field);
        this._isFieldsModified = true;
        this._eventsStrategy.fireEvent("fieldChanged", [field]);
      }
      return field;
    },
    getFieldValues: function(index2, applyFilters, options) {
      var that = this;
      var field = this._fields && this._fields[index2];
      var store = this.store();
      var loadFields = [];
      var loadOptions = {
        columns: loadFields,
        rows: [],
        values: this.getAreaFields("data"),
        filters: applyFilters ? this._fields.filter((f) => f !== field && f.area && f.filterValues && f.filterValues.length) : [],
        skipValues: true
      };
      var searchValue;
      var d = new Deferred();
      if (options) {
        searchValue = options.searchValue;
        loadOptions.columnSkip = options.skip;
        loadOptions.columnTake = options.take;
      }
      if (field && store) {
        each(field.levels || [field], function() {
          loadFields.push(extend({}, this, {
            expanded: true,
            filterValues: null,
            sortOrder: "asc",
            sortBySummaryField: null,
            searchValue
          }));
        });
        store.load(loadOptions).done(function(data2) {
          if (loadOptions.columnSkip) {
            data2.columns = data2.columns.slice(loadOptions.columnSkip);
          }
          if (loadOptions.columnTake) {
            data2.columns = data2.columns.slice(0, loadOptions.columnTake);
          }
          formatHeaders(loadOptions, data2);
          if (!loadOptions.columnTake) {
            that._sort(loadOptions, data2);
          }
          d.resolve(data2.columns);
        }).fail(d);
      } else {
        d.reject();
      }
      return d;
    },
    reload: function() {
      return this.load({
        reload: true
      });
    },
    filter: function() {
      var store = this._store;
      return store.filter.apply(store, arguments);
    },
    load: function(options) {
      var that = this;
      var d = new Deferred();
      options = options || {};
      that.beginLoading();
      d.fail(function(e) {
        that._eventsStrategy.fireEvent("loadError", [e]);
      }).always(function() {
        that.endLoading();
      });
      function loadTask() {
        that._delayedLoadTask = void 0;
        if (!that._descriptions) {
          when(getFields(that)).done(function(fields) {
            that._fieldsPrepared(fields);
            that._loadCore(options, d);
          }).fail(d.reject).fail(that._loadErrorHandler);
        } else {
          that._loadCore(options, d);
        }
      }
      if (that.store()) {
        that._delayedLoadTask = executeAsync(loadTask);
      } else {
        loadTask();
      }
      return d;
    },
    createDrillDownDataSource: function(params) {
      return this._store.createDrillDownDataSource(this._descriptions, params);
    },
    _createDescriptions: function(currentField) {
      var fields = this.fields();
      var descriptions = {
        rows: [],
        columns: [],
        values: [],
        filters: []
      };
      each(["row", "column", "data", "filter"], function(_2, areaName) {
        normalizeIndexes(_getAreaFields(fields, areaName), "areaIndex", currentField);
      });
      each(fields || [], function(_2, field) {
        var descriptionName = DESCRIPTION_NAME_BY_AREA[field.area];
        var dimension = descriptions[descriptionName];
        var groupName = field.groupName;
        if (groupName && !isNumeric(field.groupIndex)) {
          field.levels = function(fields2, groupingField) {
            return fields2.filter((field2) => field2.groupName === groupingField.groupName && isNumeric(field2.groupIndex) && field2.visible !== false).map(function(field2) {
              return extend(field2, {
                areaIndex: groupingField.areaIndex,
                area: groupingField.area,
                expanded: isDefined(field2.expanded) ? field2.expanded : groupingField.expanded,
                dataField: field2.dataField || groupingField.dataField,
                dataType: field2.dataType || groupingField.dataType,
                sortBy: field2.sortBy || groupingField.sortBy,
                sortOrder: field2.sortOrder || groupingField.sortOrder,
                sortBySummaryField: field2.sortBySummaryField || groupingField.sortBySummaryField,
                sortBySummaryPath: field2.sortBySummaryPath || groupingField.sortBySummaryPath,
                visible: field2.visible || groupingField.visible,
                showTotals: isDefined(field2.showTotals) ? field2.showTotals : groupingField.showTotals,
                showGrandTotals: isDefined(field2.showGrandTotals) ? field2.showGrandTotals : groupingField.showGrandTotals
              });
            }).sort(function(a, b) {
              return a.groupIndex - b.groupIndex;
            });
          }(fields, field);
        }
        if (!dimension || groupName && isNumeric(field.groupIndex) || field.visible === false && field.area !== "data" && field.area !== "filter") {
          return;
        }
        if (field.levels && dimension !== descriptions.filters && dimension !== descriptions.values) {
          dimension.push.apply(dimension, field.levels);
          if (field.filterValues && field.filterValues.length) {
            descriptions.filters.push(field);
          }
        } else {
          dimension.push(field);
        }
      });
      each(descriptions, function(_2, fields2) {
        sortFieldsByAreaIndex(fields2);
      });
      var indices = {};
      each(descriptions.values, function(_2, field) {
        var expression = field.calculateSummaryValue;
        if (isFunction$1(expression)) {
          var summaryCell = createMockSummaryCell(descriptions, fields, indices);
          expression(summaryCell);
        }
      });
      return descriptions;
    },
    _fieldsPrepared: function(fields) {
      this._fields = fields;
      each(fields, function(index2, field) {
        field.index = index2;
        updateCalculatedFieldProperties(field, ALL_CALCULATED_PROPERTIES);
      });
      var currentFieldState = getFieldsState(fields, ["caption"]);
      this._eventsStrategy.fireEvent("fieldsPrepared", [fields]);
      for (var i = 0; i < fields.length; i++) {
        if (fields[i].caption !== currentFieldState[i].caption) {
          setFieldProperty(fields[i], "caption", fields[i].caption, true);
        }
      }
      this._descriptions = this._createDescriptions();
    },
    isLoading: function() {
      return this._loadingCount > 0;
    },
    state: function(_state, skipLoading) {
      var that = this;
      if (arguments.length) {
        _state = extend({
          rowExpandedPaths: [],
          columnExpandedPaths: []
        }, _state);
        if (!that._descriptions) {
          that.beginLoading();
          when(getFields(that)).done(function(fields) {
            that._fields = setFieldsState(_state.fields, fields);
            that._fieldsPrepared(fields);
            !skipLoading && that.load(_state);
          }).always(function() {
            that.endLoading();
          });
        } else {
          that._fields = setFieldsState(_state.fields, that._fields);
          that._descriptions = that._createDescriptions();
          !skipLoading && that.load(_state);
        }
      } else {
        return {
          fields: getFieldsState(that._fields, STATE_PROPERTIES),
          columnExpandedPaths: getExpandedPaths(that._data, that._descriptions, "columns", that._lastLoadOptions),
          rowExpandedPaths: getExpandedPaths(that._data, that._descriptions, "rows", that._lastLoadOptions)
        };
      }
    },
    beginLoading: function() {
      this._changeLoadingCount(1);
    },
    endLoading: function() {
      this._changeLoadingCount(-1);
    },
    _changeLoadingCount: function(increment) {
      var oldLoading = this.isLoading();
      this._loadingCount += increment;
      var newLoading = this.isLoading();
      if (oldLoading ^ newLoading) {
        this._eventsStrategy.fireEvent("loadingChanged", [newLoading]);
      }
    },
    _hasPagingValues: function(options, area, oppositeIndex) {
      var takeField = area + "Take";
      var skipField = area + "Skip";
      var values = this._data.values;
      var items = this._data[area + "s"];
      var oppositeArea = area === "row" ? "column" : "row";
      var indices = [];
      if (options.path && options.area === area) {
        var headerItem = findHeaderItem(items, options.path);
        items = headerItem && headerItem.children;
        if (!items) {
          return false;
        }
      }
      if (options.oppositePath && options.area === oppositeArea) {
        var _headerItem = findHeaderItem(items, options.oppositePath);
        items = _headerItem && _headerItem.children;
        if (!items) {
          return false;
        }
      }
      for (var i = options[skipField]; i < options[skipField] + options[takeField]; i++) {
        if (items[i]) {
          indices.push(items[i].index);
        }
      }
      return indices.every((index2) => {
        if (index2 !== void 0) {
          if (area === "row") {
            return (values[index2] || [])[oppositeIndex];
          } else {
            return (values[oppositeIndex] || [])[index2];
          }
        }
      });
    },
    _processPagingCacheByArea: function(options, pageSize, area) {
      var takeField = area + "Take";
      var skipField = area + "Skip";
      var items = this._data[area + "s"];
      var oppositeArea = area === "row" ? "column" : "row";
      var item;
      if (options[takeField]) {
        if (options.path && options.area === area) {
          var headerItem = findHeaderItem(items, options.path);
          items = headerItem && headerItem.children || [];
        }
        if (options.oppositePath && options.area === oppositeArea) {
          var _headerItem2 = findHeaderItem(items, options.oppositePath);
          items = _headerItem2 && _headerItem2.children || [];
        }
        do {
          item = items[options[skipField]];
          if (item && item.index !== void 0) {
            if (this._hasPagingValues(options, oppositeArea, item.index)) {
              options[skipField]++;
              options[takeField]--;
            } else {
              break;
            }
          }
        } while (item && item.index !== void 0 && options[takeField]);
        if (options[takeField]) {
          var start = Math.floor(options[skipField] / pageSize) * pageSize;
          var end = Math.ceil((options[skipField] + options[takeField]) / pageSize) * pageSize;
          options[skipField] = start;
          options[takeField] = end - start;
        }
      }
    },
    _processPagingCache: function(storeLoadOptions) {
      var pageSize = this._pageSize;
      if (pageSize < 0) {
        return;
      }
      for (var i = 0; i < storeLoadOptions.length; i++) {
        this._processPagingCacheByArea(storeLoadOptions[i], pageSize, "row");
        this._processPagingCacheByArea(storeLoadOptions[i], pageSize, "column");
      }
    },
    _loadCore: function(options, deferred) {
      var that = this;
      var store = this._store;
      var descriptions = this._descriptions;
      var reload = options.reload || this.paginate() && that._isFieldsModified;
      var paginate = this.paginate();
      var headerName = DESCRIPTION_NAME_BY_AREA[options.area];
      options = options || {};
      if (store) {
        extend(options, descriptions);
        options.columnExpandedPaths = options.columnExpandedPaths || getExpandedPaths(this._data, options, "columns", that._lastLoadOptions);
        options.rowExpandedPaths = options.rowExpandedPaths || getExpandedPaths(this._data, options, "rows", that._lastLoadOptions);
        if (paginate) {
          options.pageSize = this._pageSize;
        }
        if (headerName) {
          options.headerName = headerName;
        }
        that.beginLoading();
        deferred.always(function() {
          that.endLoading();
        });
        var storeLoadOptions = [options];
        that._eventsStrategy.fireEvent("customizeStoreLoadOptions", [storeLoadOptions, reload]);
        if (!reload) {
          that._processPagingCache(storeLoadOptions);
        }
        storeLoadOptions = storeLoadOptions.filter((options2) => !(options2.rows.length && options2.rowTake === 0) && !(options2.columns.length && options2.columnTake === 0));
        if (!storeLoadOptions.length) {
          that._update(deferred);
          return;
        }
        var results = storeLoadOptions.map((options2) => store.load(options2));
        when.apply(null, results).done(function() {
          var results2 = arguments;
          for (var i = 0; i < results2.length; i++) {
            var _options = storeLoadOptions[i];
            var data2 = results2[i];
            var isLast = i === results2.length - 1;
            if (_options.path) {
              that.applyPartialDataSource(_options.area, _options.path, data2, isLast ? deferred : false, _options.oppositePath);
            } else if (paginate && !reload && isDataExists(that._data)) {
              that.mergePartialDataSource(data2, isLast ? deferred : false);
            } else {
              extend(that._data, data2);
              that._lastLoadOptions = _options;
              that._update(isLast ? deferred : false);
            }
          }
        }).fail(deferred.reject);
      } else {
        that._update(deferred);
      }
    },
    _sort: function(descriptions, data2, getAscOrder) {
      var store = this._store;
      if (store && !this._paginate) {
        sort(descriptions, data2, getAscOrder);
      }
    },
    paginate: function() {
      return this._paginate && this._store && this._store.supportPaging();
    },
    isEmpty: function() {
      var dataFields = this.getAreaFields("data").filter((f) => f.visible !== false);
      var data2 = this.getData();
      return !dataFields.length || !data2.values.length;
    },
    _update: function(deferred) {
      var that = this;
      var descriptions = that._descriptions;
      var loadedData = that._data;
      var dataFields = descriptions.values;
      var expressionsUsed = areExpressionsUsed(dataFields);
      when(formatHeaders(descriptions, loadedData), updateCache(loadedData.rows), updateCache(loadedData.columns)).done(function() {
        if (expressionsUsed) {
          that._sort(descriptions, loadedData, expressionsUsed);
          !that.isEmpty() && applyDisplaySummaryMode(descriptions, loadedData);
        }
        that._sort(descriptions, loadedData);
        !that.isEmpty() && isRunningTotalUsed(dataFields) && applyRunningTotal(descriptions, loadedData);
        that._data = loadedData;
        deferred !== false && when(deferred).done(function() {
          that._isFieldsModified = false;
          that._eventsStrategy.fireEvent("changed");
          if (isDefined(that._data.grandTotalRowIndex)) {
            loadedData.grandTotalRowIndex = that._data.grandTotalRowIndex;
          }
          if (isDefined(that._data.grandTotalColumnIndex)) {
            loadedData.grandTotalColumnIndex = that._data.grandTotalColumnIndex;
          }
        });
        deferred && deferred.resolve(that._data);
      });
      return deferred;
    },
    store: function() {
      return this._store;
    },
    collapseHeaderItem: function(area, path) {
      var headerItems = area === "column" ? this._data.columns : this._data.rows;
      var headerItem = findHeaderItem(headerItems, path);
      var field = this.getAreaFields(area)[path.length - 1];
      if (headerItem && headerItem.children) {
        this._eventsStrategy.fireEvent("expandValueChanging", [{
          area,
          path,
          expanded: false
        }]);
        if (field) {
          field.expanded = false;
        }
        headerItem.collapsedChildren = headerItem.children;
        delete headerItem.children;
        this._update();
        if (this.paginate()) {
          this.load();
        }
        return true;
      }
      return false;
    },
    collapseAll: function(id) {
      var dataChanged = false;
      var field = this.field(id) || {};
      var areaOffsets = [inArray(field, this.getAreaFields(field.area))];
      field.expanded = false;
      if (field && field.levels) {
        areaOffsets = [];
        field.levels.forEach((f) => {
          areaOffsets.push(inArray(f, this.getAreaFields(field.area)));
          f.expanded = false;
        });
      }
      foreachTree(this._data[field.area + "s"], function(items) {
        var item = items[0];
        var path = createPath(items);
        if (item && item.children && areaOffsets.indexOf(path.length - 1) !== -1) {
          item.collapsedChildren = item.children;
          delete item.children;
          dataChanged = true;
        }
      }, true);
      dataChanged && this._update();
    },
    expandAll: function(id) {
      var field = this.field(id);
      if (field && field.area) {
        field.expanded = true;
        if (field && field.levels) {
          field.levels.forEach((f) => {
            f.expanded = true;
          });
        }
        this.load();
      }
    },
    expandHeaderItem: function(area, path) {
      var headerItems = area === "column" ? this._data.columns : this._data.rows;
      var headerItem = findHeaderItem(headerItems, path);
      if (headerItem && !headerItem.children) {
        var hasCache = !!headerItem.collapsedChildren;
        var options = {
          area,
          path,
          expanded: true,
          needExpandData: !hasCache
        };
        this._eventsStrategy.fireEvent("expandValueChanging", [options]);
        if (hasCache) {
          headerItem.children = headerItem.collapsedChildren;
          delete headerItem.collapsedChildren;
          this._update();
        } else if (this.store()) {
          this.load(options);
        }
        return hasCache;
      }
      return false;
    },
    mergePartialDataSource: function(dataSource, deferred) {
      var that = this;
      var loadedData = that._data;
      var newRowItemIndexesToCurrent;
      var newColumnItemIndexesToCurrent;
      if (dataSource && dataSource.values) {
        dataSource.rows = dataSource.rows || [];
        dataSource.columns = dataSource.columns || [];
        newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows, loadedData.grandTotalColumnIndex);
        newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns, loadedData.grandTotalColumnIndex);
        when(newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent).done(function(newRowItemIndexesToCurrent2, newColumnItemIndexesToCurrent2) {
          if (newRowItemIndexesToCurrent2.length || newColumnItemIndexesToCurrent2.length) {
            updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent2, newColumnItemIndexesToCurrent2);
          }
          that._update(deferred);
        });
      }
    },
    applyPartialDataSource: function(area, path, dataSource, deferred, oppositePath) {
      var that = this;
      var loadedData = that._data;
      var headerItems = area === "column" ? loadedData.columns : loadedData.rows;
      var headerItem;
      var oppositeHeaderItems = area === "column" ? loadedData.rows : loadedData.columns;
      var oppositeHeaderItem;
      var newRowItemIndexesToCurrent;
      var newColumnItemIndexesToCurrent;
      if (dataSource && dataSource.values) {
        dataSource.rows = dataSource.rows || [];
        dataSource.columns = dataSource.columns || [];
        headerItem = findHeaderItem(headerItems, path);
        oppositeHeaderItem = oppositePath && findHeaderItem(oppositeHeaderItems, oppositePath);
        if (headerItem) {
          if (area === "column") {
            newColumnItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.columns, loadedData.grandTotalColumnIndex);
            if (oppositeHeaderItem) {
              newRowItemIndexesToCurrent = updateHeaderItemChildren(oppositeHeaderItems, oppositeHeaderItem, dataSource.rows, loadedData.grandTotalRowIndex);
            } else {
              newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows, loadedData.grandTotalRowIndex);
            }
          } else {
            newRowItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.rows, loadedData.grandTotalRowIndex);
            if (oppositeHeaderItem) {
              newColumnItemIndexesToCurrent = updateHeaderItemChildren(oppositeHeaderItems, oppositeHeaderItem, dataSource.columns, loadedData.grandTotalColumnIndex);
            } else {
              newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns, loadedData.grandTotalColumnIndex);
            }
          }
          when(newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent).done(function(newRowItemIndexesToCurrent2, newColumnItemIndexesToCurrent2) {
            if (area === "row" && newRowItemIndexesToCurrent2.length || area === "column" && newColumnItemIndexesToCurrent2.length) {
              updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent2, newColumnItemIndexesToCurrent2);
            }
            that._update(deferred);
          });
        }
      }
    },
    on(eventName, eventHandler) {
      this._eventsStrategy.on(eventName, eventHandler);
      return this;
    },
    off(eventName, eventHandler) {
      this._eventsStrategy.off(eventName, eventHandler);
      return this;
    },
    dispose: function() {
      var delayedLoadTask = this._delayedLoadTask;
      this._eventsStrategy.dispose();
      if (delayedLoadTask) {
        delayedLoadTask.abort();
      }
      this._isDisposed = true;
    },
    isDisposed: function() {
      return !!this._isDisposed;
    }
  };
}());
var math$1 = Math;
var GRAND_TOTAL_TYPE = "GT";
var TOTAL_TYPE = "T";
var DATA_TYPE = "D";
var NOT_AVAILABLE = "#N/A";
var CHANGING_DURATION_IF_PAGINATE = 300;
var proxyMethod = function(instance, methodName, defaultResult) {
  if (!instance[methodName]) {
    instance[methodName] = function() {
      var dataSource = this._dataSource;
      return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;
    };
  }
};
var DataController = classImpl.inherit(function() {
  function formatCellValue(value2, dataField, errorText) {
    return value2 === NOT_AVAILABLE ? errorText : formatValue(value2, dataField);
  }
  var createHeaderInfo = function() {
    var addInfoItem = function(info, options) {
      var breadth = options.lastIndex - options.index || 1;
      var itemInfo = function(headerItem, breadth2, isHorizontal, isTree) {
        var infoItem = {
          type: headerItem.type,
          text: headerItem.text
        };
        if (headerItem.path) {
          infoItem.path = headerItem.path;
        }
        if (headerItem.width) {
          infoItem.width = headerItem.width;
        }
        if (isDefined(headerItem.wordWrapEnabled)) {
          infoItem.wordWrapEnabled = headerItem.wordWrapEnabled;
        }
        if (headerItem.isLast) {
          infoItem.isLast = true;
        }
        if (headerItem.sorted) {
          infoItem.sorted = true;
        }
        if (headerItem.isMetric) {
          infoItem.dataIndex = headerItem.dataIndex;
        }
        if (isDefined(headerItem.expanded)) {
          infoItem.expanded = headerItem.expanded;
        }
        if (breadth2 > 1) {
          infoItem[isHorizontal ? "colspan" : "rowspan"] = breadth2;
        }
        if (headerItem.depthSize && headerItem.depthSize > 1) {
          infoItem[isHorizontal ? "rowspan" : "colspan"] = headerItem.depthSize;
        }
        if (headerItem.index >= 0) {
          infoItem.dataSourceIndex = headerItem.index;
        }
        if (isTree && headerItem.children && headerItem.children.length && !headerItem.children[0].isMetric) {
          infoItem.width = null;
          infoItem.isWhiteSpace = true;
        }
        return infoItem;
      }(options.headerItem, breadth, options.isHorizontal, options.isTree);
      !function(info2, infoItem, itemIndex, depthIndex, isHorizontal) {
        var index2 = isHorizontal ? depthIndex : itemIndex;
        while (!info2[index2]) {
          info2.push([]);
        }
        if (isHorizontal) {
          info2[index2].push(infoItem);
        } else {
          info2[index2].unshift(infoItem);
        }
      }(info, itemInfo, options.index, options.depth, options.isHorizontal);
      if (!options.headerItem.children || options.headerItem.children.length === 0) {
        return options.lastIndex + 1;
      }
      return options.lastIndex;
    };
    var getViewHeaderItems = function(headerItems, headerDescriptions, cellDescriptions, depthSize, options) {
      var cellDescriptionsCount = cellDescriptions.length;
      var viewHeaderItems = function(headerItems2, headerDescriptions2) {
        var headerDescriptionsCount = headerDescriptions2 && headerDescriptions2.length || 0;
        var childrenStack = [];
        var d2 = new Deferred();
        var headerItem;
        when(foreachTreeAsync(headerItems2, function(items, index2) {
          var item = items[0];
          var path = createPath(items);
          headerItem = createHeaderItem(childrenStack, path.length, index2);
          headerItem.type = DATA_TYPE;
          headerItem.value = item.value;
          headerItem.path = path;
          headerItem.text = item.text;
          headerItem.index = item.index;
          headerItem.displayText = item.displayText;
          headerItem.key = item.key;
          headerItem.isEmpty = item.isEmpty;
          if (path.length < headerDescriptionsCount && (!item.children || item.children.length !== 0)) {
            headerItem.expanded = !!item.children;
          }
        })).done(function() {
          d2.resolve(createHeaderItem(childrenStack, 0, 0).children || []);
        });
        return d2;
      }(headerItems, headerDescriptions);
      var dataFields = options.dataFields;
      var d = new Deferred();
      when(viewHeaderItems).done(function(viewHeaderItems2) {
        options.notifyProgress(0.5);
        if (options.showGrandTotals) {
          viewHeaderItems2[!options.showTotalsPrior ? "push" : "unshift"]({
            type: GRAND_TOTAL_TYPE,
            isEmpty: options.isEmptyGrandTotal
          });
        }
        var hideTotals = options.showTotals === false || dataFields.length > 0 && dataFields.length === options.hiddenTotals.length;
        var hideData = dataFields.length > 0 && options.hiddenValues.length === dataFields.length;
        if (hideData && hideTotals) {
          depthSize = 1;
        }
        if (!hideTotals || options.layout === "tree") {
          !function(headerItems2, headerDescriptions2, showTotalsPrior, isTree) {
            showTotalsPrior = showTotalsPrior || isTree;
            foreachTree(headerItems2, function(items, index2) {
              var item = items[0];
              var parentChildren = (items[1] ? items[1].children : headerItems2) || [];
              var dataField = headerDescriptions2[items.length - 1];
              if (item.type === DATA_TYPE && item.expanded && (dataField.showTotals !== false || isTree)) {
                index2 !== -1 && parentChildren.splice(showTotalsPrior ? index2 : index2 + 1, 0, extend({}, item, {
                  children: null,
                  type: TOTAL_TYPE,
                  expanded: showTotalsPrior ? true : null,
                  isAdditionalTotal: true
                }));
                if (showTotalsPrior) {
                  item.expanded = null;
                }
              }
            });
          }(viewHeaderItems2, headerDescriptions, options.showTotalsPrior, options.layout === "tree");
        }
        when(foreachTreeAsync(viewHeaderItems2, function(items) {
          var item = items[0];
          if (!item.children || item.children.length === 0) {
            item.depthSize = depthSize - items.length + 1;
          }
        })).done(function() {
          if (cellDescriptionsCount > 1) {
            !function(headerItems2, cellDescriptions2, options2) {
              foreachTree(headerItems2, function(items) {
                var item = items[0];
                var i;
                if (!item.children || item.children.length === 0) {
                  item.children = [];
                  for (i = 0; i < cellDescriptions2.length; i++) {
                    var isGrandTotal = item.type === GRAND_TOTAL_TYPE;
                    var isTotal = item.type === TOTAL_TYPE;
                    var isValue = item.type === DATA_TYPE;
                    var columnIsHidden = cellDescriptions2[i].visible === false || isGrandTotal && inArray(i, options2.hiddenGrandTotals) !== -1 || isTotal && inArray(i, options2.hiddenTotals) !== -1 || isValue && inArray(i, options2.hiddenValues) !== -1;
                    if (columnIsHidden) {
                      continue;
                    }
                    item.children.push({
                      caption: cellDescriptions2[i].caption,
                      path: item.path,
                      type: item.type,
                      value: i,
                      index: item.index,
                      dataIndex: i,
                      isMetric: true,
                      isEmpty: item.isEmpty && item.isEmpty[i]
                    });
                  }
                }
              });
            }(viewHeaderItems2, cellDescriptions, options);
          }
          !options.showEmpty && function(headerItems2) {
            foreachTree([{
              children: headerItems2
            }], function(items, index2) {
              var item = items[0];
              var parentChildren = (items[1] ? items[1].children : headerItems2) || [];
              var isEmpty2 = item.isEmpty;
              if (isEmpty2 && isEmpty2.length) {
                isEmpty2 = item.isEmpty.filter(function(isEmpty3) {
                  return isEmpty3;
                }).length === isEmpty2.length;
              }
              if (item && !item.children && isEmpty2) {
                parentChildren.splice(index2, 1);
                !function removeEmptyParent(items2, index3) {
                  var parent = items2[index3 + 1];
                  if (!items2[index3].children.length && parent && parent.children) {
                    parent.children.splice(inArray(items2[index3], parent.children), 1);
                    removeEmptyParent(items2, index3 + 1);
                  }
                }(items, 1);
              }
            });
          }(viewHeaderItems2);
          options.notifyProgress(0.75);
          when(foreachTreeAsync(viewHeaderItems2, function(items) {
            var item = items[0];
            var isMetric = item.isMetric;
            var field = headerDescriptions[items.length - 1] || {};
            if (item.type === DATA_TYPE && !isMetric) {
              item.width = field.width;
            }
            if (hideData === true && item.type === DATA_TYPE) {
              var parentChildren = (items[1] ? items[1].children : viewHeaderItems2) || [];
              parentChildren.splice(inArray(item, parentChildren), 1);
              return;
            }
            if (isMetric) {
              item.wordWrapEnabled = cellDescriptions[item.dataIndex].wordWrapEnabled;
            } else {
              item.wordWrapEnabled = field.wordWrapEnabled;
            }
            item.isLast = !item.children || !item.children.length;
            if (item.isLast) {
              each(options.sortBySummaryPaths, function(index2, sortBySummaryPath) {
                if (!isDefined(item.dataIndex)) {
                  sortBySummaryPath = sortBySummaryPath.slice(0);
                  sortBySummaryPath.pop();
                }
                if (function(items2, sortBySummaryPath2) {
                  var path;
                  var item2 = items2[0];
                  var stringValuesUsed = isString$1(sortBySummaryPath2[0]);
                  var headerItem = item2.dataIndex >= 0 ? items2[1] : item2;
                  if (stringValuesUsed && sortBySummaryPath2[0].indexOf("&[") !== -1 && headerItem.key || !headerItem.key) {
                    path = createPath(items2);
                  } else {
                    path = map(items2, function(item3) {
                      return item3.dataIndex >= 0 ? item3.value : item3.text;
                    }).reverse();
                  }
                  if (item2.type === GRAND_TOTAL_TYPE) {
                    path = path.slice(1);
                  }
                  return path.join("/") === sortBySummaryPath2.join("/");
                }(items, sortBySummaryPath)) {
                  item.sorted = true;
                  return false;
                }
              });
            }
            item.text = function(item2, description, options2) {
              var text = item2.text;
              if (isDefined(item2.displayText)) {
                text = item2.displayText;
              } else if (isDefined(item2.caption)) {
                text = item2.caption;
              } else if (item2.type === GRAND_TOTAL_TYPE) {
                text = options2.texts.grandTotal;
              }
              if (item2.isAdditionalTotal) {
                text = format(options2.texts.total || "", text);
              }
              return text;
            }(item, 0, options);
          })).done(function() {
            if (!viewHeaderItems2.length) {
              viewHeaderItems2.push({});
            }
            options.notifyProgress(1);
            d.resolve(viewHeaderItems2);
          });
        });
      });
      return d;
    };
    function createHeaderItem(childrenStack, depth, index2) {
      var parent = childrenStack[depth] = childrenStack[depth] || [];
      var node = parent[index2] = {};
      if (childrenStack[depth + 1]) {
        node.children = childrenStack[depth + 1];
        for (var i = depth + 1; i < childrenStack.length; i++) {
          childrenStack[i] = void 0;
        }
        childrenStack.length = depth + 1;
      }
      return node;
    }
    return function(headerItems, headerDescriptions, cellDescriptions, isHorizontal, options) {
      var info = [];
      var depthSize = function(headerItems2) {
        var depth = 0;
        foreachTree(headerItems2, function(items) {
          depth = math$1.max(depth, items.length);
        });
        return depth;
      }(headerItems) || 1;
      var d = new Deferred();
      getViewHeaderItems(headerItems, headerDescriptions, cellDescriptions, depthSize, options).done(function(viewHeaderItems) {
        !function(info2, viewHeaderItems2, depthSize2, isHorizontal2, isTree) {
          var lastIndex = 0;
          var index2;
          var depth;
          var indexesByDepth = [0];
          foreachTree(viewHeaderItems2, function(items) {
            var headerItem = items[0];
            depth = headerItem.isMetric ? depthSize2 : items.length - 1;
            while (indexesByDepth.length - 1 < depth) {
              indexesByDepth.push(indexesByDepth[indexesByDepth.length - 1]);
            }
            index2 = indexesByDepth[depth] || 0;
            lastIndex = addInfoItem(info2, {
              headerItem,
              index: index2,
              lastIndex,
              depth,
              isHorizontal: isHorizontal2,
              isTree
            });
            indexesByDepth.length = depth;
            indexesByDepth.push(lastIndex);
          });
        }(info, viewHeaderItems, depthSize, isHorizontal, options.layout === "tree");
        options.notifyProgress(1);
        d.resolve(info);
      });
      return d;
    };
  }();
  function createSortPaths(headerFields, dataFields) {
    var sortBySummaryPaths = [];
    each(headerFields, function(index2, headerField) {
      var fieldIndex = findField(dataFields, headerField.sortBySummaryField);
      if (fieldIndex >= 0) {
        sortBySummaryPaths.push((headerField.sortBySummaryPath || []).concat([fieldIndex]));
      }
    });
    return sortBySummaryPaths;
  }
  function foreachRowInfo(rowsInfo, callback) {
    var columnOffset = 0;
    var columnOffsetResetIndexes = [];
    for (var i = 0; i < rowsInfo.length; i++) {
      for (var j = 0; j < rowsInfo[i].length; j++) {
        var rowSpanOffset = (rowsInfo[i][j].rowspan || 1) - 1;
        var visibleIndex = i + rowSpanOffset;
        if (columnOffsetResetIndexes[i]) {
          columnOffset -= columnOffsetResetIndexes[i];
          columnOffsetResetIndexes[i] = 0;
        }
        if (callback(rowsInfo[i][j], visibleIndex, i, j, columnOffset) === false) {
          break;
        }
        columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] = (columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] || 0) + 1;
        columnOffset++;
      }
    }
  }
  function getHeaderIndexedItems(headerItems, options) {
    var visibleIndex = 0;
    var indexedItems = [];
    foreachTree(headerItems, function(items) {
      var headerItem = items[0];
      var path = createPath(items);
      if (headerItem.children && options.showTotals === false) {
        return;
      }
      var indexedItem = extend(true, {}, headerItem, {
        visibleIndex: visibleIndex++,
        path
      });
      if (isDefined(indexedItem.index)) {
        indexedItems[indexedItem.index] = indexedItem;
      } else {
        indexedItems.push(indexedItem);
      }
    });
    return indexedItems;
  }
  function createScrollController(dataController, component, dataAdapter) {
    return new VirtualScrollController(component, extend({
      hasKnownLastPage: function() {
        return true;
      },
      pageCount: function() {
        return math$1.ceil(this.totalItemsCount() / this.pageSize());
      },
      updateLoading: function() {
      },
      itemsCount: function() {
        if (this.pageIndex() < this.pageCount() - 1) {
          return this.pageSize();
        } else {
          return this.totalItemsCount() % this.pageSize();
        }
      },
      items: function() {
        return [];
      },
      viewportItems: function() {
        return [];
      },
      onChanged: function() {
      },
      isLoading: function() {
        return dataController.isLoading();
      },
      changingDuration: function() {
        var dataSource = dataController._dataSource;
        if (dataSource.paginate()) {
          return CHANGING_DURATION_IF_PAGINATE;
        }
        return dataController._changingDuration || 0;
      }
    }, dataAdapter));
  }
  var members = {
    ctor: function(options) {
      var that = this;
      var virtualScrollControllerChanged = that._fireChanged.bind(that);
      options = that._options = options || {};
      that.dataSourceChanged = Callbacks();
      that._dataSource = that._createDataSource(options);
      if (options.component && options.component.option("scrolling.mode") === "virtual") {
        that._rowsScrollController = createScrollController(that, options.component, {
          totalItemsCount: function() {
            return that.totalRowCount();
          },
          pageIndex: function(index2) {
            return that.rowPageIndex(index2);
          },
          pageSize: function() {
            return that.rowPageSize();
          },
          load: function() {
            if (that._rowsScrollController.pageIndex() >= this.pageCount()) {
              that._rowsScrollController.pageIndex(this.pageCount() - 1);
            }
            return that._rowsScrollController.handleDataChanged(function() {
              if (that._dataSource.paginate()) {
                that._dataSource.load();
              } else {
                virtualScrollControllerChanged.apply(this, arguments);
              }
            });
          }
        });
        that._columnsScrollController = createScrollController(that, options.component, {
          totalItemsCount: function() {
            return that.totalColumnCount();
          },
          pageIndex: function(index2) {
            return that.columnPageIndex(index2);
          },
          pageSize: function() {
            return that.columnPageSize();
          },
          load: function() {
            if (that._columnsScrollController.pageIndex() >= this.pageCount()) {
              that._columnsScrollController.pageIndex(this.pageCount() - 1);
            }
            return that._columnsScrollController.handleDataChanged(function() {
              if (that._dataSource.paginate()) {
                that._dataSource.load();
              } else {
                virtualScrollControllerChanged.apply(this, arguments);
              }
            });
          }
        });
      }
      that._stateStoringController = new StateStoringController(options.component).init();
      that._columnsInfo = [];
      that._rowsInfo = [];
      that._cellsInfo = [];
      that.expandValueChanging = Callbacks();
      that.loadingChanged = Callbacks();
      that.progressChanged = Callbacks();
      that.scrollChanged = Callbacks();
      that.load();
      that._update();
      that.changed = Callbacks();
    },
    _fireChanged: function() {
      var startChanging = new Date();
      this.changed && !this._lockChanged && this.changed.fire();
      this._changingDuration = new Date() - startChanging;
    },
    _correctSkipsTakes: function(rowIndex, rowSkip, rowSpan, levels, skips, takes) {
      var endIndex = rowSpan ? rowIndex + rowSpan - 1 : rowIndex;
      skips[levels.length] = skips[levels.length] || 0;
      takes[levels.length] = takes[levels.length] || 0;
      if (endIndex < rowSkip) {
        skips[levels.length]++;
      } else {
        takes[levels.length]++;
      }
    },
    _calculatePagingForRowExpandedPaths: function(options, skips, takes, rowExpandedSkips, rowExpandedTakes) {
      var rows = this._rowsInfo;
      var rowCount = Math.min(options.rowSkip + options.rowTake, rows.length);
      var rowExpandedPaths = options.rowExpandedPaths;
      var levels = [];
      var expandedPathIndexes = {};
      var i;
      var j;
      var path;
      rowExpandedPaths.forEach((path2, index2) => {
        expandedPathIndexes[path2] = index2;
      });
      for (i = 0; i < rowCount; i++) {
        takes.length = skips.length = levels.length + 1;
        for (j = 0; j < rows[i].length; j++) {
          var cell = rows[i][j];
          if (cell.type === "D") {
            this._correctSkipsTakes(i, options.rowSkip, cell.rowspan, levels, skips, takes);
            path = cell.path || path;
            var expandIndex = path && path.length > 1 ? expandedPathIndexes[path.slice(0, -1)] : -1;
            if (expandIndex >= 0) {
              rowExpandedSkips[expandIndex] = skips[levels.length] || 0;
              rowExpandedTakes[expandIndex] = takes[levels.length] || 0;
            }
            if (cell.rowspan) {
              levels.push(cell.rowspan);
            }
          }
        }
        levels = levels.map((level) => level - 1).filter((level) => level > 0);
      }
    },
    _calculatePagingForColumnExpandedPaths: function(options, skips, takes, expandedSkips, expandedTakes) {
      var skipByPath = {};
      var takeByPath = {};
      foreachColumnInfo(this._columnsInfo, function(columnInfo, columnIndex) {
        if (columnInfo.type === "D" && columnInfo.path && columnInfo.dataIndex === void 0) {
          var colspan = columnInfo.colspan || 1;
          var path = columnInfo.path.slice(0, -1).toString();
          skipByPath[path] = skipByPath[path] || 0;
          takeByPath[path] = takeByPath[path] || 0;
          if (columnIndex + colspan <= options.columnSkip) {
            skipByPath[path]++;
          } else if (columnIndex < options.columnSkip + options.columnTake) {
            takeByPath[path]++;
          }
        }
      });
      skips[0] = skipByPath[[]];
      takes[0] = takeByPath[[]];
      options.columnExpandedPaths.forEach(function(path, index2) {
        var skip = skipByPath[path];
        var take = takeByPath[path];
        if (skip !== void 0) {
          expandedSkips[index2] = skip;
        }
        if (take !== void 0) {
          expandedTakes[index2] = take;
        }
      });
    },
    _processPagingForExpandedPaths: function(options, area, storeLoadOptions, reload) {
      var expandedPaths = options[area + "ExpandedPaths"];
      var expandedSkips = expandedPaths.map(() => 0);
      var expandedTakes = expandedPaths.map(() => reload ? options.pageSize : 0);
      var skips = [];
      var takes = [];
      if (!reload) {
        if (area === "row") {
          this._calculatePagingForRowExpandedPaths(options, skips, takes, expandedSkips, expandedTakes);
        } else {
          this._calculatePagingForColumnExpandedPaths(options, skips, takes, expandedSkips, expandedTakes);
        }
      }
      this._savePagingForExpandedPaths(options, area, storeLoadOptions, skips[0], takes[0], expandedSkips, expandedTakes);
    },
    _savePagingForExpandedPaths: function(options, area, storeLoadOptions, skip, take, expandedSkips, expandedTakes) {
      var expandedPaths = options[area + "ExpandedPaths"];
      options[area + "ExpandedPaths"] = [];
      options[area + "Skip"] = skip !== void 0 ? skip : options[area + "Skip"];
      options[area + "Take"] = take !== void 0 ? take : options[area + "Take"];
      for (var i = 0; i < expandedPaths.length; i++) {
        if (expandedTakes[i]) {
          var isOppositeArea = options.area && options.area !== area;
          storeLoadOptions.push(extend({
            area,
            headerName: area + "s"
          }, options, {
            [area + "Skip"]: expandedSkips[i],
            [area + "Take"]: expandedTakes[i],
            [isOppositeArea ? "oppositePath" : "path"]: expandedPaths[i]
          }));
        }
      }
    },
    _handleCustomizeStoreLoadOptions: function(storeLoadOptions, reload) {
      var options = storeLoadOptions[0];
      var rowsScrollController = this._rowsScrollController;
      if (this._dataSource.paginate() && rowsScrollController) {
        var rowPageSize = rowsScrollController.pageSize();
        if (options.headerName === "rows") {
          options.rowSkip = 0;
          options.rowTake = rowPageSize;
          options.rowExpandedPaths = [];
        } else {
          options.rowSkip = rowsScrollController.beginPageIndex() * rowPageSize;
          options.rowTake = (rowsScrollController.endPageIndex() - rowsScrollController.beginPageIndex() + 1) * rowPageSize;
          this._processPagingForExpandedPaths(options, "row", storeLoadOptions, reload);
        }
      }
      var columnsScrollController = this._columnsScrollController;
      if (this._dataSource.paginate() && columnsScrollController) {
        var columnPageSize = columnsScrollController.pageSize();
        storeLoadOptions.forEach((options2, index2) => {
          if (options2.headerName === "columns") {
            options2.columnSkip = 0;
            options2.columnTake = columnPageSize;
            options2.columnExpandedPaths = [];
          } else {
            options2.columnSkip = columnsScrollController.beginPageIndex() * columnPageSize;
            options2.columnTake = (columnsScrollController.endPageIndex() - columnsScrollController.beginPageIndex() + 1) * columnPageSize;
            this._processPagingForExpandedPaths(options2, "column", storeLoadOptions, reload);
          }
        });
      }
    },
    load: function() {
      var that = this;
      var stateStoringController = this._stateStoringController;
      if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {
        stateStoringController.load().always(function(state) {
          if (state) {
            that._dataSource.state(state);
          } else {
            that._dataSource.load();
          }
        });
      } else {
        that._dataSource.load();
      }
    },
    calculateVirtualContentParams: function(contentParams) {
      var rowsScrollController = this._rowsScrollController;
      var columnsScrollController = this._columnsScrollController;
      if (rowsScrollController && columnsScrollController) {
        rowsScrollController.viewportItemSize(contentParams.virtualRowHeight);
        rowsScrollController.viewportSize(contentParams.viewportHeight / rowsScrollController.viewportItemSize());
        rowsScrollController.setContentItemSizes(contentParams.itemHeights);
        columnsScrollController.viewportItemSize(contentParams.virtualColumnWidth);
        columnsScrollController.viewportSize(contentParams.viewportWidth / columnsScrollController.viewportItemSize());
        columnsScrollController.setContentItemSizes(contentParams.itemWidths);
        deferUpdate(function() {
          columnsScrollController.loadIfNeed();
          rowsScrollController.loadIfNeed();
        });
        this.scrollChanged.fire({
          left: columnsScrollController.getViewportPosition(),
          top: rowsScrollController.getViewportPosition()
        });
        return {
          contentTop: rowsScrollController.getContentOffset(),
          contentLeft: columnsScrollController.getContentOffset(),
          width: columnsScrollController.getVirtualContentSize(),
          height: rowsScrollController.getVirtualContentSize()
        };
      }
    },
    setViewportPosition: function(left, top) {
      this._rowsScrollController.setViewportPosition(top || 0);
      this._columnsScrollController.setViewportPosition(left || 0);
    },
    subscribeToWindowScrollEvents: function($element) {
      this._rowsScrollController && this._rowsScrollController.subscribeToWindowScrollEvents($element);
    },
    updateWindowScrollPosition: function(position2) {
      this._rowsScrollController && this._rowsScrollController.scrollTo(position2);
    },
    updateViewOptions: function(options) {
      extend(this._options, options);
      this._update();
    },
    _handleExpandValueChanging: function(e) {
      this.expandValueChanging.fire(e);
    },
    _handleLoadingChanged: function(isLoading) {
      this.loadingChanged.fire(isLoading);
    },
    _handleProgressChanged: function(progress) {
      this.progressChanged.fire(progress);
    },
    _handleFieldsPrepared: function(e) {
      this._options.onFieldsPrepared && this._options.onFieldsPrepared(e);
    },
    _createDataSource: function(options) {
      var that = this;
      var dataSourceOptions = options.dataSource;
      var dataSource;
      that._isSharedDataSource = dataSourceOptions instanceof PivotGridDataSource;
      if (that._isSharedDataSource) {
        dataSource = dataSourceOptions;
      } else {
        dataSource = new PivotGridDataSource(dataSourceOptions);
      }
      that._expandValueChangingHandler = that._handleExpandValueChanging.bind(that);
      that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
      that._fieldsPreparedHandler = that._handleFieldsPrepared.bind(that);
      that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);
      that._changedHandler = function() {
        that._update();
        that.dataSourceChanged.fire();
      };
      that._progressChangedHandler = function(progress) {
        that._handleProgressChanged(0.8 * progress);
      };
      dataSource.on("changed", that._changedHandler);
      dataSource.on("expandValueChanging", that._expandValueChangingHandler);
      dataSource.on("loadingChanged", that._loadingChangedHandler);
      dataSource.on("progressChanged", that._progressChangedHandler);
      dataSource.on("fieldsPrepared", that._fieldsPreparedHandler);
      dataSource.on("customizeStoreLoadOptions", that._customizeStoreLoadOptionsHandler);
      return dataSource;
    },
    getDataSource: function() {
      return this._dataSource;
    },
    isLoading: function() {
      return this._dataSource.isLoading();
    },
    beginLoading: function() {
      this._dataSource.beginLoading();
    },
    endLoading: function() {
      this._dataSource.endLoading();
    },
    _update: function() {
      var that = this;
      var dataSource = that._dataSource;
      var options = that._options;
      var columnFields = dataSource.getAreaFields("column");
      var rowFields = dataSource.getAreaFields("row");
      var dataFields = dataSource.getAreaFields("data");
      var dataFieldsForRows = options.dataFieldArea === "row" ? dataFields : [];
      var dataFieldsForColumns = options.dataFieldArea !== "row" ? dataFields : [];
      var data2 = dataSource.getData();
      var hiddenTotals = function(dataFields2) {
        var result = [];
        each(dataFields2, function(index2, field) {
          if (field.showTotals === false) {
            result.push(index2);
          }
        });
        return result;
      }(dataFields);
      var hiddenValues = function(dataFields2) {
        var result = [];
        dataFields2.forEach(function(field, index2) {
          if (field.showValues === void 0 && field.showTotals === false || field.showValues === false) {
            result.push(index2);
          }
        });
        return result;
      }(dataFields);
      var hiddenGrandTotals = function(dataFields2, columnFields2) {
        var result = [];
        each(dataFields2, function(index2, field) {
          if (field.showGrandTotals === false) {
            result.push(index2);
          }
        });
        if (columnFields2.length === 0 && result.length === dataFields2.length) {
          result = [];
        }
        return result;
      }(dataFields, columnFields);
      var grandTotalsAreHiddenForNotAllDataFields = dataFields.length > 0 ? hiddenGrandTotals.length !== dataFields.length : true;
      var rowOptions = {
        isEmptyGrandTotal: data2.isEmptyGrandTotalRow,
        texts: options.texts || {},
        hiddenTotals,
        hiddenValues,
        hiddenGrandTotals: [],
        showTotals: options.showRowTotals,
        showGrandTotals: options.showRowGrandTotals !== false && grandTotalsAreHiddenForNotAllDataFields,
        sortBySummaryPaths: createSortPaths(columnFields, dataFields),
        showTotalsPrior: options.showTotalsPrior === "rows" || options.showTotalsPrior === "both",
        showEmpty: !options.hideEmptySummaryCells,
        layout: options.rowHeaderLayout,
        fields: rowFields,
        dataFields,
        progress: 0
      };
      var columnOptions = {
        isEmptyGrandTotal: data2.isEmptyGrandTotalColumn,
        texts: options.texts || {},
        hiddenTotals,
        hiddenValues,
        hiddenGrandTotals,
        showTotals: options.showColumnTotals,
        showTotalsPrior: options.showTotalsPrior === "columns" || options.showTotalsPrior === "both",
        showGrandTotals: options.showColumnGrandTotals !== false && grandTotalsAreHiddenForNotAllDataFields,
        sortBySummaryPaths: createSortPaths(rowFields, dataFields),
        showEmpty: !options.hideEmptySummaryCells,
        fields: columnFields,
        dataFields,
        progress: 0
      };
      var notifyProgress = function(progress) {
        this.progress = progress;
        that._handleProgressChanged(0.8 + 0.1 * rowOptions.progress + 0.1 * columnOptions.progress);
      };
      rowOptions.notifyProgress = notifyProgress;
      columnOptions.notifyProgress = notifyProgress;
      if (!isDefined(data2.grandTotalRowIndex)) {
        data2.grandTotalRowIndex = getHeaderIndexedItems(data2.rows, rowOptions).length;
      }
      if (!isDefined(data2.grandTotalColumnIndex)) {
        data2.grandTotalColumnIndex = getHeaderIndexedItems(data2.columns, columnOptions).length;
      }
      dataSource._changeLoadingCount(1);
      when(createHeaderInfo(data2.columns, columnFields, dataFieldsForColumns, true, columnOptions), createHeaderInfo(data2.rows, rowFields, dataFieldsForRows, false, rowOptions)).always(function() {
        dataSource._changeLoadingCount(-1);
      }).done(function(columnsInfo, rowsInfo) {
        that._columnsInfo = columnsInfo;
        that._rowsInfo = rowsInfo;
        if (that._rowsScrollController && that._columnsScrollController && that.changed && !that._dataSource.paginate()) {
          that._rowsScrollController.reset(true);
          that._columnsScrollController.reset(true);
          that._lockChanged = true;
          that._rowsScrollController.load();
          that._columnsScrollController.load();
          that._lockChanged = false;
        }
      }).done(function() {
        that._fireChanged();
        if (that._stateStoringController.isEnabled() && !that._dataSource.isLoading()) {
          that._stateStoringController.state(that._dataSource.state());
          that._stateStoringController.save();
        }
      });
    },
    getRowsInfo: function(getAllData) {
      var rowsInfo = this._rowsInfo;
      var scrollController = this._rowsScrollController;
      var rowspan;
      if (scrollController && !getAllData) {
        var startIndex = scrollController.beginPageIndex() * this.rowPageSize();
        var endIndex = scrollController.endPageIndex() * this.rowPageSize() + this.rowPageSize();
        var newRowsInfo = [];
        var maxDepth = 1;
        foreachRowInfo(rowsInfo, function(rowInfo, visibleIndex, rowIndex, _2, columnIndex) {
          var isVisible2 = visibleIndex >= startIndex && rowIndex < endIndex;
          var index2 = rowIndex < startIndex ? 0 : rowIndex - startIndex;
          var cell = rowInfo;
          if (isVisible2) {
            newRowsInfo[index2] = newRowsInfo[index2] || [];
            rowspan = rowIndex < startIndex ? rowInfo.rowspan - (startIndex - rowIndex) || 1 : rowInfo.rowspan;
            if (startIndex + index2 + rowspan > endIndex) {
              rowspan = endIndex - (index2 + startIndex) || 1;
            }
            if (rowspan !== rowInfo.rowspan) {
              cell = extend({}, cell, {
                rowspan
              });
            }
            newRowsInfo[index2].push(cell);
            maxDepth = math$1.max(maxDepth, columnIndex + 1);
          } else if (void 0 > endIndex) {
            return false;
          }
        });
        foreachRowInfo(newRowsInfo, function(rowInfo, visibleIndex, rowIndex, columnIndex, realColumnIndex) {
          var colspan = rowInfo.colspan || 1;
          if (realColumnIndex + colspan > maxDepth) {
            newRowsInfo[rowIndex][columnIndex] = extend({}, rowInfo, {
              colspan: maxDepth - realColumnIndex || 1
            });
          }
        });
        return newRowsInfo;
      }
      return rowsInfo;
    },
    getColumnsInfo: function(getAllData) {
      var info = this._columnsInfo;
      var scrollController = this._columnsScrollController;
      if (scrollController && !getAllData) {
        var startIndex = scrollController.beginPageIndex() * this.columnPageSize();
        var endIndex = scrollController.endPageIndex() * this.columnPageSize() + this.columnPageSize();
        info = createColumnsInfo(info, startIndex, endIndex);
      }
      return info;
    },
    totalRowCount: function() {
      return this._rowsInfo.length;
    },
    rowPageIndex: function(index2) {
      if (index2 !== void 0) {
        this._rowPageIndex = index2;
      }
      return this._rowPageIndex || 0;
    },
    totalColumnCount: function() {
      var count = 0;
      if (this._columnsInfo && this._columnsInfo.length) {
        for (var i = 0; i < this._columnsInfo[0].length; i++) {
          count += this._columnsInfo[0][i].colspan || 1;
        }
      }
      return count;
    },
    rowPageSize: function(size) {
      if (size !== void 0) {
        this._rowPageSize = size;
      }
      return this._rowPageSize || 20;
    },
    columnPageSize: function(size) {
      if (size !== void 0) {
        this._columnPageSize = size;
      }
      return this._columnPageSize || 20;
    },
    columnPageIndex: function(index2) {
      if (index2 !== void 0) {
        this._columnPageIndex = index2;
      }
      return this._columnPageIndex || 0;
    },
    getCellsInfo: function(getAllData) {
      var rowsInfo = this.getRowsInfo(getAllData);
      var columnsInfo = this.getColumnsInfo(getAllData);
      var data2 = this._dataSource.getData();
      var texts = this._options.texts || {};
      return function(rowsInfo2, columnsInfo2, data3, dataFields, dataFieldArea, errorText) {
        var info = [];
        var dataFieldAreaInRows = dataFieldArea === "row";
        var dataSourceCells = data3.values;
        dataSourceCells.length && foreachRowInfo(rowsInfo2, function(rowInfo, rowIndex) {
          var row = info[rowIndex] = [];
          var dataRow = dataSourceCells[rowInfo.dataSourceIndex >= 0 ? rowInfo.dataSourceIndex : data3.grandTotalRowIndex] || [];
          rowInfo.isLast && foreachColumnInfo(columnsInfo2, function(columnInfo, columnIndex) {
            var dataIndex = (dataFieldAreaInRows ? rowInfo.dataIndex : columnInfo.dataIndex) || 0;
            var dataField = dataFields[dataIndex];
            if (columnInfo.isLast && dataField && dataField.visible !== false) {
              var cell = dataRow[columnInfo.dataSourceIndex >= 0 ? columnInfo.dataSourceIndex : data3.grandTotalColumnIndex];
              if (!Array.isArray(cell)) {
                cell = [cell];
              }
              var cellValue = cell[dataIndex];
              row[columnIndex] = {
                text: formatCellValue(cellValue, dataField, errorText),
                value: cellValue,
                format: dataField.format,
                dataType: dataField.dataType,
                columnType: columnInfo.type,
                rowType: rowInfo.type,
                rowPath: rowInfo.path || [],
                columnPath: columnInfo.path || [],
                dataIndex
              };
              if (dataField.width) {
                row[columnIndex].width = dataField.width;
              }
            }
          });
        });
        return info;
      }(rowsInfo, columnsInfo, data2, this._dataSource.getAreaFields("data"), this._options.dataFieldArea, texts.dataNotAvailable);
    },
    dispose: function() {
      if (this._isSharedDataSource) {
        this._dataSource.off("changed", this._changedHandler);
        this._dataSource.off("expandValueChanging", this._expandValueChangingHandler);
        this._dataSource.off("loadingChanged", this._loadingChangedHandler);
        this._dataSource.off("progressChanged", this._progressChangedHandler);
        this._dataSource.off("fieldsPrepared", this._fieldsPreparedHandler);
        this._dataSource.off("customizeStoreLoadOptions", this._customizeStoreLoadOptionsHandler);
      } else {
        this._dataSource.dispose();
      }
      this._columnsScrollController && this._columnsScrollController.dispose();
      this._rowsScrollController && this._rowsScrollController.dispose();
      this._stateStoringController.dispose();
      this.expandValueChanging.empty();
      this.changed.empty();
      this.loadingChanged.empty();
      this.progressChanged.empty();
      this.scrollChanged.empty();
      this.dataSourceChanged.empty();
    }
  };
  proxyMethod(members, "applyPartialDataSource");
  proxyMethod(members, "collapseHeaderItem");
  proxyMethod(members, "expandHeaderItem");
  proxyMethod(members, "getData");
  proxyMethod(members, "isEmpty");
  return members;
}());
var PIVOTGRID_EXPAND_CLASS = "dx-expand";
var getRealElementWidth = function(element) {
  var width = 0;
  var offsetWidth = element.offsetWidth;
  if (element.getBoundingClientRect) {
    var clientRect = getBoundingRect(element);
    width = clientRect.width;
    if (!width) {
      width = clientRect.right - clientRect.left;
    }
    if (width <= offsetWidth - 1) {
      width = offsetWidth;
    }
  }
  return width > 0 ? width : offsetWidth;
};
function getFakeTableOffset(scrollPos, elementOffset, tableSize, viewPortSize) {
  var offset2 = 0;
  var halfTableCount = 0;
  var halfTableSize = tableSize / 2;
  if (scrollPos + viewPortSize - (elementOffset + tableSize) > 1) {
    if (scrollPos >= elementOffset + tableSize + halfTableSize) {
      halfTableCount = parseInt((scrollPos - (elementOffset + tableSize)) / halfTableSize, 10);
    }
    offset2 = elementOffset + tableSize + halfTableSize * halfTableCount;
  } else if (scrollPos < elementOffset) {
    if (scrollPos <= elementOffset - halfTableSize) {
      halfTableCount = parseInt((scrollPos - (elementOffset - halfTableSize)) / halfTableSize, 10);
    }
    offset2 = elementOffset - (tableSize - halfTableSize * halfTableCount);
  } else {
    offset2 = elementOffset;
  }
  return offset2;
}
var AreaItem = classImpl.inherit({
  _getRowElement: function(index2) {
    if (this._tableElement && this._tableElement.length > 0) {
      return this._tableElement[0].rows[index2];
    }
    return null;
  },
  _createGroupElement: function() {
    return $("<div>");
  },
  _createTableElement: function() {
    return $("<table>");
  },
  _getCellText: function(cell, encodeHtml2) {
    var cellText = cell.isWhiteSpace ? "&nbsp" : cell.text || "&nbsp";
    if (encodeHtml2 && (cellText.indexOf("<") !== -1 || cellText.indexOf(">") !== -1)) {
      cellText = $("<div>").text(cellText).html();
    }
    return cellText;
  },
  _getRowClassNames: function() {
  },
  _applyCustomStyles: function(options) {
    if (options.cell.width) {
      options.cssArray.push("min-width:" + options.cell.width + "px");
    }
    if (options.cell.sorted) {
      options.classArray.push("dx-pivotgrid-sorted");
    }
  },
  _getMainElementMarkup: function() {
    return "<tbody>";
  },
  _getCloseMainElementMarkup: function() {
    return "</tbody>";
  },
  _renderTableContent: function(tableElement, data2) {
    var rowsCount = data2.length;
    var row;
    var cell;
    var i;
    var j;
    var cellText;
    var rtlEnabled = this.option("rtlEnabled");
    var markupArray = [];
    var encodeHtml2 = this.option("encodeHtml");
    var rowClassNames;
    tableElement.data("area", this._getAreaName());
    tableElement.data("data", data2);
    tableElement.css("width", "");
    markupArray.push(this._getMainElementMarkup());
    for (i = 0; i < rowsCount; i++) {
      row = data2[i];
      var columnMarkupArray = [];
      rowClassNames = [];
      markupArray.push("<tr ");
      for (j = 0; j < row.length; j++) {
        cell = row[j];
        this._getRowClassNames(i, cell, rowClassNames);
        columnMarkupArray.push("<td ");
        if (cell) {
          cell.rowspan && columnMarkupArray.push("rowspan='" + (cell.rowspan || 1) + "'");
          cell.colspan && columnMarkupArray.push("colspan='" + (cell.colspan || 1) + "'");
          var styleOptions = {
            cellElement: void 0,
            cell,
            cellsCount: row.length,
            cellIndex: j,
            rowElement: void 0,
            rowIndex: i,
            rowsCount,
            rtlEnabled,
            classArray: [],
            cssArray: []
          };
          this._applyCustomStyles(styleOptions);
          if (styleOptions.cssArray.length) {
            columnMarkupArray.push("style='");
            columnMarkupArray.push(styleOptions.cssArray.join(";"));
            columnMarkupArray.push("'");
          }
          if (styleOptions.classArray.length) {
            columnMarkupArray.push("class='");
            columnMarkupArray.push(styleOptions.classArray.join(" "));
            columnMarkupArray.push("'");
          }
          columnMarkupArray.push(">");
          if (isDefined(cell.expanded)) {
            columnMarkupArray.push("<div class='dx-expand-icon-container'><span class='" + PIVOTGRID_EXPAND_CLASS + "'></span></div>");
          }
          cellText = this._getCellText(cell, encodeHtml2);
        } else {
          cellText = "";
        }
        columnMarkupArray.push("<span ");
        if (isDefined(cell.wordWrapEnabled)) {
          columnMarkupArray.push("style='white-space:", cell.wordWrapEnabled ? "normal" : "nowrap", ";'");
        }
        columnMarkupArray.push(">" + cellText + "</span>");
        if (cell.sorted) {
          columnMarkupArray.push("<span class='dx-icon-sorted'></span>");
        }
        columnMarkupArray.push("</td>");
      }
      if (rowClassNames.length) {
        markupArray.push("class='");
        markupArray.push(rowClassNames.join(" "));
        markupArray.push("'");
      }
      markupArray.push(">");
      markupArray.push(columnMarkupArray.join(""));
      markupArray.push("</tr>");
    }
    markupArray.push(this._getCloseMainElementMarkup());
    tableElement.append(markupArray.join(""));
    this._triggerOnCellPrepared(tableElement, data2);
  },
  _triggerOnCellPrepared: function(tableElement, data2) {
    var rowElements = tableElement.find("tr");
    var areaName = this._getAreaName();
    var onCellPrepared = this.option("onCellPrepared");
    var customStyle = this.option("_customStyleHandler");
    var hasEvent = this.component._eventsStrategy.hasEvent("cellPrepared");
    var rowElement;
    var $cellElement;
    var onCellPreparedArgs;
    var defaultActionArgs = this.component._defaultActionArgs();
    var row;
    var cell;
    var rowIndex;
    var columnIndex;
    if (onCellPrepared || hasEvent) {
      for (rowIndex = 0; rowIndex < data2.length; rowIndex++) {
        row = data2[rowIndex];
        rowElement = rowElements.eq(rowIndex);
        for (columnIndex = 0; columnIndex < row.length; columnIndex++) {
          cell = row[columnIndex];
          $cellElement = rowElement.children().eq(columnIndex);
          onCellPreparedArgs = {
            area: areaName,
            rowIndex,
            columnIndex,
            cellElement: getPublicElement($cellElement),
            cell
          };
          customStyle && customStyle(extend(onCellPreparedArgs, defaultActionArgs));
          if (hasEvent) {
            this.component._trigger("onCellPrepared", onCellPreparedArgs);
          } else {
            onCellPrepared(extend(onCellPreparedArgs, defaultActionArgs));
          }
        }
      }
    }
  },
  _getRowHeight: function(index2) {
    var row = this._getRowElement(index2);
    var height = 0;
    var offsetHeight = row.offsetHeight;
    if (row && row.lastChild) {
      if (row.getBoundingClientRect) {
        var clientRect = getBoundingRect(row);
        height = clientRect.height;
        if (height <= offsetHeight - 1) {
          height = offsetHeight;
        }
      }
      return height > 0 ? height : offsetHeight;
    }
    return 0;
  },
  _setRowHeight: function(index2, value2) {
    var row = this._getRowElement(index2);
    if (row) {
      row.style.height = value2 + "px";
    }
  },
  ctor: function(component) {
    this.component = component;
  },
  option: function() {
    return this.component.option.apply(this.component, arguments);
  },
  getRowsLength: function() {
    if (this._tableElement && this._tableElement.length > 0) {
      return this._tableElement[0].rows.length;
    }
    return 0;
  },
  getRowsHeight: function() {
    var result = [];
    var rowsLength = this.getRowsLength();
    var i;
    for (i = 0; i < rowsLength; i++) {
      result.push(this._getRowHeight(i));
    }
    return result;
  },
  setRowsHeight: function(values) {
    var totalHeight = 0;
    var valuesLength = values.length;
    var i;
    for (i = 0; i < valuesLength; i++) {
      totalHeight += values[i];
      this._setRowHeight(i, values[i]);
    }
    this._tableHeight = totalHeight;
    this._tableElement[0].style.height = totalHeight + "px";
  },
  getColumnsWidth: function() {
    var rowsLength = this.getRowsLength();
    var rowIndex;
    var row;
    var i;
    var columnIndex;
    var processedCells = [];
    var result = [];
    var fillCells = function(cells, rowIndex2, columnIndex2, rowSpan, colSpan) {
      var rowOffset;
      var columnOffset;
      for (rowOffset = 0; rowOffset < rowSpan; rowOffset++) {
        for (columnOffset = 0; columnOffset < colSpan; columnOffset++) {
          cells[rowIndex2 + rowOffset] = cells[rowIndex2 + rowOffset] || [];
          cells[rowIndex2 + rowOffset][columnIndex2 + columnOffset] = true;
        }
      }
    };
    if (rowsLength) {
      for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
        processedCells[rowIndex] = processedCells[rowIndex] || [];
        row = this._getRowElement(rowIndex);
        for (i = 0; i < row.cells.length; i++) {
          for (columnIndex = 0; processedCells[rowIndex][columnIndex]; columnIndex++) {
          }
          fillCells(processedCells, rowIndex, columnIndex, row.cells[i].rowSpan, row.cells[i].colSpan);
          if (row.cells[i].colSpan === 1) {
            result[columnIndex] = result[columnIndex] || getRealElementWidth(row.cells[i]);
          }
        }
      }
    }
    return result;
  },
  setColumnsWidth: function(values) {
    var i;
    var tableElement = this._tableElement[0];
    var colgroupElementHTML = "";
    var columnsCount = this.getColumnsCount();
    var columnWidth = [];
    for (i = 0; i < columnsCount; i++) {
      columnWidth.push(values[i] || 0);
    }
    for (i = columnsCount; i < values.length && values; i++) {
      columnWidth[columnsCount - 1] += values[i];
    }
    for (i = 0; i < columnsCount; i++) {
      colgroupElementHTML += '<col style="width: ' + columnWidth[i] + 'px">';
    }
    this._colgroupElement.html(colgroupElementHTML);
    this._tableWidth = columnWidth.reduce((sum, width) => sum + width, 0);
    tableElement.style.width = this._tableWidth + "px";
    tableElement.style.tableLayout = "fixed";
  },
  resetColumnsWidth: function() {
    this._colgroupElement.find("col").width("auto");
    this._tableElement.css({
      width: "",
      tableLayout: ""
    });
  },
  groupWidth: function(value2) {
    if (value2 === void 0) {
      return this._groupElement.width();
    } else if (value2 >= 0) {
      this._groupWidth = value2;
      return this._groupElement[0].style.width = value2 + "px";
    } else {
      return this._groupElement[0].style.width = value2;
    }
  },
  groupHeight: function(value2) {
    if (value2 === void 0) {
      return this._groupElement.height();
    }
    this._groupHeight = null;
    if (value2 >= 0) {
      this._groupHeight = value2;
      this._groupElement[0].style.height = value2 + "px";
    } else {
      this._groupElement[0].style.height = value2;
    }
  },
  groupElement: function() {
    return this._groupElement;
  },
  tableElement: function() {
    return this._tableElement;
  },
  element: function() {
    return this._rootElement;
  },
  headElement: function() {
    return this._tableElement.find("thead");
  },
  _setTableCss: function(styles) {
    if (this.option("rtlEnabled")) {
      styles.right = styles.left;
      delete styles.left;
    }
    this.tableElement().css(styles);
  },
  setVirtualContentParams: function(params) {
    this._virtualContent.css({
      width: params.width,
      height: params.height
    });
    this.groupElement().addClass("dx-virtual-mode");
  },
  disableVirtualMode: function() {
    this.groupElement().removeClass("dx-virtual-mode");
  },
  _renderVirtualContent: function() {
    if (!this._virtualContent && this.option("scrolling.mode") === "virtual") {
      this._virtualContent = $("<div>").addClass("dx-virtual-content").insertBefore(this._tableElement);
    }
  },
  reset: function() {
    var tableElement = this._tableElement[0];
    this._fakeTable && this._fakeTable.detach();
    this._fakeTable = null;
    this.disableVirtualMode();
    this.groupWidth("100%");
    this.groupHeight("auto");
    this.resetColumnsWidth();
    if (tableElement) {
      for (var i = 0; i < tableElement.rows.length; i++) {
        tableElement.rows[i].style.height = "";
      }
      tableElement.style.height = "";
      tableElement.style.width = "100%";
    }
  },
  _updateFakeTableVisibility: function() {
    var tableElement = this.tableElement()[0];
    var horizontalOffsetName = this.option("rtlEnabled") ? "right" : "left";
    var fakeTableElement = this._fakeTable[0];
    if (tableElement.style.top === fakeTableElement.style.top && fakeTableElement.style[horizontalOffsetName] === tableElement.style[horizontalOffsetName]) {
      this._fakeTable.addClass("dx-hidden");
    } else {
      this._fakeTable.removeClass("dx-hidden");
    }
  },
  _moveFakeTableHorizontally: function(scrollPos) {
    var rtlEnabled = this.option("rtlEnabled");
    var offsetStyleName = rtlEnabled ? "right" : "left";
    var tableElementOffset = parseFloat(this.tableElement()[0].style[offsetStyleName]);
    var offset2 = getFakeTableOffset(scrollPos, tableElementOffset, this._tableWidth, this._groupWidth);
    if (parseFloat(this._fakeTable[0].style[offsetStyleName]) !== offset2) {
      this._fakeTable[0].style[offsetStyleName] = offset2 + "px";
    }
  },
  _moveFakeTableTop: function(scrollPos) {
    var tableElementOffsetTop = parseFloat(this.tableElement()[0].style.top);
    var offsetTop = getFakeTableOffset(scrollPos, tableElementOffsetTop, this._tableHeight, this._groupHeight);
    if (parseFloat(this._fakeTable[0].style.top) !== offsetTop) {
      this._fakeTable[0].style.top = offsetTop + "px";
    }
  },
  _moveFakeTable: function() {
    this._updateFakeTableVisibility();
  },
  _createFakeTable: function() {
    if (!this._fakeTable) {
      this._fakeTable = this.tableElement().clone().addClass("dx-pivot-grid-fake-table").appendTo(this._virtualContent);
    }
  },
  render: function(rootElement, data2) {
    if (this._tableElement) {
      try {
        this._tableElement[0].innerHTML = "";
      } catch (e) {
        this._tableElement.empty();
      }
      this._tableElement.attr("style", "");
    } else {
      this._groupElement = this._createGroupElement();
      this._tableElement = this._createTableElement();
      this._tableElement.appendTo(this._groupElement);
      this._groupElement.appendTo(rootElement);
      this._rootElement = rootElement;
    }
    this._colgroupElement = $("<colgroup>").appendTo(this._tableElement);
    this._renderTableContent(this._tableElement, data2);
    this._renderVirtualContent();
  },
  _getScrollable: function() {
    return this.groupElement().data("dxScrollable");
  },
  _getMaxLeftOffset: (scrollable) => scrollable._container().get(0).scrollWidth - scrollable._container().get(0).clientWidth,
  on: function(eventName, handler) {
    var that = this;
    var scrollable = that._getScrollable();
    if (scrollable) {
      scrollable.on(eventName, function(e) {
        if (that.option("rtlEnabled") && isDefined(e.scrollOffset.left)) {
          e.scrollOffset.left = that._getMaxLeftOffset(scrollable) - e.scrollOffset.left;
        }
        handler(e);
      });
    }
    return this;
  },
  off: function(eventName) {
    var scrollable = this._getScrollable();
    if (scrollable) {
      scrollable.off(eventName);
    }
    return this;
  },
  scrollTo: function(pos) {
    var scrollable = this._getScrollable();
    var scrollablePos = pos;
    if (scrollable) {
      if (this.option("rtlEnabled")) {
        if (this._getAreaName() === "column") {
          scrollablePos = this._getMaxLeftOffset(scrollable) - pos;
        } else if (this._getAreaName() === "data") {
          scrollablePos = {
            x: this._getMaxLeftOffset(scrollable) - pos.x,
            y: pos.y
          };
        }
      }
      scrollable.scrollTo(scrollablePos);
      if (this._virtualContent) {
        this._createFakeTable();
        this._moveFakeTable(pos);
      }
    }
  },
  updateScrollable: function() {
    var scrollable = this._getScrollable();
    if (scrollable) {
      return scrollable.update();
    }
  },
  getColumnsCount: function() {
    var columnCount = 0;
    var row = this._getRowElement(0);
    var cells;
    if (row) {
      cells = row.cells;
      for (var i = 0, len = cells.length; i < len; ++i) {
        columnCount += cells[i].colSpan;
      }
    }
    return columnCount;
  },
  getData: function() {
    var tableElement = this._tableElement;
    return tableElement ? tableElement.data("data") : [];
  }
});
var PIVOTGRID_AREA_CLASS$1 = "dx-pivotgrid-area";
var PIVOTGRID_AREA_DATA_CLASS = "dx-pivotgrid-area-data";
var PIVOTGRID_TOTAL_CLASS$1 = "dx-total";
var PIVOTGRID_GRAND_TOTAL_CLASS$1 = "dx-grandtotal";
var PIVOTGRID_ROW_TOTAL_CLASS$1 = "dx-row-total";
var DataArea = AreaItem.inherit({
  _getAreaName: function() {
    return "data";
  },
  _createGroupElement: function() {
    return $("<div>").addClass(PIVOTGRID_AREA_CLASS$1).addClass(PIVOTGRID_AREA_DATA_CLASS);
  },
  _applyCustomStyles: function(options) {
    var cell = options.cell;
    var classArray = options.classArray;
    if (cell.rowType === "T" || cell.columnType === "T") {
      classArray.push(PIVOTGRID_TOTAL_CLASS$1);
    }
    if (cell.rowType === "GT" || cell.columnType === "GT") {
      classArray.push(PIVOTGRID_GRAND_TOTAL_CLASS$1);
    }
    if (cell.rowType === "T" || cell.rowType === "GT") {
      classArray.push(PIVOTGRID_ROW_TOTAL_CLASS$1);
    }
    if (options.rowIndex === options.rowsCount - 1) {
      options.cssArray.push("border-bottom: 0px");
    }
    this.callBase(options);
  },
  _moveFakeTable: function(scrollPos) {
    this._moveFakeTableHorizontally(scrollPos.x);
    this._moveFakeTableTop(scrollPos.y);
    this.callBase();
  },
  processScroll: function(useNativeScrolling, rtlEnabled, horizontalScroll, verticalScroll) {
    var direction = "both";
    if (horizontalScroll && !verticalScroll) {
      direction = "horizontal";
    } else if (!horizontalScroll && verticalScroll) {
      direction = "vertical";
    }
    this._groupElement.css("borderTopWidth", 0).dxScrollable({
      rtlEnabled,
      useNative: !!useNativeScrolling,
      useSimulatedScrollbar: !useNativeScrolling,
      direction,
      bounceEnabled: false,
      updateManually: true
    });
  },
  reset: function() {
    this.callBase();
    if (this._virtualContent) {
      this._virtualContent.parent().css("height", "auto");
    }
  },
  setVirtualContentParams: function(params) {
    this.callBase(params);
    this._virtualContent.parent().css("height", params.height);
    this._setTableCss({
      top: params.top,
      left: params.left
    });
  }
});
var PIVOTGRID_AREA_CLASS = "dx-pivotgrid-area";
var PIVOTGRID_AREA_COLUMN_CLASS = "dx-pivotgrid-horizontal-headers";
var PIVOTGRID_AREA_ROW_CLASS = "dx-pivotgrid-vertical-headers";
var PIVOTGRID_TOTAL_CLASS = "dx-total";
var PIVOTGRID_GRAND_TOTAL_CLASS = "dx-grandtotal";
var PIVOTGRID_ROW_TOTAL_CLASS = "dx-row-total";
var PIVOTGRID_EXPANDED_CLASS = "dx-pivotgrid-expanded";
var PIVOTGRID_COLLAPSED_CLASS = "dx-pivotgrid-collapsed";
var PIVOTGRID_LAST_CELL_CLASS = "dx-last-cell";
var PIVOTGRID_VERTICAL_SCROLL_CLASS = "dx-vertical-scroll";
var PIVOTGRID_EXPAND_BORDER = "dx-expand-border";
function getCellPath(tableElement, cell) {
  if (cell) {
    var data2 = tableElement.data().data;
    var rowIndex = cell.parentNode.rowIndex;
    var cellIndex = cell.cellIndex;
    return data2[rowIndex] && data2[rowIndex][cellIndex] && data2[rowIndex][cellIndex].path;
  }
}
var HorizontalHeadersArea = AreaItem.inherit({
  _getAreaName: function() {
    return "column";
  },
  _getAreaClassName: function() {
    return PIVOTGRID_AREA_COLUMN_CLASS;
  },
  _createGroupElement: function() {
    return $("<div>").addClass(this._getAreaClassName()).addClass(PIVOTGRID_AREA_CLASS);
  },
  _applyCustomStyles: function(options) {
    var cssArray = options.cssArray;
    var cell = options.cell;
    var rowsCount = options.rowsCount;
    var classArray = options.classArray;
    if (options.cellIndex === options.cellsCount - 1) {
      cssArray.push((options.rtlEnabled ? "border-left:" : "border-right:") + "0px");
    }
    if (cell.rowspan === rowsCount - options.rowIndex || options.rowIndex + 1 === rowsCount) {
      cssArray.push("border-bottom-width:0px");
    }
    if (cell.type === "T" || cell.type === "GT") {
      classArray.push(PIVOTGRID_ROW_TOTAL_CLASS);
    }
    if (options.cell.type === "T") {
      classArray.push(PIVOTGRID_TOTAL_CLASS);
    }
    if (options.cell.type === "GT") {
      classArray.push(PIVOTGRID_GRAND_TOTAL_CLASS);
    }
    if (isDefined(cell.expanded)) {
      classArray.push(cell.expanded ? PIVOTGRID_EXPANDED_CLASS : PIVOTGRID_COLLAPSED_CLASS);
    }
    this.callBase(options);
  },
  _getMainElementMarkup: function() {
    return "<thead class='" + this._getAreaClassName() + "'>";
  },
  _getCloseMainElementMarkup: function() {
    return "</thead>";
  },
  setVirtualContentParams: function(params) {
    this.callBase(params);
    this._setTableCss({
      left: params.left,
      top: 0
    });
    this._virtualContentWidth = params.width;
  },
  hasScroll: function() {
    var tableWidth = this._virtualContent ? this._virtualContentWidth : this._tableWidth;
    if (this._groupWidth && tableWidth) {
      return tableWidth - this._groupWidth >= 1;
    }
    return false;
  },
  processScroll: function() {
    if (!this._getScrollable()) {
      this._groupElement.dxScrollable({
        useNative: false,
        useSimulatedScrollbar: false,
        showScrollbar: false,
        bounceEnabled: false,
        direction: "horizontal",
        updateManually: true
      });
    }
  },
  processScrollBarSpacing: function(scrollBarWidth) {
    scrollBarWidth = scrollBarWidth && this.option("useBetterScroller") ? 8 : scrollBarWidth;
    var groupAlignment = this.option("rtlEnabled") ? "right" : "left";
    if (this._groupWidth) {
      this.groupWidth(this._groupWidth - scrollBarWidth);
    }
    if (this._scrollBarWidth) {
      this._groupElement.next().remove();
    }
    this._groupElement.toggleClass(PIVOTGRID_VERTICAL_SCROLL_CLASS, scrollBarWidth > 0);
    this._groupElement.css("float", groupAlignment).width(this._groupHeight);
    this._scrollBarWidth = scrollBarWidth;
  },
  ctor: function(component) {
    this.callBase(component);
    this._scrollBarWidth = 0;
  },
  getScrollPath: function(offset2) {
    var tableElement = this.tableElement();
    var cell;
    offset2 -= parseInt(tableElement[0].style.left, 10) || 0;
    each(tableElement.find("td"), function(_2, td) {
      if (td.colSpan === 1 && td.offsetLeft <= offset2 && td.offsetWidth + td.offsetLeft > offset2) {
        cell = td;
        return false;
      }
    });
    return getCellPath(tableElement, cell);
  },
  _moveFakeTable: function(scrollPos) {
    this._moveFakeTableHorizontally(scrollPos);
    this.callBase();
  }
});
var VerticalHeadersArea = HorizontalHeadersArea.inherit({
  _getAreaClassName: function() {
    return PIVOTGRID_AREA_ROW_CLASS;
  },
  _applyCustomStyles: function(options) {
    this.callBase(options);
    if (options.cellIndex === options.cellsCount - 1) {
      options.classArray.push(PIVOTGRID_LAST_CELL_CLASS);
    }
    if (options.rowIndex === options.rowsCount - 1) {
      options.cssArray.push("border-bottom: 0px");
    }
    if (options.cell.isWhiteSpace) {
      options.classArray.push("dx-white-space-column");
    }
  },
  _getAreaName: function() {
    return "row";
  },
  setVirtualContentParams: function(params) {
    this.callBase(params);
    this._setTableCss({
      top: params.top,
      left: 0
    });
    this._virtualContentHeight = params.height;
  },
  hasScroll: function() {
    var tableHeight = this._virtualContent ? this._virtualContentHeight : this._tableHeight;
    if (this._groupHeight && tableHeight) {
      return tableHeight - this._groupHeight >= 1;
    }
    return false;
  },
  processScroll: function() {
    if (!this._getScrollable()) {
      this._groupElement.dxScrollable({
        useNative: false,
        useSimulatedScrollbar: false,
        showScrollbar: false,
        bounceEnabled: false,
        direction: "vertical",
        updateManually: true
      });
    }
  },
  processScrollBarSpacing: function(scrollBarWidth) {
    scrollBarWidth = scrollBarWidth && this.option("useBetterScroller") ? 8 : scrollBarWidth;
    if (this._groupHeight) {
      this.groupHeight(this._groupHeight - scrollBarWidth);
    }
    if (this._scrollBarWidth) {
      this._groupElement.next().remove();
    }
    if (scrollBarWidth) {
      this._groupElement.after($("<div>").width("100%").height(scrollBarWidth - 1));
    }
    this._scrollBarWidth = scrollBarWidth;
  },
  getScrollPath: function(offset2) {
    var tableElement = this.tableElement();
    var cell;
    offset2 -= parseInt(tableElement[0].style.top, 10) || 0;
    each(tableElement.find("tr"), function(_2, tr) {
      var td = tr.childNodes[tr.childNodes.length - 1];
      if (td && td.rowSpan === 1 && td.offsetTop <= offset2 && td.offsetHeight + td.offsetTop > offset2) {
        cell = td;
        return false;
      }
    });
    return getCellPath(tableElement, cell);
  },
  _moveFakeTable: function(scrollPos) {
    this._moveFakeTableTop(scrollPos);
    this.callBase();
  },
  _getRowClassNames: function(rowIndex, cell, rowClassNames) {
    if (rowIndex !== 0 & cell.expanded && inArray(PIVOTGRID_EXPAND_BORDER, rowClassNames) === -1) {
      rowClassNames.push(PIVOTGRID_EXPAND_BORDER);
    }
  },
  _getMainElementMarkup: function() {
    return "<tbody class='" + this._getAreaClassName() + "'>";
  },
  _getCloseMainElementMarkup: function() {
    return "</tbody>";
  },
  updateColspans: function(columnCount) {
    var rows = this.tableElement()[0].rows;
    var columnOffset = 0;
    var columnOffsetResetIndexes = [];
    if (this.getColumnsCount() - columnCount > 0) {
      return;
    }
    for (var i = 0; i < rows.length; i++) {
      for (var j = 0; j < rows[i].cells.length; j++) {
        var cell = rows[i].cells[j];
        var rowSpan = cell.rowSpan;
        if (columnOffsetResetIndexes[i]) {
          columnOffset -= columnOffsetResetIndexes[i];
          columnOffsetResetIndexes[i] = 0;
        }
        var diff = columnCount - (columnOffset + cell.colSpan);
        if (j === rows[i].cells.length - 1 && diff > 0) {
          cell.colSpan = cell.colSpan + diff;
        }
        columnOffsetResetIndexes[i + rowSpan] = (columnOffsetResetIndexes[i + rowSpan] || 0) + cell.colSpan;
        columnOffset += cell.colSpan;
      }
    }
  }
});
var INKRIPPLE_CLASS = "dx-inkripple";
var INKRIPPLE_WAVE_CLASS = "dx-inkripple-wave";
var INKRIPPLE_SHOWING_CLASS = "dx-inkripple-showing";
var INKRIPPLE_HIDING_CLASS = "dx-inkripple-hiding";
var DEFAULT_WAVE_SIZE_COEFFICIENT = 2;
var MAX_WAVE_SIZE = 4e3;
var ANIMATION_DURATION = 300;
var HOLD_ANIMATION_DURATION = 1e3;
var DEFAULT_WAVE_INDEX = 0;
var initConfig = function() {
  var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var {
    useHoldAnimation,
    waveSizeCoefficient,
    isCentered,
    wavesNumber
  } = config2;
  return {
    waveSizeCoefficient: waveSizeCoefficient || DEFAULT_WAVE_SIZE_COEFFICIENT,
    isCentered: isCentered || false,
    wavesNumber: wavesNumber || 1,
    durations: getDurations(useHoldAnimation !== null && useHoldAnimation !== void 0 ? useHoldAnimation : true)
  };
};
var render = function(args) {
  var config2 = initConfig(args);
  return {
    showWave: showWave.bind(this, config2),
    hideWave: hideWave.bind(this, config2)
  };
};
var getInkRipple = function(element) {
  var result = element.children("." + INKRIPPLE_CLASS);
  if (result.length === 0) {
    result = $("<div>").addClass(INKRIPPLE_CLASS).appendTo(element);
  }
  return result;
};
var getWaves = function(element, wavesNumber) {
  var inkRipple = getInkRipple($(element));
  var result = inkRipple.children("." + INKRIPPLE_WAVE_CLASS).toArray();
  for (var i = result.length; i < wavesNumber; i++) {
    var $currentWave = $("<div>").appendTo(inkRipple).addClass(INKRIPPLE_WAVE_CLASS);
    result.push($currentWave[0]);
  }
  return $(result);
};
var getWaveStyleConfig = function(args, config2) {
  var element = $(config2.element);
  var elementWidth = element.outerWidth();
  var elementHeight = element.outerHeight();
  var elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight));
  var waveSize = Math.min(MAX_WAVE_SIZE, parseInt(elementDiagonal * args.waveSizeCoefficient));
  var left;
  var top;
  if (args.isCentered) {
    left = (elementWidth - waveSize) / 2;
    top = (elementHeight - waveSize) / 2;
  } else {
    var event = config2.event;
    var position2 = element.offset();
    var x = event.pageX - position2.left;
    var y = event.pageY - position2.top;
    left = x - waveSize / 2;
    top = y - waveSize / 2;
  }
  return {
    left,
    top,
    height: waveSize,
    width: waveSize
  };
};
function showWave(args, config2) {
  var $wave = getWaves(config2.element, args.wavesNumber).eq(config2.wave || DEFAULT_WAVE_INDEX);
  args.hidingTimeout && clearTimeout(args.hidingTimeout);
  hideSelectedWave($wave);
  $wave.css(getWaveStyleConfig(args, config2));
  args.showingTimeout = setTimeout(showingWaveHandler.bind(this, args, $wave), 0);
}
function showingWaveHandler(args, $wave) {
  var durationCss = args.durations.showingScale + "ms";
  $wave.addClass(INKRIPPLE_SHOWING_CLASS).css("transitionDuration", durationCss);
}
function getDurations(useHoldAnimation) {
  return {
    showingScale: useHoldAnimation ? HOLD_ANIMATION_DURATION : ANIMATION_DURATION,
    hidingScale: ANIMATION_DURATION,
    hidingOpacity: ANIMATION_DURATION
  };
}
function hideSelectedWave($wave) {
  $wave.removeClass(INKRIPPLE_HIDING_CLASS).css("transitionDuration", "");
}
function hideWave(args, config2) {
  args.showingTimeout && clearTimeout(args.showingTimeout);
  var $wave = getWaves(config2.element, config2.wavesNumber).eq(config2.wave || DEFAULT_WAVE_INDEX);
  var durations = args.durations;
  var durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
  $wave.addClass(INKRIPPLE_HIDING_CLASS).removeClass(INKRIPPLE_SHOWING_CLASS).css("transitionDuration", durationCss);
  var animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
  args.hidingTimeout = setTimeout(hideSelectedWave.bind(this, $wave), animationDuration);
}
var STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
class BaseRuleValidator {
  constructor() {
    this.NAME = "base";
  }
  defaultMessage(value2) {
    return messageLocalization.getFormatter("validation-".concat(this.NAME))(value2);
  }
  defaultFormattedMessage(value2) {
    return messageLocalization.getFormatter("validation-".concat(this.NAME, "-formatted"))(value2);
  }
  _isValueEmpty(value2) {
    return !rulesValidators.required.validate(value2, {});
  }
  validate(value2, rule) {
    var valueArray = Array.isArray(value2) ? value2 : [value2];
    var result = true;
    if (valueArray.length) {
      valueArray.every((itemValue) => {
        result = this._validate(itemValue, rule);
        return result;
      });
    } else {
      result = this._validate(null, rule);
    }
    return result;
  }
}
class RequiredRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "required";
  }
  _validate(value2, rule) {
    if (!isDefined(value2)) {
      return false;
    }
    if (value2 === false) {
      return false;
    }
    value2 = String(value2);
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    return value2 !== "";
  }
}
class NumericRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "numeric";
  }
  _validate(value2, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value2)) {
      return true;
    }
    if (rule.useCultureSettings && isString$1(value2)) {
      return !isNaN(numberLocalization.parse(value2));
    } else {
      return isNumeric(value2);
    }
  }
}
class RangeRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "range";
  }
  _validate(value2, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value2)) {
      return true;
    }
    var validNumber = rulesValidators.numeric.validate(value2, rule);
    var validValue = isDefined(value2) && value2 !== "";
    var number = validNumber ? parseFloat(value2) : validValue && value2.valueOf();
    var min = rule.min;
    var max = rule.max;
    if (!(validNumber || isDate(value2)) && !validValue) {
      return false;
    }
    if (isDefined(min)) {
      if (isDefined(max)) {
        return number >= min && number <= max;
      }
      return number >= min;
    } else if (isDefined(max)) {
      return number <= max;
    } else {
      throw errors$2.Error("E0101");
    }
  }
}
class StringLengthRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "stringLength";
  }
  _validate(value2, rule) {
    var _value;
    value2 = String((_value = value2) !== null && _value !== void 0 ? _value : "");
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.range.validate(value2.length, extend({}, rule));
  }
}
class CustomRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "custom";
  }
  validate(value2, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    var validator = rule.validator;
    var dataGetter = validator && isFunction$1(validator.option) && validator.option("dataGetter");
    var extraParams = isFunction$1(dataGetter) && dataGetter();
    var params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    return rule.validationCallback(params);
  }
}
class AsyncRuleValidator extends CustomRuleValidator {
  constructor() {
    super();
    this.NAME = "async";
  }
  validate(value2, rule) {
    if (!isDefined(rule.reevaluate)) {
      extend(rule, {
        reevaluate: true
      });
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    var validator = rule.validator;
    var dataGetter = validator && isFunction$1(validator.option) && validator.option("dataGetter");
    var extraParams = isFunction$1(dataGetter) && dataGetter();
    var params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    var callbackResult = rule.validationCallback(params);
    if (!isPromise$1(callbackResult)) {
      throw errors$2.Error("E0103");
    }
    return this._getWrappedPromise(fromPromise(callbackResult).promise());
  }
  _getWrappedPromise(promise2) {
    var deferred = new Deferred();
    promise2.then(function(res) {
      deferred.resolve(res);
    }, function(err) {
      var res = {
        isValid: false
      };
      if (isDefined(err)) {
        if (isString$1(err)) {
          res.message = err;
        } else if (isObject$1(err) && isDefined(err.message) && isString$1(err.message)) {
          res.message = err.message;
        }
      }
      deferred.resolve(res);
    });
    return deferred.promise();
  }
}
class CompareRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "compare";
  }
  _validate(value2, rule) {
    if (!rule.comparisonTarget) {
      throw errors$2.Error("E0102");
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    extend(rule, {
      reevaluate: true
    });
    var otherValue = rule.comparisonTarget();
    var type2 = rule.comparisonType || "==";
    switch (type2) {
      case "==":
        return value2 == otherValue;
      case "!=":
        return value2 != otherValue;
      case "===":
        return value2 === otherValue;
      case "!==":
        return value2 !== otherValue;
      case ">":
        return value2 > otherValue;
      case ">=":
        return value2 >= otherValue;
      case "<":
        return value2 < otherValue;
      case "<=":
        return value2 <= otherValue;
    }
  }
}
class PatternRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "pattern";
  }
  _validate(value2, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value2)) {
      return true;
    }
    var pattern = rule.pattern;
    if (isString$1(pattern)) {
      pattern = new RegExp(pattern);
    }
    return pattern.test(value2);
  }
}
class EmailRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "email";
  }
  _validate(value2, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.pattern.validate(value2, extend({}, rule, {
      pattern: /^[\d\w._-]+@[\d\w._-]+\.[\w]+$/i
    }));
  }
}
var rulesValidators = {
  required: new RequiredRuleValidator(),
  numeric: new NumericRuleValidator(),
  range: new RangeRuleValidator(),
  stringLength: new StringLengthRuleValidator(),
  custom: new CustomRuleValidator(),
  async: new AsyncRuleValidator(),
  compare: new CompareRuleValidator(),
  pattern: new PatternRuleValidator(),
  email: new EmailRuleValidator()
};
var GroupConfig = classImpl.inherit({
  ctor(group) {
    this.group = group;
    this.validators = [];
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
    this._resetValidationInfo();
    this._eventsStrategy = new EventsStrategy(this);
  },
  validate() {
    var result = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };
    this._unsubscribeFromAllChangeEvents();
    this._pendingValidators = [];
    this._resetValidationInfo();
    each(this.validators, (_2, validator) => {
      var validatorResult = validator.validate();
      result.isValid = result.isValid && validatorResult.isValid;
      if (validatorResult.brokenRules) {
        result.brokenRules = result.brokenRules.concat(validatorResult.brokenRules);
      }
      result.validators.push(validator);
      if (validatorResult.status === STATUS.pending) {
        this._addPendingValidator(validator);
      }
      this._subscribeToChangeEvents(validator);
    });
    if (this._pendingValidators.length) {
      result.status = STATUS.pending;
    } else {
      result.status = result.isValid ? STATUS.valid : STATUS.invalid;
      this._unsubscribeFromAllChangeEvents();
      this._raiseValidatedEvent(result);
    }
    this._updateValidationInfo(result);
    return extend({}, this._validationInfo.result);
  },
  _subscribeToChangeEvents(validator) {
    validator.on("validating", this._onValidatorStatusChanged);
    validator.on("validated", this._onValidatorStatusChanged);
  },
  _unsubscribeFromChangeEvents(validator) {
    validator.off("validating", this._onValidatorStatusChanged);
    validator.off("validated", this._onValidatorStatusChanged);
  },
  _unsubscribeFromAllChangeEvents() {
    each(this.validators, (_2, validator) => {
      this._unsubscribeFromChangeEvents(validator);
    });
  },
  _updateValidationInfo(result) {
    this._validationInfo.result = result;
    if (result.status !== STATUS.pending) {
      return;
    }
    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = new Deferred();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  },
  _addPendingValidator(validator) {
    var foundValidator = grep(this._pendingValidators, function(val) {
      return val === validator;
    })[0];
    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  },
  _removePendingValidator(validator) {
    var index2 = inArray(validator, this._pendingValidators);
    if (index2 >= 0) {
      this._pendingValidators.splice(index2, 1);
    }
  },
  _orderBrokenRules(brokenRules) {
    var orderedRules = [];
    each(this.validators, function(_2, validator) {
      var foundRules = grep(brokenRules, function(rule) {
        return rule.validator === validator;
      });
      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    });
    return orderedRules;
  },
  _updateBrokenRules(result) {
    if (!this._validationInfo.result) {
      return;
    }
    var brokenRules = this._validationInfo.result.brokenRules;
    var rules = grep(brokenRules, function(rule) {
      return rule.validator !== result.validator;
    });
    if (result.brokenRules) {
      brokenRules = rules.concat(result.brokenRules);
    }
    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  },
  _onValidatorStatusChanged(result) {
    if (result.status === STATUS.pending) {
      this._addPendingValidator(result.validator);
      return;
    }
    this._resolveIfComplete(result);
  },
  _resolveIfComplete(result) {
    this._removePendingValidator(result.validator);
    this._updateBrokenRules(result);
    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();
      if (!this._validationInfo.result) {
        return;
      }
      this._validationInfo.result.status = this._validationInfo.result.brokenRules.length === 0 ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      var res = extend({}, this._validationInfo.result, {
        complete: null
      });
      var deferred = this._validationInfo.deferred;
      this._validationInfo.deferred = null;
      this._raiseValidatedEvent(res);
      deferred && setTimeout(() => {
        deferred.resolve(res);
      });
    }
  },
  _raiseValidatedEvent(result) {
    this._eventsStrategy.fireEvent("validated", [result]);
  },
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  },
  _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  },
  removeRegisteredValidator(validator) {
    var index2 = inArray(validator, this.validators);
    if (index2 > -1) {
      this.validators.splice(index2, 1);
      this._synchronizeValidationInfo();
      this._resolveIfComplete({
        validator
      });
    }
  },
  registerValidator(validator) {
    if (inArray(validator, this.validators) < 0) {
      this.validators.push(validator);
      this._synchronizeValidationInfo();
    }
  },
  reset() {
    each(this.validators, function(_2, validator) {
      validator.reset();
    });
    this._pendingValidators = [];
    this._resetValidationInfo();
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
var ValidationEngine = {
  groups: [],
  getGroupConfig(group) {
    var result = grep(this.groups, function(config2) {
      return config2.group === group;
    });
    if (result.length) {
      return result[0];
    }
  },
  findGroup($element, model) {
    var $dxGroup = $element.parents(".dx-validationgroup").first();
    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup("instance");
    }
    return model;
  },
  initGroups() {
    this.groups = [];
    this.addGroup();
  },
  addGroup(group) {
    var config2 = this.getGroupConfig(group);
    if (!config2) {
      config2 = new GroupConfig(group);
      this.groups.push(config2);
    }
    return config2;
  },
  removeGroup(group) {
    var config2 = this.getGroupConfig(group);
    var index2 = inArray(config2, this.groups);
    if (index2 > -1) {
      this.groups.splice(index2, 1);
    }
    return config2;
  },
  _setDefaultMessage(info) {
    var {
      rule,
      validator,
      name: name2
    } = info;
    if (!isDefined(rule.message)) {
      if (validator.defaultFormattedMessage && isDefined(name2)) {
        rule.message = validator.defaultFormattedMessage(name2);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule(info) {
    var {
      result,
      rule
    } = info;
    if (!result.brokenRule) {
      result.brokenRule = rule;
    }
    if (!result.brokenRules) {
      result.brokenRules = [];
    }
    result.brokenRules.push(rule);
  },
  validate(value2, rules, name2) {
    var _rules$;
    var result = {
      name: name2,
      value: value2,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    var validator = rules === null || rules === void 0 ? void 0 : (_rules$ = rules[0]) === null || _rules$ === void 0 ? void 0 : _rules$.validator;
    var asyncRuleItems = [];
    each(rules || [], (_2, rule) => {
      var ruleValidator = rulesValidators[rule.type];
      var ruleValidationResult;
      if (ruleValidator) {
        if (isDefined(rule.isValid) && rule.value === value2 && !rule.reevaluate) {
          if (!rule.isValid) {
            result.isValid = false;
            this._addBrokenRule({
              result,
              rule
            });
            return false;
          }
          return true;
        }
        rule.value = value2;
        if (rule.type === "async") {
          asyncRuleItems.push({
            rule,
            ruleValidator
          });
          return true;
        }
        ruleValidationResult = ruleValidator.validate(value2, rule);
        rule.isValid = ruleValidationResult;
        if (!ruleValidationResult) {
          result.isValid = false;
          this._setDefaultMessage({
            rule,
            validator: ruleValidator,
            name: name2
          });
          this._addBrokenRule({
            result,
            rule
          });
        }
        if (!rule.isValid) {
          return false;
        }
      } else {
        throw errors$2.Error("E0100");
      }
    });
    if (result.isValid && !result.brokenRules && asyncRuleItems.length) {
      result = this._validateAsyncRules({
        value: value2,
        items: asyncRuleItems,
        result,
        name: name2
      });
    }
    this._synchronizeGroupValidationInfo(validator, result);
    result.status = result.pendingRules ? STATUS.pending : result.isValid ? STATUS.valid : STATUS.invalid;
    return result;
  },
  _synchronizeGroupValidationInfo(validator, result) {
    var _result$brokenRules;
    if (!validator) {
      return;
    }
    var groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
    groupConfig._updateBrokenRules.call(groupConfig, {
      validator,
      brokenRules: (_result$brokenRules = result.brokenRules) !== null && _result$brokenRules !== void 0 ? _result$brokenRules : []
    });
  },
  _validateAsyncRules(_ref) {
    var {
      result,
      value: value2,
      items,
      name: name2
    } = _ref;
    var asyncResults = [];
    each(items, (_2, item) => {
      var validateResult = item.ruleValidator.validate(value2, item.rule);
      if (!isPromise$1(validateResult)) {
        this._updateRuleConfig({
          rule: item.rule,
          ruleResult: this._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name: name2
        });
      } else {
        if (!result.pendingRules) {
          result.pendingRules = [];
        }
        result.pendingRules.push(item.rule);
        var asyncResult = validateResult.then((res) => {
          var ruleResult = this._getPatchedRuleResult(res);
          this._updateRuleConfig({
            rule: item.rule,
            ruleResult,
            validator: item.ruleValidator,
            name: name2
          });
          return ruleResult;
        });
        asyncResults.push(asyncResult);
      }
    });
    if (asyncResults.length) {
      result.complete = Promise$3.all(asyncResults).then((values) => this._getAsyncRulesResult({
        result,
        values
      }));
    }
    return result;
  },
  _updateRuleConfig(_ref2) {
    var {
      rule,
      ruleResult,
      validator,
      name: name2
    } = _ref2;
    rule.isValid = ruleResult.isValid;
    if (!ruleResult.isValid) {
      if (isDefined(ruleResult.message) && isString$1(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule,
          validator,
          name: name2
        });
      }
    }
  },
  _getPatchedRuleResult(ruleResult) {
    var result;
    if (isObject$1(ruleResult)) {
      result = extend({}, ruleResult);
      if (!isDefined(result.isValid)) {
        result.isValid = true;
      }
    } else {
      result = {
        isValid: isBoolean(ruleResult) ? ruleResult : true
      };
    }
    return result;
  },
  _getAsyncRulesResult(_ref3) {
    var {
      values,
      result
    } = _ref3;
    each(values, (index2, val) => {
      if (val.isValid === false) {
        result.isValid = val.isValid;
        var rule = result.pendingRules[index2];
        this._addBrokenRule({
          result,
          rule
        });
      }
    });
    result.pendingRules = null;
    result.complete = null;
    result.status = result.isValid ? STATUS.valid : STATUS.invalid;
    return result;
  },
  registerValidatorInGroup(group, validator) {
    var groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  _shouldRemoveGroup(group, validatorsInGroup) {
    var isDefaultGroup = group === void 0;
    var isValidationGroupInstance = group && group.NAME === "dxValidationGroup";
    return !isDefaultGroup && !isValidationGroupInstance && !validatorsInGroup.length;
  },
  removeRegisteredValidator(group, validator) {
    var config2 = ValidationEngine.getGroupConfig(group);
    if (config2) {
      config2.removeRegisteredValidator.call(config2, validator);
      var validatorsInGroup = config2.validators;
      if (this._shouldRemoveGroup(group, validatorsInGroup)) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions(options) {
    var initedOptions = {};
    if (options) {
      ["isValid", "validationStatus", "validationError", "validationErrors"].forEach((prop) => {
        if (prop in options) {
          extend(initedOptions, this.synchronizeValidationOptions({
            name: prop,
            value: options[prop]
          }, options));
        }
      });
    }
    return initedOptions;
  },
  synchronizeValidationOptions(_ref4, options) {
    var {
      name: name2,
      value: value2
    } = _ref4;
    switch (name2) {
      case "validationStatus":
        var isValid = value2 === STATUS.valid || value2 === STATUS.pending;
        return options.isValid !== isValid ? {
          isValid
        } : {};
      case "isValid":
        var {
          validationStatus
        } = options;
        var newStatus = validationStatus;
        if (value2 && validationStatus === STATUS.invalid) {
          newStatus = STATUS.valid;
        } else if (!value2 && validationStatus !== STATUS.invalid) {
          newStatus = STATUS.invalid;
        }
        return newStatus !== validationStatus ? {
          validationStatus: newStatus
        } : {};
      case "validationErrors":
        var validationError = !value2 || !value2.length ? null : value2[0];
        return options.validationError !== validationError ? {
          validationError
        } : {};
      case "validationError":
        var {
          validationErrors
        } = options;
        if (!value2 && validationErrors) {
          return {
            validationErrors: null
          };
        } else if (value2 && !validationErrors) {
          return {
            validationErrors: [value2]
          };
        } else if (value2 && validationErrors && value2 !== validationErrors[0]) {
          validationErrors[0] = value2;
          return {
            validationErrors: validationErrors.slice()
          };
        }
    }
    return {};
  },
  validateGroup(group) {
    var groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors$2.Error("E0110");
    }
    return groupConfig.validate();
  },
  resetGroup(group) {
    var groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors$2.Error("E0110");
    }
    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var ICON_CLASS$1 = "dx-icon";
var SVG_ICON_CLASS = "dx-svg-icon";
var getImageSourceType = (source) => {
  if (!source || typeof source !== "string") {
    return false;
  }
  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return "svg";
  }
  if (/data:.*base64|\.|[^<\s]\//.test(source)) {
    return "image";
  }
  if (/^[\w-_]+$/.test(source)) {
    return "dxIcon";
  }
  if (/^\s?([\w-_]\s?)+$/.test(source)) {
    return "fontIcon";
  }
  return false;
};
var getImageContainer = (source) => {
  switch (getImageSourceType(source)) {
    case "image":
      return $("<img>").attr("src", source).addClass(ICON_CLASS$1);
    case "fontIcon":
      return $("<i>").addClass("".concat(ICON_CLASS$1, " ").concat(source));
    case "dxIcon":
      return $("<i>").addClass("".concat(ICON_CLASS$1, " ").concat(ICON_CLASS$1, "-").concat(source));
    case "svg":
      return $("<i>").addClass("".concat(ICON_CLASS$1, " ").concat(SVG_ICON_CLASS)).append(source);
    default:
      return null;
  }
};
var ANONYMOUS_TEMPLATE_NAME$2 = "content";
class Button extends Widget {
  constructor() {
    super(...arguments);
    this._feedbackHideTimeout = 100;
  }
  _$content() {
    return this.$element().find(".dx-button-content");
  }
  _$submitInput() {
    return this.$element().find(".dx-button-submit-input");
  }
  _attachActiveEvents(active$1, inactive) {
    var $el = this._eventBindingTarget();
    var selector = this._activeStateUnit;
    active.off($el, {
      namespace: "inkRipple",
      selector
    });
    active.on($el, new Action(active$1), new Action(inactive, {
      excludeValidators: ["disabled", "readOnly"]
    }), {
      showTimeout: this._feedbackShowTimeout,
      hideTimeout: this._feedbackHideTimeout,
      selector,
      namespace: "inkRipple"
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => devices.real().deviceType === "desktop" && !devices.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterial(current()),
      options: {
        useInkRipple: true
      }
    }]);
  }
  _executeClickAction(event) {
    this._clickAction({
      validationGroup: this._validationGroupConfig,
      event
    });
  }
  _findGroup() {
    var $element = this.$element();
    var model = this._modelByElement($element);
    var {
      validationGroup
    } = this.option();
    return validationGroup || ValidationEngine.findGroup($element, model);
  }
  _getContentData() {
    var {
      icon,
      text,
      type: type2,
      _templateData
    } = this.option();
    return extend({
      icon: type2 === "back" && !icon ? "back" : icon,
      text
    }, _templateData);
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      hoverStateEnabled: true,
      onClick: null,
      type: "normal",
      text: "",
      icon: "",
      iconPosition: "left",
      validationGroup: void 0,
      activeStateEnabled: true,
      template: "content",
      useSubmitBehavior: false,
      useInkRipple: false,
      _templateData: {},
      stylingMode: "contained"
    });
  }
  _getSubmitAction() {
    var needValidate = true;
    var validationStatus = "valid";
    return this._createAction((_ref) => {
      var {
        event
      } = _ref;
      if (needValidate) {
        var validationGroup = this._validationGroupConfig;
        if (validationGroup) {
          var {
            status,
            complete
          } = validationGroup.validate();
          validationStatus = status;
          if (status === "pending") {
            needValidate = false;
            this.option("disabled", true);
            complete.then((_ref2) => {
              var {
                status: status2
              } = _ref2;
              this.option("disabled", false);
              validationStatus = status2;
              validationStatus === "valid" && this._submitInput().click();
              needValidate = true;
            });
          }
        }
      }
      validationStatus !== "valid" && event.preventDefault();
      event.stopPropagation();
    });
  }
  _initMarkup() {
    this.$element().addClass("dx-button");
    this._renderType();
    this._renderStylingMode();
    this._renderInkRipple();
    this._renderClick();
    this._updateAriaLabel();
    super._initMarkup();
    this._updateContent();
    this.setAria("role", "button");
  }
  _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME$2;
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new FunctionTemplate((_ref3) => {
        var {
          model = {},
          container
        } = _ref3;
        var {
          text,
          icon
        } = model;
        var {
          iconPosition
        } = this.option();
        var $icon = getImageContainer(icon);
        var $textContainer = text && $("<span>").text(text).addClass("dx-button-text");
        var $container = $(container);
        $container.append($textContainer);
        if (iconPosition === "left") {
          $container.prepend($icon);
        } else {
          $icon.addClass("dx-icon-right");
          $container.append($icon);
        }
      })
    });
    super._initTemplates();
  }
  _optionChanged(args) {
    var {
      name: name2
    } = args;
    switch (name2) {
      case "onClick":
        this._updateClick();
        break;
      case "icon":
      case "text":
        this._updateContent();
        this._updateAriaLabel();
        break;
      case "type":
        this._updateType();
        this._updateContent();
        break;
      case "_templateData":
        break;
      case "template":
      case "iconPosition":
        this._updateContent();
        break;
      case "stylingMode":
        this._updateStylingMode();
        break;
      case "useSubmitBehavior":
        this._updateSubmitInput();
        break;
      case "useInkRipple":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _renderClick() {
    var $el = this.$element();
    dxClick.off($el, {
      namespace: this.NAME
    });
    dxClick.on($el, (event) => this._executeClickAction(event), {
      namespace: this.NAME
    });
    this._updateClick();
  }
  _renderInkRipple() {
    var {
      text,
      icon,
      type: type2,
      useInkRipple
    } = this.option();
    if (useInkRipple) {
      var isOnlyIconButton = !text && icon || type2 === "back";
      var _inkRipple = render(isOnlyIconButton ? {
        waveSizeCoefficient: 1,
        useHoldAnimation: false,
        isCentered: true
      } : {});
      var changeWaveVisibility = (event, visible2) => {
        var {
          activeStateEnabled,
          useInkRipple: useInkRipple2
        } = this.option();
        if (useInkRipple2 && activeStateEnabled && !this._disposed) {
          var config2 = {
            element: this._$content(),
            event
          };
          visible2 ? _inkRipple.showWave(config2) : _inkRipple.hideWave(config2);
        }
      };
      this._attachActiveEvents((_ref4) => {
        var {
          event
        } = _ref4;
        return changeWaveVisibility(event, true);
      }, (_ref5) => {
        var {
          event
        } = _ref5;
        return changeWaveVisibility(event);
      });
    }
  }
  _renderStylingMode() {
    var $element = this.$element();
    var {
      stylingMode
    } = this.option();
    if (["contained", "text", "outlined"].indexOf(stylingMode) === -1) {
      stylingMode = this._getDefaultOptions().stylingMode;
    }
    $element.addClass("dx-button-mode-".concat(stylingMode));
  }
  _renderSubmitInput() {
    var {
      useSubmitBehavior
    } = this.option();
    if (useSubmitBehavior) {
      var submitAction = this._getSubmitAction();
      var $content = this._$content();
      $("<input>").attr("type", "submit").attr("tabindex", -1).addClass("dx-button-submit-input").appendTo($content);
      click.on(this._$submitInput(), (event) => submitAction({
        event
      }));
    }
  }
  _renderType() {
    var {
      type: type2
    } = this.option();
    var $element = this.$element();
    type2 && $element.addClass("dx-button-".concat(type2));
  }
  _submitInput() {
    return this._$submitInput().get(0);
  }
  _supportedKeys() {
    var click2 = (e) => {
      e.preventDefault();
      this._executeClickAction(e);
    };
    return extend(super._supportedKeys(), {
      space: click2,
      enter: click2
    });
  }
  _updateAriaLabel() {
    var ariaTarget = this._getAriaTarget();
    var {
      icon,
      text
    } = this.option();
    if (!text) {
      if (getImageSourceType(icon) === "image") {
        icon = icon.indexOf("base64") === -1 ? icon.replace(/.+\/([^.]+)\..+$/, "$1") : "Base64";
      }
      text = icon || "";
    }
    ariaTarget.attr("aria-label", text || null);
  }
  _updateClick() {
    this._clickAction = this._createActionByOption("onClick", {
      excludeValidators: ["readOnly"],
      afterExecute: () => {
        var {
          useSubmitBehavior
        } = this.option();
        useSubmitBehavior && setTimeout(() => this._submitInput().click());
      }
    });
  }
  _updateContent() {
    var $element = this.$element();
    var $content = this._$content();
    var data2 = this._getContentData();
    var {
      template,
      iconPosition
    } = this.option();
    var {
      icon,
      text
    } = data2;
    $content.length ? $content.empty() : $content = $("<div>").addClass("dx-button-content").appendTo($element);
    $element.toggleClass("dx-button-has-icon", !!icon).toggleClass("dx-button-icon-right", !!icon && iconPosition !== "left").toggleClass("dx-button-has-text", !!text);
    var $template = $(this._getTemplateByOption("template").render({
      model: data2,
      container: getPublicElement($content),
      transclude: this._templateManager.anonymousTemplateName === template
    }));
    if ($template.hasClass("dx-template-wrapper")) {
      $template.addClass("dx-button-content");
      $content.replaceWith($template);
    }
    this._updateSubmitInput();
  }
  _updateSubmitInput() {
    var {
      useSubmitBehavior
    } = this.option();
    var $submitInput = this._$submitInput();
    if (!useSubmitBehavior && $submitInput.length) {
      $submitInput.remove();
    } else if (useSubmitBehavior && !$submitInput.length) {
      this._renderSubmitInput();
    }
  }
  _updateStylingMode() {
    var $element = this.$element();
    ["contained", "text", "outlined"].map((mode) => "dx-button-mode-".concat(mode)).forEach((className) => {
      $element.removeClass(className);
    });
    this._renderStylingMode();
  }
  _updateType() {
    var $element = this.$element();
    ["back", "danger", "default", "normal", "success"].map((type2) => "dx-button-".concat(type2)).forEach((className) => {
      $element.removeClass(className);
    });
    this._renderType();
  }
  get _validationGroupConfig() {
    return ValidationEngine.getGroupConfig(this._findGroup());
  }
}
registerComponent("dxButton", Button);
var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions";
var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
var DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler";
var DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler";
var DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD = "_dataSourceFromUrlLoadMode";
var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
var DataHelperMixin = {
  postCtor: function() {
    this.on("disposing", function() {
      this._disposeDataSource();
    }.bind(this));
  },
  _refreshDataSource: function() {
    this._initDataSource();
    this._loadDataSource();
  },
  _initDataSource: function() {
    var dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
    var widgetDataSourceOptions;
    var dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD in this && this[DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD]()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
    }
  },
  _addDataSourceHandlers: function() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  },
  _addReadyWatcher: function() {
    this._dataSource.on("loadingChanged", function(isLoading) {
      this._ready && this._ready(!isLoading);
    }.bind(this));
  },
  _addDataSourceChangeHandler: function() {
    var dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = function(e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }.bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler: function() {
    this._proxiedDataSourceLoadErrorHandler = this[DATA_SOURCE_LOAD_ERROR_METHOD].bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler: function() {
    this._proxiedDataSourceLoadingChangedHandler = this[DATA_SOURCE_LOADING_CHANGED_METHOD].bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource: function() {
    if (this._dataSource) {
      var dataSource = this._dataSource;
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle: function(key, value2) {
    key = key === "this" ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  },
  _isLastPage: function() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading: function() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource: function() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource: function() {
    return this._dataSource || null;
  }
};
var INVISIBLE_STATE_CLASS$1 = "dx-state-invisible";
var DISABLED_STATE_CLASS$2 = "dx-state-disabled";
var ITEM_CONTENT_PLACEHOLDER_CLASS$1 = "dx-item-content-placeholder";
var forcibleWatcher = function(watchMethod, fn, callback) {
  var filteredCallback = function(value2) {
    if (oldValue !== value2) {
      callback(value2, oldValue);
      oldValue = value2;
    }
  };
  var oldValue;
  return {
    dispose: watchMethod(fn, filteredCallback),
    force: function() {
      filteredCallback(fn());
    }
  };
};
var CollectionItem = classImpl.inherit({
  ctor: function($element, options, rawData) {
    this._$element = $element;
    this._options = options;
    this._rawData = rawData;
    attachInstanceToElement($element, this, this._dispose);
    this._render();
  },
  _render: function() {
    var $placeholder = $("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS$1);
    this._$element.append($placeholder);
    this._watchers = [];
    this._renderWatchers();
  },
  _renderWatchers: function() {
    this._startWatcher("disabled", this._renderDisabled.bind(this));
    this._startWatcher("visible", this._renderVisible.bind(this));
  },
  _startWatcher: function(field, render2) {
    var rawData = this._rawData;
    var exprGetter = this._options.fieldGetter(field);
    var watcher = forcibleWatcher(this._options.watchMethod(), function() {
      return exprGetter(rawData);
    }, function(value2, oldValue) {
      this._dirty = true;
      render2(value2, oldValue);
    }.bind(this));
    this._watchers.push(watcher);
  },
  setDataField: function() {
    this._dirty = false;
    each(this._watchers, function(_2, watcher) {
      watcher.force();
    });
    if (this._dirty) {
      return true;
    }
  },
  _renderDisabled: function(value2, oldValue) {
    this._$element.toggleClass(DISABLED_STATE_CLASS$2, !!value2);
    this._updateOwnerFocus(value2);
  },
  _updateOwnerFocus: function(isDisabled) {
    var ownerComponent = this._options.owner;
    if (ownerComponent && isDisabled) {
      ownerComponent._resetItemFocus(this._$element);
    }
  },
  _renderVisible: function(value2, oldValue) {
    this._$element.toggleClass(INVISIBLE_STATE_CLASS$1, value2 !== void 0 && !value2);
  },
  _dispose: function() {
    each(this._watchers, function(_2, watcher) {
      watcher.dispose();
    });
  }
});
CollectionItem.getInstance = function($element) {
  return getInstanceByElement($element, this);
};
var abs = Math.abs;
var HOLD_EVENT_NAME = "dxhold";
var HOLD_TIMEOUT = 750;
var TOUCH_BOUNDARY = 5;
var HoldEmitter = Emitter.inherit({
  start: function(e) {
    this._startEventData = eventData(e);
    this._startTimer(e);
  },
  _startTimer: function(e) {
    var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
    this._holdTimer = setTimeout(function() {
      this._requestAccept(e);
      this._fireEvent(HOLD_EVENT_NAME, e, {
        target: e.target
      });
      this._forgetAccept();
    }.bind(this), holdTimeout);
  },
  move: function(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved: function(e) {
    var delta = eventDelta(this._startEventData, eventData(e));
    return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY;
  },
  end: function() {
    this._stopTimer();
  },
  _stopTimer: function() {
    clearTimeout(this._holdTimer);
  },
  cancel: function() {
    this._stopTimer();
  },
  dispose: function() {
    this._stopTimer();
  }
});
registerEmitter({
  emitter: HoldEmitter,
  bubble: true,
  events: [HOLD_EVENT_NAME]
});
var holdEvent = {
  name: HOLD_EVENT_NAME
};
var CONTEXTMENU_NAMESPACE = "dxContexMenu";
var CONTEXTMENU_NAMESPACED_EVENT_NAME = addNamespace$1("contextmenu", CONTEXTMENU_NAMESPACE);
var HOLD_NAMESPACED_EVENT_NAME = addNamespace$1(holdEvent.name, CONTEXTMENU_NAMESPACE);
var CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
var ContextMenu$1 = classImpl.inherit({
  setup: function(element) {
    var $element = $(element);
    eventsEngine.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
    if (touch || devices.isSimulator()) {
      eventsEngine.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler: function(e) {
    if (isMouseEvent(e) && !devices.isSimulator()) {
      return;
    }
    this._fireContextMenu(e);
  },
  _contextMenuHandler: function(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu: function(e) {
    return fireEvent({
      type: CONTEXTMENU_EVENT_NAME,
      originalEvent: e
    });
  },
  teardown: function(element) {
    eventsEngine.off(element, "." + CONTEXTMENU_NAMESPACE);
  }
});
registerEvent(CONTEXTMENU_EVENT_NAME, new ContextMenu$1());
var name = CONTEXTMENU_EVENT_NAME;
var watchChanges = function(rawData, watchMethod, fields, fieldsMap, callback) {
  var fieldsDispose;
  var globalDispose = ((data2, watchMethod2, callback2) => watchMethod2(() => data2, callback2))(rawData, watchMethod, function(dataWithRawFields) {
    fieldsDispose && fieldsDispose();
    if (isPrimitive(dataWithRawFields)) {
      callback(dataWithRawFields);
      return;
    }
    fieldsDispose = function(data2, watchMethod2, fields2, fieldsMap2, callback2) {
      var resolvedData = {};
      var missedFields = fields2.slice();
      var watchHandlers = fields2.map(function(name2) {
        var fieldGetter = fieldsMap2[name2];
        return watchMethod2(fieldGetter ? () => fieldGetter(data2) : () => data2[name2], function(value2) {
          resolvedData[name2] = value2;
          if (missedFields.length) {
            var index2 = missedFields.indexOf(name2);
            if (index2 >= 0) {
              missedFields.splice(index2, 1);
            }
          }
          if (!missedFields.length) {
            callback2(resolvedData);
          }
        });
      });
      return function() {
        watchHandlers.forEach((dispose) => dispose());
      };
    }(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
  });
  return function() {
    fieldsDispose && fieldsDispose();
    globalDispose && globalDispose();
  };
};
class BindableTemplate extends TemplateBase {
  constructor(render2, fields, watchMethod, fieldsMap) {
    super();
    this._render = render2;
    this._fields = fields;
    this._fieldsMap = fieldsMap || {};
    this._watchMethod = watchMethod;
  }
  _renderCore(options) {
    var $container = $(options.container);
    var dispose = watchChanges(options.model, this._watchMethod, this._fields, this._fieldsMap, (data2) => {
      $container.empty();
      this._render($container, data2, options.model);
    });
    eventsEngine.on($container, removeEvent, dispose);
    return $container.contents();
  }
}
var COLLECTION_CLASS = "dx-collection";
var ITEM_CLASS$2 = "dx-item";
var CONTENT_CLASS_POSTFIX = "-content";
var ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
var ITEM_DATA_KEY$1 = "dxItemData";
var ITEM_INDEX_KEY = "dxItemIndex";
var ITEM_TEMPLATE_ID_PREFIX = "tmpl-";
var ITEMS_OPTIONS_NAME = "dxItem";
var SELECTED_ITEM_CLASS$1 = "dx-item-selected";
var ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait";
var EMPTY_COLLECTION = "dx-empty-collection";
var TEMPLATE_WRAPPER_CLASS$1 = "dx-template-wrapper";
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var ANONYMOUS_TEMPLATE_NAME$1 = "item";
var FOCUS_UP$1 = "up";
var FOCUS_DOWN$1 = "down";
var FOCUS_LEFT$1 = "left";
var FOCUS_RIGHT$1 = "right";
var FOCUS_PAGE_UP = "pageup";
var FOCUS_PAGE_DOWN = "pagedown";
var FOCUS_LAST$1 = "last";
var FOCUS_FIRST$1 = "first";
var CollectionWidget$2 = Widget.inherit({
  _activeStateUnit: "." + ITEM_CLASS$2,
  _supportedKeys: function() {
    var enter = function(e) {
      var $itemElement = $(this.option("focusedElement"));
      if (!$itemElement.length) {
        return;
      }
      this._itemClickHandler(extend({}, e, {
        target: $itemElement.get(0),
        currentTarget: $itemElement.get(0)
      }));
    };
    var move2 = function(location, e) {
      if (!isCommandKeyPressed(e)) {
        e.preventDefault();
        e.stopPropagation();
        this._moveFocus(location, e);
      }
    };
    return extend(this.callBase(), {
      space: function(e) {
        e.preventDefault();
        enter.call(this, e);
      },
      enter,
      leftArrow: move2.bind(this, FOCUS_LEFT$1),
      rightArrow: move2.bind(this, FOCUS_RIGHT$1),
      upArrow: move2.bind(this, FOCUS_UP$1),
      downArrow: move2.bind(this, FOCUS_DOWN$1),
      pageUp: move2.bind(this, FOCUS_UP$1),
      pageDown: move2.bind(this, FOCUS_DOWN$1),
      home: move2.bind(this, FOCUS_FIRST$1),
      end: move2.bind(this, FOCUS_LAST$1)
    });
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      selectOnFocus: false,
      loopItemFocus: true,
      items: [],
      itemTemplate: "item",
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: messageLocalization.format("dxCollectionWidget-noDataText"),
      dataSource: null,
      _itemAttributes: {},
      itemTemplateProperty: "template",
      focusOnSelectedItem: true,
      focusedElement: null,
      displayExpr: void 0,
      disabledExpr: function(data2) {
        return data2 ? data2.disabled : void 0;
      },
      visibleExpr: function(data2) {
        return data2 ? data2.visible : void 0;
      }
    });
  },
  _init: function() {
    this._compileDisplayGetter();
    this.callBase();
    this._cleanRenderedItems();
    this._refreshDataSource();
  },
  _compileDisplayGetter: function() {
    var displayExpr = this.option("displayExpr");
    this._displayGetter = displayExpr ? compileGetter(this.option("displayExpr")) : void 0;
  },
  _initTemplates: function() {
    this._initItemsFromMarkup();
    this._initDefaultItemTemplate();
    this.callBase();
  },
  _getAnonymousTemplateName: function() {
    return ANONYMOUS_TEMPLATE_NAME$1;
  },
  _initDefaultItemTemplate: function() {
    var fieldsMap = this._getFieldsMap();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(function($container, data2) {
        if (isPlainObject(data2)) {
          this._prepareDefaultItemTemplate(data2, $container);
        } else {
          if (fieldsMap && isFunction$1(fieldsMap.text)) {
            data2 = fieldsMap.text(data2);
          }
          $container.text(String(ensureDefined(data2, "")));
        }
      }.bind(this), this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
    });
  },
  _getBindableFields: function() {
    return ["text", "html"];
  },
  _getFieldsMap: function() {
    if (this._displayGetter) {
      return {
        text: this._displayGetter
      };
    }
  },
  _prepareDefaultItemTemplate: function(data2, $container) {
    if (isDefined(data2.text)) {
      $container.text(data2.text);
    }
    if (isDefined(data2.html)) {
      $container.html(data2.html);
    }
  },
  _initItemsFromMarkup: function() {
    var rawItems = findTemplates(this.$element(), ITEMS_OPTIONS_NAME);
    if (!rawItems.length || this.option("items").length) {
      return;
    }
    var items = rawItems.map((_ref) => {
      var {
        element,
        options
      } = _ref;
      var isTemplateRequired = /\S/.test(element.innerHTML) && !options.template;
      if (isTemplateRequired) {
        options.template = this._prepareItemTemplate(element);
      } else {
        $(element).remove();
      }
      return options;
    });
    this.option("items", items);
  },
  _prepareItemTemplate: function(item) {
    var templateId = ITEM_TEMPLATE_ID_PREFIX + new Guid();
    var $template = $(item).detach().clone().removeAttr("data-options").addClass(TEMPLATE_WRAPPER_CLASS$1);
    this._saveTemplate(templateId, $template);
    return templateId;
  },
  _dataSourceOptions: function() {
    return {
      paginate: false
    };
  },
  _cleanRenderedItems: function() {
    this._renderedItemsCount = 0;
  },
  _focusTarget: function() {
    return this.$element();
  },
  _focusInHandler: function(e) {
    this.callBase.apply(this, arguments);
    if (inArray(e.target, this._focusTarget()) === -1) {
      return;
    }
    var $focusedElement = $(this.option("focusedElement"));
    if ($focusedElement.length) {
      this._setFocusedItem($focusedElement);
    } else {
      var $activeItem = this._getActiveItem();
      if ($activeItem.length) {
        this.option("focusedElement", getPublicElement($activeItem));
      }
    }
  },
  _focusOutHandler: function() {
    this.callBase.apply(this, arguments);
    var $target = $(this.option("focusedElement"));
    this._updateFocusedItemState($target, false);
  },
  _getActiveItem: function(last) {
    var $focusedElement = $(this.option("focusedElement"));
    if ($focusedElement.length) {
      return $focusedElement;
    }
    var index2 = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0;
    var activeElements = this._getActiveElement();
    var lastIndex = activeElements.length - 1;
    if (index2 < 0) {
      index2 = last ? lastIndex : 0;
    }
    return activeElements.eq(index2);
  },
  _moveFocus: function(location) {
    var $items = this._getAvailableItems();
    var $newTarget;
    switch (location) {
      case FOCUS_PAGE_UP:
      case FOCUS_UP$1:
        $newTarget = this._prevItem($items);
        break;
      case FOCUS_PAGE_DOWN:
      case FOCUS_DOWN$1:
        $newTarget = this._nextItem($items);
        break;
      case FOCUS_RIGHT$1:
        $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
        break;
      case FOCUS_LEFT$1:
        $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
        break;
      case FOCUS_FIRST$1:
        $newTarget = $items.first();
        break;
      case FOCUS_LAST$1:
        $newTarget = $items.last();
        break;
      default:
        return false;
    }
    if ($newTarget.length !== 0) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  },
  _getVisibleItems: function($itemElements) {
    $itemElements = $itemElements || this._itemElements();
    return $itemElements.filter(":visible");
  },
  _getAvailableItems: function($itemElements) {
    return this._getVisibleItems($itemElements).not(".dx-state-disabled");
  },
  _prevItem: function($items) {
    var $target = this._getActiveItem();
    var targetIndex = $items.index($target);
    var $last = $items.last();
    var $item = $($items[targetIndex - 1]);
    var loop = this.option("loopItemFocus");
    if ($item.length === 0 && loop) {
      $item = $last;
    }
    return $item;
  },
  _nextItem: function($items) {
    var $target = this._getActiveItem(true);
    var targetIndex = $items.index($target);
    var $first = $items.first();
    var $item = $($items[targetIndex + 1]);
    var loop = this.option("loopItemFocus");
    if ($item.length === 0 && loop) {
      $item = $first;
    }
    return $item;
  },
  _selectFocusedItem: function($target) {
    this.selectItem($target);
  },
  _updateFocusedItemState: function(target, isFocused, needCleanItemId) {
    var $target = $(target);
    if ($target.length) {
      this._refreshActiveDescendant();
      this._refreshItemId($target, needCleanItemId);
      this._toggleFocusClass(isFocused, $target);
    }
    this._updateParentActiveDescendant();
  },
  _refreshActiveDescendant: function($target) {
    this.setAria("activedescendant", isDefined(this.option("focusedElement")) ? this.getFocusedItemId() : null, $target);
  },
  _refreshItemId: function($target, needCleanItemId) {
    if (!needCleanItemId && this.option("focusedElement")) {
      this.setAria("id", this.getFocusedItemId(), $target);
    } else {
      this.setAria("id", null, $target);
    }
  },
  _setFocusedItem: function($target) {
    if (!$target || !$target.length) {
      return;
    }
    this._updateFocusedItemState($target, true);
    this.onFocusedItemChanged(this.getFocusedItemId());
    if (this.option("selectOnFocus")) {
      this._selectFocusedItem($target);
    }
  },
  _findItemElementByItem: function(item) {
    var result = $();
    var that = this;
    this.itemElements().each(function() {
      var $item = $(this);
      if ($item.data(that._itemDataKey()) === item) {
        result = $item;
        return false;
      }
    });
    return result;
  },
  _getIndexByItem: function(item) {
    return this.option("items").indexOf(item);
  },
  _itemOptionChanged: function(item, property, value2, oldValue) {
    var $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value2)) {
      this._refreshItem($item, item);
    }
    var isDisabling = property === "disabled" && value2;
    if (isDisabling) {
      this._resetItemFocus($item);
    }
  },
  _resetItemFocus($item) {
    if ($item.is(this.option("focusedElement"))) {
      this.option("focusedElement", null);
    }
  },
  _refreshItem: function($item) {
    var itemData = this._getItemData($item);
    var index2 = $item.data(this._itemIndexKey());
    this._renderItem(this._renderedItemsCount + index2, itemData, null, $item);
  },
  _updateParentActiveDescendant: noop,
  _optionChanged: function(args) {
    if (args.name === "items") {
      var matches = args.fullName.match(ITEM_PATH_REGEX);
      if (matches && matches.length) {
        var property = matches[matches.length - 1];
        var itemPath = args.fullName.replace("." + property, "");
        var item = this.option(itemPath);
        this._itemOptionChanged(item, property, args.value, args.previousValue);
        return;
      }
    }
    switch (args.name) {
      case "items":
      case "_itemAttributes":
      case "itemTemplateProperty":
      case "useItemTextAsTitle":
        this._cleanRenderedItems();
        this._invalidate();
        break;
      case "dataSource":
        this._refreshDataSource();
        this._renderEmptyMessage();
        break;
      case "noDataText":
        this._renderEmptyMessage();
        break;
      case "itemTemplate":
        this._invalidate();
        break;
      case "onItemRendered":
        this._createItemRenderAction();
        break;
      case "onItemClick":
        break;
      case "onItemHold":
      case "itemHoldTimeout":
        this._attachHoldEvent();
        break;
      case "onItemContextMenu":
        this._attachContextMenuEvent();
        break;
      case "onFocusedItemChanged":
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        break;
      case "selectOnFocus":
      case "loopItemFocus":
      case "focusOnSelectedItem":
        break;
      case "focusedElement":
        this._updateFocusedItemState(args.previousValue, false, true);
        this._setFocusedItem($(args.value));
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDefaultItemTemplate();
        this._invalidate();
        break;
      case "visibleExpr":
      case "disabledExpr":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  _invalidate: function() {
    this.option("focusedElement", null);
    return this.callBase.apply(this, arguments);
  },
  _loadNextPage: function() {
    var dataSource = this._dataSource;
    this._expectNextPageLoading();
    dataSource.pageIndex(1 + dataSource.pageIndex());
    return dataSource.load();
  },
  _expectNextPageLoading: function() {
    this._startIndexForAppendedItems = 0;
  },
  _expectLastItemLoading: function() {
    this._startIndexForAppendedItems = -1;
  },
  _forgetNextPageLoading: function() {
    this._startIndexForAppendedItems = null;
  },
  _dataSourceChangedHandler: function(newItems) {
    var items = this.option("items");
    if (this._initialized && items && this._shouldAppendItems()) {
      this._renderedItemsCount = items.length;
      if (!this._isLastPage() || this._startIndexForAppendedItems !== -1) {
        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
      }
      this._forgetNextPageLoading();
      this._refreshContent();
    } else {
      this.option("items", newItems.slice());
    }
  },
  _refreshContent: function() {
    this._prepareContent();
    this._renderContent();
  },
  _dataSourceLoadErrorHandler: function() {
    this._forgetNextPageLoading();
    this.option("items", this.option("items"));
  },
  _shouldAppendItems: function() {
    return this._startIndexForAppendedItems != null && this._allowDynamicItemsAppend();
  },
  _allowDynamicItemsAppend: function() {
    return false;
  },
  _clean: function() {
    this._cleanFocusState();
    this._cleanItemContainer();
  },
  _cleanItemContainer: function() {
    $(this._itemContainer()).empty();
  },
  _dispose: function() {
    this.callBase();
    clearTimeout(this._itemFocusTimeout);
  },
  _refresh: function() {
    this._cleanRenderedItems();
    this.callBase.apply(this, arguments);
  },
  _itemContainer: function() {
    return this.$element();
  },
  _itemClass: function() {
    return ITEM_CLASS$2;
  },
  _itemContentClass: function() {
    return this._itemClass() + CONTENT_CLASS_POSTFIX;
  },
  _selectedItemClass: function() {
    return SELECTED_ITEM_CLASS$1;
  },
  _itemResponseWaitClass: function() {
    return ITEM_RESPONSE_WAIT_CLASS;
  },
  _itemSelector: function() {
    return "." + this._itemClass();
  },
  _itemDataKey: function() {
    return ITEM_DATA_KEY$1;
  },
  _itemIndexKey: function() {
    return ITEM_INDEX_KEY;
  },
  _itemElements: function() {
    return this._itemContainer().find(this._itemSelector());
  },
  _initMarkup: function() {
    this.callBase();
    this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
    this.$element().addClass(COLLECTION_CLASS);
    this._prepareContent();
  },
  _prepareContent: deferRenderer(function() {
    this._renderContentImpl();
  }),
  _renderContent: function() {
    this._fireContentReadyAction();
  },
  _render: function() {
    this.callBase();
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
  },
  _attachClickEvent: function() {
    var itemSelector = this._itemSelector();
    var clickEventNamespace = addNamespace$1(CLICK_EVENT_NAME$2, this.NAME);
    var pointerDownEventNamespace = addNamespace$1(pointer.down, this.NAME);
    var that = this;
    var pointerDownAction = new Action(function(args) {
      var event = args.event;
      that._itemPointerDownHandler(event);
    });
    eventsEngine.off(this._itemContainer(), clickEventNamespace, itemSelector);
    eventsEngine.off(this._itemContainer(), pointerDownEventNamespace, itemSelector);
    eventsEngine.on(this._itemContainer(), clickEventNamespace, itemSelector, function(e) {
      this._itemClickHandler(e);
    }.bind(this));
    eventsEngine.on(this._itemContainer(), pointerDownEventNamespace, itemSelector, function(e) {
      pointerDownAction.execute({
        element: $(e.target),
        event: e
      });
    });
  },
  _itemClickHandler: function(e, args, config2) {
    this._itemDXEventHandler(e, "onItemClick", args, config2);
  },
  _itemPointerDownHandler: function(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    this._itemFocusHandler = function() {
      clearTimeout(this._itemFocusTimeout);
      this._itemFocusHandler = null;
      if (e.isDefaultPrevented()) {
        return;
      }
      var $target = $(e.target);
      var $closestItem = $target.closest(this._itemElements());
      var $closestFocusable = this._closestFocusable($target);
      if ($closestItem.length && $closestFocusable && inArray($closestFocusable.get(0), this._focusTarget()) !== -1) {
        this.option("focusedElement", getPublicElement($closestItem));
      }
    }.bind(this);
    this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this));
  },
  _closestFocusable: function($target) {
    if ($target.is(focusable)) {
      return $target;
    } else {
      $target = $target.parent();
      while ($target.length && !domAdapter.isDocument($target.get(0))) {
        if ($target.is(focusable)) {
          return $target;
        }
        $target = $target.parent();
      }
    }
  },
  _forcePointerDownFocus: function() {
    this._itemFocusHandler && this._itemFocusHandler();
  },
  _updateFocusState: function() {
    this.callBase.apply(this, arguments);
    this._forcePointerDownFocus();
  },
  _attachHoldEvent: function() {
    var $itemContainer = this._itemContainer();
    var itemSelector = this._itemSelector();
    var eventName = addNamespace$1(holdEvent.name, this.NAME);
    eventsEngine.off($itemContainer, eventName, itemSelector);
    eventsEngine.on($itemContainer, eventName, itemSelector, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  },
  _getHoldTimeout: function() {
    return this.option("itemHoldTimeout");
  },
  _shouldFireHoldEvent: function() {
    return this.hasActionSubscription("onItemHold");
  },
  _itemHoldHandler: function(e) {
    if (this._shouldFireHoldEvent()) {
      this._itemDXEventHandler(e, "onItemHold");
    } else {
      e.cancel = true;
    }
  },
  _attachContextMenuEvent: function() {
    var $itemContainer = this._itemContainer();
    var itemSelector = this._itemSelector();
    var eventName = addNamespace$1(name, this.NAME);
    eventsEngine.off($itemContainer, eventName, itemSelector);
    eventsEngine.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
  },
  _shouldFireContextMenuEvent: function() {
    return this.hasActionSubscription("onItemContextMenu");
  },
  _itemContextMenuHandler: function(e) {
    if (this._shouldFireContextMenuEvent()) {
      this._itemDXEventHandler(e, "onItemContextMenu");
    } else {
      e.cancel = true;
    }
  },
  _renderContentImpl: function() {
    var items = this.option("items") || [];
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
  },
  _renderItems: function(items) {
    if (items.length) {
      each(items, function(index2, itemData) {
        this._renderItem(this._renderedItemsCount + index2, itemData);
      }.bind(this));
    }
    this._renderEmptyMessage();
  },
  _renderItem: function(index2, itemData, $container, $itemToReplace) {
    $container = $container || this._itemContainer();
    var $itemFrame = this._renderItemFrame(index2, itemData, $container, $itemToReplace);
    this._setElementData($itemFrame, itemData, index2);
    $itemFrame.attr(this.option("_itemAttributes"));
    this._attachItemClickEvent(itemData, $itemFrame);
    var $itemContent = this._getItemContent($itemFrame);
    var renderContentPromise = this._renderItemContent({
      index: index2,
      itemData,
      container: getPublicElement($itemContent),
      contentClass: this._itemContentClass(),
      defaultTemplateName: this.option("itemTemplate")
    });
    var that = this;
    when(renderContentPromise).done(function($itemContent2) {
      that._postprocessRenderItem({
        itemElement: $itemFrame,
        itemContent: $itemContent2,
        itemData,
        itemIndex: index2
      });
      that._executeItemRenderAction(index2, itemData, getPublicElement($itemFrame));
    });
    return $itemFrame;
  },
  _getItemContent: function($itemFrame) {
    var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS);
    $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
    return $itemContent;
  },
  _attachItemClickEvent: function(itemData, $itemElement) {
    if (!itemData || !itemData.onClick) {
      return;
    }
    eventsEngine.on($itemElement, CLICK_EVENT_NAME$2, function(e) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }.bind(this));
  },
  _renderItemContent: function(args) {
    var itemTemplateName = this._getItemTemplateName(args);
    var itemTemplate = this._getTemplate(itemTemplateName);
    this._addItemContentClasses(args);
    var $templateResult = $(this._createItemByTemplate(itemTemplate, args));
    if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS$1)) {
      return args.container;
    }
    return this._renderItemContentByNode(args, $templateResult);
  },
  _renderItemContentByNode: function(args, $node) {
    $(args.container).replaceWith($node);
    args.container = getPublicElement($node);
    this._addItemContentClasses(args);
    return $node;
  },
  _addItemContentClasses: function(args) {
    var classes = [ITEM_CLASS$2 + CONTENT_CLASS_POSTFIX, args.contentClass];
    $(args.container).addClass(classes.join(" "));
  },
  _appendItemToContainer: function($container, $itemFrame, index2) {
    $itemFrame.appendTo($container);
  },
  _renderItemFrame: function(index2, itemData, $container, $itemToReplace) {
    var $itemFrame = $("<div>");
    new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
    if ($itemToReplace && $itemToReplace.length) {
      $itemToReplace.replaceWith($itemFrame);
    } else {
      this._appendItemToContainer.call(this, $container, $itemFrame, index2);
    }
    if (this.option("useItemTextAsTitle")) {
      var displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
      $itemFrame.attr("title", displayValue);
    }
    return $itemFrame;
  },
  _itemOptions: function() {
    var that = this;
    return {
      watchMethod: function() {
        return that.option("integrationOptions.watchMethod");
      },
      owner: that,
      fieldGetter: function(field) {
        var expr = that.option(field + "Expr");
        var getter = compileGetter(expr);
        return getter;
      }
    };
  },
  _postprocessRenderItem: noop,
  _executeItemRenderAction: function(index2, itemData, itemElement) {
    this._getItemRenderAction()({
      itemElement,
      itemIndex: index2,
      itemData
    });
  },
  _setElementData: function(element, data2, index2) {
    element.addClass([ITEM_CLASS$2, this._itemClass()].join(" ")).data(this._itemDataKey(), data2).data(this._itemIndexKey(), index2);
  },
  _createItemRenderAction: function() {
    return this._itemRenderAction = this._createActionByOption("onItemRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
  },
  _getItemRenderAction: function() {
    return this._itemRenderAction || this._createItemRenderAction();
  },
  _getItemTemplateName: function(args) {
    var data2 = args.itemData;
    var templateProperty = args.templateProperty || this.option("itemTemplateProperty");
    var template = data2 && data2[templateProperty];
    return template || args.defaultTemplateName;
  },
  _createItemByTemplate: function(itemTemplate, renderArgs) {
    return itemTemplate.render({
      model: renderArgs.itemData,
      container: renderArgs.container,
      index: renderArgs.index
    });
  },
  _emptyMessageContainer: function() {
    return this._itemContainer();
  },
  _renderEmptyMessage: function(items) {
    items = items || this.option("items");
    var noDataText = this.option("noDataText");
    var hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();
    if (hideNoData && this._$noData) {
      this._$noData.remove();
      this._$noData = null;
      this.setAria("label", void 0);
    }
    if (!hideNoData) {
      this._$noData = this._$noData || $("<div>").addClass("dx-empty-message");
      this._$noData.appendTo(this._emptyMessageContainer()).html(noDataText);
      this.setAria("label", noDataText);
    }
    this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
  },
  _itemDXEventHandler: function(dxEvent, handlerOptionName, actionArgs, actionConfig) {
    this._itemEventHandler(dxEvent.target, handlerOptionName, extend(actionArgs, {
      event: dxEvent
    }), actionConfig);
  },
  _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
    var action = this._createActionByOption(handlerOptionName, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
    var action = this._createAction(handler, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerImpl: function(initiator, action, actionArgs) {
    var $itemElement = this._closestItemElement($(initiator));
    var args = extend({}, actionArgs);
    return action(extend(actionArgs, this._extendActionArgs($itemElement), args));
  },
  _extendActionArgs: function($itemElement) {
    return {
      itemElement: getPublicElement($itemElement),
      itemIndex: this._itemElements().index($itemElement),
      itemData: this._getItemData($itemElement)
    };
  },
  _closestItemElement: function($element) {
    return $($element).closest(this._itemSelector());
  },
  _getItemData: function(itemElement) {
    return $(itemElement).data(this._itemDataKey());
  },
  _getSummaryItemsWidth: function(items, includeMargin) {
    var result = 0;
    if (items) {
      each(items, function(_2, item) {
        result += $(item).outerWidth(includeMargin || false);
      });
    }
    return result;
  },
  getFocusedItemId: function() {
    if (!this._focusedItemId) {
      this._focusedItemId = "dx-" + new Guid();
    }
    return this._focusedItemId;
  },
  itemElements: function() {
    return this._itemElements();
  },
  itemsContainer: function() {
    return this._itemContainer();
  }
}).include(DataHelperMixin);
CollectionWidget$2.ItemClass = CollectionItem;
var abstract$3 = classImpl.abstract;
var EditStrategy = classImpl.inherit({
  ctor: function(collectionWidget) {
    this._collectionWidget = collectionWidget;
  },
  getIndexByItemData: abstract$3,
  getItemDataByIndex: abstract$3,
  getKeysByItems: abstract$3,
  getItemsByKeys: abstract$3,
  itemsGetter: abstract$3,
  getKeyByIndex: function(index2) {
    var resultIndex = this._denormalizeItemIndex(index2);
    return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
  },
  _equalKeys: function(key1, key2) {
    if (this._collectionWidget._isKeySpecified()) {
      return equalByValue(key1, key2);
    } else {
      return key1 === key2;
    }
  },
  beginCache: function() {
    this._cache = {};
  },
  endCache: function() {
    this._cache = null;
  },
  getIndexByKey: abstract$3,
  getNormalizedIndex: function(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return value2;
    }
    if (this._isItemIndex(value2)) {
      return this._normalizeItemIndex(value2);
    }
    if (this._isNode(value2)) {
      return this._getNormalizedItemIndex(value2);
    }
    return this._normalizeItemIndex(this.getIndexByItemData(value2));
  },
  getIndex: function(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._denormalizeItemIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return value2;
    }
    if (this._isNode(value2)) {
      return this._denormalizeItemIndex(this._getNormalizedItemIndex(value2));
    }
    return this.getIndexByItemData(value2);
  },
  getItemElement: function(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._getItemByNormalizedIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(value2));
    }
    if (this._isNode(value2)) {
      return $(value2);
    }
    var normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value2));
    return this._getItemByNormalizedIndex(normalizedItemIndex);
  },
  _isNode: (el) => domAdapter.isNode(el && isRenderer(el) ? el.get(0) : el),
  deleteItemAtIndex: abstract$3,
  itemPlacementFunc: function(movingIndex, destinationIndex) {
    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before";
  },
  moveItemAtIndexToIndex: abstract$3,
  _isNormalizedItemIndex: function(index2) {
    return typeof index2 === "number" && Math.round(index2) === index2;
  },
  _isItemIndex: abstract$3,
  _getNormalizedItemIndex: abstract$3,
  _normalizeItemIndex: abstract$3,
  _denormalizeItemIndex: abstract$3,
  _getItemByNormalizedIndex: abstract$3,
  _itemsFromSameParent: abstract$3
});
var PlainEditStrategy = EditStrategy.inherit({
  _getPlainItems: function() {
    return this._collectionWidget.option("items") || [];
  },
  getIndexByItemData: function(itemData) {
    var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    if (keyOf) {
      return this.getIndexByKey(keyOf(itemData));
    } else {
      return inArray(itemData, this._getPlainItems());
    }
  },
  getItemDataByIndex: function(index2) {
    return this._getPlainItems()[index2];
  },
  deleteItemAtIndex: function(index2) {
    this._getPlainItems().splice(index2, 1);
  },
  itemsGetter: function() {
    return this._getPlainItems();
  },
  getKeysByItems: function(items) {
    var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    var result = items;
    if (keyOf) {
      result = [];
      for (var i = 0; i < items.length; i++) {
        result.push(keyOf(items[i]));
      }
    }
    return result;
  },
  getIndexByKey: function(key) {
    var cache = this._cache;
    var keys2 = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
    if (cache && !cache.keys) {
      cache.keys = keys2;
    }
    if (typeof key === "object") {
      for (var i = 0, length = keys2.length; i < length; i++) {
        if (this._equalKeys(key, keys2[i])) {
          return i;
        }
      }
    } else {
      return keys2.indexOf(key);
    }
    return -1;
  },
  getItemsByKeys: function(keys2, items) {
    return (items || keys2).slice();
  },
  moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
    var items = this._getPlainItems();
    var movedItemData = items[movingIndex];
    items.splice(movingIndex, 1);
    items.splice(destinationIndex, 0, movedItemData);
  },
  _isItemIndex: function(index2) {
    return typeof index2 === "number" && Math.round(index2) === index2;
  },
  _getNormalizedItemIndex: function(itemElement) {
    return this._collectionWidget._itemElements().index(itemElement);
  },
  _normalizeItemIndex: function(index2) {
    return index2;
  },
  _denormalizeItemIndex: function(index2) {
    return index2;
  },
  _getItemByNormalizedIndex: function(index2) {
    return index2 > -1 ? this._collectionWidget._itemElements().eq(index2) : null;
  },
  _itemsFromSameParent: function() {
    return true;
  }
});
var SelectionStrategy = classImpl.inherit({
  ctor: function(options) {
    this.options = options;
    this._setOption("disabledItemKeys", []);
    this._clearItemKeys();
  },
  _clearItemKeys: function() {
    this._setOption("addedItemKeys", []);
    this._setOption("removedItemKeys", []);
    this._setOption("removedItems", []);
    this._setOption("addedItems", []);
  },
  validate: noop,
  _setOption: function(name2, value2) {
    this.options[name2] = value2;
  },
  onSelectionChanged: function() {
    var addedItemKeys = this.options.addedItemKeys;
    var removedItemKeys = this.options.removedItemKeys;
    var addedItems = this.options.addedItems;
    var removedItems = this.options.removedItems;
    var selectedItems = this.options.selectedItems;
    var selectedItemKeys = this.options.selectedItemKeys;
    var onSelectionChanged = this.options.onSelectionChanged || noop;
    this._clearItemKeys();
    onSelectionChanged({
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems
    });
  },
  equalKeys: function(key1, key2) {
    if (this.options.equalByReference) {
      if (isObject$1(key1) && isObject$1(key2)) {
        return key1 === key2;
      }
    }
    return equalByValue(key1, key2);
  },
  getSelectableItems: function(items) {
    return items.filter(function(item) {
      return !item.disabled;
    });
  },
  _clearSelection: function(keys2, preserve, isDeselect, isSelectAll) {
    keys2 = keys2 || [];
    keys2 = Array.isArray(keys2) ? keys2 : [keys2];
    this.validate();
    return this.selectedItemKeys(keys2, preserve, isDeselect, isSelectAll);
  },
  _loadFilteredData: function(remoteFilter, localFilter, select, isSelectAll) {
    var filterLength = encodeURI(JSON.stringify(remoteFilter)).length;
    var needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
    var deferred = new Deferred();
    var loadOptions = {
      filter: needLoadAllData ? void 0 : remoteFilter,
      select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
    };
    if (remoteFilter && remoteFilter.length === 0) {
      deferred.resolve([]);
    } else {
      this.options.load(loadOptions).done(function(items) {
        var filteredItems = isPlainObject(items) ? items.data : items;
        if (localFilter && !isSelectAll) {
          filteredItems = filteredItems.filter(localFilter);
        } else if (needLoadAllData) {
          filteredItems = query(filteredItems).filter(remoteFilter).toArray();
        }
        deferred.resolve(filteredItems);
      }).fail(deferred.reject.bind(deferred));
    }
    return deferred;
  },
  updateSelectedItemKeyHash: function(keys2) {
    for (var i = 0; i < keys2.length; i++) {
      var keyHash = getKeyHash(keys2[i]);
      if (!isObject$1(keyHash)) {
        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
        var keyIndices = this.options.keyHashIndices[keyHash];
        keyIndices.push(i);
      }
    }
  },
  _isAnyItemSelected: function(items) {
    for (var i = 0; i < items.length; i++) {
      if (this.options.isItemSelected(items[i])) {
        return;
      }
    }
    return false;
  },
  _getFullSelectAllState: function() {
    var items = this.options.plainItems();
    var dataFilter = this.options.filter();
    var selectedItems = this.options.selectedItems;
    if (dataFilter) {
      selectedItems = query(selectedItems).filter(dataFilter).toArray();
    }
    var selectedItemsLength = selectedItems.length;
    if (!selectedItemsLength) {
      return this._isAnyItemSelected(items);
    }
    if (selectedItemsLength >= this.options.totalCount() - this.options.disabledItemKeys.length) {
      return true;
    }
    return;
  },
  _getVisibleSelectAllState: function() {
    var items = this.getSelectableItems(this.options.plainItems());
    var hasSelectedItems = false;
    var hasUnselectedItems = false;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var itemData = this.options.getItemData(item);
      var key = this.options.keyOf(itemData);
      if (this.options.isSelectableItem(item)) {
        if (this.isItemKeySelected(key)) {
          hasSelectedItems = true;
        } else {
          hasUnselectedItems = true;
        }
      }
    }
    if (hasSelectedItems) {
      return !hasUnselectedItems ? true : void 0;
    } else {
      return false;
    }
  }
});
var deferredStrategy = SelectionStrategy.inherit({
  getSelectedItems: function() {
    return this._loadFilteredData(this.options.selectionFilter);
  },
  getSelectedItemKeys: function() {
    var d = new Deferred();
    var that = this;
    var key = this.options.key();
    var select = isString$1(key) ? [key] : key;
    this._loadFilteredData(this.options.selectionFilter, null, select).done(function(items) {
      var keys2 = items.map(function(item) {
        return that.options.keyOf(item);
      });
      d.resolve(keys2);
    }).fail(d.reject);
    return d.promise();
  },
  selectedItemKeys: function(keys2, preserve, isDeselect, isSelectAll) {
    if (isSelectAll) {
      var filter = this.options.filter();
      var needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
      if (needResetSelectionFilter) {
        this._setOption("selectionFilter", isDeselect ? [] : null);
      } else {
        this._addSelectionFilter(isDeselect, filter, isSelectAll);
      }
    } else {
      if (!preserve) {
        this._setOption("selectionFilter", []);
      }
      for (var i = 0; i < keys2.length; i++) {
        if (isDeselect) {
          this.removeSelectedItem(keys2[i]);
        } else {
          this.addSelectedItem(keys2[i]);
        }
      }
    }
    this.onSelectionChanged();
    return new Deferred().resolve();
  },
  setSelectedItems: function(keys2) {
    this._setOption("selectionFilter", null);
    for (var i = 0; i < keys2.length; i++) {
      this.addSelectedItem(keys2[i]);
    }
  },
  isItemDataSelected: function(itemData) {
    return this.isItemKeySelected(itemData);
  },
  isItemKeySelected: function(itemData) {
    var selectionFilter = this.options.selectionFilter;
    if (!selectionFilter) {
      return true;
    }
    return !!query([itemData]).filter(selectionFilter).toArray().length;
  },
  _getKeyExpr: function() {
    var keyField = this.options.key();
    if (Array.isArray(keyField) && keyField.length === 1) {
      return keyField[0];
    }
    return keyField;
  },
  _normalizeKey: function(key) {
    var keyExpr = this.options.key();
    if (Array.isArray(keyExpr) && keyExpr.length === 1) {
      return key[keyExpr[0]];
    }
    return key;
  },
  _getFilterByKey: function(key) {
    var keyField = this._getKeyExpr();
    var filter = [keyField, "=", this._normalizeKey(key)];
    if (Array.isArray(keyField)) {
      filter = [];
      for (var i = 0; i < keyField.length; i++) {
        filter.push([keyField[i], "=", key[keyField[i]]]);
        if (i !== keyField.length - 1) {
          filter.push("and");
        }
      }
    }
    return filter;
  },
  addSelectedItem: function(key) {
    var filter = this._getFilterByKey(key);
    this._addSelectionFilter(false, filter);
  },
  removeSelectedItem: function(key) {
    var filter = this._getFilterByKey(key);
    this._addSelectionFilter(true, filter);
  },
  validate: function() {
    var key = this.options.key;
    if (key && key() === void 0) {
      throw errors$1.Error("E1042", "Deferred selection");
    }
  },
  _findSubFilter: function(selectionFilter, filter) {
    if (!selectionFilter) {
      return -1;
    }
    var filterString = JSON.stringify(filter);
    for (var index2 = 0; index2 < selectionFilter.length; index2++) {
      var subFilter = selectionFilter[index2];
      if (subFilter && JSON.stringify(subFilter) === filterString) {
        return index2;
      }
    }
    return -1;
  },
  _isLastSubFilter: function(selectionFilter, filter) {
    if (selectionFilter && filter) {
      return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || this._findSubFilter([selectionFilter], filter) === 0;
    }
    return false;
  },
  _addFilterOperator: function(selectionFilter, filterOperator) {
    if (selectionFilter.length > 1 && isString$1(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
      selectionFilter = [selectionFilter];
    }
    if (selectionFilter.length) {
      selectionFilter.push(filterOperator);
    }
    return selectionFilter;
  },
  _denormalizeFilter: function(filter) {
    if (filter && isString$1(filter[0])) {
      filter = [filter];
    }
    return filter;
  },
  _addSelectionFilter: function(isDeselect, filter, isSelectAll) {
    var currentFilter = isDeselect ? ["!", filter] : filter;
    var currentOperation = isDeselect ? "and" : "or";
    var needAddFilter = true;
    var selectionFilter = this.options.selectionFilter || [];
    selectionFilter = this._denormalizeFilter(selectionFilter);
    if (selectionFilter && selectionFilter.length) {
      this._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
      var filterIndex = this._removeSameFilter(selectionFilter, filter, !isDeselect);
      var isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
      needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
      if (needAddFilter) {
        selectionFilter = this._addFilterOperator(selectionFilter, currentOperation);
      }
    }
    if (needAddFilter) {
      selectionFilter.push(currentFilter);
    }
    selectionFilter = this._normalizeFilter(selectionFilter);
    this._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter);
  },
  _normalizeFilter: function(filter) {
    if (filter && filter.length === 1) {
      filter = filter[0];
    }
    return filter;
  },
  _removeFilterByIndex: function(filter, filterIndex, isSelectAll) {
    var operation = filter[1];
    if (filterIndex > 0) {
      filter.splice(filterIndex - 1, 2);
    } else {
      filter.splice(filterIndex, 2);
    }
    if (isSelectAll && operation === "and") {
      filter.splice(0, filter.length);
    }
  },
  _isSimpleKeyFilter: function(filter, key) {
    return filter.length === 3 && filter[0] === key && filter[1] === "=";
  },
  _isKeyFilter: function(filter) {
    if (filter.length === 2 && filter[0] === "!") {
      return this._isKeyFilter(filter[1]);
    }
    var keyField = this._getKeyExpr();
    if (Array.isArray(keyField)) {
      if (filter.length !== 2 * keyField.length - 1) {
        return false;
      }
      for (var i = 0; i < keyField.length; i++) {
        if (i > 0 && filter[2 * i - 1] !== "and") {
          return false;
        }
        if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
          return false;
        }
      }
      return true;
    }
    return this._isSimpleKeyFilter(filter, keyField);
  },
  _hasKeyFiltersOnlyStartingFromIndex: function(selectionFilter, filterIndex) {
    if (filterIndex >= 0) {
      for (var i = filterIndex; i < selectionFilter.length; i++) {
        if (typeof selectionFilter[i] !== "string" && !this._isKeyFilter(selectionFilter[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  },
  _removeSameFilter: function(selectionFilter, filter, inverted, isSelectAll) {
    filter = inverted ? ["!", filter] : filter;
    if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
      selectionFilter.splice(0, selectionFilter.length);
      return 0;
    }
    var filterIndex = this._findSubFilter(selectionFilter, filter);
    if (filterIndex >= 0) {
      this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
      return filterIndex;
    } else {
      for (var i = 0; i < selectionFilter.length; i++) {
        if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
          var _filterIndex = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
          if (_filterIndex >= 0) {
            if (!selectionFilter[i].length) {
              this._removeFilterByIndex(selectionFilter, i, isSelectAll);
            } else if (selectionFilter[i].length === 1) {
              selectionFilter[i] = selectionFilter[i][0];
            }
            return _filterIndex;
          }
        }
      }
      return -1;
    }
  },
  getSelectAllState: function() {
    var filter = this.options.filter();
    var selectionFilter = this.options.selectionFilter;
    if (!selectionFilter) {
      return true;
    }
    if (!selectionFilter.length) {
      return false;
    }
    if (!filter || !filter.length) {
      return;
    }
    selectionFilter = this._denormalizeFilter(selectionFilter);
    if (this._isLastSubFilter(selectionFilter, filter)) {
      return true;
    }
    if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
      return false;
    }
    return;
  }
});
var getKeyWrapper = function(item, getKey) {
  var key = getKey(item);
  if (isObject$1(key)) {
    try {
      return JSON.stringify(key);
    } catch (e) {
      return key;
    }
  }
  return key;
};
var getSameNewByOld = function(oldItem, newItems, newIndexByKey, getKey) {
  var key = getKeyWrapper(oldItem, getKey);
  return newItems[newIndexByKey[key]];
};
var isKeysEqual = function(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) {
    return false;
  }
  for (var i = 0; i < newKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      return false;
    }
  }
  return true;
};
var findChanges = function(oldItems, newItems, getKey, isItemEquals) {
  var oldIndexByKey = {};
  var newIndexByKey = {};
  var addedCount = 0;
  var removeCount = 0;
  var result = [];
  oldItems.forEach(function(item, index3) {
    var key2 = getKeyWrapper(item, getKey);
    oldIndexByKey[key2] = index3;
  });
  newItems.forEach(function(item, index3) {
    var key2 = getKeyWrapper(item, getKey);
    newIndexByKey[key2] = index3;
  });
  var itemCount = Math.max(oldItems.length, newItems.length);
  for (var index2 = 0; index2 < itemCount + addedCount; index2++) {
    var newItem = newItems[index2];
    var oldNextIndex = index2 - addedCount + removeCount;
    var nextOldItem = oldItems[oldNextIndex];
    var isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);
    if (isRemoved) {
      if (nextOldItem) {
        result.push({
          type: "remove",
          key: getKey(nextOldItem),
          index: index2,
          oldItem: nextOldItem
        });
        removeCount++;
        index2--;
      }
    } else {
      var key = getKeyWrapper(newItem, getKey);
      var oldIndex = oldIndexByKey[key];
      var oldItem = oldItems[oldIndex];
      if (!oldItem) {
        addedCount++;
        result.push({
          type: "insert",
          data: newItem,
          index: index2
        });
      } else if (oldIndex === oldNextIndex) {
        if (!isItemEquals(oldItem, newItem)) {
          result.push({
            type: "update",
            data: newItem,
            key: getKey(newItem),
            index: index2,
            oldItem
          });
        }
      } else {
        return;
      }
    }
  }
  return result;
};
var SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
  this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
    equalKeys = equalKeys === void 0 ? equalByValue : equalKeys;
    return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
  };
  this.getExpr = function(keyExpr) {
    if (!keyExpr) {
      return;
    }
    var filterExpr;
    selectedItemKeys.forEach(function(key, index2) {
      filterExpr = filterExpr || [];
      var filterExprPart;
      if (index2 > 0) {
        filterExpr.push(isSelectAll ? "and" : "or");
      }
      if (isString$1(keyExpr)) {
        filterExprPart = getFilterForPlainKey(keyExpr, key);
      } else {
        filterExprPart = function(keyExpr2, itemKeyValue) {
          var filterExpr2 = [];
          for (var i = 0, length = keyExpr2.length; i < length; i++) {
            var currentKeyExpr = keyExpr2[i];
            var currentKeyValue = itemKeyValue && itemKeyValue[currentKeyExpr];
            var filterExprPart2 = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
            if (!filterExprPart2) {
              break;
            }
            if (i > 0) {
              filterExpr2.push(isSelectAll ? "or" : "and");
            }
            filterExpr2.push(filterExprPart2);
          }
          return filterExpr2;
        }(keyExpr, key);
      }
      filterExpr.push(filterExprPart);
    });
    if (filterExpr && filterExpr.length === 1) {
      filterExpr = filterExpr[0];
    }
    return filterExpr;
  };
  this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
    var filterExpr = this.getExpr(keyExpr);
    var combinedFilter = filterExpr;
    if (isSelectAll && dataSourceFilter) {
      if (filterExpr) {
        combinedFilter = [];
        combinedFilter.push(filterExpr);
        combinedFilter.push(dataSourceFilter);
      } else {
        combinedFilter = dataSourceFilter;
      }
    }
    return combinedFilter;
  };
  var selectedItemKeyHashesMap;
  function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
    var key = keyOf(item);
    var keyHash;
    var i;
    if (!equalByReference) {
      keyHash = getKeyHash(key);
      if (!isObject$1(keyHash)) {
        var selectedKeyHashesMap = function(selectedItemKeys2) {
          if (!selectedItemKeyHashesMap) {
            selectedItemKeyHashesMap = {};
            for (var i2 = 0; i2 < selectedItemKeys2.length; i2++) {
              selectedItemKeyHashesMap[getKeyHash(selectedItemKeys2[i2])] = true;
            }
          }
          return selectedItemKeyHashesMap;
        }(function(keys2, keyOf2, keyExpr2) {
          return Array.isArray(keyExpr2) ? keys2.map((key2) => keyOf2(key2)) : keys2;
        }(selectedItemKeys, keyOf, keyExpr));
        if (selectedKeyHashesMap[keyHash]) {
          return !isSelectAll;
        }
        return !!isSelectAll;
      }
    }
    for (i = 0; i < selectedItemKeys.length; i++) {
      if (equalKeys(selectedItemKeys[i], key)) {
        return !isSelectAll;
      }
    }
    return !!isSelectAll;
  }
  function getFilterForPlainKey(keyExpr, keyValue) {
    if (keyValue === void 0) {
      return;
    }
    return [keyExpr, isSelectAll ? "<>" : "=", keyValue];
  }
};
var standardStrategy = SelectionStrategy.inherit({
  ctor: function(options) {
    this.callBase(options);
    this._initSelectedItemKeyHash();
  },
  _initSelectedItemKeyHash: function() {
    this._setOption("keyHashIndices", this.options.equalByReference ? null : {});
  },
  getSelectedItemKeys: function() {
    return this.options.selectedItemKeys.slice(0);
  },
  getSelectedItems: function() {
    return this.options.selectedItems.slice(0);
  },
  _preserveSelectionUpdate: function(items, isDeselect) {
    var keyOf = this.options.keyOf;
    var keyIndicesToRemoveMap;
    var keyIndex;
    var i;
    if (!keyOf) {
      return;
    }
    var isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
    if (isBatchDeselect) {
      keyIndicesToRemoveMap = {};
    }
    for (i = 0; i < items.length; i++) {
      var item = items[i];
      var key = keyOf(item);
      if (isDeselect) {
        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap);
        if (keyIndicesToRemoveMap && keyIndex >= 0) {
          keyIndicesToRemoveMap[keyIndex] = true;
        }
      } else {
        this.addSelectedItem(key, item);
      }
    }
    if (isBatchDeselect) {
      this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
    }
  },
  _batchRemoveSelectedItems: function(keyIndicesToRemoveMap) {
    var selectedItemKeys = this.options.selectedItemKeys.slice(0);
    var selectedItems = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0;
    this.options.selectedItems.length = 0;
    for (var i = 0; i < selectedItemKeys.length; i++) {
      if (!keyIndicesToRemoveMap[i]) {
        this.options.selectedItemKeys.push(selectedItemKeys[i]);
        this.options.selectedItems.push(selectedItems[i]);
      }
    }
    this._initSelectedItemKeyHash();
    this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  },
  _loadSelectedItemsCore: function(keys2, isDeselect, isSelectAll) {
    var deferred = new Deferred();
    var key = this.options.key();
    if (!keys2.length && !isSelectAll) {
      deferred.resolve([]);
      return deferred;
    }
    var filter = this.options.filter();
    if (isSelectAll && isDeselect && !filter) {
      deferred.resolve(this.getSelectedItems());
      return deferred;
    }
    var selectionFilterCreator = new SelectionFilterCreator(keys2, isSelectAll);
    var combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter);
    var deselectedItems = [];
    if (isDeselect) {
      deselectedItems = combinedFilter ? query(this.options.selectedItems).filter(combinedFilter).toArray() : this.options.selectedItems.slice(0);
    }
    var filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
    var localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
    filteredItems = filteredItems.filter(localFilter);
    if (deselectedItems.length || !isSelectAll && filteredItems.length === keys2.length) {
      deferred.resolve(filteredItems);
    } else {
      deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
    }
    return deferred;
  },
  _replaceSelectionUpdate: function(items) {
    var internalKeys = [];
    var keyOf = this.options.keyOf;
    if (!keyOf) {
      return;
    }
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var key = keyOf(item);
      internalKeys.push(key);
    }
    this.setSelectedItems(internalKeys, items);
  },
  _warnOnIncorrectKeys: function(keys2) {
    var allowNullValue = this.options.allowNullValue;
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if ((!allowNullValue || key !== null) && !this.isItemKeySelected(key)) {
        errors$1.log("W1002", key);
      }
    }
  },
  _isMultiSelectEnabled: function() {
    var mode = this.options.mode;
    return mode === "all" || mode === "multiple";
  },
  _requestInProgress: function() {
    var _this$_lastLoadDeferr;
    return ((_this$_lastLoadDeferr = this._lastLoadDeferred) === null || _this$_lastLoadDeferr === void 0 ? void 0 : _this$_lastLoadDeferr.state()) === "pending";
  },
  _concatRequestsItems: function(keys2, isDeselect, oldRequestItems, updatedKeys) {
    var selectedItems;
    var deselectedItems = isDeselect ? keys2 : [];
    if (updatedKeys) {
      selectedItems = updatedKeys;
    } else {
      selectedItems = removeDuplicates(keys2, this.options.selectedItemKeys);
    }
    return {
      addedItems: oldRequestItems.added.concat(selectedItems),
      removedItems: oldRequestItems.removed.concat(deselectedItems),
      keys: keys2
    };
  },
  _collectLastRequestData: function(keys2, isDeselect, isSelectAll, updatedKeys) {
    var isDeselectAll = isDeselect && isSelectAll;
    var oldRequestItems = {
      added: [],
      removed: []
    };
    var multiSelectEnabled = this._isMultiSelectEnabled();
    var lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
    if (multiSelectEnabled) {
      if (this._shouldMergeWithLastRequest) {
        if (isDeselectAll) {
          this._lastLoadDeferred.reject();
          lastRequestData = {};
        } else if (!isKeysEqual(keys2, this.options.selectedItemKeys)) {
          oldRequestItems.added = lastRequestData.addedItems;
          oldRequestItems.removed = lastRequestData.removedItems;
          if (!isDeselect) {
            this._lastLoadDeferred.reject();
          }
        }
      }
      lastRequestData = this._concatRequestsItems(keys2, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? void 0 : updatedKeys);
    }
    return lastRequestData;
  },
  _updateKeysByLastRequestData: function(keys2, isDeselect, isSelectAll) {
    var currentKeys = keys2;
    if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
      var _this$_lastRequestDat, _this$_lastRequestDat2;
      currentKeys = removeDuplicates(keys2.concat((_this$_lastRequestDat = this._lastRequestData) === null || _this$_lastRequestDat === void 0 ? void 0 : _this$_lastRequestDat.addedItems), (_this$_lastRequestDat2 = this._lastRequestData) === null || _this$_lastRequestDat2 === void 0 ? void 0 : _this$_lastRequestDat2.removedItems);
      currentKeys = uniqueValues(currentKeys);
    }
    return currentKeys;
  },
  _loadSelectedItems: function(keys2, isDeselect, isSelectAll, updatedKeys) {
    var that = this;
    var deferred = new Deferred();
    this._shouldMergeWithLastRequest = this._requestInProgress();
    this._lastRequestData = this._collectLastRequestData(keys2, isDeselect, isSelectAll, updatedKeys);
    when(that._lastLoadDeferred).always(function() {
      var currentKeys = that._updateKeysByLastRequestData(keys2, isDeselect, isSelectAll);
      that._shouldMergeWithLastRequest = false;
      that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll).done(deferred.resolve).fail(deferred.reject);
    });
    that._lastLoadDeferred = deferred;
    return deferred;
  },
  selectedItemKeys: function(keys2, preserve, isDeselect, isSelectAll, updatedKeys) {
    var that = this;
    var deferred = that._loadSelectedItems(keys2, isDeselect, isSelectAll, updatedKeys);
    deferred.done(function(items) {
      if (preserve) {
        that._preserveSelectionUpdate(items, isDeselect);
      } else {
        that._replaceSelectionUpdate(items);
      }
      that.onSelectionChanged();
    });
    return deferred;
  },
  addSelectedItem: function(key, itemData) {
    if (isDefined(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
      if (this.options.disabledItemKeys.indexOf(key) === -1) {
        this.options.disabledItemKeys.push(key);
      }
      return;
    }
    var keyHash = this._getKeyHash(key);
    if (this._indexOfSelectedItemKey(keyHash) === -1) {
      if (!isObject$1(keyHash) && this.options.keyHashIndices) {
        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
      }
      this.options.selectedItemKeys.push(key);
      this.options.addedItemKeys.push(key);
      this.options.addedItems.push(itemData);
      this.options.selectedItems.push(itemData);
    }
  },
  _getSelectedIndexByKey: function(key, ignoreIndicesMap) {
    var selectedItemKeys = this.options.selectedItemKeys;
    for (var index2 = 0; index2 < selectedItemKeys.length; index2++) {
      if ((!ignoreIndicesMap || !ignoreIndicesMap[index2]) && this.equalKeys(selectedItemKeys[index2], key)) {
        return index2;
      }
    }
    return -1;
  },
  _getSelectedIndexByHash: function(key, ignoreIndicesMap) {
    var indices = this.options.keyHashIndices[key];
    if (indices && indices.length > 1 && ignoreIndicesMap) {
      indices = indices.filter(function(index2) {
        return !ignoreIndicesMap[index2];
      });
    }
    return indices && indices[0] >= 0 ? indices[0] : -1;
  },
  _indexOfSelectedItemKey: function(key, ignoreIndicesMap) {
    var selectedIndex;
    if (this.options.equalByReference) {
      selectedIndex = this.options.selectedItemKeys.indexOf(key);
    } else if (isObject$1(key)) {
      selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
    } else {
      selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
    }
    return selectedIndex;
  },
  _shiftSelectedKeyIndices: function(keyIndex) {
    for (var currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
      var currentKey = this.options.selectedItemKeys[currentKeyIndex];
      var currentKeyHash = getKeyHash(currentKey);
      var currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
      if (!currentKeyIndices) {
        continue;
      }
      for (var i = 0; i < currentKeyIndices.length; i++) {
        if (currentKeyIndices[i] > keyIndex) {
          currentKeyIndices[i]--;
        }
      }
    }
  },
  removeSelectedItem: function(key, keyIndicesToRemoveMap) {
    var keyHash = this._getKeyHash(key);
    var isBatchDeselect = !!keyIndicesToRemoveMap;
    var keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
    if (keyIndex < 0) {
      return keyIndex;
    }
    this.options.removedItemKeys.push(key);
    this.options.removedItems.push(this.options.selectedItems[keyIndex]);
    if (isBatchDeselect) {
      return keyIndex;
    }
    this.options.selectedItemKeys.splice(keyIndex, 1);
    this.options.selectedItems.splice(keyIndex, 1);
    if (isObject$1(keyHash) || !this.options.keyHashIndices) {
      return keyIndex;
    }
    var keyIndices = this.options.keyHashIndices[keyHash];
    if (!keyIndices) {
      return keyIndex;
    }
    keyIndices.shift();
    if (!keyIndices.length) {
      delete this.options.keyHashIndices[keyHash];
    }
    this._shiftSelectedKeyIndices(keyIndex);
    return keyIndex;
  },
  _updateAddedItemKeys: function(keys2, items) {
    for (var i = 0; i < keys2.length; i++) {
      if (!this.isItemKeySelected(keys2[i])) {
        this.options.addedItemKeys.push(keys2[i]);
        this.options.addedItems.push(items[i]);
      }
    }
  },
  _updateRemovedItemKeys: function(keys2, oldSelectedKeys, oldSelectedItems) {
    for (var i = 0; i < oldSelectedKeys.length; i++) {
      if (!this.isItemKeySelected(oldSelectedKeys[i])) {
        this.options.removedItemKeys.push(oldSelectedKeys[i]);
        this.options.removedItems.push(oldSelectedItems[i]);
      }
    }
  },
  _isItemSelectionInProgress: function(key, checkPending) {
    var shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
    if (shouldCheckPending) {
      var _this$_lastRequestDat3;
      return ((_this$_lastRequestDat3 = this._lastRequestData.addedItems) === null || _this$_lastRequestDat3 === void 0 ? void 0 : _this$_lastRequestDat3.indexOf(key)) !== -1;
    } else {
      return false;
    }
  },
  _getKeyHash: function(key) {
    return this.options.equalByReference ? key : getKeyHash(key);
  },
  setSelectedItems: function(keys2, items) {
    this._updateAddedItemKeys(keys2, items);
    var oldSelectedKeys = this.options.selectedItemKeys;
    var oldSelectedItems = this.options.selectedItems;
    if (!this.options.equalByReference) {
      this._initSelectedItemKeyHash();
      this.updateSelectedItemKeyHash(keys2);
    }
    this._setOption("selectedItemKeys", keys2);
    this._setOption("selectedItems", items);
    this._updateRemovedItemKeys(keys2, oldSelectedKeys, oldSelectedItems);
  },
  isItemDataSelected: function(itemData) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var key = this.options.keyOf(itemData);
    return this.isItemKeySelected(key, options);
  },
  isItemKeySelected: function(key) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var result = this._isItemSelectionInProgress(key, options.checkPending);
    if (!result) {
      var keyHash = this._getKeyHash(key);
      var index2 = this._indexOfSelectedItemKey(keyHash);
      result = index2 !== -1;
    }
    return result;
  },
  getSelectAllState: function(visibleOnly) {
    if (visibleOnly) {
      return this._getVisibleSelectAllState();
    } else {
      return this._getFullSelectAllState();
    }
  }
});
var Selection = classImpl.inherit({
  ctor: function(options) {
    this.options = extend(this._getDefaultOptions(), options, {
      selectedItemKeys: options.selectedKeys || []
    });
    this._selectionStrategy = this.options.deferred ? new deferredStrategy(this.options) : new standardStrategy(this.options);
    this._focusedItemIndex = -1;
    if (!this.options.equalByReference) {
      this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
    }
  },
  _getDefaultOptions: function() {
    return {
      allowNullValue: false,
      deferred: false,
      equalByReference: false,
      mode: "multiple",
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: noop,
      key: noop,
      keyOf: function(item) {
        return item;
      },
      load: function() {
        return new Deferred().resolve([]);
      },
      totalCount: function() {
        return -1;
      },
      isSelectableItem: function() {
        return true;
      },
      isItemSelected: function() {
        return false;
      },
      getItemData: function(item) {
        return item;
      },
      dataFields: noop,
      filter: noop
    };
  },
  validate: function() {
    this._selectionStrategy.validate();
  },
  getSelectedItemKeys: function() {
    return this._selectionStrategy.getSelectedItemKeys();
  },
  getSelectedItems: function() {
    return this._selectionStrategy.getSelectedItems();
  },
  selectionFilter: function(value2) {
    if (value2 === void 0) {
      return this.options.selectionFilter;
    }
    var filterIsChanged = this.options.selectionFilter !== value2 && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value2);
    this.options.selectionFilter = value2;
    filterIsChanged && this.onSelectionChanged();
  },
  setSelection: function(keys2, updatedKeys) {
    return this.selectedItemKeys(keys2, false, false, false, updatedKeys);
  },
  select: function(keys2) {
    return this.selectedItemKeys(keys2, true);
  },
  deselect: function(keys2) {
    return this.selectedItemKeys(keys2, true, true);
  },
  selectedItemKeys: function(keys2, preserve, isDeselect, isSelectAll, updatedKeys) {
    var _keys;
    keys2 = (_keys = keys2) !== null && _keys !== void 0 ? _keys : [];
    keys2 = Array.isArray(keys2) ? keys2 : [keys2];
    this.validate();
    return this._selectionStrategy.selectedItemKeys(keys2, preserve, isDeselect, isSelectAll, updatedKeys);
  },
  clearSelection: function() {
    return this.selectedItemKeys([]);
  },
  _addSelectedItem: function(itemData, key) {
    this._selectionStrategy.addSelectedItem(key, itemData);
  },
  _removeSelectedItem: function(key) {
    this._selectionStrategy.removeSelectedItem(key);
  },
  _setSelectedItems: function(keys2, items) {
    this._selectionStrategy.setSelectedItems(keys2, items);
  },
  onSelectionChanged: function() {
    this._selectionStrategy.onSelectionChanged();
  },
  changeItemSelection: function(itemIndex, keys2) {
    var isSelectedItemsChanged;
    var items = this.options.plainItems();
    var item = items[itemIndex];
    if (!this.isSelectable() || !this.isDataItem(item)) {
      return false;
    }
    var itemData = this.options.getItemData(item);
    var itemKey = this.options.keyOf(itemData);
    keys2 = keys2 || {};
    if (keys2.shift && this.options.mode === "multiple" && this._focusedItemIndex >= 0) {
      isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items);
    } else if (keys2.control) {
      this._resetItemSelectionWhenShiftKeyPressed();
      var isSelected = this._selectionStrategy.isItemDataSelected(itemData);
      if (this.options.mode === "single") {
        this.clearSelectedItems();
      }
      if (isSelected) {
        this._removeSelectedItem(itemKey);
      } else {
        this._addSelectedItem(itemData, itemKey);
      }
      isSelectedItemsChanged = true;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();
      var isKeysEqual2 = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
      if (this.options.selectedItemKeys.length !== 1 || !isKeysEqual2) {
        this._setSelectedItems([itemKey], [itemData]);
        isSelectedItemsChanged = true;
      }
    }
    if (isSelectedItemsChanged) {
      this._focusedItemIndex = itemIndex;
      this.onSelectionChanged();
      return true;
    }
  },
  isDataItem: function(item) {
    return this.options.isSelectableItem(item);
  },
  isSelectable: function() {
    return this.options.mode === "single" || this.options.mode === "multiple";
  },
  isItemDataSelected: function(data2) {
    return this._selectionStrategy.isItemDataSelected(data2, {
      checkPending: true
    });
  },
  isItemSelected: function(arg, options) {
    return this._selectionStrategy.isItemKeySelected(arg, options);
  },
  _resetItemSelectionWhenShiftKeyPressed: function() {
    delete this._shiftFocusedItemIndex;
  },
  _resetFocusedItemIndex: function() {
    this._focusedItemIndex = -1;
  },
  changeItemSelectionWhenShiftKeyPressed: function(itemIndex, items) {
    var isSelectedItemsChanged = false;
    var itemIndexStep;
    var index2;
    var keyOf = this.options.keyOf;
    var focusedItem = items[this._focusedItemIndex];
    var focusedData = this.options.getItemData(focusedItem);
    var focusedKey = keyOf(focusedData);
    var isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
    if (!isDefined(this._shiftFocusedItemIndex)) {
      this._shiftFocusedItemIndex = this._focusedItemIndex;
    }
    var data2;
    var itemKey;
    if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
      itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      for (index2 = this._focusedItemIndex; index2 !== this._shiftFocusedItemIndex; index2 += itemIndexStep) {
        if (this.isDataItem(items[index2])) {
          itemKey = keyOf(this.options.getItemData(items[index2]));
          this._removeSelectedItem(itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if (itemIndex !== this._shiftFocusedItemIndex) {
      itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      for (index2 = itemIndex; index2 !== this._shiftFocusedItemIndex; index2 += itemIndexStep) {
        if (this.isDataItem(items[index2])) {
          data2 = this.options.getItemData(items[index2]);
          itemKey = keyOf(data2);
          this._addSelectedItem(data2, itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if (this.isDataItem(focusedItem) && !isFocusedItemSelected) {
      this._addSelectedItem(focusedData, focusedKey);
      isSelectedItemsChanged = true;
    }
    return isSelectedItemsChanged;
  },
  clearSelectedItems: function() {
    this._setSelectedItems([], []);
  },
  selectAll: function(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._onePageSelectAll(false);
    } else {
      return this.selectedItemKeys([], true, false, true);
    }
  },
  deselectAll: function(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._onePageSelectAll(true);
    } else {
      return this.selectedItemKeys([], true, true, true);
    }
  },
  _onePageSelectAll: function(isDeselect) {
    var items = this._selectionStrategy.getSelectableItems(this.options.plainItems());
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (this.isDataItem(item)) {
        var itemData = this.options.getItemData(item);
        var itemKey = this.options.keyOf(itemData);
        var isSelected = this.isItemSelected(itemKey);
        if (!isSelected && !isDeselect) {
          this._addSelectedItem(itemData, itemKey);
        }
        if (isSelected && isDeselect) {
          this._removeSelectedItem(itemKey);
        }
      }
    }
    this.onSelectionChanged();
    return new Deferred().resolve();
  },
  getSelectAllState: function(visibleOnly) {
    return this._selectionStrategy.getSelectAllState(visibleOnly);
  }
});
var ITEM_DELETING_DATA_KEY = "dxItemDeleting";
var NOT_EXISTING_INDEX = -1;
var indexExists = function(index2) {
  return index2 !== NOT_EXISTING_INDEX;
};
var CollectionWidget$1 = CollectionWidget$2.inherit({
  _setOptionsByReference: function() {
    this.callBase();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      selectionMode: "none",
      selectionRequired: false,
      selectionByClick: true,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: NOT_EXISTING_INDEX,
      selectedItem: null,
      onSelectionChanged: null,
      onItemReordered: null,
      onItemDeleting: null,
      onItemDeleted: null
    });
  },
  ctor: function(element, options) {
    this._userOptions = options || {};
    this.callBase(element, options);
  },
  _init: function() {
    this._initEditStrategy();
    this.callBase();
    this._initKeyGetter();
    this._initSelectionModule();
  },
  _initKeyGetter: function() {
    this._keyGetter = compileGetter(this.option("keyExpr"));
  },
  _getKeysByItems: function(selectedItems) {
    return this._editStrategy.getKeysByItems(selectedItems);
  },
  _getItemsByKeys: function(selectedItemKeys, selectedItems) {
    return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
  },
  _getKeyByIndex: function(index2) {
    return this._editStrategy.getKeyByIndex(index2);
  },
  _getIndexByKey: function(key) {
    return this._editStrategy.getIndexByKey(key);
  },
  _getIndexByItemData: function(itemData) {
    return this._editStrategy.getIndexByItemData(itemData);
  },
  _isKeySpecified: function() {
    return !!(this._dataSource && this._dataSource.key());
  },
  _getCombinedFilter: function() {
    return this._dataSource && this._dataSource.filter();
  },
  key: function() {
    if (this.option("keyExpr")) {
      return this.option("keyExpr");
    }
    return this._dataSource && this._dataSource.key();
  },
  keyOf: function(item) {
    var key = item;
    var store = this._dataSource && this._dataSource.store();
    if (this.option("keyExpr")) {
      key = this._keyGetter(item);
    } else if (store) {
      key = store.keyOf(item);
    }
    return key;
  },
  _nullValueSelectionSupported: function() {
    return false;
  },
  _initSelectionModule: function() {
    var that = this;
    var itemsGetter = that._editStrategy.itemsGetter;
    this._selection = new Selection({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option("selectionMode"),
      maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanged: function(args) {
        if (args.addedItemKeys.length || args.removedItemKeys.length) {
          that.option("selectedItems", that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
          that._updateSelectedItems(args);
        }
      },
      filter: that._getCombinedFilter.bind(that),
      totalCount: function() {
        var items = that.option("items");
        var dataSource = that._dataSource;
        return dataSource && dataSource.totalCount() >= 0 ? dataSource.totalCount() : items.length;
      },
      key: that.key.bind(that),
      keyOf: that.keyOf.bind(that),
      load: function(options) {
        if (that._dataSource) {
          var loadOptions = that._dataSource.loadOptions();
          options.customQueryParams = loadOptions.customQueryParams;
          options.userData = that._dataSource._userData;
        }
        var store = that._dataSource && that._dataSource.store();
        if (store) {
          return store.load(options).done(function(loadResult) {
            if (that._disposed) {
              return;
            }
            var items = normalizeLoadResult(loadResult).data;
            that._dataSource._applyMapFunction(items);
          });
        } else {
          return new Deferred().resolve(this.plainItems());
        }
      },
      dataFields: function() {
        return that._dataSource && that._dataSource.select();
      },
      plainItems: itemsGetter.bind(that._editStrategy)
    });
  },
  _initEditStrategy: function() {
    var Strategy = PlainEditStrategy;
    this._editStrategy = new Strategy(this);
  },
  _getSelectedItemIndices: function(keys2) {
    var that = this;
    var indices = [];
    keys2 = keys2 || this._selection.getSelectedItemKeys();
    that._editStrategy.beginCache();
    each(keys2, function(_2, key) {
      var selectedIndex = that._getIndexByKey(key);
      if (indexExists(selectedIndex)) {
        indices.push(selectedIndex);
      }
    });
    that._editStrategy.endCache();
    return indices;
  },
  _initMarkup: function() {
    this._rendering = true;
    if (!this._dataSource || !this._dataSource.isLoading()) {
      this._syncSelectionOptions().done(() => this._normalizeSelectedItems());
    }
    this.callBase();
  },
  _render: function() {
    this.callBase();
    this._rendering = false;
  },
  _fireContentReadyAction: function() {
    this._rendering = false;
    this._rendered = true;
    this.callBase.apply(this, arguments);
  },
  _syncSelectionOptions: function(byOption) {
    byOption = byOption || this._chooseSelectOption();
    var selectedItem;
    var selectedIndex;
    var selectedItemKeys;
    var selectedItems;
    switch (byOption) {
      case "selectedIndex":
        selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedItem", selectedItem);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedItem", null);
        }
        break;
      case "selectedItems":
        selectedItems = this.option("selectedItems") || [];
        selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : NOT_EXISTING_INDEX;
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
        this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
        this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
        break;
      case "selectedItem":
        selectedItem = this.option("selectedItem");
        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedIndex", NOT_EXISTING_INDEX);
        }
        break;
      case "selectedItemKeys":
        selectedItemKeys = this.option("selectedItemKeys");
        if (this.option("selectionRequired")) {
          var selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
          if (!indexExists(selectedItemIndex)) {
            return this._syncSelectionOptions("selectedIndex");
          }
        }
        return this._selection.setSelection(selectedItemKeys);
    }
    return new Deferred().resolve().promise();
  },
  _chooseSelectOption: function() {
    var optionName = "selectedIndex";
    var isOptionDefined = function(optionName2) {
      var optionValue = this.option(optionName2);
      var length = isDefined(optionValue) && optionValue.length;
      return length || optionName2 in this._userOptions;
    }.bind(this);
    if (isOptionDefined("selectedItems")) {
      optionName = "selectedItems";
    } else if (isOptionDefined("selectedItem")) {
      optionName = "selectedItem";
    } else if (isOptionDefined("selectedItemKeys")) {
      optionName = "selectedItemKeys";
    }
    return optionName;
  },
  _compareKeys: function(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
      return false;
    }
    for (var i = 0; i < newKeys.length; i++) {
      if (oldKeys[i] !== newKeys[i]) {
        return false;
      }
    }
    return true;
  },
  _normalizeSelectedItems: function() {
    if (this.option("selectionMode") === "none") {
      this._setOptionWithoutOptionChange("selectedItems", []);
      this._syncSelectionOptions("selectedItems");
    } else if (this.option("selectionMode") === "single") {
      var newSelection = this.option("selectedItems");
      if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
        var currentSelection = this._selection.getSelectedItems();
        var normalizedSelection = newSelection[0] === void 0 ? currentSelection[0] : newSelection[0];
        if (normalizedSelection === void 0) {
          normalizedSelection = this._editStrategy.itemsGetter()[0];
        }
        if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
          normalizedSelection.items = [normalizedSelection.items[0]];
        }
        this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
        this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
        return this._syncSelectionOptions("selectedItems");
      } else {
        this._selection.setSelection(this._getKeysByItems(newSelection));
      }
    } else {
      var newKeys = this._getKeysByItems(this.option("selectedItems"));
      var oldKeys = this._selection.getSelectedItemKeys();
      if (!this._compareKeys(oldKeys, newKeys)) {
        this._selection.setSelection(newKeys);
      }
    }
    return new Deferred().resolve().promise();
  },
  _itemClickHandler: function(e) {
    this._createAction(function(e2) {
      this._itemSelectHandler(e2.event);
    }.bind(this), {
      validatingTargetName: "itemElement"
    })({
      itemElement: $(e.currentTarget),
      event: e
    });
    this.callBase.apply(this, arguments);
  },
  _itemSelectHandler: function(e) {
    if (!this.option("selectionByClick")) {
      return;
    }
    var $itemElement = e.currentTarget;
    if (this.isItemSelected($itemElement)) {
      this.unselectItem(e.currentTarget);
    } else {
      this.selectItem(e.currentTarget);
    }
  },
  _selectedItemElement: function(index2) {
    return this._itemElements().eq(index2);
  },
  _postprocessRenderItem: function(args) {
    if (this.option("selectionMode") !== "none") {
      var $itemElement = $(args.itemElement);
      var normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
      var isItemSelected = this._isItemSelected(normalizedItemIndex);
      this._processSelectableItem($itemElement, isItemSelected);
    }
  },
  _processSelectableItem: function($itemElement, isSelected) {
    $itemElement.toggleClass(this._selectedItemClass(), isSelected);
    this._setAriaSelected($itemElement, String(isSelected));
  },
  _updateSelectedItems: function(args) {
    var that = this;
    var addedItemKeys = args.addedItemKeys;
    var removedItemKeys = args.removedItemKeys;
    if (that._rendered && (addedItemKeys.length || removedItemKeys.length)) {
      var selectionChangePromise = that._selectionChangePromise;
      if (!that._rendering) {
        var addedSelection = [];
        var normalizedIndex;
        var removedSelection = [];
        that._editStrategy.beginCache();
        for (var i = 0; i < addedItemKeys.length; i++) {
          normalizedIndex = that._getIndexByKey(addedItemKeys[i]);
          addedSelection.push(normalizedIndex);
          that._addSelection(normalizedIndex);
        }
        for (var _i = 0; _i < removedItemKeys.length; _i++) {
          normalizedIndex = that._getIndexByKey(removedItemKeys[_i]);
          removedSelection.push(normalizedIndex);
          that._removeSelection(normalizedIndex);
        }
        that._editStrategy.endCache();
        that._updateSelection(addedSelection, removedSelection);
      }
      when(selectionChangePromise).done(function() {
        that._fireSelectionChangeEvent(args.addedItems, args.removedItems);
      });
    }
  },
  _fireSelectionChangeEvent: function(addedItems, removedItems) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems,
      removedItems
    });
  },
  _updateSelection: noop,
  _setAriaSelected: function($target, value2) {
    this.setAria("selected", value2, $target);
  },
  _removeSelection: function(normalizedIndex) {
    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, false);
      eventsEngine.triggerHandler($itemElement, "stateChanged", false);
    }
  },
  _addSelection: function(normalizedIndex) {
    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, true);
      eventsEngine.triggerHandler($itemElement, "stateChanged", true);
    }
  },
  _isItemSelected: function(index2) {
    var key = this._getKeyByIndex(index2);
    return this._selection.isItemSelected(key, {
      checkPending: true
    });
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "selectionMode":
        this._invalidate();
        break;
      case "dataSource":
        if (!args.value || Array.isArray(args.value) && !args.value.length) {
          this.option("selectedItemKeys", []);
        }
        this.callBase(args);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
      case "selectedItemKeys":
        this._syncSelectionOptions(args.name).done(() => this._normalizeSelectedItems());
        break;
      case "keyExpr":
        this._initKeyGetter();
        break;
      case "selectionRequired":
        this._normalizeSelectedItems();
        break;
      case "selectionByClick":
      case "onSelectionChanged":
      case "onItemDeleting":
      case "onItemDeleted":
      case "onItemReordered":
      case "maxFilterLengthInRequest":
        break;
      default:
        this.callBase(args);
    }
  },
  _clearSelectedItems: function() {
    this._setOptionWithoutOptionChange("selectedItems", []);
    this._syncSelectionOptions("selectedItems");
  },
  _waitDeletingPrepare: function($itemElement) {
    if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
      return new Deferred().resolve().promise();
    }
    $itemElement.data(ITEM_DELETING_DATA_KEY, true);
    var deferred = new Deferred();
    var deletingActionArgs = {
      cancel: false
    };
    var deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
      excludeValidators: ["disabled", "readOnly"]
    });
    when(deletePromise).always(function(value2) {
      var deletePromiseExists = !deletePromise;
      var deletePromiseResolved = !deletePromiseExists && deletePromise.state() === "resolved";
      var argumentsSpecified = !!arguments.length;
      var shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value2;
      when(fromPromise(deletingActionArgs.cancel)).always(function() {
        $itemElement.data(ITEM_DELETING_DATA_KEY, false);
      }).done(function(cancel2) {
        shouldDelete && !cancel2 ? deferred.resolve() : deferred.reject();
      }).fail(deferred.reject);
    }.bind(this));
    return deferred.promise();
  },
  _deleteItemFromDS: function($item) {
    if (!this._dataSource) {
      return new Deferred().resolve().promise();
    }
    var deferred = new Deferred();
    var disabledState = this.option("disabled");
    var dataStore = this._dataSource.store();
    this.option("disabled", true);
    if (!dataStore.remove) {
      throw errors$1.Error("E1011");
    }
    dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
      if (key !== void 0) {
        deferred.resolve();
      } else {
        deferred.reject();
      }
    }).fail(function() {
      deferred.reject();
    });
    deferred.always(function() {
      this.option("disabled", disabledState);
    }.bind(this));
    return deferred;
  },
  _tryRefreshLastPage: function() {
    var deferred = new Deferred();
    if (this._isLastPage() || this.option("grouped")) {
      deferred.resolve();
    } else {
      this._refreshLastPage().done(function() {
        deferred.resolve();
      });
    }
    return deferred.promise();
  },
  _refreshLastPage: function() {
    this._expectLastItemLoading();
    return this._dataSource.load();
  },
  _updateSelectionAfterDelete: function(index2) {
    var key = this._getKeyByIndex(index2);
    this._selection.deselect([key]);
  },
  _updateIndicesAfterIndex: function(index2) {
    var itemElements = this._itemElements();
    for (var i = index2 + 1; i < itemElements.length; i++) {
      $(itemElements[i]).data(this._itemIndexKey(), i - 1);
    }
  },
  _simulateOptionChange: function(optionName) {
    var optionValue = this.option(optionName);
    if (optionValue instanceof DataSource) {
      return;
    }
    this._optionChangedAction({
      name: optionName,
      fullName: optionName,
      value: optionValue
    });
  },
  isItemSelected: function(itemElement) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
  },
  selectItem: function(itemElement) {
    if (this.option("selectionMode") === "none") {
      return;
    }
    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    var key = this._getKeyByIndex(itemIndex);
    if (this._selection.isItemSelected(key)) {
      return;
    }
    if (this.option("selectionMode") === "single") {
      this._selection.setSelection([key]);
    } else {
      var selectedItemKeys = this.option("selectedItemKeys") || [];
      this._selection.setSelection([...selectedItemKeys, key], [key]);
    }
  },
  unselectItem: function(itemElement) {
    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    var selectedItemKeys = this._selection.getSelectedItemKeys();
    if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
      return;
    }
    var key = this._getKeyByIndex(itemIndex);
    if (!this._selection.isItemSelected(key, {
      checkPending: true
    })) {
      return;
    }
    this._selection.deselect([key]);
  },
  _deleteItemElementByIndex: function(index2) {
    this._updateSelectionAfterDelete(index2);
    this._updateIndicesAfterIndex(index2);
    this._editStrategy.deleteItemAtIndex(index2);
  },
  _afterItemElementDeleted: function($item, deletedActionArgs) {
    var changingOption = this._dataSource ? "dataSource" : "items";
    this._simulateOptionChange(changingOption);
    this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
      beforeExecute: function() {
        $item.remove();
      },
      excludeValidators: ["disabled", "readOnly"]
    });
    this._renderEmptyMessage();
  },
  deleteItem: function(itemElement) {
    var that = this;
    var deferred = new Deferred();
    var $item = this._editStrategy.getItemElement(itemElement);
    var index2 = this._editStrategy.getNormalizedIndex(itemElement);
    var itemResponseWaitClass = this._itemResponseWaitClass();
    if (indexExists(index2)) {
      this._waitDeletingPrepare($item).done(function() {
        $item.addClass(itemResponseWaitClass);
        var deletedActionArgs = that._extendActionArgs($item);
        that._deleteItemFromDS($item).done(function() {
          that._deleteItemElementByIndex(index2);
          that._afterItemElementDeleted($item, deletedActionArgs);
          that._tryRefreshLastPage().done(function() {
            deferred.resolveWith(that);
          });
        }).fail(function() {
          $item.removeClass(itemResponseWaitClass);
          deferred.rejectWith(that);
        });
      }).fail(function() {
        deferred.rejectWith(that);
      });
    } else {
      deferred.rejectWith(that);
    }
    return deferred.promise();
  },
  reorderItem: function(itemElement, toItemElement) {
    var deferred = new Deferred();
    var that = this;
    var strategy2 = this._editStrategy;
    var $movingItem = strategy2.getItemElement(itemElement);
    var $destinationItem = strategy2.getItemElement(toItemElement);
    var movingIndex = strategy2.getNormalizedIndex(itemElement);
    var destinationIndex = strategy2.getNormalizedIndex(toItemElement);
    var changingOption = this._dataSource ? "dataSource" : "items";
    var canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
    if (canMoveItems) {
      deferred.resolveWith(this);
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise().done(function() {
      $destinationItem[strategy2.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
      strategy2.moveItemAtIndexToIndex(movingIndex, destinationIndex);
      this._updateIndicesAfterIndex(movingIndex);
      that.option("selectedItems", that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));
      if (changingOption === "items") {
        that._simulateOptionChange(changingOption);
      }
      that._itemEventHandler($movingItem, "onItemReordered", {
        fromIndex: strategy2.getIndex(movingIndex),
        toIndex: strategy2.getIndex(destinationIndex)
      }, {
        excludeValidators: ["disabled", "readOnly"]
      });
    });
  }
});
var AsyncCollectionWidget = CollectionWidget$1.inherit({
  _initMarkup() {
    this._deferredItems = [];
    this.callBase();
  },
  _renderItemContent(args) {
    var renderContentDeferred = new Deferred();
    var itemDeferred = new Deferred();
    this._deferredItems[args.index] = itemDeferred;
    var $itemContent = this.callBase.call(this, args);
    itemDeferred.done(() => {
      renderContentDeferred.resolve($itemContent);
    });
    return renderContentDeferred.promise();
  },
  _createItemByTemplate(itemTemplate, renderArgs) {
    return itemTemplate.render({
      model: renderArgs.itemData,
      container: renderArgs.container,
      index: renderArgs.index,
      onRendered: () => {
        this._deferredItems[renderArgs.index].resolve();
      }
    });
  },
  _postProcessRenderItems: noop,
  _renderItemsAsync() {
    var d = new Deferred();
    when.apply(this, this._deferredItems).done(() => {
      this._postProcessRenderItems();
      d.resolve();
    });
    return d.promise();
  },
  _clean() {
    this.callBase();
    this._deferredItems = [];
  }
});
var TOOLBAR_CLASS = "dx-toolbar";
var TOOLBAR_BEFORE_CLASS = "dx-toolbar-before";
var TOOLBAR_CENTER_CLASS = "dx-toolbar-center";
var TOOLBAR_AFTER_CLASS = "dx-toolbar-after";
var TOOLBAR_MINI_CLASS = "dx-toolbar-mini";
var TOOLBAR_ITEM_CLASS = "dx-toolbar-item";
var TOOLBAR_LABEL_CLASS = "dx-toolbar-label";
var TOOLBAR_BUTTON_CLASS = "dx-toolbar-button";
var TOOLBAR_ITEMS_CONTAINER_CLASS = "dx-toolbar-items-container";
var TOOLBAR_GROUP_CLASS = "dx-toolbar-group";
var TOOLBAR_COMPACT_CLASS = "dx-toolbar-compact";
var TOOLBAR_LABEL_SELECTOR = "." + TOOLBAR_LABEL_CLASS;
var TOOLBAR_MULTILINE_CLASS = "dx-toolbar-multiline";
var TEXT_BUTTON_MODE = "text";
var DEFAULT_BUTTON_TYPE = "default";
var TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
var ToolbarBase = AsyncCollectionWidget.inherit({
  compactMode: false,
  ctor: function(element, options) {
    this._userOptions = options || {};
    this.callBase(element, options);
    if ("height" in this._userOptions) {
      errors$2.log("W0001", this.NAME, "height", "20.1", "Functionality associated with this option is not intended for the Toolbar widget.");
    }
  },
  _getSynchronizableOptionsForCreateComponent: function() {
    return this.callBase().filter((item) => item !== "disabled");
  },
  _initTemplates: function() {
    this.callBase();
    var template = new BindableTemplate(function($container, data2, rawModel) {
      if (isPlainObject(data2)) {
        if (data2.text) {
          $container.text(data2.text).wrapInner("<div>");
        }
        if (data2.html) {
          $container.html(data2.html);
        }
        if (data2.widget === "dxButton") {
          if (this.option("useFlatButtons")) {
            data2.options = data2.options || {};
            data2.options.stylingMode = data2.options.stylingMode || TEXT_BUTTON_MODE;
          }
          if (this.option("useDefaultButtons")) {
            data2.options = data2.options || {};
            data2.options.type = data2.options.type || DEFAULT_BUTTON_TYPE;
          }
        }
      } else {
        $container.text(String(data2));
      }
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: rawModel,
        parent: this
      });
    }.bind(this), ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
    this._templateManager.addDefaultTemplates({
      item: template,
      menuItem: template
    });
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      renderAs: "topToolbar",
      grouped: false,
      useFlatButtons: false,
      useDefaultButtons: false,
      multiline: false
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function() {
        return isMaterial();
      },
      options: {
        useFlatButtons: true
      }
    }]);
  },
  _itemContainer: function() {
    return this._$toolbarItemsContainer.find(["." + TOOLBAR_BEFORE_CLASS, "." + TOOLBAR_CENTER_CLASS, "." + TOOLBAR_AFTER_CLASS].join(","));
  },
  _itemClass: function() {
    return TOOLBAR_ITEM_CLASS;
  },
  _itemDataKey: function() {
    return TOOLBAR_ITEM_DATA_KEY;
  },
  _buttonClass: function() {
    return TOOLBAR_BUTTON_CLASS;
  },
  _dimensionChanged: function() {
    this._arrangeItems();
    this._applyCompactMode();
  },
  _initMarkup: function() {
    this._renderToolbar();
    this._renderSections();
    this.callBase();
    this.setAria("role", "toolbar");
  },
  _waitParentAnimationFinished: function() {
    var $element = this.$element();
    return new Promise$3((resolve) => {
      var runCheck = () => {
        clearTimeout(this._waitParentAnimationTimeout);
        this._waitParentAnimationTimeout = setTimeout(() => (() => {
          var readyToResolve = true;
          $element.parents().each((_2, parent) => {
            if (fx.isAnimating($(parent))) {
              readyToResolve = false;
              return false;
            }
          });
          if (readyToResolve) {
            resolve();
          }
          return readyToResolve;
        })() || runCheck(), 15);
      };
      runCheck();
    });
  },
  _render: function() {
    this.callBase();
    this._renderItemsAsync();
    if (isMaterial()) {
      Promise$3.all([this._waitParentAnimationFinished(), this._checkWebFontForLabelsLoaded()]).then(this._dimensionChanged.bind(this));
    }
  },
  _postProcessRenderItems: function() {
    this._arrangeItems();
  },
  _renderToolbar: function() {
    this.$element().addClass(TOOLBAR_CLASS).toggleClass(TOOLBAR_MULTILINE_CLASS, this.option("multiline"));
    this._$toolbarItemsContainer = $("<div>").addClass(TOOLBAR_ITEMS_CONTAINER_CLASS).appendTo(this.$element());
  },
  _renderSections: function() {
    var $container = this._$toolbarItemsContainer;
    var that = this;
    each(["before", "center", "after"], function() {
      var sectionClass = "dx-toolbar-" + this;
      var $section = $container.find("." + sectionClass);
      if (!$section.length) {
        that["_$" + this + "Section"] = $section = $("<div>").addClass(sectionClass).appendTo($container);
      }
    });
  },
  _checkWebFontForLabelsLoaded: function() {
    var $labels = this.$element().find(TOOLBAR_LABEL_SELECTOR);
    var promises = [];
    $labels.each((_2, label) => {
      var text = $(label).text();
      var fontWeight = $(label).css("fontWeight");
      promises.push(waitWebFont(text, fontWeight));
    });
    return Promise$3.all(promises);
  },
  _arrangeItems: function(elementWidth) {
    elementWidth = elementWidth || this.$element().width();
    this._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    var beforeRect = getBoundingRect(this._$beforeSection.get(0));
    var afterRect = getBoundingRect(this._$afterSection.get(0));
    this._alignCenterSection(beforeRect, afterRect, elementWidth);
    var $label = this._$toolbarItemsContainer.find(TOOLBAR_LABEL_SELECTOR).eq(0);
    var $section = $label.parent();
    if (!$label.length) {
      return;
    }
    var labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;
    var widthBeforeSection = $section.hasClass(TOOLBAR_BEFORE_CLASS) ? 0 : labelOffset;
    var widthAfterSection = $section.hasClass(TOOLBAR_AFTER_CLASS) ? 0 : afterRect.width;
    var elemsAtSectionWidth = 0;
    $section.children().not(TOOLBAR_LABEL_SELECTOR).each(function() {
      elemsAtSectionWidth += $(this).outerWidth();
    });
    var freeSpace = elementWidth - elemsAtSectionWidth;
    var sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);
    if ($section.hasClass(TOOLBAR_BEFORE_CLASS)) {
      this._alignSection(this._$beforeSection, sectionMaxWidth);
    } else {
      var labelPaddings = $label.outerWidth() - $label.width();
      $label.css("maxWidth", sectionMaxWidth - labelPaddings);
    }
  },
  _alignCenterSection: function(beforeRect, afterRect, elementWidth) {
    this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);
    var isRTL = this.option("rtlEnabled");
    var leftRect = isRTL ? afterRect : beforeRect;
    var rightRect = isRTL ? beforeRect : afterRect;
    var centerRect = getBoundingRect(this._$centerSection.get(0));
    if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
      this._$centerSection.css({
        marginLeft: leftRect.width,
        marginRight: rightRect.width,
        float: leftRect.width > rightRect.width ? "none" : "right"
      });
    }
  },
  _alignSection: function($section, maxWidth) {
    var $labels = $section.find(TOOLBAR_LABEL_SELECTOR);
    var labels = $labels.toArray();
    maxWidth -= this._getCurrentLabelsPaddings(labels);
    var currentWidth = this._getCurrentLabelsWidth(labels);
    var difference = Math.abs(currentWidth - maxWidth);
    if (maxWidth < currentWidth) {
      labels = labels.reverse();
      this._alignSectionLabels(labels, difference, false);
    } else {
      this._alignSectionLabels(labels, difference, true);
    }
  },
  _alignSectionLabels: function(labels, difference, expanding) {
    var getRealLabelWidth = function(label) {
      return getBoundingRect(label).width;
    };
    for (var i = 0; i < labels.length; i++) {
      var $label = $(labels[i]);
      var currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));
      var labelMaxWidth = void 0;
      if (expanding) {
        $label.css("maxWidth", "inherit");
      }
      var possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);
      if (possibleLabelWidth < difference) {
        labelMaxWidth = expanding ? possibleLabelWidth : 0;
        difference -= possibleLabelWidth;
      } else {
        labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;
        $label.css("maxWidth", labelMaxWidth);
        break;
      }
      $label.css("maxWidth", labelMaxWidth);
    }
  },
  _applyCompactMode: function() {
    var $element = this.$element();
    $element.removeClass(TOOLBAR_COMPACT_CLASS);
    if (this.option("compactMode") && this._getSummaryItemsWidth(this.itemElements(), true) > $element.width()) {
      $element.addClass(TOOLBAR_COMPACT_CLASS);
    }
  },
  _getCurrentLabelsWidth: function(labels) {
    var width = 0;
    labels.forEach(function(label, index2) {
      width += $(label).outerWidth();
    });
    return width;
  },
  _getCurrentLabelsPaddings: function(labels) {
    var padding = 0;
    labels.forEach(function(label, index2) {
      padding += $(label).outerWidth() - $(label).width();
    });
    return padding;
  },
  _renderItem: function(index2, item, itemContainer, $after) {
    var location = item.location || "center";
    var container = itemContainer || this["_$" + location + "Section"];
    var itemHasText = !!(item.text || item.html);
    var itemElement = this.callBase(index2, item, container, $after);
    itemElement.toggleClass(this._buttonClass(), !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText).addClass(item.cssClass);
    return itemElement;
  },
  _renderGroupedItems: function() {
    var that = this;
    each(this.option("items"), function(groupIndex, group) {
      var groupItems = group.items;
      var $container = $("<div>").addClass(TOOLBAR_GROUP_CLASS);
      var location = group.location || "center";
      if (!groupItems || !groupItems.length) {
        return;
      }
      each(groupItems, function(itemIndex, item) {
        that._renderItem(itemIndex, item, $container, null);
      });
      that._$toolbarItemsContainer.find(".dx-toolbar-" + location).append($container);
    });
  },
  _renderItems: function(items) {
    var grouped = this.option("grouped") && items.length && items[0].items;
    grouped ? this._renderGroupedItems() : this.callBase(items);
  },
  _getToolbarItems: function() {
    return this.option("items") || [];
  },
  _renderContentImpl: function() {
    var items = this._getToolbarItems();
    this.$element().toggleClass(TOOLBAR_MINI_CLASS, items.length === 0);
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
    this._applyCompactMode();
  },
  _renderEmptyMessage: noop,
  _clean: function() {
    this._$toolbarItemsContainer.children().empty();
    this.$element().empty();
  },
  _visibilityChanged: function(visible2) {
    if (visible2) {
      this._arrangeItems();
    }
  },
  _isVisible: function() {
    return this.$element().width() > 0 && this.$element().height() > 0;
  },
  _getIndexByItem: function(item) {
    return inArray(item, this._getToolbarItems());
  },
  _itemOptionChanged: function(item, property, value2) {
    this.callBase.apply(this, [item, property, value2]);
    this._arrangeItems();
  },
  _optionChanged: function(args) {
    var name2 = args.name;
    switch (name2) {
      case "width":
        this.callBase.apply(this, arguments);
        this._dimensionChanged();
        break;
      case "multiline":
        this.$element().toggleClass(TOOLBAR_MULTILINE_CLASS, args.value);
        break;
      case "renderAs":
      case "useFlatButtons":
      case "useDefaultButtons":
        this._invalidate();
        break;
      case "compactMode":
        this._applyCompactMode();
        break;
      case "grouped":
        break;
      default:
        this.callBase.apply(this, arguments);
    }
  },
  _dispose: function() {
    this.callBase();
    clearTimeout(this._waitParentAnimationTimeout);
  }
});
registerComponent("dxToolbarBase", ToolbarBase);
var window$8 = getWindow();
var POPUP_CLASS = "dx-popup";
var POPUP_WRAPPER_CLASS = "dx-popup-wrapper";
var POPUP_FULL_SCREEN_CLASS = "dx-popup-fullscreen";
var POPUP_FULL_SCREEN_WIDTH_CLASS = "dx-popup-fullscreen-width";
var POPUP_NORMAL_CLASS = "dx-popup-normal";
var POPUP_CONTENT_CLASS = "dx-popup-content";
var POPUP_DRAGGABLE_CLASS = "dx-popup-draggable";
var POPUP_TITLE_CLASS = "dx-popup-title";
var POPUP_TITLE_CLOSEBUTTON_CLASS = "dx-closebutton";
var POPUP_BOTTOM_CLASS = "dx-popup-bottom";
var POPUP_HAS_CLOSE_BUTTON_CLASS = "dx-has-close-button";
var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var POPUP_CONTENT_FLEX_HEIGHT_CLASS = "dx-popup-flex-height";
var POPUP_CONTENT_INHERIT_HEIGHT_CLASS = "dx-popup-inherit-height";
var ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
var BUTTON_DEFAULT_TYPE = "default";
var BUTTON_NORMAL_TYPE = "normal";
var BUTTON_TEXT_MODE = "text";
var BUTTON_CONTAINED_MODE = "contained";
var IS_IE11 = coreBrowserUtils.msie && parseInt(coreBrowserUtils.version) === 11;
var IS_OLD_SAFARI = coreBrowserUtils.safari && compare(coreBrowserUtils.version, [11]) < 0;
var HEIGHT_STRATEGIES = {
  static: "",
  inherit: POPUP_CONTENT_INHERIT_HEIGHT_CLASS,
  flex: POPUP_CONTENT_FLEX_HEIGHT_CLASS
};
var getButtonPlace = (name2) => {
  var device = devices.current();
  var platform = device.platform;
  var toolbar = "bottom";
  var location = "before";
  if (platform === "ios") {
    switch (name2) {
      case "cancel":
        toolbar = "top";
        break;
      case "clear":
        toolbar = "top";
        location = "after";
        break;
      case "done":
        location = "after";
    }
  } else if (platform === "android" && device.version && parseInt(device.version[0]) > 4) {
    switch (name2) {
      case "cancel":
      case "done":
        location = "after";
    }
  }
  return {
    toolbar,
    location
  };
};
var Popup = Overlay.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      fullScreen: false,
      title: "",
      showTitle: true,
      titleTemplate: "title",
      onTitleRendered: null,
      dragEnabled: false,
      toolbarItems: [],
      showCloseButton: false,
      bottomTemplate: "bottom",
      useDefaultToolbarButtons: false,
      useFlatToolbarButtons: false,
      autoResizeEnabled: true
    });
  },
  _defaultOptionsRules: function() {
    var themeName = current();
    return this.callBase().concat([{
      device: {
        platform: "ios"
      },
      options: {
        animation: this._iosAnimation
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        animation: this._androidAnimation
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        showCloseButton: true
      }
    }, {
      device: function(_device) {
        return devices.real().deviceType === "desktop" && _device.platform === "generic";
      },
      options: {
        dragEnabled: true
      }
    }, {
      device: function() {
        return devices.real().deviceType === "desktop" && !devices.isSimulator();
      },
      options: {
        focusStateEnabled: true
      }
    }, {
      device: function() {
        return isMaterial(themeName);
      },
      options: {
        useDefaultToolbarButtons: true,
        useFlatToolbarButtons: true
      }
    }]);
  },
  _iosAnimation: {
    show: {
      type: "slide",
      duration: 400,
      from: {
        position: {
          my: "top",
          at: "bottom"
        }
      },
      to: {
        position: {
          my: "center",
          at: "center"
        }
      }
    },
    hide: {
      type: "slide",
      duration: 400,
      from: {
        opacity: 1,
        position: {
          my: "center",
          at: "center"
        }
      },
      to: {
        opacity: 1,
        position: {
          my: "top",
          at: "bottom"
        }
      }
    }
  },
  _androidAnimation: function() {
    return this.option("fullScreen") ? {
      show: {
        type: "slide",
        duration: 300,
        from: {
          top: "30%",
          opacity: 0
        },
        to: {
          top: 0,
          opacity: 1
        }
      },
      hide: {
        type: "slide",
        duration: 300,
        from: {
          top: 0,
          opacity: 1
        },
        to: {
          top: "30%",
          opacity: 0
        }
      }
    } : {
      show: {
        type: "fade",
        duration: 400,
        from: 0,
        to: 1
      },
      hide: {
        type: "fade",
        duration: 400,
        from: 1,
        to: 0
      }
    };
  },
  _init: function() {
    this.callBase();
    this.$element().addClass(POPUP_CLASS);
    this.$wrapper().addClass(POPUP_WRAPPER_CLASS);
    this._$popupContent = this._$content.wrapInner($("<div>").addClass(POPUP_CONTENT_CLASS)).children().eq(0);
  },
  _render: function() {
    var isFullscreen = this.option("fullScreen");
    this._toggleFullScreenClass(isFullscreen);
    this.callBase();
  },
  _toggleFullScreenClass: function(value2) {
    this.$overlayContent().toggleClass(POPUP_FULL_SCREEN_CLASS, value2).toggleClass(POPUP_NORMAL_CLASS, !value2);
  },
  _initTemplates: function() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      title: new EmptyTemplate(),
      bottom: new EmptyTemplate()
    });
  },
  _renderContentImpl: function() {
    this._renderTitle();
    this.callBase();
    this._renderBottom();
  },
  _renderTitle: function() {
    var items = this._getToolbarItems("top");
    var titleText = this.option("title");
    var showTitle = this.option("showTitle");
    if (showTitle && !!titleText) {
      items.unshift({
        location: devices.current().ios ? "center" : "before",
        text: titleText
      });
    }
    if (showTitle || items.length > 0) {
      this._$title && this._$title.remove();
      var $title = $("<div>").addClass(POPUP_TITLE_CLASS).insertBefore(this.$content());
      this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass(POPUP_TITLE_CLASS);
      this._renderDrag();
      this._executeTitleRenderAction(this._$title);
      this._$title.toggleClass(POPUP_HAS_CLOSE_BUTTON_CLASS, this._hasCloseButton());
    } else if (this._$title) {
      this._$title.detach();
    }
  },
  _renderTemplateByType: function(optionName, data2, $container, additionalToolbarOptions) {
    var template = this._getTemplateByOption(optionName);
    var toolbarTemplate = template instanceof EmptyTemplate;
    if (toolbarTemplate) {
      var integrationOptions = extend({}, this.option("integrationOptions"), {
        skipTemplates: ["content", "title"]
      });
      var toolbarOptions = extend(additionalToolbarOptions, {
        items: data2,
        rtlEnabled: this.option("rtlEnabled"),
        useDefaultButtons: this.option("useDefaultToolbarButtons"),
        useFlatButtons: this.option("useFlatToolbarButtons"),
        integrationOptions
      });
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: {
          widget: "dxToolbarBase",
          options: toolbarOptions
        }
      });
      var $toolbar = $container.children("div");
      $container.replaceWith($toolbar);
      return $toolbar;
    } else {
      var $result = $(template.render({
        container: getPublicElement($container)
      }));
      if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
        $container.replaceWith($result);
        $container = $result;
      }
      return $container;
    }
  },
  _executeTitleRenderAction: function($titleElement) {
    this._getTitleRenderAction()({
      titleElement: getPublicElement($titleElement)
    });
  },
  _getTitleRenderAction: function() {
    return this._titleRenderAction || this._createTitleRenderAction();
  },
  _createTitleRenderAction: function() {
    return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _getCloseButton: function() {
    return {
      toolbar: "top",
      location: "after",
      template: this._getCloseButtonRenderer()
    };
  },
  _getCloseButtonRenderer: function() {
    return (_2, __, container) => {
      var $button = $("<div>").addClass(POPUP_TITLE_CLOSEBUTTON_CLASS);
      this._createComponent($button, Button, {
        icon: "close",
        onClick: this._createToolbarItemAction(void 0),
        stylingMode: "text",
        integrationOptions: {}
      });
      $(container).append($button);
    };
  },
  _getToolbarItems: function(toolbar) {
    var toolbarItems = this.option("toolbarItems");
    var toolbarsItems = [];
    this._toolbarItemClasses = [];
    var currentPlatform = devices.current().platform;
    var index2 = 0;
    each(toolbarItems, (_2, data2) => {
      var isShortcut = isDefined(data2.shortcut);
      var item = isShortcut ? getButtonPlace(data2.shortcut) : data2;
      if (isShortcut && currentPlatform === "ios" && index2 < 2) {
        item.toolbar = "top";
        index2++;
      }
      item.toolbar = data2.toolbar || item.toolbar || "top";
      if (item && item.toolbar === toolbar) {
        if (isShortcut) {
          extend(item, {
            location: data2.location
          }, this._getToolbarItemByAlias(data2));
        }
        var isLTROrder = currentPlatform === "generic";
        if (data2.shortcut === "done" && isLTROrder || data2.shortcut === "cancel" && !isLTROrder) {
          toolbarsItems.unshift(item);
        } else {
          toolbarsItems.push(item);
        }
      }
    });
    if (toolbar === "top" && this._hasCloseButton()) {
      toolbarsItems.push(this._getCloseButton());
    }
    return toolbarsItems;
  },
  _hasCloseButton() {
    return this.option("showCloseButton") && this.option("showTitle");
  },
  _getLocalizationKey: (itemType) => itemType.toLowerCase() === "done" ? "OK" : camelize(itemType, true),
  _getToolbarItemByAlias: function(data2) {
    var that = this;
    var itemType = data2.shortcut;
    if (inArray(itemType, ALLOWED_TOOLBAR_ITEM_ALIASES) < 0) {
      return false;
    }
    var itemConfig = extend({
      text: messageLocalization.format(this._getLocalizationKey(itemType)),
      onClick: this._createToolbarItemAction(data2.onClick),
      integrationOptions: {},
      type: that.option("useDefaultToolbarButtons") ? BUTTON_DEFAULT_TYPE : BUTTON_NORMAL_TYPE,
      stylingMode: that.option("useFlatToolbarButtons") ? BUTTON_TEXT_MODE : BUTTON_CONTAINED_MODE
    }, data2.options || {});
    var itemClass = POPUP_CLASS + "-" + itemType;
    this._toolbarItemClasses.push(itemClass);
    return {
      template: function(_2, __, container) {
        var $toolbarItem = $("<div>").addClass(itemClass).appendTo(container);
        that._createComponent($toolbarItem, Button, itemConfig);
      }
    };
  },
  _createToolbarItemAction: function(clickAction) {
    return this._createAction(clickAction, {
      afterExecute: function(e) {
        e.component.hide();
      }
    });
  },
  _renderBottom: function() {
    var items = this._getToolbarItems("bottom");
    if (items.length) {
      this._$bottom && this._$bottom.remove();
      var $bottom = $("<div>").addClass(POPUP_BOTTOM_CLASS).insertAfter(this.$content());
      this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom, {
        compactMode: true
      }).addClass(POPUP_BOTTOM_CLASS);
      this._toggleClasses();
    } else {
      this._$bottom && this._$bottom.detach();
    }
  },
  _toggleClasses: function() {
    var aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
    each(aliases, (_2, alias) => {
      var className = POPUP_CLASS + "-" + alias;
      if (inArray(className, this._toolbarItemClasses) >= 0) {
        this.$wrapper().addClass(className + "-visible");
        this._$bottom.addClass(className);
      } else {
        this.$wrapper().removeClass(className + "-visible");
        this._$bottom.removeClass(className);
      }
    });
  },
  _getContainer: function() {
    if (this.option("fullScreen")) {
      return $(window$8);
    }
    return this.callBase();
  },
  _getDragTarget: function() {
    return this.topToolbar();
  },
  _renderGeometryImpl: function(isDimensionChanged) {
    if (!isDimensionChanged) {
      this._resetContentHeight();
    }
    this.callBase(...arguments);
    this._setContentHeight();
  },
  _resetContentHeight: function() {
    this.$content().css({
      height: "auto",
      maxHeight: "none"
    });
  },
  _renderDrag: function() {
    this.callBase();
    this.$overlayContent().toggleClass(POPUP_DRAGGABLE_CLASS, this.option("dragEnabled"));
  },
  _renderResize: function() {
    this.callBase();
    this._resizable.option("onResize", function() {
      this._setContentHeight();
      this._actions.onResize(arguments);
    }.bind(this));
  },
  _setContentHeight: function() {
    (this.option("forceApplyBindings") || noop)();
    var overlayContent = this.$overlayContent().get(0);
    var currentHeightStrategyClass = this._chooseHeightStrategy(overlayContent);
    this.$content().css(this._getHeightCssStyles(currentHeightStrategyClass, overlayContent));
    this._setHeightClasses(this.$overlayContent(), currentHeightStrategyClass);
  },
  _heightStrategyChangeOffset: function(currentHeightStrategyClass, popupVerticalPaddings) {
    return currentHeightStrategyClass === HEIGHT_STRATEGIES.flex ? -popupVerticalPaddings : 0;
  },
  _chooseHeightStrategy: function(overlayContent) {
    var isAutoWidth = overlayContent.style.width === "auto" || overlayContent.style.width === "";
    var currentHeightStrategyClass = HEIGHT_STRATEGIES.static;
    if (this._isAutoHeight() && this.option("autoResizeEnabled")) {
      if (isAutoWidth || IS_OLD_SAFARI) {
        if (!IS_IE11) {
          currentHeightStrategyClass = HEIGHT_STRATEGIES.inherit;
        }
      } else {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.flex;
      }
    }
    return currentHeightStrategyClass;
  },
  _getHeightCssStyles: function(currentHeightStrategyClass, overlayContent) {
    var cssStyles = {};
    var contentMaxHeight = this._getOptionValue("maxHeight", overlayContent);
    var contentMinHeight = this._getOptionValue("minHeight", overlayContent);
    var popupHeightParts = this._splitPopupHeight();
    var toolbarsAndVerticalOffsetsHeight = popupHeightParts.header + popupHeightParts.footer + popupHeightParts.contentVerticalOffsets + popupHeightParts.popupVerticalOffsets + this._heightStrategyChangeOffset(currentHeightStrategyClass, popupHeightParts.popupVerticalPaddings);
    if (currentHeightStrategyClass === HEIGHT_STRATEGIES.static) {
      if (!this._isAutoHeight() || contentMaxHeight || contentMinHeight) {
        var overlayHeight = this.option("fullScreen") ? Math.min(getBoundingRect(overlayContent).height, getWindow().innerHeight) : getBoundingRect(overlayContent).height;
        var contentHeight = overlayHeight - toolbarsAndVerticalOffsetsHeight;
        cssStyles = {
          height: Math.max(0, contentHeight),
          minHeight: "auto",
          maxHeight: "auto"
        };
      }
    } else {
      var container = $(this._getContainer()).get(0);
      var maxHeightValue = addOffsetToMaxHeight(contentMaxHeight, -toolbarsAndVerticalOffsetsHeight, container);
      var minHeightValue = addOffsetToMinHeight(contentMinHeight, -toolbarsAndVerticalOffsetsHeight, container);
      cssStyles = {
        height: "auto",
        minHeight: minHeightValue,
        maxHeight: maxHeightValue
      };
    }
    return cssStyles;
  },
  _setHeightClasses: function($container, currentClass) {
    var excessClasses = "";
    for (var name2 in HEIGHT_STRATEGIES) {
      if (HEIGHT_STRATEGIES[name2] !== currentClass) {
        excessClasses += " " + HEIGHT_STRATEGIES[name2];
      }
    }
    $container.removeClass(excessClasses).addClass(currentClass);
  },
  _isAutoHeight: function() {
    return this.$overlayContent().get(0).style.height === "auto";
  },
  _splitPopupHeight: function() {
    var topToolbar = this.topToolbar();
    var bottomToolbar = this.bottomToolbar();
    return {
      header: getVisibleHeight(topToolbar && topToolbar.get(0)),
      footer: getVisibleHeight(bottomToolbar && bottomToolbar.get(0)),
      contentVerticalOffsets: getVerticalOffsets(this.$overlayContent().get(0), true),
      popupVerticalOffsets: getVerticalOffsets(this.$content().get(0), true),
      popupVerticalPaddings: getVerticalOffsets(this.$content().get(0), false)
    };
  },
  _shouldFixBodyPosition: function() {
    return this.callBase() || this.option("fullScreen");
  },
  _toggleSafariFullScreen: function(value2) {
    var toggleFullScreenBeforeShown = this._shouldFixBodyPosition() && value2 && !this._isShown;
    if (toggleFullScreenBeforeShown) {
      this._bodyScrollTop = value2 ? window$8.pageYOffset : void 0;
    } else {
      this._toggleSafariScrolling(!value2);
    }
  },
  _renderDimensions: function() {
    if (this.option("fullScreen")) {
      this.$overlayContent().css({
        width: "100%",
        height: "100%",
        minWidth: "",
        maxWidth: "",
        minHeight: "",
        maxHeight: ""
      });
    } else {
      this.callBase(...arguments);
    }
    if (hasWindow$1()) {
      this._renderFullscreenWidthClass();
    }
  },
  _renderFullscreenWidthClass: function() {
    this.$overlayContent().toggleClass(POPUP_FULL_SCREEN_WIDTH_CLASS, this.$overlayContent().outerWidth() === $(window$8).width());
  },
  refreshPosition: function() {
    this._renderPosition();
  },
  _renderPosition: function() {
    if (this.option("fullScreen")) {
      move(this.$overlayContent(), {
        top: 0,
        left: 0
      });
    } else {
      (this.option("forceApplyBindings") || noop)();
      return this.callBase(...arguments);
    }
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "showTitle":
      case "title":
      case "titleTemplate":
        this._renderTitle();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "bottomTemplate":
        this._renderBottom();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "onTitleRendered":
        this._createTitleRenderAction(args.value);
        break;
      case "toolbarItems":
      case "useDefaultToolbarButtons":
      case "useFlatToolbarButtons":
        var shouldRenderGeometry = !args.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
        this._renderTitle();
        this._renderBottom();
        if (shouldRenderGeometry) {
          this._renderGeometry();
          triggerResizeEvent(this.$overlayContent());
        }
        break;
      case "dragEnabled":
        this._renderDrag();
        break;
      case "autoResizeEnabled":
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "fullScreen":
        this._toggleFullScreenClass(args.value);
        this._toggleSafariFullScreen(args.value);
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "showCloseButton":
        this._renderTitle();
        break;
      default:
        this.callBase(args);
    }
  },
  bottomToolbar: function() {
    return this._$bottom;
  },
  topToolbar: function() {
    return this._$title;
  },
  $content: function() {
    return this._$popupContent;
  },
  content: function() {
    return getPublicElement(this.$content());
  },
  $overlayContent: function() {
    return this._$content;
  }
});
registerComponent("dxPopup", Popup);
var {
  ios,
  mac
} = devices.real();
var isFocusingOnCaretChange = coreBrowserUtils.msie || ios || mac;
var getCaret = function(input) {
  var range;
  try {
    range = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } catch (e) {
    range = {
      start: 0,
      end: 0
    };
  }
  return range;
};
var setCaret = function(input, position2) {
  if (!domAdapter.getBody().contains(input)) {
    return;
  }
  try {
    input.selectionStart = position2.start;
    input.selectionEnd = position2.end;
  } catch (e) {
  }
};
var caret$1 = function(input, position2) {
  var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  input = $(input).get(0);
  if (!isDefined(position2)) {
    return getCaret(input);
  }
  if (!force && isFocusingOnCaretChange && domAdapter.getActiveElement() !== input) {
    return;
  }
  setCaret(input, position2);
};
function isModernAndroidDevice() {
  var {
    android,
    version: version2
  } = devices.real();
  return android && version2[0] > 4;
}
function isInputEventsL2Supported() {
  return "onbeforeinput" in domAdapter.createElement("input") || isModernAndroidDevice();
}
var EMPTY_CHAR$3 = " ";
var BaseMaskRule = classImpl.inherit({
  ctor: function(config2) {
    this._value = EMPTY_CHAR$3;
    extend(this, config2);
  },
  next: function(rule) {
    if (!arguments.length) {
      return this._next;
    }
    this._next = rule;
  },
  text: noop,
  value: noop,
  rawValue: noop,
  handle: noop,
  _prepareHandlingArgs: function(args, config2) {
    var _config$str, _config$start, _config$length;
    config2 = config2 || {};
    var handlingProperty = Object.prototype.hasOwnProperty.call(args, "value") ? "value" : "text";
    args[handlingProperty] = (_config$str = config2.str) !== null && _config$str !== void 0 ? _config$str : args[handlingProperty];
    args.start = (_config$start = config2.start) !== null && _config$start !== void 0 ? _config$start : args.start;
    args.length = (_config$length = config2.length) !== null && _config$length !== void 0 ? _config$length : args.length;
    args.index = args.index + 1;
    return args;
  },
  reset: noop,
  clear: noop,
  first: function(index2) {
    index2 = index2 || 0;
    return this.next().first(index2 + 1);
  },
  isAccepted: function() {
    return false;
  },
  adjustedCaret: function(caret2, isForwardDirection, char) {
    return isForwardDirection ? this._adjustedForward(caret2, 0, char) : this._adjustedBackward(caret2, 0, char);
  },
  _adjustedForward: noop,
  _adjustedBackward: noop,
  isValid: noop
});
var EmptyMaskRule = BaseMaskRule.inherit({
  next: noop,
  handle: function() {
    return 0;
  },
  text: function() {
    return "";
  },
  value: function() {
    return "";
  },
  first: function() {
    return 0;
  },
  rawValue: function() {
    return "";
  },
  adjustedCaret: function() {
    return 0;
  },
  isValid: function() {
    return true;
  }
});
var MaskRule = BaseMaskRule.inherit({
  text: function() {
    return (this._value !== EMPTY_CHAR$3 ? this._value : this.maskChar) + this.next().text();
  },
  value: function() {
    return this._value + this.next().value();
  },
  rawValue: function() {
    return this._value + this.next().rawValue();
  },
  handle: function(args) {
    var str = Object.prototype.hasOwnProperty.call(args, "value") ? args.value : args.text;
    if (!str || !str.length || !args.length) {
      return 0;
    }
    if (args.start) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start - 1
      }));
    }
    var char = str[0];
    var rest = str.substring(1);
    this._tryAcceptChar(char, args);
    return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    })) + 1 : this.handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }));
  },
  clear: function(args) {
    this._tryAcceptChar(EMPTY_CHAR$3, args);
    this.next().clear(this._prepareHandlingArgs(args));
  },
  reset: function() {
    this._accepted(false);
    this.next().reset();
  },
  _tryAcceptChar: function(char, args) {
    this._accepted(false);
    if (!this._isAllowed(char, args)) {
      return;
    }
    var acceptedChar = char === EMPTY_CHAR$3 ? this.maskChar : char;
    args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
    this._accepted(true);
    this._value = char;
  },
  _accepted: function(value2) {
    if (!arguments.length) {
      return !!this._isAccepted;
    }
    this._isAccepted = !!value2;
  },
  first: function(index2) {
    return this._value === EMPTY_CHAR$3 ? index2 || 0 : this.callBase(index2);
  },
  _isAllowed: function(char, args) {
    if (char === EMPTY_CHAR$3) {
      return true;
    }
    return this._isValid(char, args);
  },
  _isValid: function(char, args) {
    var allowedChars = this.allowedChars;
    if (allowedChars instanceof RegExp) {
      return allowedChars.test(char);
    }
    if (isFunction$1(allowedChars)) {
      return allowedChars(char, args.index, args.fullText);
    }
    if (Array.isArray(allowedChars)) {
      return inArray(char, allowedChars) > -1;
    }
    return allowedChars === char;
  },
  isAccepted: function(caret2) {
    return caret2 === 0 ? this._accepted() : this.next().isAccepted(caret2 - 1);
  },
  _adjustedForward: function(caret2, index2, char) {
    if (index2 >= caret2) {
      return index2;
    }
    return this.next()._adjustedForward(caret2, index2 + 1, char) || index2 + 1;
  },
  _adjustedBackward: function(caret2, index2) {
    if (index2 >= caret2 - 1) {
      return caret2;
    }
    return this.next()._adjustedBackward(caret2, index2 + 1) || index2 + 1;
  },
  isValid: function(args) {
    return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args));
  }
});
var StubMaskRule = MaskRule.inherit({
  value: function() {
    return this.next().value();
  },
  handle: function(args) {
    var hasValueProperty = Object.prototype.hasOwnProperty.call(args, "value");
    var str = hasValueProperty ? args.value : args.text;
    if (!str.length || !args.length) {
      return 0;
    }
    if (args.start || hasValueProperty) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start && args.start - 1
      }));
    }
    var char = str[0];
    var rest = str.substring(1);
    this._tryAcceptChar(char);
    var nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }) : args;
    return this.next().handle(nextArgs) + 1;
  },
  clear: function(args) {
    this._accepted(false);
    this.next().clear(this._prepareHandlingArgs(args));
  },
  _tryAcceptChar: function(char) {
    this._accepted(this._isValid(char));
  },
  _isValid: function(char) {
    return char === this.maskChar;
  },
  first: function(index2) {
    index2 = index2 || 0;
    return this.next().first(index2 + 1);
  },
  _adjustedForward: function(caret2, index2, char) {
    if (index2 >= caret2 && char === this.maskChar) {
      return index2;
    }
    if (caret2 === index2 + 1 && this._accepted()) {
      return caret2;
    }
    return this.next()._adjustedForward(caret2, index2 + 1, char);
  },
  _adjustedBackward: function(caret2, index2) {
    if (index2 >= caret2 - 1) {
      return 0;
    }
    return this.next()._adjustedBackward(caret2, index2 + 1);
  },
  isValid: function(args) {
    return this.next().isValid(this._prepareHandlingArgs(args));
  }
});
var INVALID_MESSAGE = "dx-invalid-message";
var INVALID_MESSAGE_AUTO$1 = "dx-invalid-message-auto";
var INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
var INVALID_MESSAGE_CONTENT = "dx-invalid-message-content";
var VALIDATION_MESSAGE_MIN_WIDTH = 100;
var ValidationMessage = Overlay.inherit({
  _getDefaultOptions() {
    return extend(this.callBase(), {
      integrationOptions: {},
      templatesRenderAsynchronously: false,
      shading: false,
      width: "auto",
      height: "auto",
      closeOnOutsideClick: false,
      closeOnTargetScroll: false,
      animation: null,
      visible: true,
      propagateOutsideClick: true,
      _checkParentVisibility: false,
      rtlEnabled: false,
      contentTemplate: this._renderInnerHtml,
      maxWidth: "100%",
      mode: "auto",
      validationErrors: void 0,
      positionRequest: void 0,
      describedElement: void 0,
      boundary: void 0,
      offset: {
        h: 0,
        v: 0
      }
    });
  },
  _init() {
    this.callBase();
    this.updateMaxWidth();
    this._updatePosition();
  },
  _initMarkup() {
    this.callBase();
    this.$element().addClass(INVALID_MESSAGE);
    this.$wrapper().addClass(INVALID_MESSAGE);
    this._toggleModeClass();
    this._updateContentId();
  },
  _updateContentId() {
    var describedElement = this.option("describedElement") || this.option("container");
    var contentId = $(describedElement).attr("aria-describedby");
    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr("id", contentId);
  },
  _renderInnerHtml(element) {
    var $element = element && $(element);
    var validationErrors = this.option("validationErrors") || [];
    var validationErrorMessage = "";
    validationErrors.forEach((err) => {
      var separator = validationErrorMessage ? "<br />" : "";
      validationErrorMessage += separator + encodeHtml((err === null || err === void 0 ? void 0 : err.message) || "");
    });
    $element === null || $element === void 0 ? void 0 : $element.html(validationErrorMessage);
  },
  _toggleModeClass() {
    var mode = this.option("mode");
    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO$1, mode === "auto").toggleClass(INVALID_MESSAGE_ALWAYS, mode === "always");
  },
  updateMaxWidth() {
    var _target$outerWidth;
    var target = this.option("target");
    var targetWidth = (target === null || target === void 0 ? void 0 : (_target$outerWidth = target.outerWidth) === null || _target$outerWidth === void 0 ? void 0 : _target$outerWidth.call(target)) || $(target).outerWidth();
    var maxWidth = "100%";
    if (targetWidth) {
      maxWidth = Math.max(targetWidth, VALIDATION_MESSAGE_MIN_WIDTH);
    }
    this.option({
      maxWidth
    });
  },
  _updatePosition: function() {
    var {
      positionRequest,
      rtlEnabled,
      offset: offset2,
      boundary
    } = this.option();
    var positionSide = getDefaultAlignment(rtlEnabled);
    var verticalPositions = positionRequest === "below" ? [" top", " bottom"] : [" bottom", " top"];
    if (rtlEnabled) {
      offset2.h = -offset2.h;
    }
    if (positionRequest !== "below") {
      offset2.v = -offset2.v;
    }
    this.option("position", {
      offset: offset2,
      boundary,
      my: positionSide + verticalPositions[0],
      at: positionSide + verticalPositions[1],
      collision: "none flip"
    });
  },
  _optionChanged(args) {
    var {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "target":
        this.updateMaxWidth();
        this.callBase(args);
        break;
      case "boundary":
        this.option("position.boundary", value2);
        break;
      case "mode":
        this._toggleModeClass(value2);
        break;
      case "rtlEnabled":
      case "offset":
      case "positionRequest":
        this._updatePosition();
        break;
      case "validationErrors":
        this._renderInnerHtml(this.$content());
        break;
      default:
        this.callBase(args);
    }
  }
});
registerComponent("dxValidationMessage", ValidationMessage);
var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
var READONLY_STATE_CLASS = "dx-state-readonly";
var INVALID_CLASS = "dx-invalid";
var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
var VALIDATION_TARGET = "dx-validation-target";
var VALIDATION_STATUS_VALID = "valid";
var VALIDATION_STATUS_INVALID = "invalid";
var READONLY_NAMESPACE = "editorReadOnly";
var ALLOWED_STYLING_MODES = ["outlined", "filled", "underlined"];
var VALIDATION_MESSAGE_KEYS_MAP = {
  validationMessageMode: "mode",
  validationMessageOffset: "offset",
  validationBoundary: "boundary"
};
var Editor = Widget.inherit({
  ctor: function() {
    this.showValidationMessageTimeout = null;
    this.validationRequest = Callbacks();
    this.callBase.apply(this, arguments);
  },
  _createElement: function(element) {
    this.callBase(element);
    var $element = this.$element();
    if ($element) {
      data($element[0], VALIDATION_TARGET, this);
    }
  },
  _initOptions: function(options) {
    this.callBase.apply(this, arguments);
    this.option(ValidationEngine.initValidationOptions(options));
  },
  _init: function() {
    this.callBase();
    this._options.cache("validationTooltipOptions", this.option("validationTooltipOptions"));
    var $element = this.$element();
    $element.addClass(DX_INVALID_BADGE_CLASS);
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      value: null,
      name: "",
      onValueChanged: null,
      readOnly: false,
      isValid: true,
      validationError: null,
      validationErrors: null,
      validationStatus: VALIDATION_STATUS_VALID,
      validationMessageMode: "auto",
      validationBoundary: void 0,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {}
    });
  },
  _attachKeyboardEvents: function() {
    if (!this.option("readOnly")) {
      this.callBase();
    }
  },
  _setOptionsByReference: function() {
    this.callBase();
    extend(this._optionsByReference, {
      validationError: true
    });
  },
  _createValueChangeAction: function() {
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _suppressValueChangeAction: function() {
    this._valueChangeActionSuppressed = true;
  },
  _resumeValueChangeAction: function() {
    this._valueChangeActionSuppressed = false;
  },
  _initMarkup: function() {
    this._toggleReadOnlyState();
    this._setSubmitElementName(this.option("name"));
    this.callBase();
    this._renderValidationState();
  },
  _raiseValueChangeAction: function(value2, previousValue) {
    if (!this._valueChangeAction) {
      this._createValueChangeAction();
    }
    this._valueChangeAction(this._valueChangeArgs(value2, previousValue));
  },
  _valueChangeArgs: function(value2, previousValue) {
    return {
      value: value2,
      previousValue,
      event: this._valueChangeEventInstance
    };
  },
  _saveValueChangeEvent: function(e) {
    this._valueChangeEventInstance = e;
  },
  _focusInHandler: function(e) {
    var isValidationMessageShownOnFocus = this.option("validationMessageMode") === "auto";
    if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
      var _this$_validationMess;
      var $validationMessageWrapper = (_this$_validationMess = this._validationMessage) === null || _this$_validationMess === void 0 ? void 0 : _this$_validationMess.$wrapper();
      $validationMessageWrapper === null || $validationMessageWrapper === void 0 ? void 0 : $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO);
      clearTimeout(this.showValidationMessageTimeout);
      this.showValidationMessageTimeout = setTimeout(() => $validationMessageWrapper === null || $validationMessageWrapper === void 0 ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO), 150);
    }
    return this.callBase(e);
  },
  _canValueBeChangedByClick: function() {
    return false;
  },
  _getStylingModePrefix: function() {
    return "dx-editor-";
  },
  _renderStylingMode: function() {
    var optionValue = this.option("stylingMode");
    var prefix = this._getStylingModePrefix();
    var allowedStylingClasses = ALLOWED_STYLING_MODES.map((mode) => prefix + mode);
    allowedStylingClasses.forEach((className) => this.$element().removeClass(className));
    var stylingModeClass = prefix + optionValue;
    if (allowedStylingClasses.indexOf(stylingModeClass) === -1) {
      var defaultOptionValue = this._getDefaultOptions().stylingMode;
      var platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules()).stylingMode;
      stylingModeClass = prefix + (platformOptionValue || defaultOptionValue);
    }
    this.$element().addClass(stylingModeClass);
  },
  _getValidationErrors: function() {
    var validationErrors = this.option("validationErrors");
    if (!validationErrors && this.option("validationError")) {
      validationErrors = [this.option("validationError")];
    }
    return validationErrors;
  },
  _disposeValidationMessage: function() {
    if (this._$validationMessage) {
      this._$validationMessage.remove();
      this.setAria("describedby", null);
      this._$validationMessage = void 0;
      this._validationMessage = void 0;
    }
  },
  _toggleValidationClasses: function(isInvalid) {
    this.$element().toggleClass(INVALID_CLASS, isInvalid);
    this.setAria(VALIDATION_STATUS_INVALID, isInvalid || void 0);
  },
  _renderValidationState: function() {
    var isValid = this.option("isValid") && this.option("validationStatus") !== VALIDATION_STATUS_INVALID;
    var validationErrors = this._getValidationErrors();
    var $element = this.$element();
    this._toggleValidationClasses(!isValid);
    if (!hasWindow$1()) {
      return;
    }
    this._disposeValidationMessage();
    if (!isValid && validationErrors) {
      var {
        validationMessageMode,
        validationMessageOffset,
        validationBoundary,
        rtlEnabled
      } = this.option();
      this._$validationMessage = $("<div>").appendTo($element);
      this.setAria("describedby", "dx-" + new Guid());
      this._validationMessage = new ValidationMessage(this._$validationMessage, extend({
        validationErrors,
        rtlEnabled,
        target: this._getValidationMessageTarget(),
        container: $element,
        mode: validationMessageMode,
        positionRequest: "below",
        offset: validationMessageOffset,
        boundary: validationBoundary,
        describedElement: this._focusTarget()
      }, this._options.cache("validationTooltipOptions")));
      this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions");
    }
  },
  _getValidationMessageTarget: function() {
    return this.$element();
  },
  _toggleReadOnlyState: function() {
    var readOnly = this.option("readOnly");
    this._toggleBackspaceHandler(readOnly);
    this.$element().toggleClass(READONLY_STATE_CLASS, !!readOnly);
    this.setAria("readonly", readOnly || void 0);
  },
  _toggleBackspaceHandler: function(isReadOnly) {
    var $eventTarget = this._keyboardEventBindingTarget();
    var eventName = addNamespace$1("keydown", READONLY_NAMESPACE);
    eventsEngine.off($eventTarget, eventName);
    if (isReadOnly) {
      eventsEngine.on($eventTarget, eventName, (e) => {
        if (normalizeKeyName(e) === "backspace") {
          e.preventDefault();
        }
      });
    }
  },
  _dispose: function() {
    var element = this.$element()[0];
    data(element, VALIDATION_TARGET, null);
    clearTimeout(this.showValidationMessageTimeout);
    this._disposeValidationMessage();
    this.callBase();
  },
  _setSubmitElementName: function(name2) {
    var $submitElement = this._getSubmitElement();
    if (!$submitElement) {
      return;
    }
    if (name2.length > 0) {
      $submitElement.attr("name", name2);
    } else {
      $submitElement.removeAttr("name");
    }
  },
  _getSubmitElement: function() {
    return null;
  },
  _setValidationMessageOption: function(_ref) {
    var _this$_validationMess2;
    var {
      name: name2,
      value: value2
    } = _ref;
    var optionKey = VALIDATION_MESSAGE_KEYS_MAP[name2] ? VALIDATION_MESSAGE_KEYS_MAP[name2] : name2;
    (_this$_validationMess2 = this._validationMessage) === null || _this$_validationMess2 === void 0 ? void 0 : _this$_validationMess2.option(optionKey, value2);
  },
  _hasActiveElement: noop,
  _optionChanged: function(args) {
    var _this$_validationMess3;
    switch (args.name) {
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "readOnly":
        this._toggleReadOnlyState();
        this._refreshFocusState();
        break;
      case "value":
        if (args.value != args.previousValue) {
          this.validationRequest.fire({
            value: args.value,
            editor: this
          });
        }
        if (!this._valueChangeActionSuppressed) {
          this._raiseValueChangeAction(args.value, args.previousValue);
          this._saveValueChangeEvent(void 0);
        }
        break;
      case "width":
        this.callBase(args);
        (_this$_validationMess3 = this._validationMessage) === null || _this$_validationMess3 === void 0 ? void 0 : _this$_validationMess3.updateMaxWidth();
        break;
      case "name":
        this._setSubmitElementName(args.value);
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(ValidationEngine.synchronizeValidationOptions(args, this.option()));
        this._renderValidationState();
        break;
      case "validationBoundary":
      case "validationMessageMode":
      case "validationMessageOffset":
        this._setValidationMessageOption(args);
        break;
      case "rtlEnabled":
        this._setValidationMessageOption(args);
        this.callBase(args);
        break;
      case "validationTooltipOptions":
        this._innerWidgetOptionChanged(this._validationMessage, args);
        break;
      default:
        this.callBase(args);
    }
  },
  blur: function() {
    if (this._hasActiveElement()) {
      resetActiveElement();
    }
  },
  reset: function() {
    var defaultOptions = this._getDefaultOptions();
    this.option("value", defaultOptions.value);
  }
});
Editor.isEditor = (instance) => instance instanceof Editor;
class TextEditorButton {
  constructor(name2, editor, options) {
    this.instance = null;
    this.$container = null;
    this.$placeMarker = null;
    this.editor = editor;
    this.name = name2;
    this.options = options || {};
  }
  _addPlaceMarker($container) {
    this.$placeMarker = $("<div>").appendTo($container);
  }
  _addToContainer($element) {
    var {
      $placeMarker,
      $container
    } = this;
    $placeMarker ? $placeMarker.replaceWith($element) : $element.appendTo($container);
  }
  _attachEvents() {
    throw "Not implemented";
  }
  _create() {
    throw "Not implemented";
  }
  _isRendered() {
    return !!this.instance;
  }
  _isVisible() {
    var {
      editor,
      options
    } = this;
    return options.visible || !editor.option("readOnly");
  }
  _isDisabled() {
    throw "Not implemented";
  }
  _shouldRender() {
    return this._isVisible() && !this._isRendered();
  }
  dispose() {
    var {
      instance,
      $placeMarker
    } = this;
    if (instance) {
      instance.dispose ? instance.dispose() : instance.remove();
      this.instance = null;
    }
    $placeMarker && $placeMarker.remove();
  }
  render() {
    var $container = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.$container;
    this.$container = $container;
    if (this._isVisible()) {
      var {
        instance,
        $element
      } = this._create();
      this.instance = instance;
      this._attachEvents(instance, $element);
    } else {
      this._addPlaceMarker($container);
    }
  }
  update() {
    if (this._shouldRender()) {
      this.render();
    }
    return !!this.instance;
  }
}
var pointerDown = pointer.down;
var STATE_INVISIBLE_CLASS$1 = "dx-state-invisible";
var TEXTEDITOR_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
var TEXTEDITOR_CLEAR_ICON_CLASS = "dx-icon-clear";
var TEXTEDITOR_ICON_CLASS = "dx-icon";
var TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS = "dx-show-clear-button";
class ClearButton extends TextEditorButton {
  _create() {
    var $element = $("<span>").addClass(TEXTEDITOR_CLEAR_BUTTON_CLASS).append($("<span>").addClass(TEXTEDITOR_ICON_CLASS).addClass(TEXTEDITOR_CLEAR_ICON_CLASS));
    this._addToContainer($element);
    this.update(true);
    return {
      instance: $element,
      $element
    };
  }
  _isVisible() {
    var {
      editor
    } = this;
    return editor._isClearButtonVisible();
  }
  _attachEvents(instance, $button) {
    var {
      editor
    } = this;
    var editorName = editor.NAME;
    eventsEngine.on($button, addNamespace$1(pointerDown, editorName), (e) => {
      e.preventDefault();
      if (e.pointerType !== "mouse") {
        editor._clearValueHandler(e);
      }
    });
    eventsEngine.on($button, addNamespace$1(CLICK_EVENT_NAME$2, editorName), (e) => editor._clearValueHandler(e));
  }
  _legacyRender($editor, isVisible2) {
    $editor.toggleClass(TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS, isVisible2);
  }
  update() {
    var rendered = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    !rendered && super.update();
    var {
      editor,
      instance
    } = this;
    var $editor = editor.$element();
    var isVisible2 = this._isVisible();
    instance && instance.toggleClass(STATE_INVISIBLE_CLASS$1, !isVisible2);
    this._legacyRender($editor, isVisible2);
  }
}
var CUSTOM_BUTTON_HOVERED_CLASS = "dx-custom-button-hovered";
class CustomButton extends TextEditorButton {
  _attachEvents(instance, $element) {
    var {
      editor
    } = this;
    eventsEngine.on($element, HOVERSTART, () => {
      editor.$element().addClass(CUSTOM_BUTTON_HOVERED_CLASS);
    });
    eventsEngine.on($element, HOVEREND, () => {
      editor.$element().removeClass(CUSTOM_BUTTON_HOVERED_CLASS);
    });
    eventsEngine.on($element, CLICK_EVENT_NAME$2, (e) => {
      e.stopPropagation();
    });
  }
  _create() {
    var {
      editor
    } = this;
    var $element = $("<div>");
    this._addToContainer($element);
    var instance = editor._createComponent($element, Button, extend({}, this.options, {
      ignoreParentReadOnly: true,
      disabled: this._isDisabled(),
      integrationOptions: this._prepareIntegrationOptions(editor)
    }));
    return {
      $element,
      instance
    };
  }
  _prepareIntegrationOptions(editor) {
    return extend({}, editor.option("integrationOptions"), {
      skipTemplates: ["content"]
    });
  }
  update() {
    var isUpdated = super.update();
    if (this.instance) {
      this.instance.option("disabled", this._isDisabled());
    }
    return isUpdated;
  }
  _isVisible() {
    var {
      editor
    } = this;
    return editor.option("visible");
  }
  _isDisabled() {
    var isDefinedByUser = this.options.disabled !== void 0;
    if (isDefinedByUser) {
      return this.instance ? this.instance.option("disabled") : this.options.disabled;
    } else {
      return this.editor.option("readOnly");
    }
  }
}
var TEXTEDITOR_BUTTONS_CONTAINER_CLASS$1 = "dx-texteditor-buttons-container";
function checkButtonInfo(buttonInfo) {
  (() => {
    if (!buttonInfo || typeof buttonInfo !== "object" || Array.isArray(buttonInfo)) {
      throw errors$1.Error("E1053");
    }
  })();
  (() => {
    if (!("name" in buttonInfo)) {
      throw errors$1.Error("E1054");
    }
  })();
  (() => {
    var {
      name: name2
    } = buttonInfo;
    if (typeof name2 !== "string") {
      throw errors$1.Error("E1055");
    }
  })();
  (() => {
    var {
      location
    } = buttonInfo;
    if ("location" in buttonInfo && location !== "after" && location !== "before") {
      buttonInfo.location = "after";
    }
  })();
}
function checkNamesUniqueness(existingNames, newName) {
  if (existingNames.indexOf(newName) !== -1) {
    throw errors$1.Error("E1055", newName);
  }
  existingNames.push(newName);
}
function isPredefinedButtonName(name2, predefinedButtonsInfo) {
  return !!find(predefinedButtonsInfo, (info) => info.name === name2);
}
class TextEditorButtonCollection {
  constructor(editor, defaultButtonsInfo) {
    this.buttons = [];
    this.defaultButtonsInfo = defaultButtonsInfo;
    this.editor = editor;
  }
  _compileButtonInfo(buttons) {
    var names = [];
    return buttons.map((button) => {
      var isStringButton = typeof button === "string";
      if (!isStringButton) {
        checkButtonInfo(button);
      }
      var isDefaultButton = isStringButton || isPredefinedButtonName(button.name, this.defaultButtonsInfo);
      if (isDefaultButton) {
        var defaultButtonInfo = find(this.defaultButtonsInfo, (_ref) => {
          var {
            name: name3
          } = _ref;
          return name3 === button || name3 === button.name;
        });
        if (!defaultButtonInfo) {
          throw errors$1.Error("E1056", this.editor.NAME, button);
        }
        checkNamesUniqueness(names, button);
        return defaultButtonInfo;
      } else {
        var {
          name: name2
        } = button;
        checkNamesUniqueness(names, name2);
        return extend(button, {
          Ctor: CustomButton
        });
      }
    });
  }
  _createButton(buttonsInfo) {
    var {
      Ctor,
      options,
      name: name2
    } = buttonsInfo;
    var button = new Ctor(name2, this.editor, options);
    this.buttons.push(button);
    return button;
  }
  _renderButtons(buttons, $container, targetLocation) {
    var $buttonsContainer = null;
    var buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;
    buttonsInfo.forEach((buttonsInfo2) => {
      var {
        location = "after"
      } = buttonsInfo2;
      if (location === targetLocation) {
        this._createButton(buttonsInfo2).render((() => {
          $buttonsContainer = $buttonsContainer || $("<div>").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS$1);
          targetLocation === "before" ? $container.prepend($buttonsContainer) : $container.append($buttonsContainer);
          return $buttonsContainer;
        })());
      }
    });
    return $buttonsContainer;
  }
  clean() {
    this.buttons.forEach((button) => button.dispose());
    this.buttons = [];
  }
  getButton(buttonName) {
    var button = find(this.buttons, (_ref2) => {
      var {
        name: name2
      } = _ref2;
      return name2 === buttonName;
    });
    return button && button.instance;
  }
  renderAfterButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "after");
  }
  renderBeforeButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "before");
  }
  updateButtons(names) {
    this.buttons.forEach((button) => {
      if (!names || names.indexOf(button.name) !== -1) {
        button.update();
      }
    });
  }
}
var TEXTEDITOR_CLASS = "dx-texteditor";
var TEXTEDITOR_INPUT_CONTAINER_CLASS = "dx-texteditor-input-container";
var TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input";
var TEXTEDITOR_INPUT_SELECTOR = "." + TEXTEDITOR_INPUT_CLASS;
var TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container";
var TEXTEDITOR_BUTTONS_CONTAINER_CLASS = "dx-texteditor-buttons-container";
var TEXTEDITOR_PLACEHOLDER_CLASS = "dx-placeholder";
var TEXTEDITOR_EMPTY_INPUT_CLASS = "dx-texteditor-empty";
var STATE_INVISIBLE_CLASS = "dx-state-invisible";
var TEXTEDITOR_PENDING_INDICATOR_CLASS = "dx-pending-indicator";
var TEXTEDITOR_VALIDATION_PENDING_CLASS = "dx-validation-pending";
var TEXTEDITOR_VALID_CLASS = "dx-valid";
var EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
var CONTROL_KEYS = ["tab", "enter", "shift", "control", "alt", "escape", "pageUp", "pageDown", "end", "home", "leftArrow", "upArrow", "rightArrow", "downArrow"];
function checkButtonsOptionType(buttons) {
  if (isDefined(buttons) && !Array.isArray(buttons)) {
    throw errors$1.Error("E1053");
  }
}
var TextEditorBase = Editor.inherit({
  ctor: function(_2, options) {
    if (options) {
      checkButtonsOptionType(options.buttons);
    }
    this._buttonCollection = new TextEditorButtonCollection(this, this._getDefaultButtons());
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this.callBase.apply(this, arguments);
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      buttons: void 0,
      value: "",
      spellcheck: false,
      showClearButton: false,
      valueChangeEvent: "change",
      placeholder: "",
      inputAttr: {},
      onFocusIn: null,
      onFocusOut: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onChange: null,
      onInput: null,
      onCut: null,
      onCopy: null,
      onPaste: null,
      onEnterKey: null,
      mode: "text",
      hoverStateEnabled: true,
      focusStateEnabled: true,
      text: void 0,
      displayValueFormatter: function(value2) {
        return isDefined(value2) && value2 !== false ? value2 : "";
      },
      stylingMode: configMethod().editorStylingMode || "outlined",
      showValidationMark: true
    });
  },
  _defaultOptionsRules: function() {
    var themeName = current();
    return this.callBase().concat([{
      device: function() {
        return isMaterial(themeName);
      },
      options: {
        stylingMode: configMethod().editorStylingMode || "underlined"
      }
    }]);
  },
  _setDeprecatedOptions: function() {
    this.callBase();
    extend(this._deprecatedOptions, {
      onKeyPress: {
        since: "20.1",
        message: "This event is removed from the web standards and will be deprecated in modern browsers soon."
      }
    });
  },
  _getDefaultButtons: function() {
    return [{
      name: "clear",
      Ctor: ClearButton
    }];
  },
  _isClearButtonVisible: function() {
    return this.option("showClearButton") && !this.option("readOnly");
  },
  _input: function() {
    return this.$element().find(TEXTEDITOR_INPUT_SELECTOR).first();
  },
  _isFocused: function() {
    return focused(this._input()) || this.callBase();
  },
  _inputWrapper: function() {
    return this.$element();
  },
  _buttonsContainer: function() {
    return this._inputWrapper().find("." + TEXTEDITOR_BUTTONS_CONTAINER_CLASS).eq(0);
  },
  _isControlKey: function(key) {
    return CONTROL_KEYS.indexOf(key) !== -1;
  },
  _renderStylingMode: function() {
    this.callBase();
    this._updateButtonsStyling(this.option("stylingMode"));
  },
  _initMarkup: function() {
    this.$element().addClass(TEXTEDITOR_CLASS);
    this._renderInput();
    this._renderStylingMode();
    this._renderInputType();
    this._renderPlaceholder();
    this._renderProps();
    this.callBase();
    this._renderValue();
  },
  _render: function() {
    this._renderPlaceholder();
    this._refreshValueChangeEvent();
    this._renderEvents();
    this._renderEnterKeyAction();
    this._renderEmptinessEvent();
    this.callBase();
  },
  _renderInput: function() {
    this._$buttonsContainer = this._$textEditorContainer = $("<div>").addClass(TEXTEDITOR_CONTAINER_CLASS).appendTo(this.$element());
    this._$textEditorInputContainer = $("<div>").addClass(TEXTEDITOR_INPUT_CONTAINER_CLASS).appendTo(this._$textEditorContainer);
    this._$textEditorInputContainer.append(this._createInput());
    this._renderButtonContainers();
  },
  _getInputContainer() {
    return this._$textEditorInputContainer;
  },
  _renderPendingIndicator: function() {
    this.$element().addClass(TEXTEDITOR_VALIDATION_PENDING_CLASS);
    var $inputContainer = this._getInputContainer();
    var $indicatorElement = $("<div>").addClass(TEXTEDITOR_PENDING_INDICATOR_CLASS).appendTo($inputContainer);
    this._pendingIndicator = this._createComponent($indicatorElement, LoadIndicator);
  },
  _disposePendingIndicator: function() {
    if (!this._pendingIndicator) {
      return;
    }
    this._pendingIndicator.dispose();
    this._pendingIndicator.$element().remove();
    this._pendingIndicator = null;
    this.$element().removeClass(TEXTEDITOR_VALIDATION_PENDING_CLASS);
  },
  _renderValidationState: function() {
    this.callBase();
    var isPending2 = this.option("validationStatus") === "pending";
    var $element = this.$element();
    if (isPending2) {
      !this._pendingIndicator && this._renderPendingIndicator();
      this._showValidMark = false;
    } else {
      if (this.option("validationStatus") === "invalid") {
        this._showValidMark = false;
      }
      if (!this._showValidMark && this.option("showValidationMark") === true) {
        this._showValidMark = this.option("validationStatus") === "valid" && !!this._pendingIndicator;
      }
      this._disposePendingIndicator();
    }
    $element.toggleClass(TEXTEDITOR_VALID_CLASS, !!this._showValidMark);
  },
  _renderButtonContainers: function() {
    var buttons = this.option("buttons");
    this._$beforeButtonsContainer = this._buttonCollection.renderBeforeButtons(buttons, this._$buttonsContainer);
    this._$afterButtonsContainer = this._buttonCollection.renderAfterButtons(buttons, this._$buttonsContainer);
  },
  _cleanButtonContainers: function() {
    var _this$_$beforeButtons, _this$_$afterButtonsC;
    (_this$_$beforeButtons = this._$beforeButtonsContainer) === null || _this$_$beforeButtons === void 0 ? void 0 : _this$_$beforeButtons.remove();
    (_this$_$afterButtonsC = this._$afterButtonsContainer) === null || _this$_$afterButtonsC === void 0 ? void 0 : _this$_$afterButtonsC.remove();
    this._buttonCollection.clean();
  },
  _clean() {
    this._buttonCollection.clean();
    this._disposePendingIndicator();
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._$textEditorContainer = null;
    this._$buttonsContainer = null;
    this.callBase();
  },
  _createInput: function() {
    var $input = $("<input>");
    this._applyInputAttributes($input, this.option("inputAttr"));
    return $input;
  },
  _setSubmitElementName: function(name2) {
    var inputAttrName = this.option("inputAttr.name");
    return this.callBase(name2 || inputAttrName || "");
  },
  _applyInputAttributes: function($input, customAttributes) {
    var inputAttributes = extend(this._getDefaultAttributes(), customAttributes);
    $input.attr(inputAttributes).addClass(TEXTEDITOR_INPUT_CLASS).css("minHeight", this.option("height") ? "0" : "");
  },
  _getDefaultAttributes: function() {
    var defaultAttributes = {
      autocomplete: "off"
    };
    var {
      ios: ios2,
      mac: mac2
    } = devices.real();
    if (ios2 || mac2) {
      defaultAttributes.placeholder = " ";
    }
    return defaultAttributes;
  },
  _updateButtons: function(names) {
    this._buttonCollection.updateButtons(names);
  },
  _updateButtonsStyling: function(editorStylingMode) {
    each(this.option("buttons"), (_2, _ref) => {
      var {
        options,
        name: buttonName
      } = _ref;
      if (options && !options.stylingMode && this.option("visible")) {
        var buttonInstance = this.getButton(buttonName);
        buttonInstance.option && buttonInstance.option("stylingMode", editorStylingMode === "underlined" ? "text" : "contained");
      }
    });
  },
  _renderValue: function() {
    var renderInputPromise = this._renderInputValue();
    return renderInputPromise.promise();
  },
  _renderInputValue: function(value2) {
    var _value;
    value2 = (_value = value2) !== null && _value !== void 0 ? _value : this.option("value");
    var text = this.option("text");
    var displayValue = this.option("displayValue");
    var displayValueFormatter = this.option("displayValueFormatter");
    if (displayValue !== void 0 && value2 !== null) {
      text = displayValueFormatter(displayValue);
    } else if (!isDefined(text)) {
      text = displayValueFormatter(value2);
    }
    this.option("text", text);
    if (this._input().val() !== (isDefined(text) ? text : "")) {
      this._renderDisplayText(text);
    } else {
      this._toggleEmptinessEventHandler();
    }
    return new Deferred().resolve();
  },
  _renderDisplayText: function(text) {
    this._input().val(text);
    this._toggleEmptinessEventHandler();
  },
  _isValueValid: function() {
    if (this._input().length) {
      var validity = this._input().get(0).validity;
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  },
  _toggleEmptiness: function(isEmpty2) {
    this.$element().toggleClass(TEXTEDITOR_EMPTY_INPUT_CLASS, isEmpty2);
    this._togglePlaceholder(isEmpty2);
  },
  _togglePlaceholder: function(isEmpty2) {
    this.$element().find(".".concat(TEXTEDITOR_PLACEHOLDER_CLASS)).eq(0).toggleClass(STATE_INVISIBLE_CLASS, !isEmpty2);
  },
  _renderProps: function() {
    this._toggleReadOnlyState();
    this._toggleSpellcheckState();
    this._toggleTabIndex();
  },
  _toggleDisabledState: function(value2) {
    this.callBase.apply(this, arguments);
    var $input = this._input();
    $input.prop("disabled", value2);
  },
  _toggleTabIndex: function() {
    var $input = this._input();
    var disabled = this.option("disabled");
    var focusStateEnabled = this.option("focusStateEnabled");
    if (disabled || !focusStateEnabled) {
      $input.attr("tabIndex", -1);
    } else {
      $input.removeAttr("tabIndex");
    }
  },
  _toggleReadOnlyState: function() {
    this._input().prop("readOnly", this._readOnlyPropValue());
    this.callBase();
  },
  _readOnlyPropValue: function() {
    return this.option("readOnly");
  },
  _toggleSpellcheckState: function() {
    this._input().prop("spellcheck", this.option("spellcheck"));
  },
  _renderPlaceholder: function() {
    this._renderPlaceholderMarkup();
    this._attachPlaceholderEvents();
  },
  _renderPlaceholderMarkup: function() {
    if (this._$placeholder) {
      this._$placeholder.remove();
      this._$placeholder = null;
    }
    var $input = this._input();
    var placeholderText = this.option("placeholder");
    var $placeholder = this._$placeholder = $("<div>").attr("data-dx_placeholder", placeholderText);
    $placeholder.insertAfter($input);
    $placeholder.addClass(TEXTEDITOR_PLACEHOLDER_CLASS);
  },
  _attachPlaceholderEvents: function() {
    var startEvent = addNamespace$1(pointer.up, this.NAME);
    eventsEngine.on(this._$placeholder, startEvent, () => {
      eventsEngine.trigger(this._input(), "focus");
    });
    this._toggleEmptinessEventHandler();
  },
  _placeholder: function() {
    return this._$placeholder || $();
  },
  _clearValueHandler: function(e) {
    var $input = this._input();
    e.stopPropagation();
    this._saveValueChangeEvent(e);
    this._clearValue();
    !this._isFocused() && eventsEngine.trigger($input, "focus");
    eventsEngine.trigger($input, "input");
  },
  _clearValue: function() {
    this.reset();
  },
  _renderEvents: function() {
    var $input = this._input();
    each(EVENTS_LIST, (_2, event) => {
      if (this.hasActionSubscription("on" + event)) {
        var action = this._createActionByOption("on" + event, {
          excludeValidators: ["readOnly"]
        });
        eventsEngine.on($input, addNamespace$1(event.toLowerCase(), this.NAME), (e) => {
          if (this._disposed) {
            return;
          }
          action({
            event: e
          });
        });
      }
    });
  },
  _refreshEvents: function() {
    var $input = this._input();
    each(EVENTS_LIST, (_2, event) => {
      eventsEngine.off($input, addNamespace$1(event.toLowerCase(), this.NAME));
    });
    this._renderEvents();
  },
  _keyPressHandler: function() {
    this.option("text", this._input().val());
  },
  _keyDownHandler: function(e) {
    var $input = this._input();
    var isCtrlEnter = e.ctrlKey && normalizeKeyName(e) === "enter";
    var isNewValue = $input.val() !== this.option("value");
    if (isCtrlEnter && isNewValue) {
      eventsEngine.trigger($input, "change");
    }
  },
  _renderValueChangeEvent: function() {
    var keyPressEvent = addNamespace$1(this._renderValueEventName(), "".concat(this.NAME, "TextChange"));
    var valueChangeEvent = addNamespace$1(this.option("valueChangeEvent"), "".concat(this.NAME, "ValueChange"));
    var keyDownEvent = addNamespace$1("keydown", "".concat(this.NAME, "TextChange"));
    var $input = this._input();
    eventsEngine.on($input, keyPressEvent, this._keyPressHandler.bind(this));
    eventsEngine.on($input, valueChangeEvent, this._valueChangeEventHandler.bind(this));
    eventsEngine.on($input, keyDownEvent, this._keyDownHandler.bind(this));
  },
  _cleanValueChangeEvent: function() {
    var valueChangeNamespace = ".".concat(this.NAME, "ValueChange");
    var textChangeNamespace = ".".concat(this.NAME, "TextChange");
    eventsEngine.off(this._input(), valueChangeNamespace);
    eventsEngine.off(this._input(), textChangeNamespace);
  },
  _refreshValueChangeEvent: function() {
    this._cleanValueChangeEvent();
    this._renderValueChangeEvent();
  },
  _renderValueEventName: function() {
    return "input change keypress";
  },
  _focusTarget: function() {
    return this._input();
  },
  _focusEventTarget: function() {
    return this.element();
  },
  _isInput: function(element) {
    return element === this._input().get(0);
  },
  _preventNestedFocusEvent: function(event) {
    if (event.isDefaultPrevented()) {
      return true;
    }
    var result = this._isNestedTarget(event.relatedTarget);
    if (event.type === "focusin") {
      result = result && this._isNestedTarget(event.target) && !this._isInput(event.target);
    }
    result && event.preventDefault();
    return result;
  },
  _isNestedTarget: function(target) {
    return !!this.$element().find(target).length;
  },
  _focusClassTarget: function() {
    return this.$element();
  },
  _focusInHandler: function(event) {
    this._preventNestedFocusEvent(event);
    this.callBase.apply(this, arguments);
  },
  _focusOutHandler: function(event) {
    this._preventNestedFocusEvent(event);
    this.callBase.apply(this, arguments);
  },
  _toggleFocusClass: function(isFocused, $element) {
    this.callBase(isFocused, this._focusClassTarget($element));
  },
  _hasFocusClass: function(element) {
    return this.callBase($(element || this.$element()));
  },
  _renderEmptinessEvent: function() {
    var $input = this._input();
    eventsEngine.on($input, "input blur", this._toggleEmptinessEventHandler.bind(this));
  },
  _toggleEmptinessEventHandler: function() {
    var text = this._input().val();
    var isEmpty2 = (text === "" || text === null) && this._isValueValid();
    this._toggleEmptiness(isEmpty2);
  },
  _valueChangeEventHandler: function(e, formattedValue) {
    this._saveValueChangeEvent(e);
    this.option("value", arguments.length > 1 ? formattedValue : this._input().val());
    this._saveValueChangeEvent(void 0);
  },
  _renderEnterKeyAction: function() {
    this._enterKeyAction = this._createActionByOption("onEnterKey", {
      excludeValidators: ["readOnly"]
    });
    eventsEngine.off(this._input(), "keyup.onEnterKey.dxTextEditor");
    eventsEngine.on(this._input(), "keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this));
  },
  _enterKeyHandlerUp: function(e) {
    if (this._disposed) {
      return;
    }
    if (normalizeKeyName(e) === "enter") {
      this._enterKeyAction({
        event: e
      });
    }
  },
  _updateValue: function() {
    this._options.silent("text", null);
    this._renderValue();
  },
  _dispose: function() {
    this._enterKeyAction = void 0;
    this.callBase();
  },
  _getSubmitElement: function() {
    return this._input();
  },
  _hasActiveElement: function() {
    return this._input().is(domAdapter.getActiveElement());
  },
  _optionChanged: function(args) {
    var {
      name: name2,
      fullName,
      value: value2
    } = args;
    if (inArray(name2.replace("on", ""), EVENTS_LIST) > -1) {
      this._refreshEvents();
      return;
    }
    switch (name2) {
      case "valueChangeEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "focusStateEnabled":
        this.callBase(args);
        this._toggleTabIndex();
        break;
      case "spellcheck":
        this._toggleSpellcheckState();
        break;
      case "mode":
        this._renderInputType();
        break;
      case "onEnterKey":
        this._renderEnterKeyAction();
        break;
      case "placeholder":
        this._renderPlaceholder();
        break;
      case "readOnly":
      case "disabled":
        this._updateButtons();
        this.callBase(args);
        break;
      case "showClearButton":
        this._updateButtons(["clear"]);
        break;
      case "text":
        break;
      case "value":
        this._updateValue();
        this.callBase(args);
        break;
      case "inputAttr":
        this._applyInputAttributes(this._input(), this.option(name2));
        break;
      case "stylingMode":
        this._renderStylingMode();
        break;
      case "buttons":
        if (fullName === name2) {
          checkButtonsOptionType(value2);
        }
        this._cleanButtonContainers();
        this._renderButtonContainers();
        this._updateButtonsStyling(this.option("stylingMode"));
        break;
      case "visible":
        this.callBase(args);
        if (value2 && this.option("buttons")) {
          this._cleanButtonContainers();
          this._renderButtonContainers();
          this._updateButtonsStyling(this.option("stylingMode"));
        }
        break;
      case "displayValueFormatter":
        this._invalidate();
        break;
      case "showValidationMark":
        break;
      default:
        this.callBase(args);
    }
  },
  _renderInputType: function() {
    this._setInputType(this.option("mode"));
  },
  _setInputType: function(type2) {
    var input = this._input();
    if (type2 === "search") {
      type2 = "text";
    }
    try {
      input.prop("type", type2);
    } catch (e) {
      input.prop("type", "text");
    }
  },
  getButton(name2) {
    return this._buttonCollection.getButton(name2);
  },
  focus: function() {
    eventsEngine.trigger(this._input(), "focus");
  },
  reset: function() {
    if (this._showValidMark) {
      this._showValidMark = false;
      this._renderValidationState();
    }
    var defaultOptions = this._getDefaultOptions();
    if (this.option("value") === defaultOptions.value) {
      this._options.silent("text", "");
      this._renderValue();
    } else {
      this.option("value", defaultOptions.value);
    }
  },
  on: function(eventName, eventHandler) {
    var result = this.callBase(eventName, eventHandler);
    var event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
    if (EVENTS_LIST.indexOf(event) >= 0) {
      this._refreshEvents();
    }
    return result;
  }
});
var MASK_EVENT_NAMESPACE = "dxMask";
var BLUR_EVENT = "blur beforedeactivate";
var EMPTY_CHAR$2 = " ";
class BaseMaskStrategy {
  constructor(editor) {
    this.editor = editor;
    this.DIRECTION = {
      FORWARD: "forward",
      BACKWARD: "backward"
    };
    this.NAME = this._getStrategyName();
  }
  _getStrategyName() {
    return "base";
  }
  editorOption() {
    return this.editor.option(...arguments);
  }
  editorInput() {
    return this.editor._input();
  }
  editorCaret(newCaret) {
    if (!newCaret) {
      return this.editor._caret();
    }
    this.editor._caret(newCaret);
  }
  getHandler(handlerName) {
    var handler = this["_".concat(handlerName, "Handler")] || function() {
    };
    return handler.bind(this);
  }
  attachEvents() {
    var $input = this.editorInput();
    this.getHandleEventNames().forEach((eventName) => {
      var subscriptionName = addNamespace$1(eventName.toLowerCase(), MASK_EVENT_NAMESPACE);
      eventsEngine.on($input, subscriptionName, this.getEventHandler(eventName));
    });
    this._attachChangeEventHandlers();
  }
  getHandleEventNames() {
    return ["focusIn", "focusOut", "keyDown", "input", "paste", "cut", "drop"];
  }
  getEventHandler(eventName) {
    return this["_".concat(eventName, "Handler")].bind(this);
  }
  detachEvents() {
    eventsEngine.off(this.editorInput(), ".".concat(MASK_EVENT_NAMESPACE));
  }
  _attachChangeEventHandlers() {
    if (inArray("change", this.editorOption("valueChangeEvent").split(" ")) === -1) {
      return;
    }
    eventsEngine.on(this.editorInput(), addNamespace$1(BLUR_EVENT, MASK_EVENT_NAMESPACE), function(e) {
      this._suppressCaretChanging(this._changeHandler, [e]);
      this._changeHandler(e);
    }.bind(this.editor));
  }
  _focusInHandler() {
    this.editor._showMaskPlaceholder();
    this.editor._direction(this.DIRECTION.FORWARD);
    if (!this.editor._isValueEmpty() && this.editorOption("isValid")) {
      this.editor._adjustCaret();
    } else {
      var caret2 = this.editor._maskRulesChain.first();
      this._caretTimeout = setTimeout(function() {
        this._caret({
          start: caret2,
          end: caret2
        });
      }.bind(this.editor), 0);
    }
  }
  _focusOutHandler(event) {
    this.editor._changeHandler(event);
    if (this.editorOption("showMaskMode") === "onFocus" && this.editor._isValueEmpty()) {
      this.editorOption("text", "");
      this.editor._renderDisplayText("");
    }
  }
  _cutHandler(event) {
    var caret2 = this.editorCaret();
    var selectedText = this.editorInput().val().substring(caret2.start, caret2.end);
    this.editor._maskKeyHandler(event, () => clipboardText(event, selectedText));
  }
  _dropHandler() {
    this._clearDragTimer();
    this._dragTimer = setTimeout(function() {
      this.option("value", this._convertToValue(this._input().val()));
    }.bind(this.editor));
  }
  _clearDragTimer() {
    clearTimeout(this._dragTimer);
  }
  _keyDownHandler() {
    this._keyPressHandled = false;
  }
  _pasteHandler(event) {
    var {
      editor
    } = this;
    this._keyPressHandled = true;
    var caret2 = this.editorCaret();
    editor._maskKeyHandler(event, () => {
      var pastedText = clipboardText(event);
      var restText = editor._maskRulesChain.text().substring(caret2.end);
      var accepted = editor._handleChain({
        text: pastedText,
        start: caret2.start,
        length: pastedText.length
      });
      var newCaret = caret2.start + accepted;
      editor._handleChain({
        text: restText,
        start: newCaret,
        length: restText.length
      });
      editor._caret({
        start: newCaret,
        end: newCaret
      });
    });
  }
  _autoFillHandler(event) {
    var {
      editor
    } = this;
    var inputVal = this.editorInput().val();
    this._inputHandlerTimer = setTimeout(() => {
      this._keyPressHandled = true;
      if (this._isAutoFill()) {
        this._keyPressHandled = true;
        editor._maskKeyHandler(event, () => {
          editor._handleChain({
            text: inputVal,
            start: 0,
            length: inputVal.length
          });
        });
        editor._validateMask();
      }
    });
  }
  _isAutoFill() {
    var $input = this.editor._input();
    var result = false;
    if (coreBrowserUtils.msie && coreBrowserUtils.version > 11) {
      result = $input.hasClass("edge-autofilled");
    } else if (coreBrowserUtils.webkit) {
      var input = $input.get(0);
      result = input && input.matches(":-webkit-autofill");
    }
    return result;
  }
  runWithoutEventProcessing(action) {
    var keyPressHandled = this._keyPressHandled;
    this._keyPressHandled = true;
    action();
    this._keyPressHandled = keyPressHandled;
  }
  _backspaceHandler() {
  }
  _delHandler(event) {
    var {
      editor
    } = this;
    this._keyPressHandled = true;
    editor._maskKeyHandler(event, () => !editor._hasSelection() && editor._handleKey(EMPTY_CHAR$2));
  }
  clean() {
    this._clearDragTimer();
    clearTimeout(this._backspaceHandlerTimeout);
    clearTimeout(this._caretTimeout);
    clearTimeout(this._inputHandlerTimer);
  }
}
var BACKSPACE_INPUT_TYPE = "deleteContentBackward";
var EMPTY_CHAR$1 = " ";
class DefaultMaskStrategy extends BaseMaskStrategy {
  _getStrategyName() {
    return "default";
  }
  getHandleEventNames() {
    return [...super.getHandleEventNames(), "keyPress"];
  }
  _keyPressHandler(event) {
    if (this._keyPressHandled) {
      return;
    }
    this._keyPressHandled = true;
    if (this.editor._isControlKeyFired(event)) {
      return;
    }
    var {
      editor
    } = this;
    editor._maskKeyHandler(event, () => editor._handleKey(getChar(event)));
  }
  _inputHandler(event) {
    if (this._backspaceInputHandled(event.originalEvent && event.originalEvent.inputType)) {
      this._handleBackspaceInput(event);
    }
    if (event.originalEvent) {
      this._autoFillHandler(event);
    }
    if (this._keyPressHandled) {
      return;
    }
    this._keyPressHandled = true;
    var inputValue = this.editorInput().val();
    var caret2 = this.editorCaret();
    if (!caret2.end) {
      return;
    }
    caret2.start = caret2.end - 1;
    var oldValue = inputValue.substring(0, caret2.start) + inputValue.substring(caret2.end);
    var char = inputValue[caret2.start];
    var {
      editor
    } = this;
    this.editorInput().val(oldValue);
    editor._caret({
      start: caret2.start,
      end: caret2.start
    });
    editor._maskKeyHandler(event, () => editor._handleKey(char));
  }
  _backspaceHandler(event) {
    var {
      editor
    } = this;
    this._keyPressHandled = true;
    var afterBackspaceHandler = (needAdjustCaret, callBack) => {
      if (needAdjustCaret) {
        editor._direction(this.DIRECTION.FORWARD);
        editor._adjustCaret();
      }
      var currentCaret = this.editorCaret();
      return new Promise$3((resolve) => {
        clearTimeout(this._backspaceHandlerTimeout);
        this._backspaceHandlerTimeout = setTimeout(function() {
          callBack(currentCaret);
          resolve();
        });
      });
    };
    editor._maskKeyHandler(event, () => {
      if (editor._hasSelection()) {
        return afterBackspaceHandler(true, (currentCaret) => {
          editor._displayMask(currentCaret);
          editor._maskRulesChain.reset();
        });
      }
      if (editor._tryMoveCaretBackward()) {
        return afterBackspaceHandler(false, (currentCaret) => {
          this.editorCaret(currentCaret);
        });
      }
      editor._handleKey(EMPTY_CHAR$1, this.DIRECTION.BACKWARD);
      return afterBackspaceHandler(true, (currentCaret) => {
        editor._displayMask(currentCaret);
        editor._maskRulesChain.reset();
      });
    });
  }
  _backspaceInputHandled(inputType2) {
    return inputType2 === BACKSPACE_INPUT_TYPE && !this._keyPressHandled;
  }
  _handleBackspaceInput(event) {
    var {
      start,
      end
    } = this.editorCaret();
    this.editorCaret({
      start: start + 1,
      end: end + 1
    });
    this._backspaceHandler(event);
  }
}
var DELETE_INPUT_TYPE = "deleteContentBackward";
class InputEventsMaskStrategy extends BaseMaskStrategy {
  _getStrategyName() {
    return "inputEvents";
  }
  getHandleEventNames() {
    return [...super.getHandleEventNames(), "beforeInput"];
  }
  _beforeInputHandler() {
    this._prevCaret = this.editorCaret();
  }
  _inputHandler(_ref) {
    var {
      originalEvent
    } = _ref;
    if (!originalEvent) {
      return;
    }
    var {
      inputType: inputType2,
      data: data2
    } = originalEvent;
    var currentCaret = this.editorCaret();
    if (inputType2 === DELETE_INPUT_TYPE) {
      var length = this._prevCaret.end - this._prevCaret.start || 1;
      this.editor.setBackwardDirection();
      this._updateEditorMask({
        start: currentCaret.start,
        length,
        text: this._getEmptyString(length)
      });
    } else {
      var _this$_prevCaret, _this$_prevCaret2, _this$_prevCaret3;
      if (!currentCaret.end) {
        return;
      }
      this._autoFillHandler(originalEvent);
      this.editorCaret(currentCaret);
      var _length = ((_this$_prevCaret = this._prevCaret) === null || _this$_prevCaret === void 0 ? void 0 : _this$_prevCaret.end) - ((_this$_prevCaret2 = this._prevCaret) === null || _this$_prevCaret2 === void 0 ? void 0 : _this$_prevCaret2.start);
      var newData = data2 + (_length ? this._getEmptyString(_length - data2.length) : "");
      this.editor.setForwardDirection();
      var hasValidChars = this._updateEditorMask({
        start: (_this$_prevCaret3 = this._prevCaret) === null || _this$_prevCaret3 === void 0 ? void 0 : _this$_prevCaret3.start,
        length: _length || newData.length,
        text: newData
      });
      if (!hasValidChars) {
        this.editorCaret(this._prevCaret);
      }
    }
  }
  _getEmptyString(length) {
    return Array(length + 1).join(" ");
  }
  _updateEditorMask(args) {
    var textLength = args.text.length;
    var updatedCharsCount = this.editor._handleChain(args);
    if (this.editor.isForwardDirection()) {
      var {
        start,
        end
      } = this.editorCaret();
      var correction = updatedCharsCount - textLength;
      if (start <= updatedCharsCount && updatedCharsCount > 1) {
        this.editorCaret({
          start: start + correction,
          end: end + correction
        });
      }
      this.editor.isForwardDirection() && this.editor._adjustCaret();
    }
    this.editor._displayMask();
    return !!updatedCharsCount;
  }
}
var stubCaret = function() {
  return {};
};
var caret = caret$1;
var EMPTY_CHAR = " ";
var ESCAPED_CHAR = "\\";
var TEXTEDITOR_MASKED_CLASS = "dx-texteditor-masked";
var FORWARD_DIRECTION = "forward";
var BACKWARD_DIRECTION = "backward";
var buildInMaskRules = {
  0: /[0-9]/,
  9: /[0-9\s]/,
  "#": /[-+0-9\s]/,
  L: function(char) {
    return isLiteralChar(char);
  },
  l: function(char) {
    return isLiteralChar(char) || isSpaceChar(char);
  },
  C: /\S/,
  c: /./,
  A: function(char) {
    return isLiteralChar(char) || isNumericChar(char);
  },
  a: function(char) {
    return isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char);
  }
};
function isNumericChar(char) {
  return /[0-9]/.test(char);
}
function isLiteralChar(char) {
  var code = char.charCodeAt();
  return 64 < code && code < 91 || 96 < code && code < 123 || code > 127;
}
function isSpaceChar(char) {
  return char === " ";
}
var TextEditorMask = TextEditorBase.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      mask: "",
      maskChar: "_",
      maskRules: {},
      maskInvalidMessage: messageLocalization.format("validation-mask"),
      useMaskedValue: false,
      showMaskMode: "always"
    });
  },
  _supportedKeys: function() {
    var that = this;
    var keyHandlerMap = {
      backspace: that._maskStrategy.getHandler("backspace"),
      del: that._maskStrategy.getHandler("del"),
      enter: that._changeHandler
    };
    var result = that.callBase();
    each(keyHandlerMap, function(key, callback) {
      var parentHandler = result[key];
      result[key] = function(e) {
        that.option("mask") && callback.call(that, e);
        parentHandler && parentHandler(e);
      };
    });
    return result;
  },
  _getSubmitElement: function() {
    return !this.option("mask") ? this.callBase() : this._$hiddenElement;
  },
  _init: function() {
    this.callBase();
    this._initMaskStrategy();
  },
  _initMaskStrategy: function() {
    this._maskStrategy = isInputEventsL2Supported() ? new InputEventsMaskStrategy(this) : new DefaultMaskStrategy(this);
  },
  _initMarkup: function() {
    this._renderHiddenElement();
    this.callBase();
  },
  _attachMouseWheelEventHandlers: function() {
    var hasMouseWheelHandler = this._onMouseWheel !== noop;
    if (!hasMouseWheelHandler) {
      return;
    }
    var input = this._input();
    var eventName = addNamespace$1(EVENT_NAME, this.NAME);
    var mouseWheelAction = this._createAction(function(e) {
      var {
        event
      } = e;
      if (focused(input) && !isCommandKeyPressed(event)) {
        this._onMouseWheel(event);
        event.preventDefault();
        event.stopPropagation();
      }
    }.bind(this));
    eventsEngine.off(input, eventName);
    eventsEngine.on(input, eventName, function(e) {
      mouseWheelAction({
        event: e
      });
    });
  },
  _onMouseWheel: noop,
  _render: function() {
    this._renderMask();
    this.callBase();
    this._attachMouseWheelEventHandlers();
  },
  _renderHiddenElement: function() {
    if (this.option("mask")) {
      this._$hiddenElement = $("<input>").attr("type", "hidden").appendTo(this._inputWrapper());
    }
  },
  _removeHiddenElement: function() {
    this._$hiddenElement && this._$hiddenElement.remove();
  },
  _renderMask: function() {
    this.$element().removeClass(TEXTEDITOR_MASKED_CLASS);
    this._maskRulesChain = null;
    this._maskStrategy.detachEvents();
    if (!this.option("mask")) {
      return;
    }
    this.$element().addClass(TEXTEDITOR_MASKED_CLASS);
    this._maskStrategy.attachEvents();
    this._parseMask();
    this._renderMaskedValue();
  },
  _suppressCaretChanging: function(callback, args) {
    caret = stubCaret;
    try {
      callback.apply(this, args);
    } finally {
      caret = caret$1;
    }
  },
  _changeHandler: function(e) {
    var $input = this._input();
    var inputValue = $input.val();
    if (inputValue === this._changedValue) {
      return;
    }
    this._changedValue = inputValue;
    var changeEvent = createEvent(e, {
      type: "change"
    });
    eventsEngine.trigger($input, changeEvent);
  },
  _parseMask: function() {
    this._maskRules = extend({}, buildInMaskRules, this.option("maskRules"));
    this._maskRulesChain = this._parseMaskRule(0);
  },
  _parseMaskRule: function(index2) {
    var mask = this.option("mask");
    if (index2 >= mask.length) {
      return new EmptyMaskRule();
    }
    var currentMaskChar = mask[index2];
    var isEscapedChar = currentMaskChar === ESCAPED_CHAR;
    var result = isEscapedChar ? new StubMaskRule({
      maskChar: mask[index2 + 1]
    }) : this._getMaskRule(currentMaskChar);
    result.next(this._parseMaskRule(index2 + 1 + isEscapedChar));
    return result;
  },
  _getMaskRule: function(pattern) {
    var ruleConfig;
    each(this._maskRules, function(rulePattern, allowedChars) {
      if (rulePattern === pattern) {
        ruleConfig = {
          pattern: rulePattern,
          allowedChars
        };
        return false;
      }
    });
    return isDefined(ruleConfig) ? new MaskRule(extend({
      maskChar: this.option("maskChar")
    }, ruleConfig)) : new StubMaskRule({
      maskChar: pattern
    });
  },
  _renderMaskedValue: function() {
    if (!this._maskRulesChain) {
      return;
    }
    var value2 = this.option("value") || "";
    this._maskRulesChain.clear(this._normalizeChainArguments());
    var chainArgs = {
      length: value2.length
    };
    chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value2;
    this._handleChain(chainArgs);
    this._displayMask();
  },
  _replaceSelectedText: function(text, selection, char) {
    if (char === void 0) {
      return text;
    }
    var textBefore = text.slice(0, selection.start);
    var textAfter = text.slice(selection.end);
    var edited = textBefore + char + textAfter;
    return edited;
  },
  _isMaskedValueMode: function() {
    return this.option("useMaskedValue");
  },
  _displayMask: function(caret2) {
    caret2 = caret2 || this._caret();
    this._renderValue();
    this._caret(caret2);
  },
  _isValueEmpty: function() {
    return isEmpty$1(this._value);
  },
  _shouldShowMask: function() {
    var showMaskMode = this.option("showMaskMode");
    if (showMaskMode === "onFocus") {
      return focused(this._input()) || !this._isValueEmpty();
    }
    return true;
  },
  _showMaskPlaceholder: function() {
    if (this._shouldShowMask()) {
      var text = this._maskRulesChain.text();
      this.option("text", text);
      if (this.option("showMaskMode") === "onFocus") {
        this._renderDisplayText(text);
      }
    }
  },
  _renderValue: function() {
    if (this._maskRulesChain) {
      this._showMaskPlaceholder();
      if (this._$hiddenElement) {
        var value2 = this._maskRulesChain.value();
        var submitElementValue = !isEmpty$1(value2) ? this._getPreparedValue() : "";
        this._$hiddenElement.val(submitElementValue);
      }
    }
    return this.callBase();
  },
  _getPreparedValue: function() {
    return this._convertToValue().replace(/\s+$/, "");
  },
  _valueChangeEventHandler: function(e) {
    if (!this._maskRulesChain) {
      this.callBase.apply(this, arguments);
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", this._getPreparedValue());
  },
  _isControlKeyFired: function(e) {
    return this._isControlKey(normalizeKeyName(e)) || isCommandKeyPressed(e);
  },
  _handleChain: function(args) {
    var handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
    this._value = this._maskRulesChain.value();
    this._textValue = this._maskRulesChain.text();
    return handledCount;
  },
  _normalizeChainArguments: function(args) {
    args = args || {};
    args.index = 0;
    args.fullText = this._maskRulesChain.text();
    return args;
  },
  _convertToValue: function(text) {
    if (this._isMaskedValueMode()) {
      text = this._replaceMaskCharWithEmpty(text || this._textValue || "");
    } else {
      text = text || this._value || "";
    }
    return text;
  },
  _replaceMaskCharWithEmpty: function(text) {
    return text.replace(new RegExp(this.option("maskChar"), "g"), EMPTY_CHAR);
  },
  _maskKeyHandler: function(e, keyHandler) {
    if (this.option("readOnly")) {
      return;
    }
    this.setForwardDirection();
    e.preventDefault();
    this._handleSelection();
    var previousText = this._input().val();
    var raiseInputEvent = () => {
      if (previousText !== this._input().val()) {
        this._maskStrategy.runWithoutEventProcessing(() => eventsEngine.trigger(this._input(), "input"));
      }
    };
    var handled = keyHandler();
    if (handled) {
      handled.then(raiseInputEvent);
    } else {
      this.setForwardDirection();
      this._adjustCaret();
      this._displayMask();
      this._maskRulesChain.reset();
      raiseInputEvent();
    }
  },
  _handleKey: function(key, direction) {
    this._direction(direction || FORWARD_DIRECTION);
    this._adjustCaret(key);
    this._handleKeyChain(key);
    this._moveCaret();
  },
  _handleSelection: function() {
    if (!this._hasSelection()) {
      return;
    }
    var caret2 = this._caret();
    var emptyChars = new Array(caret2.end - caret2.start + 1).join(EMPTY_CHAR);
    this._handleKeyChain(emptyChars);
  },
  _handleKeyChain: function(chars) {
    var caret2 = this._caret();
    var start = this.isForwardDirection() ? caret2.start : caret2.start - 1;
    var end = this.isForwardDirection() ? caret2.end : caret2.end - 1;
    var length = start === end ? 1 : end - start;
    this._handleChain({
      text: chars,
      start,
      length
    });
  },
  _tryMoveCaretBackward: function() {
    this.setBackwardDirection();
    var currentCaret = this._caret().start;
    this._adjustCaret();
    return !currentCaret || currentCaret !== this._caret().start;
  },
  _adjustCaret: function(char) {
    var caret2 = this._maskRulesChain.adjustedCaret(this._caret().start, this.isForwardDirection(), char);
    this._caret({
      start: caret2,
      end: caret2
    });
  },
  _moveCaret: function() {
    var currentCaret = this._caret().start;
    var maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);
    var caret2 = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;
    this._caret({
      start: caret2,
      end: caret2
    });
  },
  _caret: function(position2, force) {
    var $input = this._input();
    if (!$input.length) {
      return;
    }
    if (!arguments.length) {
      return caret($input);
    }
    caret($input, position2, force);
  },
  _hasSelection: function() {
    var caret2 = this._caret();
    return caret2.start !== caret2.end;
  },
  _direction: function(direction) {
    if (!arguments.length) {
      return this._typingDirection;
    }
    this._typingDirection = direction;
  },
  setForwardDirection: function() {
    this._direction(FORWARD_DIRECTION);
  },
  setBackwardDirection: function() {
    this._direction(BACKWARD_DIRECTION);
  },
  isForwardDirection: function() {
    return this._direction() === FORWARD_DIRECTION;
  },
  _clean: function() {
    this._maskStrategy && this._maskStrategy.clean();
    this.callBase();
  },
  _validateMask: function() {
    if (!this._maskRulesChain) {
      return;
    }
    var isValid = isEmpty$1(this.option("value")) || this._maskRulesChain.isValid(this._normalizeChainArguments());
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("maskInvalidMessage")
      }
    });
  },
  _updateHiddenElement: function() {
    this._removeHiddenElement();
    if (this.option("mask")) {
      this._input().removeAttr("name");
      this._renderHiddenElement();
    }
    this._setSubmitElementName(this.option("name"));
  },
  _updateMaskOption: function() {
    this._updateHiddenElement();
    this._renderMask();
    this._validateMask();
  },
  _processEmptyMask: function(mask) {
    if (mask) {
      return;
    }
    var value2 = this.option("value");
    this.option({
      text: value2,
      isValid: true
    });
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
    this._renderValue();
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "mask":
        this._updateMaskOption();
        this._processEmptyMask(args.value);
        break;
      case "maskChar":
      case "maskRules":
      case "useMaskedValue":
        this._updateMaskOption();
        break;
      case "value":
        this._renderMaskedValue();
        this._validateMask();
        this.callBase(args);
        this._changedValue = this._input().val();
        break;
      case "maskInvalidMessage":
        break;
      case "showMaskMode":
        this.option("text", "");
        this._renderValue();
        break;
      default:
        this.callBase(args);
    }
  }
});
registerComponent("dxTextEditor", TextEditorMask);
var window$7 = getWindow();
var navigator$2 = getNavigator();
var ua = navigator$2.userAgent;
var ignoreKeys = ["backspace", "tab", "enter", "pageUp", "pageDown", "end", "home", "leftArrow", "rightArrow", "downArrow", "upArrow", "del"];
var TEXTBOX_CLASS = "dx-textbox";
var SEARCHBOX_CLASS = "dx-searchbox";
var ICON_CLASS = "dx-icon";
var SEARCH_ICON_CLASS = "dx-icon-search";
var TextBox = TextEditorMask.inherit({
  ctor: function(element, options) {
    if (options) {
      this._showClearButton = options.showClearButton;
    }
    this.callBase.apply(this, arguments);
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      value: "",
      mode: "text",
      maxLength: null
    });
  },
  _initMarkup: function() {
    this.$element().addClass(TEXTBOX_CLASS);
    this.callBase();
    this.setAria("role", "textbox");
  },
  _renderContentImpl: function() {
    this._renderMaxLengthHandlers();
    this.callBase();
  },
  _renderInputType: function() {
    this.callBase();
    this._renderSearchMode();
  },
  _renderMaxLengthHandlers: function() {
    if (this._isAndroidOrIE()) {
      eventsEngine.on(this._input(), addNamespace$1("keydown", this.NAME), this._onKeyDownCutOffHandler.bind(this));
      eventsEngine.on(this._input(), addNamespace$1("change", this.NAME), this._onChangeCutOffHandler.bind(this));
    }
  },
  _useTemplates: function() {
    return false;
  },
  _renderProps: function() {
    this.callBase();
    this._toggleMaxLengthProp();
  },
  _toggleMaxLengthProp: function() {
    var maxLength = this._getMaxLength();
    if (maxLength && maxLength > 0) {
      this._input().attr("maxLength", maxLength);
    } else {
      this._input().removeAttr("maxLength");
    }
  },
  _renderSearchMode: function() {
    var $element = this._$element;
    if (this.option("mode") === "search") {
      $element.addClass(SEARCHBOX_CLASS);
      this._renderSearchIcon();
      if (this._showClearButton === void 0) {
        this._showClearButton = this.option("showClearButton");
        this.option("showClearButton", true);
      }
    } else {
      $element.removeClass(SEARCHBOX_CLASS);
      this._$searchIcon && this._$searchIcon.remove();
      this.option("showClearButton", this._showClearButton === void 0 ? this.option("showClearButton") : this._showClearButton);
      delete this._showClearButton;
    }
  },
  _renderSearchIcon: function() {
    var $searchIcon = $("<div>").addClass(ICON_CLASS).addClass(SEARCH_ICON_CLASS);
    $searchIcon.prependTo(this._input().parent());
    this._$searchIcon = $searchIcon;
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "maxLength":
        this._toggleMaxLengthProp();
        this._renderMaxLengthHandlers();
        break;
      case "mask":
        this.callBase(args);
        this._toggleMaxLengthProp();
        break;
      default:
        this.callBase(args);
    }
  },
  _onKeyDownCutOffHandler: function(e) {
    var actualMaxLength = this._getMaxLength();
    if (actualMaxLength && !e.ctrlKey && !this._hasSelection()) {
      var $input = $(e.target);
      var key = normalizeKeyName(e);
      this._cutOffExtraChar($input);
      return $input.val().length < actualMaxLength || inArray(key, ignoreKeys) !== -1 || window$7.getSelection().toString() !== "";
    } else {
      return true;
    }
  },
  _onChangeCutOffHandler: function(e) {
    var $input = $(e.target);
    if (this.option("maxLength")) {
      this._cutOffExtraChar($input);
    }
  },
  _cutOffExtraChar: function($input) {
    var actualMaxLength = this._getMaxLength();
    var textInput = $input.val();
    if (actualMaxLength && textInput.length > actualMaxLength) {
      $input.val(textInput.substr(0, actualMaxLength));
    }
  },
  _getMaxLength: function() {
    var isMaskSpecified = !!this.option("mask");
    return isMaskSpecified ? null : this.option("maxLength");
  },
  _isAndroidOrIE: function() {
    var realDevice2 = devices.real();
    var version2 = realDevice2.version.join(".");
    return coreBrowserUtils.msie || realDevice2.platform === "android" && version2 && /^(2\.|4\.1)/.test(version2) && !/chrome/i.test(ua);
  }
});
registerComponent("dxTextBox", TextBox);
var searchBoxMixin = {
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      searchMode: "",
      searchExpr: null,
      searchValue: "",
      searchEnabled: false,
      searchEditorOptions: {}
    });
  },
  _initMarkup: function() {
    this._renderSearch();
    this.callBase();
  },
  _renderSearch: function() {
    var $element = this.$element();
    var searchEnabled = this.option("searchEnabled");
    var searchBoxClassName = this._addWidgetPrefix("search");
    var rootElementClassName = this._addWidgetPrefix("with-search");
    if (!searchEnabled) {
      $element.removeClass(rootElementClassName);
      this._removeSearchBox();
      return;
    }
    var editorOptions = this._getSearchEditorOptions();
    if (this._searchEditor) {
      this._searchEditor.option(editorOptions);
    } else {
      $element.addClass(rootElementClassName);
      this._$searchEditorElement = $("<div>").addClass(searchBoxClassName).prependTo($element);
      this._searchEditor = this._createComponent(this._$searchEditorElement, TextBox, editorOptions);
    }
  },
  _removeSearchBox: function() {
    this._$searchEditorElement && this._$searchEditorElement.remove();
    delete this._$searchEditorElement;
    delete this._searchEditor;
  },
  _getSearchEditorOptions: function() {
    var that = this;
    var userEditorOptions = that.option("searchEditorOptions");
    var searchText = messageLocalization.format("Search");
    return extend({
      mode: "search",
      placeholder: searchText,
      tabIndex: that.option("tabIndex"),
      value: that.option("searchValue"),
      valueChangeEvent: "input",
      inputAttr: {
        "aria-label": searchText
      },
      onValueChanged: function(e) {
        var searchTimeout = that.option("searchTimeout");
        that._valueChangeDeferred = new Deferred();
        clearTimeout(that._valueChangeTimeout);
        that._valueChangeDeferred.done(function() {
          this.option("searchValue", e.value);
        }.bind(that));
        if (e.event && e.event.type === "input" && searchTimeout) {
          that._valueChangeTimeout = setTimeout(function() {
            that._valueChangeDeferred.resolve();
          }, searchTimeout);
        } else {
          that._valueChangeDeferred.resolve();
        }
      }
    }, userEditorOptions);
  },
  _getAriaTarget: function() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.$element();
  },
  _focusTarget: function() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _updateFocusState: function(e, isFocused) {
    if (this.option("searchEnabled")) {
      this._toggleFocusClass(isFocused, this.$element());
    }
    this.callBase(e, isFocused);
  },
  getOperationBySearchMode: function(searchMode) {
    return searchMode === "equals" ? "=" : searchMode;
  },
  _cleanAria: function($target) {
    this.setAria({
      role: null,
      activedescendant: null
    }, $target);
    $target.attr("tabIndex", null);
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "searchEnabled":
      case "searchEditorOptions":
        this._cleanAria(this.option("searchEnabled") ? this.$element() : this._itemContainer());
        this._invalidate();
        break;
      case "searchExpr":
      case "searchMode":
      case "searchValue":
        if (!this._dataSource) {
          errors$1.log("W1009");
          return;
        }
        if (args.name === "searchMode") {
          this._dataSource.searchOperation(this.getOperationBySearchMode(args.value));
        } else {
          this._dataSource[args.name](args.value);
        }
        this._dataSource.load();
        break;
      case "searchTimeout":
        break;
      default:
        this.callBase(args);
    }
  },
  focus: function() {
    if (!this.option("focusedElement") && this.option("searchEnabled")) {
      this._searchEditor && this._searchEditor.focus();
      return;
    }
    this.callBase();
  },
  _refresh: function() {
    if (this._valueChangeDeferred) {
      this._valueChangeDeferred.resolve();
    }
    this.callBase();
  }
};
var CHECKBOX_CLASS = "dx-checkbox";
var CHECKBOX_ICON_CLASS = "dx-checkbox-icon";
var CHECKBOX_CHECKED_CLASS = "dx-checkbox-checked";
var CHECKBOX_CONTAINER_CLASS = "dx-checkbox-container";
var CHECKBOX_TEXT_CLASS = "dx-checkbox-text";
var CHECKBOX_HAS_TEXT_CLASS = "dx-checkbox-has-text";
var CHECKBOX_INDETERMINATE_CLASS = "dx-checkbox-indeterminate";
var CHECKBOX_FEEDBACK_HIDE_TIMEOUT = 100;
var CheckBox = Editor.inherit({
  _supportedKeys: function() {
    return extend(this.callBase(), {
      space: function(e) {
        e.preventDefault();
        this._clickAction({
          event: e
        });
      }
    });
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      value: false,
      text: "",
      useInkRipple: false
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function() {
        return devices.real().deviceType === "desktop" && !devices.isSimulator();
      },
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _canValueBeChangedByClick: function() {
    return true;
  },
  _useTemplates: function() {
    return false;
  },
  _feedbackHideTimeout: CHECKBOX_FEEDBACK_HIDE_TIMEOUT,
  _initMarkup: function() {
    this._renderSubmitElement();
    this._$container = $("<div>").addClass(CHECKBOX_CONTAINER_CLASS);
    this.setAria("role", "checkbox");
    this.$element().addClass(CHECKBOX_CLASS);
    this._renderValue();
    this._renderIcon();
    this._renderText();
    this.option("useInkRipple") && this._renderInkRipple();
    this.$element().append(this._$container);
    this.callBase();
  },
  _render: function() {
    this._renderClick();
    this.callBase();
  },
  _renderSubmitElement: function() {
    this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.$element());
  },
  _getSubmitElement: function() {
    return this._$submitElement;
  },
  _renderInkRipple: function() {
    this._inkRipple = render({
      waveSizeCoefficient: 2.5,
      useHoldAnimation: false,
      wavesNumber: 2,
      isCentered: true
    });
  },
  _renderInkWave: function(element, dxEvent, doRender, waveIndex) {
    if (!this._inkRipple) {
      return;
    }
    var config2 = {
      element,
      event: dxEvent,
      wave: waveIndex
    };
    if (doRender) {
      this._inkRipple.showWave(config2);
    } else {
      this._inkRipple.hideWave(config2);
    }
  },
  _updateFocusState: function(e, value2) {
    this.callBase.apply(this, arguments);
    this._renderInkWave(this._$icon, e, value2, 0);
  },
  _toggleActiveState: function($element, value2, e) {
    this.callBase.apply(this, arguments);
    this._renderInkWave(this._$icon, e, value2, 1);
  },
  _renderIcon: function() {
    this._$icon = $("<span>").addClass(CHECKBOX_ICON_CLASS).prependTo(this._$container);
  },
  _renderText: function() {
    var textValue = this.option("text");
    if (!textValue) {
      if (this._$text) {
        this._$text.remove();
        this.$element().removeClass(CHECKBOX_HAS_TEXT_CLASS);
      }
      return;
    }
    if (!this._$text) {
      this._$text = $("<span>").addClass(CHECKBOX_TEXT_CLASS);
    }
    this._$text.text(textValue);
    this._$container.append(this._$text);
    this.$element().addClass(CHECKBOX_HAS_TEXT_CLASS);
  },
  _renderClick: function() {
    var that = this;
    var eventName = addNamespace$1(CLICK_EVENT_NAME$2, that.NAME);
    that._clickAction = that._createAction(that._clickHandler);
    eventsEngine.off(that.$element(), eventName);
    eventsEngine.on(that.$element(), eventName, function(e) {
      that._clickAction({
        event: e
      });
    });
  },
  _clickHandler: function(args) {
    var that = args.component;
    that._saveValueChangeEvent(args.event);
    that.option("value", !that.option("value"));
  },
  _renderValue: function() {
    var $element = this.$element();
    var checked = this.option("value");
    var indeterminate = checked === void 0;
    $element.toggleClass(CHECKBOX_CHECKED_CLASS, Boolean(checked));
    $element.toggleClass(CHECKBOX_INDETERMINATE_CLASS, indeterminate);
    this._getSubmitElement().val(checked);
    this.setAria("checked", indeterminate ? "mixed" : checked || "false");
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "useInkRipple":
        this._invalidate();
        break;
      case "value":
        this._renderValue();
        this.callBase(args);
        break;
      case "text":
        this._renderText();
        this._renderDimensions();
        break;
      default:
        this.callBase(args);
    }
  },
  _clean: function() {
    delete this._inkRipple;
    this.callBase();
  }
});
registerComponent("dxCheckBox", CheckBox);
var DataConverter = classImpl.inherit({
  ctor: function() {
    this._dataStructure = [];
    this._itemsCount = 0;
    this._visibleItemsCount = 0;
  },
  _indexByKey: {},
  _convertItemsToNodes: function(items, parentKey) {
    var that = this;
    each(items, function(_2, item) {
      var parentId = isDefined(parentKey) ? parentKey : that._getParentId(item);
      var node = that._convertItemToNode(item, parentId);
      that._dataStructure.push(node);
      that._checkForDuplicateId(node.internalFields.key);
      that._indexByKey[node.internalFields.key] = that._dataStructure.length - 1;
      if (that._itemHasChildren(item)) {
        that._convertItemsToNodes(that._dataAccessors.getters.items(item), node.internalFields.key);
      }
    });
  },
  _checkForDuplicateId: function(key) {
    if (isDefined(this._indexByKey[key])) {
      throw errors$1.Error("E1040", key);
    }
  },
  _getParentId: function(item) {
    return this._dataType === "plain" ? this._dataAccessors.getters.parentKey(item) : void 0;
  },
  _itemHasChildren: function(item) {
    if (this._dataType === "plain") {
      return;
    }
    var items = this._dataAccessors.getters.items(item);
    return items && items.length;
  },
  _getUniqueKey: function(item) {
    var keyGetter = this._dataAccessors.getters.key;
    var itemKey = keyGetter(item);
    var isCorrectKey = keyGetter && (itemKey || itemKey === 0) && isPrimitive(itemKey);
    return isCorrectKey ? itemKey : this.getItemsCount();
  },
  _convertItemToNode: function(item, parentKey) {
    this._itemsCount++;
    item.visible !== false && this._visibleItemsCount++;
    var node = {
      internalFields: {
        disabled: this._dataAccessors.getters.disabled(item, {
          defaultValue: false
        }),
        expanded: this._dataAccessors.getters.expanded(item, {
          defaultValue: false
        }),
        selected: this._dataAccessors.getters.selected(item, {
          defaultValue: false
        }),
        key: this._getUniqueKey(item),
        parentKey: isDefined(parentKey) ? parentKey : this._rootValue,
        item: this._makeObjectFromPrimitive(item),
        childrenKeys: []
      }
    };
    extend(node, item);
    delete node.items;
    return node;
  },
  setChildrenKeys: function() {
    var that = this;
    each(this._dataStructure, function(_2, node) {
      if (node.internalFields.parentKey === that._rootValue) {
        return;
      }
      var parent = that.getParentNode(node);
      parent && parent.internalFields.childrenKeys.push(node.internalFields.key);
    });
  },
  _makeObjectFromPrimitive: function(item) {
    if (isPrimitive(item)) {
      var key = item;
      item = {};
      this._dataAccessors.setters.key(item, key);
    }
    return item;
  },
  _convertToPublicNode: function(node, parent) {
    if (!node) {
      return null;
    }
    var publicNode = {
      text: this._dataAccessors.getters.display(node),
      key: node.internalFields.key,
      selected: node.internalFields.selected,
      expanded: node.internalFields.expanded,
      disabled: node.internalFields.disabled,
      parent: parent || null,
      itemData: node.internalFields.item,
      children: [],
      items: []
    };
    if (publicNode.parent) {
      publicNode.parent.children.push(publicNode);
      publicNode.parent.items.push(publicNode);
    }
    return publicNode;
  },
  convertToPublicNodes: function(data2, parent) {
    if (!data2.length) {
      return [];
    }
    var that = this;
    var publicNodes = [];
    each(data2, function(_2, node) {
      node = isPrimitive(node) ? that._getByKey(node) : node;
      var publicNode = that._convertToPublicNode(node, parent);
      publicNode.children = that.convertToPublicNodes(node.internalFields.childrenKeys, publicNode);
      publicNodes.push(publicNode);
      node.internalFields.publicNode = publicNode;
    });
    return publicNodes;
  },
  setDataAccessors: function(accessors) {
    this._dataAccessors = accessors;
  },
  _getByKey: function(key) {
    return this._dataStructure[this.getIndexByKey(key)] || null;
  },
  getParentNode: function(node) {
    return this._getByKey(node.internalFields.parentKey);
  },
  getByKey: function(data2, key) {
    if (key === null || key === void 0) {
      return null;
    }
    var result = null;
    var that = this;
    var getByKey = function(data3, key2) {
      each(data3, function(_2, element) {
        var currentElementKey = element.internalFields && element.internalFields.key || that._dataAccessors.getters.key(element);
        if (currentElementKey.toString() === key2.toString()) {
          result = element;
          return false;
        }
      });
      return result;
    };
    return getByKey(data2, key);
  },
  getItemsCount: function() {
    return this._itemsCount;
  },
  getVisibleItemsCount: function() {
    return this._visibleItemsCount;
  },
  updateIndexByKey: function() {
    var that = this;
    this._indexByKey = {};
    each(this._dataStructure, function(index2, node) {
      that._checkForDuplicateId(node.internalFields.key);
      that._indexByKey[node.internalFields.key] = index2;
    });
  },
  updateChildrenKeys: function() {
    this._indexByKey = {};
    this.removeChildrenKeys();
    this.updateIndexByKey();
    this.setChildrenKeys();
  },
  removeChildrenKeys: function() {
    this._indexByKey = {};
    each(this._dataStructure, function(index2, node) {
      node.internalFields.childrenKeys = [];
    });
  },
  getIndexByKey: function(key) {
    return this._indexByKey[key];
  },
  createPlainStructure: function(items, rootValue, dataType) {
    this._itemsCount = 0;
    this._visibleItemsCount = 0;
    this._rootValue = rootValue;
    this._dataType = dataType;
    this._indexByKey = {};
    this._convertItemsToNodes(items);
    this.setChildrenKeys();
    return this._dataStructure;
  }
});
var EXPANDED = "expanded";
var SELECTED = "selected";
var DISABLED = "disabled";
var DataAdapter = classImpl.inherit({
  ctor: function(options) {
    this.options = {};
    extend(this.options, this._defaultOptions(), options);
    this.options.dataConverter.setDataAccessors(this.options.dataAccessors);
    this._selectedNodesKeys = [];
    this._expandedNodesKeys = [];
    this._dataStructure = [];
    this._createInternalDataStructure();
    this.getTreeNodes();
  },
  setOption: function(name2, value2) {
    this.options[name2] = value2;
    if (name2 === "recursiveSelection") {
      this._updateSelection();
    }
  },
  _defaultOptions: function() {
    return {
      dataAccessors: void 0,
      items: [],
      multipleSelection: true,
      recursiveSelection: false,
      recursiveExpansion: false,
      rootValue: 0,
      searchValue: "",
      dataType: "tree",
      searchMode: "contains",
      dataConverter: new DataConverter(),
      onNodeChanged: noop,
      sort: null
    };
  },
  _createInternalDataStructure: function() {
    this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType);
    this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure;
    this.options.dataConverter._dataStructure = this._dataStructure;
    this._updateSelection();
    this._updateExpansion();
  },
  _updateSelection: function() {
    if (this.options.recursiveSelection) {
      this._setChildrenSelection();
      this._setParentSelection();
    }
    this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED);
  },
  _updateExpansion: function(key) {
    if (this.options.recursiveExpansion) {
      key ? this._updateOneBranch(key) : this._setParentExpansion();
    }
    this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED);
  },
  _updateNodesKeysArray: function(property) {
    var that = this;
    var array = [];
    each(that._getDataBySelectionMode(), function(_2, node) {
      if (!that._isNodeVisible(node)) {
        return;
      }
      if (node.internalFields[property]) {
        if (property === EXPANDED || that.options.multipleSelection) {
          array.push(node.internalFields.key);
        } else {
          array.length && that.toggleSelection(array[0], false, true);
          array = [node.internalFields.key];
        }
      }
    });
    return array;
  },
  _getDataBySelectionMode: function() {
    return this.options.multipleSelection ? this.getData() : this.getFullData();
  },
  _isNodeVisible: function(node) {
    return node.internalFields.item.visible !== false;
  },
  _getByKey: function(data2, key) {
    return data2 === this._dataStructure ? this.options.dataConverter._getByKey(key) : this.options.dataConverter.getByKey(data2, key);
  },
  _setChildrenSelection: function() {
    var that = this;
    each(this._dataStructure, function(_2, node) {
      if (!node.internalFields.childrenKeys.length) {
        return;
      }
      var isSelected = node.internalFields.selected;
      isSelected === true && that._toggleChildrenSelection(node, isSelected);
    });
  },
  _setParentSelection: function() {
    var that = this;
    each(this._dataStructure, function(_2, node) {
      var parent = that.options.dataConverter.getParentNode(node);
      if (parent && node.internalFields.parentKey !== that.options.rootValue) {
        that._iterateParents(node, function(parent2) {
          var newParentState = that._calculateSelectedState(parent2);
          that._setFieldState(parent2, SELECTED, newParentState);
        });
      }
    });
  },
  _setParentExpansion: function() {
    var that = this;
    each(this._dataStructure, function(_2, node) {
      if (!node.internalFields.expanded) {
        return;
      }
      that._updateOneBranch(node.internalFields.key);
    });
  },
  _updateOneBranch: function(key) {
    var that = this;
    var node = this.getNodeByKey(key);
    that._iterateParents(node, function(parent) {
      that._setFieldState(parent, EXPANDED, true);
    });
  },
  _iterateChildren: function(node, recursive, callback, processedKeys) {
    if (!isFunction$1(callback)) {
      return;
    }
    var that = this;
    var nodeKey = node.internalFields.key;
    processedKeys = processedKeys || [];
    if (processedKeys.indexOf(nodeKey) === -1) {
      processedKeys.push(nodeKey);
      each(node.internalFields.childrenKeys, function(_2, key) {
        var child = that.getNodeByKey(key);
        callback(child);
        if (child.internalFields.childrenKeys.length && recursive) {
          that._iterateChildren(child, recursive, callback, processedKeys);
        }
      });
    }
  },
  _iterateParents: function(node, callback, processedKeys) {
    if (node.internalFields.parentKey === this.options.rootValue || !isFunction$1(callback)) {
      return;
    }
    processedKeys = processedKeys || [];
    var key = node.internalFields.key;
    if (processedKeys.indexOf(key) === -1) {
      processedKeys.push(key);
      var parent = this.options.dataConverter.getParentNode(node);
      if (parent) {
        callback(parent);
        if (parent.internalFields.parentKey !== this.options.rootValue) {
          this._iterateParents(parent, callback, processedKeys);
        }
      }
    }
  },
  _calculateSelectedState: function(node) {
    var itemsCount = node.internalFields.childrenKeys.length;
    var selectedItemsCount = 0;
    var invisibleItemsCount = 0;
    var result = false;
    for (var i = 0; i <= itemsCount - 1; i++) {
      var childNode = this.getNodeByKey(node.internalFields.childrenKeys[i]);
      var isChildInvisible = childNode.internalFields.item.visible === false;
      var childState = childNode.internalFields.selected;
      if (isChildInvisible) {
        invisibleItemsCount++;
        continue;
      }
      if (childState) {
        selectedItemsCount++;
      } else if (childState === void 0) {
        selectedItemsCount += 0.5;
      }
    }
    if (selectedItemsCount) {
      result = selectedItemsCount === itemsCount - invisibleItemsCount ? true : void 0;
    }
    return result;
  },
  _toggleChildrenSelection: function(node, state) {
    var that = this;
    this._iterateChildren(node, true, function(child) {
      if (that._isNodeVisible(child)) {
        that._setFieldState(child, SELECTED, state);
      }
    });
  },
  _setFieldState: function(node, field, state) {
    if (node.internalFields[field] === state) {
      return;
    }
    node.internalFields[field] = state;
    if (node.internalFields.publicNode) {
      node.internalFields.publicNode[field] = state;
    }
    this.options.dataAccessors.setters[field](node.internalFields.item, state);
    this.options.onNodeChanged(node);
  },
  _markChildren: function(keys2) {
    var that = this;
    each(keys2, function(_2, key) {
      var index2 = that.getIndexByKey(key);
      var node = that.getNodeByKey(key);
      that._dataStructure[index2] = 0;
      node.internalFields.childrenKeys.length && that._markChildren(node.internalFields.childrenKeys);
    });
  },
  _removeNode: function(key) {
    var node = this.getNodeByKey(key);
    this._dataStructure[this.getIndexByKey(key)] = 0;
    this._markChildren(node.internalFields.childrenKeys);
    var that = this;
    var counter = 0;
    var items = extend([], this._dataStructure);
    each(items, function(index2, item) {
      if (!item) {
        that._dataStructure.splice(index2 - counter, 1);
        counter++;
      }
    });
  },
  _addNode: function(item) {
    var dataConverter = this.options.dataConverter;
    var node = dataConverter._convertItemToNode(item, this.options.dataAccessors.getters.parentKey(item));
    this._dataStructure = this._dataStructure.concat(node);
    this._initialDataStructure = this._initialDataStructure.concat(node);
    dataConverter._dataStructure = dataConverter._dataStructure.concat(node);
  },
  _updateFields: function() {
    this.options.dataConverter.updateChildrenKeys();
    this._updateSelection();
    this._updateExpansion();
  },
  getSelectedNodesKeys: function() {
    return this._selectedNodesKeys;
  },
  getExpandedNodesKeys: function() {
    return this._expandedNodesKeys;
  },
  getData: function() {
    return this._dataStructure;
  },
  getFullData: function() {
    return this._initialDataStructure;
  },
  getNodeByItem: function(item) {
    var result = null;
    each(this._dataStructure, function(_2, node) {
      if (node.internalFields.item === item) {
        result = node;
        return false;
      }
    });
    return result;
  },
  getNodesByItems: function(items) {
    var that = this;
    var nodes = [];
    each(items, function(_2, item) {
      var node = that.getNodeByItem(item);
      node && nodes.push(node);
    });
    return nodes;
  },
  getNodeByKey: function(key, data2) {
    return this._getByKey(data2 || this._getDataBySelectionMode(), key);
  },
  getTreeNodes: function() {
    return this.options.dataConverter.convertToPublicNodes(this.getRootNodes());
  },
  getItemsCount: function() {
    return this.options.dataConverter.getItemsCount();
  },
  getVisibleItemsCount: function() {
    return this.options.dataConverter.getVisibleItemsCount();
  },
  getPublicNode: function(node) {
    return node.internalFields.publicNode;
  },
  getRootNodes: function() {
    return this.getChildrenNodes(this.options.rootValue);
  },
  getChildrenNodes: function(parentKey) {
    return query(this._dataStructure).filter(["internalFields.parentKey", parentKey]).toArray();
  },
  getIndexByKey: function(key) {
    return this.options.dataConverter.getIndexByKey(key);
  },
  addItem: function(item) {
    this._addNode(item);
    this._updateFields();
  },
  removeItem: function(key) {
    this._removeNode(key);
    this._updateFields();
  },
  toggleSelection: function(key, state, selectRecursive) {
    var isSingleModeUnselect = this._isSingleModeUnselect(state);
    var node = this._getByKey(selectRecursive || isSingleModeUnselect ? this._initialDataStructure : this._dataStructure, key);
    this._setFieldState(node, SELECTED, state);
    if (this.options.recursiveSelection && !selectRecursive) {
      state ? this._setChildrenSelection() : this._toggleChildrenSelection(node, state);
      this._setParentSelection();
    }
    this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED);
  },
  _isSingleModeUnselect: function(selectionState) {
    return !this.options.multipleSelection && !selectionState;
  },
  toggleNodeDisabledState: function(key, state) {
    var node = this.getNodeByKey(key);
    this._setFieldState(node, DISABLED, state);
  },
  toggleSelectAll: function(state) {
    if (!isDefined(state)) {
      return;
    }
    var that = this;
    var lastSelectedKey = that._selectedNodesKeys[that._selectedNodesKeys.length - 1];
    var dataStructure = that._isSingleModeUnselect(state) ? this._initialDataStructure : this._dataStructure;
    each(dataStructure, function(index2, node) {
      if (!that._isNodeVisible(node)) {
        return;
      }
      that._setFieldState(node, SELECTED, state);
    });
    that._selectedNodesKeys = that._updateNodesKeysArray(SELECTED);
    if (!state && that.options.selectionRequired) {
      that.toggleSelection(lastSelectedKey, true);
    }
  },
  isAllSelected: function() {
    if (this.getSelectedNodesKeys().length) {
      return this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? true : void 0;
    } else {
      return false;
    }
  },
  toggleExpansion: function(key, state) {
    var node = this.getNodeByKey(key);
    this._setFieldState(node, EXPANDED, state);
    if (state) {
      this._updateExpansion(key);
    }
    this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED);
  },
  isFiltered: function(item) {
    return !this.options.searchValue.length || !!this._filterDataStructure(this.options.searchValue, [item]).length;
  },
  _createCriteria: function(selector, value2, operation) {
    var searchFilter = [];
    if (!Array.isArray(selector)) {
      return [selector, operation, value2];
    }
    each(selector, function(i, item) {
      searchFilter.push([item, operation, value2], "or");
    });
    searchFilter.pop();
    return searchFilter;
  },
  _filterDataStructure: function(filterValue, dataStructure) {
    var selector = this.options.searchExpr || this.options.dataAccessors.getters.display;
    var operation = searchBoxMixin.getOperationBySearchMode(this.options.searchMode);
    var criteria = this._createCriteria(selector, filterValue, operation);
    dataStructure = dataStructure || this._initialDataStructure;
    return query(dataStructure).filter(criteria).toArray();
  },
  search: function(searchValue) {
    var that = this;
    var matches = this._filterDataStructure(searchValue);
    var dataConverter = this.options.dataConverter;
    !function lookForParents(matches2, index2) {
      var length = matches2.length;
      while (index2 < length) {
        var node = matches2[index2];
        if (node.internalFields.parentKey === that.options.rootValue) {
          index2++;
          continue;
        }
        var parent = dataConverter.getParentNode(node);
        if (!parent) {
          errors$1.log("W1007", node.internalFields.parentKey, node.internalFields.key);
          index2++;
          continue;
        }
        if (!parent.internalFields.expanded) {
          that._setFieldState(parent, EXPANDED, true);
        }
        if (inArray(parent, matches2) > -1) {
          index2++;
          continue;
        }
        matches2.splice(index2, 0, parent);
        lookForParents(matches2, index2);
      }
    }(matches, 0);
    if (this.options.sort) {
      matches = storeHelper.queryByOptions(query(matches), {
        sort: this.options.sort
      }).toArray();
    }
    dataConverter._indexByKey = {};
    each(matches, function(index2, node) {
      node.internalFields.childrenKeys = [];
      dataConverter._indexByKey[node.internalFields.key] = index2;
    });
    dataConverter._dataStructure = matches;
    dataConverter.setChildrenKeys();
    return dataConverter._dataStructure;
  }
});
var DISABLED_STATE_CLASS$1 = "dx-state-disabled";
var HierarchicalCollectionWidget = CollectionWidget$1.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      keyExpr: "id",
      displayExpr: "text",
      selectedExpr: "selected",
      disabledExpr: "disabled",
      itemsExpr: "items",
      hoverStateEnabled: true,
      parentIdExpr: "parentId",
      expandedExpr: "expanded"
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function() {
        return devices.real().deviceType === "desktop" && !devices.isSimulator();
      },
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _init: function() {
    this.callBase();
    this._initAccessors();
    this._initDataAdapter();
    this._initDynamicTemplates();
  },
  _initDataSource: function() {
    this.callBase();
    this._dataSource && this._dataSource.paginate(false);
  },
  _initDataAdapter: function() {
    var accessors = this._createDataAdapterAccessors();
    this._dataAdapter = new DataAdapter(extend({
      dataAccessors: {
        getters: accessors.getters,
        setters: accessors.setters
      },
      items: this.option("items")
    }, this._getDataAdapterOptions()));
  },
  _getDataAdapterOptions: noop,
  _initDynamicTemplates: function() {
    var that = this;
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(function($container, itemData) {
        $container.html(itemData.html).append(this._getIconContainer(itemData)).append(this._getTextContainer(itemData)).append(this._getPopoutContainer(itemData));
        that._addContentClasses(itemData, $container.parent());
      }.bind(this), ["text", "html", "items", "icon"], this.option("integrationOptions.watchMethod"), {
        text: this._displayGetter,
        items: this._itemsGetter
      })
    });
  },
  _getIconContainer: function(itemData) {
    return itemData.icon ? getImageContainer(itemData.icon) : void 0;
  },
  _getTextContainer: function(itemData) {
    return $("<span>").text(itemData.text);
  },
  _getPopoutContainer: noop,
  _addContentClasses: noop,
  _initAccessors: function() {
    var that = this;
    each(this._getAccessors(), function(_2, accessor) {
      that._compileAccessor(accessor);
    });
    this._compileDisplayGetter();
  },
  _getAccessors: function() {
    return ["key", "selected", "items", "disabled", "parentId", "expanded"];
  },
  _getChildNodes: function(node) {
    var that = this;
    var arr = [];
    each(node.internalFields.childrenKeys, function(_2, key) {
      var childNode = that._dataAdapter.getNodeByKey(key);
      arr.push(childNode);
    });
    return arr;
  },
  _hasChildren: function(node) {
    return node && node.internalFields.childrenKeys.length;
  },
  _compileAccessor: function(optionName) {
    var getter = "_" + optionName + "Getter";
    var setter = "_" + optionName + "Setter";
    var optionExpr = this.option(optionName + "Expr");
    if (!optionExpr) {
      this[getter] = noop;
      this[setter] = noop;
      return;
    } else if (isFunction$1(optionExpr)) {
      this[setter] = function(obj, value2) {
        obj[optionExpr()] = value2;
      };
      this[getter] = function(obj) {
        return obj[optionExpr()];
      };
      return;
    }
    this[getter] = compileGetter(optionExpr);
    this[setter] = compileSetter(optionExpr);
  },
  _createDataAdapterAccessors: function() {
    var that = this;
    var accessors = {
      getters: {},
      setters: {}
    };
    each(this._getAccessors(), function(_2, accessor) {
      var getterName = "_" + accessor + "Getter";
      var setterName = "_" + accessor + "Setter";
      var newAccessor = accessor === "parentId" ? "parentKey" : accessor;
      accessors.getters[newAccessor] = that[getterName];
      accessors.setters[newAccessor] = that[setterName];
    });
    accessors.getters.display = !this._displayGetter ? (itemData) => itemData.text : this._displayGetter;
    return accessors;
  },
  _initMarkup: function() {
    this.callBase();
    this._addWidgetClass();
  },
  _addWidgetClass: function() {
    this._focusTarget().addClass(this._widgetClass());
  },
  _widgetClass: noop,
  _renderItemFrame: function(index2, itemData) {
    var $itemFrame = this.callBase.apply(this, arguments);
    $itemFrame.toggleClass(DISABLED_STATE_CLASS$1, !!this._disabledGetter(itemData));
    return $itemFrame;
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "displayExpr":
      case "keyExpr":
        this._initAccessors();
        this._initDynamicTemplates();
        this.repaint();
        break;
      case "itemsExpr":
      case "selectedExpr":
      case "disabledExpr":
      case "expandedExpr":
      case "parentIdExpr":
        this._initAccessors();
        this._initDataAdapter();
        this.repaint();
        break;
      case "items":
        this._initDataAdapter();
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  }
});
var DBLCLICK_EVENT_NAME = "dxdblclick";
var DBLCLICK_NAMESPACE = "dxDblClick";
var NAMESPACED_CLICK_EVENT = addNamespace$1(CLICK_EVENT_NAME$2, DBLCLICK_NAMESPACE);
var DBLCLICK_TIMEOUT = 300;
var DblClick = classImpl.inherit({
  ctor: function() {
    this._handlerCount = 0;
    this._forgetLastClick();
  },
  _forgetLastClick: function() {
    this._firstClickTarget = null;
    this._lastClickTimeStamp = -DBLCLICK_TIMEOUT;
  },
  add: function() {
    if (this._handlerCount <= 0) {
      eventsEngine.on(domAdapter.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
    }
    this._handlerCount++;
  },
  _clickHandler: function(e) {
    var timeStamp = e.timeStamp || Date.now();
    var timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
    var isSimulated = timeBetweenClicks < 0;
    var isDouble = !isSimulated && timeBetweenClicks < DBLCLICK_TIMEOUT;
    if (isDouble) {
      fireEvent({
        type: DBLCLICK_EVENT_NAME,
        target: closestCommonParent(this._firstClickTarget, e.target),
        originalEvent: e
      });
      this._forgetLastClick();
    } else {
      this._firstClickTarget = e.target;
      this._lastClickTimeStamp = timeStamp;
    }
  },
  remove: function() {
    this._handlerCount--;
    if (this._handlerCount <= 0) {
      this._forgetLastClick();
      eventsEngine.off(domAdapter.getDocument(), NAMESPACED_CLICK_EVENT);
    }
  }
});
registerEvent(DBLCLICK_EVENT_NAME, new DblClick());
var abstract$2 = classImpl.abstract;
var realDevice = devices.real();
var SCROLL_INIT_EVENT = "dxscrollinit";
var SCROLL_START_EVENT = "dxscrollstart";
var SCROLL_MOVE_EVENT = "dxscroll";
var SCROLL_END_EVENT = "dxscrollend";
var SCROLL_STOP_EVENT = "dxscrollstop";
var SCROLL_CANCEL_EVENT = "dxscrollcancel";
var Locker = classImpl.inherit(function() {
  var NAMESPACED_SCROLL_EVENT = addNamespace$1("scroll", "dxScrollEmitter");
  return {
    ctor: function(element) {
      this._element = element;
      this._locked = false;
      var that = this;
      this._proxiedScroll = function(e) {
        that._scroll(e);
      };
      eventsEngine.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    },
    _scroll: abstract$2,
    check: function(e, callback) {
      if (this._locked) {
        callback();
      }
    },
    dispose: function() {
      eventsEngine.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    }
  };
}());
var TimeoutLocker = Locker.inherit({
  ctor: function(element, timeout) {
    this.callBase(element);
    this._timeout = timeout;
  },
  _scroll: function() {
    this._prepare();
    this._forget();
  },
  _prepare: function() {
    if (this._timer) {
      this._clearTimer();
    }
    this._locked = true;
  },
  _clearTimer: function() {
    clearTimeout(this._timer);
    this._locked = false;
    this._timer = null;
  },
  _forget: function() {
    var that = this;
    this._timer = setTimeout(function() {
      that._clearTimer();
    }, this._timeout);
  },
  dispose: function() {
    this.callBase();
    this._clearTimer();
  }
});
var WheelLocker = TimeoutLocker.inherit({
  ctor: function(element) {
    this.callBase(element, 400);
    this._lastWheelDirection = null;
  },
  check: function(e, callback) {
    this._checkDirectionChanged(e);
    this.callBase(e, callback);
  },
  _checkDirectionChanged: function(e) {
    if (!isDxMouseWheelEvent(e)) {
      this._lastWheelDirection = null;
      return;
    }
    var direction = e.shiftKey || false;
    var directionChange = this._lastWheelDirection !== null && direction !== this._lastWheelDirection;
    this._lastWheelDirection = direction;
    this._locked = this._locked && !directionChange;
  }
});
var PointerLocker = TimeoutLocker.inherit({
  ctor: function(element) {
    this.callBase(element, 400);
  }
});
!function() {
  var ios8_greater = realDevice.ios && compare(realDevice.version, [8]) >= 0;
  var android5_greater = realDevice.android && compare(realDevice.version, [5]) >= 0;
  if (!(ios8_greater || android5_greater)) {
    return;
  }
  PointerLocker = Locker.inherit({
    _scroll: function() {
      this._locked = true;
      var that = this;
      cancelAnimationFrame(this._scrollFrame);
      this._scrollFrame = requestAnimationFrame(function() {
        that._locked = false;
      });
    },
    check: function(e, callback) {
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
      var that = this;
      var callBase = this.callBase;
      this._checkFrame = requestAnimationFrame(function() {
        callBase.call(that, e, callback);
        that._locked = false;
      });
    },
    dispose: function() {
      this.callBase();
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
    }
  });
}();
var ScrollEmitter = GestureEmitter.inherit(function() {
  var FRAME_DURATION2 = Math.round(1e3 / 60);
  return {
    ctor: function(element) {
      this.callBase.apply(this, arguments);
      this.direction = "both";
      this._pointerLocker = new PointerLocker(element);
      this._wheelLocker = new WheelLocker(element);
    },
    validate: function() {
      return true;
    },
    configure: function(data2) {
      if (data2.scrollTarget) {
        this._pointerLocker.dispose();
        this._wheelLocker.dispose();
        this._pointerLocker = new PointerLocker(data2.scrollTarget);
        this._wheelLocker = new WheelLocker(data2.scrollTarget);
      }
      this.callBase(data2);
    },
    _init: function(e) {
      this._wheelLocker.check(e, function() {
        if (isDxMouseWheelEvent(e)) {
          this._accept(e);
        }
      }.bind(this));
      this._pointerLocker.check(e, function() {
        var skipCheck = this.isNative && isMouseEvent(e);
        if (!isDxMouseWheelEvent(e) && !skipCheck) {
          this._accept(e);
        }
      }.bind(this));
      this._fireEvent(SCROLL_INIT_EVENT, e);
      this._prevEventData = eventData(e);
    },
    move: function(e) {
      this.callBase.apply(this, arguments);
      e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start: function(e) {
      this._savedEventData = eventData(e);
      this._fireEvent(SCROLL_START_EVENT, e);
      this._prevEventData = eventData(e);
    },
    _move: function(e) {
      var currentEventData = eventData(e);
      this._fireEvent(SCROLL_MOVE_EVENT, e, {
        delta: eventDelta(this._prevEventData, currentEventData)
      });
      var delta = eventDelta(this._savedEventData, currentEventData);
      if (delta.time > 200) {
        this._savedEventData = this._prevEventData;
      }
      this._prevEventData = eventData(e);
    },
    _end: function(e) {
      var endEventDelta = eventDelta(this._prevEventData, eventData(e));
      var velocity = {
        x: 0,
        y: 0
      };
      if (!isDxMouseWheelEvent(e) && endEventDelta.time < 100) {
        var delta = eventDelta(this._savedEventData, this._prevEventData);
        var velocityMultiplier = FRAME_DURATION2 / delta.time;
        velocity = {
          x: delta.x * velocityMultiplier,
          y: delta.y * velocityMultiplier
        };
      }
      this._fireEvent(SCROLL_END_EVENT, e, {
        velocity
      });
    },
    _stop: function(e) {
      this._fireEvent(SCROLL_STOP_EVENT, e);
    },
    cancel: function(e) {
      this.callBase.apply(this, arguments);
      this._fireEvent(SCROLL_CANCEL_EVENT, e);
    },
    dispose: function() {
      this.callBase.apply(this, arguments);
      this._pointerLocker.dispose();
      this._wheelLocker.dispose();
    },
    _clearSelection: function() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover: function() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    }
  };
}());
registerEmitter({
  emitter: ScrollEmitter,
  events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
});
var scrollEvents = {
  init: SCROLL_INIT_EVENT,
  start: SCROLL_START_EVENT,
  move: SCROLL_MOVE_EVENT,
  end: SCROLL_END_EVENT,
  stop: SCROLL_STOP_EVENT,
  cancel: SCROLL_CANCEL_EVENT
};
var abstract$1 = classImpl.abstract;
var Animator = classImpl.inherit({
  ctor: function() {
    this._finished = true;
    this._stopped = false;
    this._proxiedStepCore = this._stepCore.bind(this);
  },
  start: function() {
    this._stopped = false;
    this._finished = false;
    this._stepCore();
  },
  stop: function() {
    this._stopped = true;
    cancelAnimationFrame(this._stepAnimationFrame);
  },
  _stepCore: function() {
    if (this._isStopped()) {
      this._stop();
      return;
    }
    if (this._isFinished()) {
      this._finished = true;
      this._complete();
      return;
    }
    this._step();
    this._stepAnimationFrame = requestAnimationFrame(this._proxiedStepCore);
  },
  _step: abstract$1,
  _isFinished: noop,
  _stop: noop,
  _complete: noop,
  _isStopped: function() {
    return this._stopped;
  },
  inProgress: function() {
    return !(this._stopped || this._finished);
  }
});
var SCROLLBAR = "dxScrollbar";
var SCROLLABLE_SCROLLBAR_CLASS$1 = "dx-scrollable-scrollbar";
var SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = "".concat(SCROLLABLE_SCROLLBAR_CLASS$1, "-active");
var SCROLLABLE_SCROLL_CLASS = "dx-scrollable-scroll";
var SCROLLABLE_SCROLL_CONTENT_CLASS = "dx-scrollable-scroll-content";
var HOVER_ENABLED_STATE = "dx-scrollbar-hoverable";
var HORIZONTAL$3 = "horizontal";
var THUMB_MIN_SIZE = 15;
var SCROLLBAR_VISIBLE = {
  onScroll: "onScroll",
  onHover: "onHover",
  always: "always",
  never: "never"
};
var activeScrollbar = null;
var Scrollbar = Widget.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      direction: null,
      visible: false,
      activeStateEnabled: false,
      visibilityMode: SCROLLBAR_VISIBLE.onScroll,
      containerSize: 0,
      contentSize: 0,
      expandable: true,
      scaleRatio: 1
    });
  },
  _init: function() {
    this.callBase();
    this._isHovered = false;
  },
  _initMarkup: function() {
    this._renderThumb();
    this.callBase();
  },
  _render: function() {
    this.callBase();
    this._renderDirection();
    this._update();
    this._attachPointerDownHandler();
    this.option("hoverStateEnabled", this._isHoverMode());
    this.$element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"));
  },
  _renderThumb: function() {
    this._$thumb = $("<div>").addClass(SCROLLABLE_SCROLL_CLASS);
    $("<div>").addClass(SCROLLABLE_SCROLL_CONTENT_CLASS).appendTo(this._$thumb);
    this.$element().addClass(SCROLLABLE_SCROLLBAR_CLASS$1).append(this._$thumb);
  },
  isThumb: function($element) {
    return !!this.$element().find($element).length;
  },
  _isHoverMode: function() {
    var visibilityMode = this.option("visibilityMode");
    return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option("expandable");
  },
  _renderDirection: function() {
    var direction = this.option("direction");
    this.$element().addClass("dx-scrollbar-" + direction);
    this._dimension = direction === HORIZONTAL$3 ? "width" : "height";
    this._prop = direction === HORIZONTAL$3 ? "left" : "top";
  },
  _attachPointerDownHandler: function() {
    eventsEngine.on(this._$thumb, addNamespace$1(pointer.down, SCROLLBAR), this.feedbackOn.bind(this));
  },
  feedbackOn: function() {
    this.$element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
    activeScrollbar = this;
  },
  feedbackOff: function() {
    this.$element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
    activeScrollbar = null;
  },
  cursorEnter: function() {
    this._isHovered = true;
    if (this._needScrollbar()) {
      this.option("visible", true);
    }
  },
  cursorLeave: function() {
    this._isHovered = false;
    this.option("visible", false);
  },
  _renderDimensions: function() {
    this._$thumb.css({
      width: this.option("width"),
      height: this.option("height")
    });
  },
  _toggleVisibility: function(visible2) {
    if (this.option("visibilityMode") === SCROLLBAR_VISIBLE.onScroll) {
      this._$thumb.css("opacity");
    }
    visible2 = this._adjustVisibility(visible2);
    this.option().visible = visible2;
    this._$thumb.toggleClass("dx-state-invisible", !visible2);
  },
  _adjustVisibility: function(visible2) {
    if (this._baseContainerToContentRatio && !this._needScrollbar()) {
      return false;
    }
    switch (this.option("visibilityMode")) {
      case SCROLLBAR_VISIBLE.onScroll:
        break;
      case SCROLLBAR_VISIBLE.onHover:
        visible2 = visible2 || !!this._isHovered;
        break;
      case SCROLLBAR_VISIBLE.never:
        visible2 = false;
        break;
      case SCROLLBAR_VISIBLE.always:
        visible2 = true;
    }
    return visible2;
  },
  moveTo: function(location) {
    if (this._isHidden()) {
      return;
    }
    if (isPlainObject(location)) {
      location = location[this._prop] || 0;
    }
    var scrollBarLocation = {};
    scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
    move(this._$thumb, scrollBarLocation);
  },
  _calculateScrollBarPosition: function(location) {
    return -location * this._thumbRatio;
  },
  _update: function() {
    var containerSize = Math.round(this.option("containerSize"));
    var contentSize = Math.round(this.option("contentSize"));
    var baseContainerSize = Math.round(this.option("baseContainerSize"));
    var baseContentSize = Math.round(this.option("baseContentSize"));
    if (isNaN(baseContainerSize)) {
      baseContainerSize = containerSize;
      baseContentSize = contentSize;
    }
    this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
    this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
    var thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), THUMB_MIN_SIZE));
    this._thumbRatio = (containerSize - thumbSize) / (this.option("scaleRatio") * (contentSize - containerSize));
    this.option(this._dimension, thumbSize / this.option("scaleRatio"));
    this.$element().css("display", this._needScrollbar() ? "" : "none");
  },
  _isHidden: function() {
    return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never;
  },
  _needScrollbar: function() {
    return !this._isHidden() && this._baseContainerToContentRatio < 1;
  },
  containerToContentRatio: function() {
    return this._realContainerToContentRatio;
  },
  _normalizeSize: function(size) {
    return isPlainObject(size) ? size[this._dimension] || 0 : size;
  },
  _clean: function() {
    this.callBase();
    if (this === activeScrollbar) {
      activeScrollbar = null;
    }
    eventsEngine.off(this._$thumb, "." + SCROLLBAR);
  },
  _optionChanged: function(args) {
    if (this._isHidden()) {
      return;
    }
    switch (args.name) {
      case "containerSize":
      case "contentSize":
        this.option()[args.name] = this._normalizeSize(args.value);
        this._update();
        break;
      case "baseContentSize":
      case "baseContainerSize":
        this._update();
        break;
      case "visibilityMode":
      case "direction":
        this._invalidate();
        break;
      case "scaleRatio":
        this._update();
        break;
      default:
        this.callBase.apply(this, arguments);
    }
  },
  update: deferRenderer(function() {
    this._adjustVisibility() && this.option("visible", true);
  })
});
readyCallback.add(function() {
  eventsEngine.subscribeGlobal(domAdapter.getDocument(), addNamespace$1(pointer.up, SCROLLBAR), function() {
    if (activeScrollbar) {
      activeScrollbar.feedbackOff();
    }
  });
});
var SCROLLABLE_SIMULATED = "dxSimulatedScrollable";
var SCROLLABLE_STRATEGY$1 = "dxScrollableStrategy";
var SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + "Cursor";
var SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + "Keyboard";
var SCROLLABLE_SIMULATED_CLASS = "dx-scrollable-simulated";
var SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible";
var SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar";
var VERTICAL$2 = "vertical";
var HORIZONTAL$2 = "horizontal";
var ACCELERATION = 0.92;
var OUT_BOUNDS_ACCELERATION = 0.5;
var MIN_VELOCITY_LIMIT = 1;
var FRAME_DURATION = Math.round(1e3 / 60);
var SCROLL_LINE_HEIGHT = 40;
var VALIDATE_WHEEL_TIMEOUT = 500;
var BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5;
var BOUNCE_DURATION = 400;
var BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION;
var BOUNCE_ACCELERATION_SUM = (1 - Math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);
var KEY_CODES = {
  PAGE_UP: "pageUp",
  PAGE_DOWN: "pageDown",
  END: "end",
  HOME: "home",
  LEFT: "leftArrow",
  UP: "upArrow",
  RIGHT: "rightArrow",
  DOWN: "downArrow",
  TAB: "tab"
};
var InertiaAnimator = Animator.inherit({
  ctor: function(scroller) {
    this.callBase();
    this.scroller = scroller;
  },
  VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
  _isFinished: function() {
    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
  },
  _step: function() {
    this.scroller._scrollStep(this.scroller._velocity);
    this.scroller._velocity *= this._acceleration();
  },
  _acceleration: function() {
    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION;
  },
  _complete: function() {
    this.scroller._scrollComplete();
  }
});
var BounceAnimator = InertiaAnimator.inherit({
  VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
  _isFinished: function() {
    return this.scroller._crossBoundOnNextStep() || this.callBase();
  },
  _acceleration: function() {
    return ACCELERATION;
  },
  _complete: function() {
    this.scroller._move(this.scroller._bounceLocation);
    this.callBase();
  }
});
var Scroller = classImpl.inherit({
  ctor: function(options) {
    this._initOptions(options);
    this._initAnimators();
    this._initScrollbar();
  },
  _initOptions: function(options) {
    this._location = 0;
    this._topReached = false;
    this._bottomReached = false;
    this._axis = options.direction === HORIZONTAL$2 ? "x" : "y";
    this._prop = options.direction === HORIZONTAL$2 ? "left" : "top";
    this._dimension = options.direction === HORIZONTAL$2 ? "width" : "height";
    this._scrollProp = options.direction === HORIZONTAL$2 ? "scrollLeft" : "scrollTop";
    each(options, (optionName, optionValue) => {
      this["_" + optionName] = optionValue;
    });
  },
  _initAnimators: function() {
    this._inertiaAnimator = new InertiaAnimator(this);
    this._bounceAnimator = new BounceAnimator(this);
  },
  _initScrollbar: function() {
    this._scrollbar = new Scrollbar($("<div>").appendTo(this._$container), {
      direction: this._direction,
      visible: this._scrollByThumb,
      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
      expandable: this._scrollByThumb
    });
    this._$scrollbar = this._scrollbar.$element();
  },
  _visibilityModeNormalize: function(mode) {
    return mode === true ? "onScroll" : mode === false ? "never" : mode;
  },
  _scrollStep: function(delta) {
    var prevLocation = this._location;
    this._location += delta;
    this._suppressBounce();
    this._move();
    if (Math.abs(prevLocation - this._location) < 1) {
      return;
    }
    eventsEngine.triggerHandler(this._$container, {
      type: "scroll"
    });
  },
  _suppressBounce: function() {
    if (this._bounceEnabled || this._inBounds(this._location)) {
      return;
    }
    this._velocity = 0;
    this._location = this._boundLocation();
  },
  _boundLocation: function(location) {
    location = location !== void 0 ? location : this._location;
    return Math.max(Math.min(location, this._maxOffset), this._minOffset);
  },
  _move: function(location) {
    this._location = location !== void 0 ? location * this._getScaleRatio() : this._location;
    this._moveContent();
    this._moveScrollbar();
  },
  _moveContent: function() {
    var location = this._location;
    this._$container[this._scrollProp](-location / this._getScaleRatio());
    this._moveContentByTranslator(location);
  },
  _getScaleRatio: function() {
    if (hasWindow$1() && !this._scaleRatio) {
      var element = this._$element.get(0);
      var realDimension = this._getRealDimension(element, this._dimension);
      var baseDimension = this._getBaseDimension(element, this._dimension);
      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;
    }
    return this._scaleRatio || 1;
  },
  _getRealDimension: function(element, dimension) {
    return Math.round(getBoundingRect(element)[dimension]);
  },
  _getBaseDimension: function(element, dimension) {
    var dimensionName = "offset" + titleize(dimension);
    return element[dimensionName];
  },
  _moveContentByTranslator: function(location) {
    var translateOffset;
    var minOffset = -this._maxScrollPropValue;
    if (location > 0) {
      translateOffset = location;
    } else if (location <= minOffset) {
      translateOffset = location - minOffset;
    } else {
      translateOffset = location % 1;
    }
    if (this._translateOffset === translateOffset) {
      return;
    }
    var targetLocation = {};
    targetLocation[this._prop] = translateOffset;
    this._translateOffset = translateOffset;
    if (translateOffset === 0) {
      resetPosition(this._$content);
      return;
    }
    move(this._$content, targetLocation);
  },
  _moveScrollbar: function() {
    this._scrollbar.moveTo(this._location);
  },
  _scrollComplete: function() {
    if (this._inBounds()) {
      this._hideScrollbar();
      if (this._completeDeferred) {
        this._completeDeferred.resolve();
      }
    }
    this._scrollToBounds();
  },
  _scrollToBounds: function() {
    if (this._inBounds()) {
      return;
    }
    this._bounceAction();
    this._setupBounce();
    this._bounceAnimator.start();
  },
  _setupBounce: function() {
    var boundLocation = this._bounceLocation = this._boundLocation();
    var bounceDistance = boundLocation - this._location;
    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;
  },
  _inBounds: function(location) {
    location = location !== void 0 ? location : this._location;
    return this._boundLocation(location) === location;
  },
  _crossBoundOnNextStep: function() {
    var location = this._location;
    var nextLocation = location + this._velocity;
    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;
  },
  _initHandler: function(e) {
    this._stopScrolling();
    this._prepareThumbScrolling(e);
  },
  _stopScrolling: deferRenderer(function() {
    this._hideScrollbar();
    this._inertiaAnimator.stop();
    this._bounceAnimator.stop();
  }),
  _prepareThumbScrolling: function(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      return;
    }
    var $target = $(e.originalEvent.target);
    var scrollbarClicked = this._isScrollbar($target);
    if (scrollbarClicked) {
      this._moveToMouseLocation(e);
    }
    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
    if (this._thumbScrolling) {
      this._scrollbar.feedbackOn();
    }
  },
  _isThumbScrollingHandler: function($target) {
    return this._isThumb($target);
  },
  _moveToMouseLocation: function(e) {
    var mouseLocation = e["page" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];
    var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;
    this._scrollStep(-Math.round(location));
  },
  _startHandler: function() {
    this._showScrollbar();
  },
  _moveHandler: function(delta) {
    if (this._crossThumbScrolling) {
      return;
    }
    if (this._thumbScrolling) {
      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());
    }
    this._scrollBy(delta);
  },
  _scrollBy: function(delta) {
    delta = delta[this._axis];
    if (!this._inBounds()) {
      delta *= OUT_BOUNDS_ACCELERATION;
    }
    this._scrollStep(delta);
  },
  _scrollByHandler: function(delta) {
    this._scrollBy(delta);
    this._scrollComplete();
  },
  _containerToContentRatio: function() {
    return this._scrollbar.containerToContentRatio();
  },
  _endHandler: function(velocity) {
    this._completeDeferred = new Deferred();
    this._velocity = velocity[this._axis];
    this._inertiaHandler();
    this._resetThumbScrolling();
    return this._completeDeferred.promise();
  },
  _inertiaHandler: function() {
    this._suppressInertia();
    this._inertiaAnimator.start();
  },
  _suppressInertia: function() {
    if (!this._inertiaEnabled || this._thumbScrolling) {
      this._velocity = 0;
    }
  },
  _resetThumbScrolling: function() {
    this._thumbScrolling = false;
    this._crossThumbScrolling = false;
  },
  _stopHandler: function() {
    if (this._thumbScrolling) {
      this._scrollComplete();
    }
    this._resetThumbScrolling();
    this._scrollToBounds();
  },
  _disposeHandler: function() {
    this._stopScrolling();
    this._$scrollbar.remove();
  },
  _updateHandler: function() {
    this._update();
    this._moveToBounds();
  },
  _update: function() {
    this._stopScrolling();
    return deferUpdate(() => {
      this._resetScaleRatio();
      this._updateLocation();
      this._updateBounds();
      this._updateScrollbar();
      deferRender(() => {
        this._moveScrollbar();
        this._scrollbar.update();
      });
    });
  },
  _resetScaleRatio: function() {
    this._scaleRatio = null;
  },
  _updateLocation: function() {
    this._location = (locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
  },
  _updateBounds: function() {
    this._maxOffset = Math.round(this._getMaxOffset());
    this._minOffset = Math.round(this._getMinOffset());
  },
  _getMaxOffset: function() {
    return 0;
  },
  _getMinOffset: function() {
    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
    return -this._maxScrollPropValue;
  },
  _updateScrollbar: deferUpdater(function() {
    var containerSize = this._containerSize();
    var contentSize = this._contentSize();
    var baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
    var baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
    deferRender(() => {
      this._scrollbar.option({
        containerSize,
        contentSize,
        baseContainerSize,
        baseContentSize,
        scaleRatio: this._getScaleRatio()
      });
    });
  }),
  _moveToBounds: deferRenderer(deferUpdater(deferRenderer(function() {
    var location = this._boundLocation();
    var locationChanged = location !== this._location;
    this._location = location;
    this._move();
    if (locationChanged) {
      this._scrollAction();
    }
  }))),
  _createActionsHandler: function(actions) {
    this._scrollAction = actions.scroll;
    this._bounceAction = actions.bounce;
  },
  _showScrollbar: function() {
    this._scrollbar.option("visible", true);
  },
  _hideScrollbar: function() {
    this._scrollbar.option("visible", false);
  },
  _containerSize: function() {
    return this._getRealDimension(this._$container.get(0), this._dimension);
  },
  _contentSize: function() {
    var isOverflowHidden = this._$content.css("overflow" + this._axis.toUpperCase()) === "hidden";
    var contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
    if (!isOverflowHidden) {
      var containerScrollSize = this._$content[0]["scroll" + titleize(this._dimension)] * this._getScaleRatio();
      contentSize = Math.max(containerScrollSize, contentSize);
    }
    return contentSize;
  },
  _validateEvent: function(e) {
    var $target = $(e.originalEvent.target);
    return this._isThumb($target) || this._isScrollbar($target) || this._isContent($target);
  },
  _isThumb: function($element) {
    return this._scrollByThumb && this._scrollbar.isThumb($element);
  },
  _isScrollbar: function($element) {
    return this._scrollByThumb && $element && $element.is(this._$scrollbar);
  },
  _isContent: function($element) {
    return this._scrollByContent && !!$element.closest(this._$element).length;
  },
  _reachedMin: function() {
    return this._location <= this._minOffset;
  },
  _reachedMax: function() {
    return this._location >= this._maxOffset;
  },
  _cursorEnterHandler: function() {
    this._resetScaleRatio();
    this._updateScrollbar();
    this._scrollbar.cursorEnter();
  },
  _cursorLeaveHandler: function() {
    this._scrollbar.cursorLeave();
  },
  dispose: noop
});
var hoveredScrollable;
var activeScrollable;
var SimulatedStrategy = classImpl.inherit({
  ctor: function(scrollable) {
    this._init(scrollable);
  },
  _init: function(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = scrollable._$container;
    this._$wrapper = scrollable._$wrapper;
    this._$content = scrollable._$content;
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
  },
  render: function() {
    this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);
    this._createScrollers();
    if (this.option("useKeyboard")) {
      this._$container.prop("tabIndex", 0);
    }
    this._attachKeyboardHandler();
    this._attachCursorHandlers();
  },
  _createScrollers: function() {
    this._scrollers = {};
    if (this._isDirection(HORIZONTAL$2)) {
      this._createScroller(HORIZONTAL$2);
    }
    if (this._isDirection(VERTICAL$2)) {
      this._createScroller(VERTICAL$2);
    }
    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, this.option("showScrollbar") === "always");
  },
  _createScroller: function(direction) {
    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));
  },
  _scrollerOptions: function(direction) {
    return {
      direction,
      $content: this._$content,
      $container: this._$container,
      $wrapper: this._$wrapper,
      $element: this._$element,
      scrollByContent: this.option("scrollByContent"),
      scrollByThumb: this.option("scrollByThumb"),
      scrollbarVisible: this.option("showScrollbar"),
      bounceEnabled: this.option("bounceEnabled"),
      inertiaEnabled: this.option("inertiaEnabled"),
      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
    };
  },
  _applyScaleRatio: function(targetLocation) {
    for (var direction in this._scrollers) {
      var prop = this._getPropByDirection(direction);
      if (isDefined(targetLocation[prop])) {
        var scroller = this._scrollers[direction];
        targetLocation[prop] *= scroller._getScaleRatio();
      }
    }
    return targetLocation;
  },
  _isAnyThumbScrolling: function($target) {
    var result = false;
    this._eventHandler("isThumbScrolling", $target).done(function(isThumbScrollingVertical, isThumbScrollingHorizontal) {
      result = isThumbScrollingVertical || isThumbScrollingHorizontal;
    });
    return result;
  },
  handleInit: function(e) {
    this._suppressDirections(e);
    this._eventForUserAction = e;
    this._eventHandler("init", e);
  },
  _suppressDirections: function(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      this._prepareDirections(true);
      return;
    }
    this._prepareDirections();
    this._eachScroller(function(scroller, direction) {
      var isValid = scroller._validateEvent(e);
      this._validDirections[direction] = isValid;
    });
  },
  _prepareDirections: function(value2) {
    value2 = value2 || false;
    this._validDirections = {};
    this._validDirections[HORIZONTAL$2] = value2;
    this._validDirections[VERTICAL$2] = value2;
  },
  _eachScroller: function(callback) {
    callback = callback.bind(this);
    each(this._scrollers, function(direction, scroller) {
      callback(scroller, direction);
    });
  },
  handleStart: function(e) {
    this._eventForUserAction = e;
    this._eventHandler("start").done(this._startAction);
  },
  _saveActive: function() {
    activeScrollable = this;
  },
  _resetActive: function() {
    if (activeScrollable === this) {
      activeScrollable = null;
    }
  },
  handleMove: function(e) {
    if (this._isLocked()) {
      e.cancel = true;
      this._resetActive();
      return;
    }
    this._saveActive();
    e.preventDefault && e.preventDefault();
    this._adjustDistance(e, e.delta);
    this._eventForUserAction = e;
    this._eventHandler("move", e.delta);
  },
  _adjustDistance: function(e, distance) {
    distance.x *= this._validDirections[HORIZONTAL$2];
    distance.y *= this._validDirections[VERTICAL$2];
    var devicePixelRatio = this._tryGetDevicePixelRatio();
    if (devicePixelRatio && isDxMouseWheelEvent(e.originalEvent)) {
      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;
    }
  },
  _tryGetDevicePixelRatio: function() {
    if (hasWindow$1()) {
      return getWindow().devicePixelRatio;
    }
  },
  handleEnd: function(e) {
    this._resetActive();
    this._refreshCursorState(e.originalEvent && e.originalEvent.target);
    this._adjustDistance(e, e.velocity);
    this._eventForUserAction = e;
    return this._eventHandler("end", e.velocity).done(this._endAction);
  },
  handleCancel: function(e) {
    this._resetActive();
    this._eventForUserAction = e;
    return this._eventHandler("end", {
      x: 0,
      y: 0
    });
  },
  handleStop: function() {
    this._resetActive();
    this._eventHandler("stop");
  },
  handleScroll: function() {
    this._updateRtlConfig();
    this._scrollAction();
  },
  _attachKeyboardHandler: function() {
    eventsEngine.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_KEYBOARD));
    if (!this.option("disabled") && this.option("useKeyboard")) {
      eventsEngine.on(this._$element, addNamespace$1("keydown", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));
    }
  },
  _keyDownHandler: function(e) {
    clearTimeout(this._updateHandlerTimeout);
    this._updateHandlerTimeout = setTimeout(() => {
      if (normalizeKeyName(e) === KEY_CODES.TAB) {
        this._eachScroller((scroller) => {
          scroller._updateHandler();
        });
      }
    });
    if (!this._$container.is(domAdapter.getActiveElement())) {
      return;
    }
    var handled = true;
    switch (normalizeKeyName(e)) {
      case KEY_CODES.DOWN:
        this._scrollByLine({
          y: 1
        });
        break;
      case KEY_CODES.UP:
        this._scrollByLine({
          y: -1
        });
        break;
      case KEY_CODES.RIGHT:
        this._scrollByLine({
          x: 1
        });
        break;
      case KEY_CODES.LEFT:
        this._scrollByLine({
          x: -1
        });
        break;
      case KEY_CODES.PAGE_DOWN:
        this._scrollByPage(1);
        break;
      case KEY_CODES.PAGE_UP:
        this._scrollByPage(-1);
        break;
      case KEY_CODES.HOME:
        this._scrollToHome();
        break;
      case KEY_CODES.END:
        this._scrollToEnd();
        break;
      default:
        handled = false;
    }
    if (handled) {
      e.stopPropagation();
      e.preventDefault();
    }
  },
  _scrollByLine: function(lines) {
    var devicePixelRatio = this._tryGetDevicePixelRatio();
    var scrollOffset = SCROLL_LINE_HEIGHT;
    if (devicePixelRatio) {
      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;
    }
    this.scrollBy({
      top: (lines.y || 0) * -scrollOffset,
      left: (lines.x || 0) * -scrollOffset
    });
  },
  _scrollByPage: function(page) {
    var prop = this._wheelProp();
    var dimension = this._dimensionByProp(prop);
    var distance = {};
    distance[prop] = page * -this._$container[dimension]();
    this.scrollBy(distance);
  },
  _dimensionByProp: function(prop) {
    return prop === "left" ? "width" : "height";
  },
  _getPropByDirection: function(direction) {
    return direction === HORIZONTAL$2 ? "left" : "top";
  },
  _scrollToHome: function() {
    var prop = this._wheelProp();
    var distance = {};
    distance[prop] = 0;
    this._component.scrollTo(distance);
  },
  _scrollToEnd: function() {
    var prop = this._wheelProp();
    var dimension = this._dimensionByProp(prop);
    var distance = {};
    distance[prop] = this._$content[dimension]() - this._$container[dimension]();
    this._component.scrollTo(distance);
  },
  createActions: function() {
    this._startAction = this._createActionHandler("onStart");
    this._endAction = this._createActionHandler("onEnd");
    this._updateAction = this._createActionHandler("onUpdated");
    this._createScrollerActions();
  },
  _createScrollerActions: function() {
    this._scrollAction = this._createActionHandler("onScroll");
    this._bounceAction = this._createActionHandler("onBounce");
    this._eventHandler("createActions", {
      scroll: this._scrollAction,
      bounce: this._bounceAction
    });
  },
  _createActionHandler: function(optionName) {
    var actionHandler = this._createActionByOption(optionName);
    return () => {
      actionHandler(extend(this._createActionArgs(), arguments));
    };
  },
  _createActionArgs: function() {
    var {
      horizontal: scrollerX,
      vertical: scrollerY
    } = this._scrollers;
    var offset2 = this._getScrollOffset();
    this._scrollOffset = {
      top: scrollerY && offset2.top,
      left: scrollerX && offset2.left
    };
    return {
      event: this._eventForUserAction,
      scrollOffset: this._scrollOffset,
      reachedLeft: scrollerX && scrollerX._reachedMax(),
      reachedRight: scrollerX && scrollerX._reachedMin(),
      reachedTop: scrollerY && scrollerY._reachedMax(),
      reachedBottom: scrollerY && scrollerY._reachedMin()
    };
  },
  _getScrollOffset() {
    return {
      top: -this.location().top,
      left: -this.location().left
    };
  },
  _eventHandler: function(eventName) {
    var args = [].slice.call(arguments).slice(1);
    var deferreds = map(this._scrollers, (scroller) => scroller["_" + eventName + "Handler"].apply(scroller, args));
    return when.apply($, deferreds).promise();
  },
  location: function() {
    var location = locate(this._$content);
    location.top -= this._$container.scrollTop();
    location.left -= this._$container.scrollLeft();
    return location;
  },
  disabledChanged: function() {
    this._attachCursorHandlers();
  },
  _attachCursorHandlers: function() {
    eventsEngine.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_CURSOR));
    if (!this.option("disabled") && this._isHoverMode()) {
      eventsEngine.on(this._$element, addNamespace$1("mouseenter", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
      eventsEngine.on(this._$element, addNamespace$1("mouseleave", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));
    }
  },
  _isHoverMode: function() {
    return this.option("showScrollbar") === "onHover";
  },
  _cursorEnterHandler: function(e) {
    e = e || {};
    e.originalEvent = e.originalEvent || {};
    if (activeScrollable || e.originalEvent._hoverHandled) {
      return;
    }
    if (hoveredScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    hoveredScrollable = this;
    this._eventHandler("cursorEnter");
    e.originalEvent._hoverHandled = true;
  },
  _cursorLeaveHandler: function(e) {
    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
      return;
    }
    this._eventHandler("cursorLeave");
    hoveredScrollable = null;
    this._refreshCursorState(e && e.relatedTarget);
  },
  _refreshCursorState: function(target) {
    if (!this._isHoverMode() && (!target || activeScrollable)) {
      return;
    }
    var $target = $(target);
    var $scrollable = $target.closest(".".concat(SCROLLABLE_SIMULATED_CLASS, ":not(.dx-state-disabled)"));
    var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY$1);
    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    if (targetScrollable) {
      targetScrollable._cursorEnterHandler();
    }
  },
  update: function() {
    var result = this._eventHandler("update").done(this._updateAction);
    return when(result, deferUpdate(() => {
      var allowedDirections = this._allowedDirections();
      deferRender(() => {
        var touchDirection = allowedDirections.vertical ? "pan-x" : "";
        touchDirection = allowedDirections.horizontal ? "pan-y" : touchDirection;
        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? "none" : touchDirection;
        this._$container.css("touchAction", touchDirection);
      });
      return when().promise();
    }));
  },
  _allowedDirections: function() {
    var bounceEnabled = this.option("bounceEnabled");
    var verticalScroller = this._scrollers[VERTICAL$2];
    var horizontalScroller = this._scrollers[HORIZONTAL$2];
    return {
      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
    };
  },
  _updateBounds: function() {
    this._scrollers[HORIZONTAL$2] && this._scrollers[HORIZONTAL$2]._updateBounds();
  },
  _isHorizontalAndRtlEnabled: function() {
    return this.option("rtlEnabled") && this.option("direction") !== VERTICAL$2;
  },
  updateRtlPosition: function(needInitializeRtlConfig) {
    if (needInitializeRtlConfig) {
      this._rtlConfig = {
        scrollRight: 0,
        clientWidth: this._$container.get(0).clientWidth,
        windowPixelRatio: this._getWindowDevicePixelRatio()
      };
    }
    this._updateBounds();
    if (this._isHorizontalAndRtlEnabled()) {
      deferUpdate(() => {
        var scrollLeft = this._getMaxOffset().left - this._rtlConfig.scrollRight;
        if (scrollLeft <= 0) {
          scrollLeft = 0;
          this._rtlConfig.scrollRight = this._getMaxOffset().left;
        }
        deferRender(() => {
          if (this._getScrollOffset().left !== scrollLeft) {
            this._rtlConfig.skipUpdating = true;
            this._component.scrollTo({
              left: scrollLeft
            });
            this._rtlConfig.skipUpdating = false;
          }
        });
      });
    }
  },
  _updateRtlConfig: function() {
    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
      var {
        clientWidth,
        scrollLeft
      } = this._$container.get(0);
      var windowPixelRatio = this._getWindowDevicePixelRatio();
      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;
      }
      this._rtlConfig.clientWidth = clientWidth;
      this._rtlConfig.windowPixelRatio = windowPixelRatio;
    }
  },
  _getWindowDevicePixelRatio: function() {
    return hasWindow$1() ? getWindow().devicePixelRatio : 1;
  },
  scrollBy: function(distance) {
    var verticalScroller = this._scrollers[VERTICAL$2];
    var horizontalScroller = this._scrollers[HORIZONTAL$2];
    if (verticalScroller) {
      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
    }
    if (horizontalScroller) {
      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
    }
    this._prepareDirections(true);
    this._startAction();
    this._eventHandler("scrollBy", {
      x: distance.left,
      y: distance.top
    });
    this._endAction();
    this._updateRtlConfig();
  },
  validate: function(e) {
    if (isDxMouseWheelEvent(e) && isCommandKeyPressed(e)) {
      return false;
    }
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("bounceEnabled")) {
      return true;
    }
    return isDxMouseWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e);
  },
  _validateWheel: function(e) {
    var scroller = this._scrollers[this._wheelDirection(e)];
    var reachedMin = scroller._reachedMin();
    var reachedMax = scroller._reachedMax();
    var contentGreaterThanContainer = !reachedMin || !reachedMax;
    var locatedNotAtBound = !reachedMin && !reachedMax;
    var scrollFromMin = reachedMin && e.delta > 0;
    var scrollFromMax = reachedMax && e.delta < 0;
    var validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
    validated = validated || this._validateWheelTimer !== void 0;
    if (validated) {
      clearTimeout(this._validateWheelTimer);
      this._validateWheelTimer = setTimeout(() => {
        this._validateWheelTimer = void 0;
      }, VALIDATE_WHEEL_TIMEOUT);
    }
    return validated;
  },
  _validateMove: function(e) {
    if (!this.option("scrollByContent") && !$(e.target).closest(".".concat(SCROLLABLE_SCROLLBAR_CLASS)).length) {
      return false;
    }
    return this._allowedDirection();
  },
  getDirection: function(e) {
    return isDxMouseWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection();
  },
  _wheelProp: function() {
    return this._wheelDirection() === HORIZONTAL$2 ? "left" : "top";
  },
  _wheelDirection: function(e) {
    switch (this.option("direction")) {
      case HORIZONTAL$2:
        return HORIZONTAL$2;
      case VERTICAL$2:
        return VERTICAL$2;
      default:
        return e && e.shiftKey ? HORIZONTAL$2 : VERTICAL$2;
    }
  },
  dispose: function() {
    this._resetActive();
    if (hoveredScrollable === this) {
      hoveredScrollable = null;
    }
    this._eventHandler("dispose");
    this._detachEventHandlers();
    this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);
    this._eventForUserAction = null;
    clearTimeout(this._validateWheelTimer);
    clearTimeout(this._updateHandlerTimeout);
  },
  _detachEventHandlers: function() {
    eventsEngine.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_CURSOR));
    eventsEngine.off(this._$container, ".".concat(SCROLLABLE_SIMULATED_KEYBOARD));
  }
});
var getScrollRtlBehavior = callOnce(function() {
  var document2 = domAdapter.getDocument();
  document2.body.insertAdjacentHTML("beforeend", "<div style='direction: rtl;\n       position: absolute; left: 0; top: -1; overflow: hidden; width: 1px;\n       height: 1px;'><div style='width: 2px; height: 1px;'></div></div>");
  var scroller = document2.body.lastElementChild;
  var initiallyPositive = scroller.scrollLeft > 0;
  scroller.scrollLeft = -1;
  var hasNegative = scroller.scrollLeft < 0;
  var result = {
    decreasing: hasNegative || initiallyPositive,
    positive: !hasNegative
  };
  document2.body.removeChild(scroller);
  return result;
});
var SCROLLABLE_NATIVE = "dxNativeScrollable";
var SCROLLABLE_NATIVE_CLASS = "dx-scrollable-native";
var SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated";
var SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden";
var VERTICAL$1 = "vertical";
var HORIZONTAL$1 = "horizontal";
var HIDE_SCROLLBAR_TIMEOUT = 500;
var NativeStrategy = classImpl.inherit({
  ctor: function(scrollable) {
    this._init(scrollable);
  },
  _init: function(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = scrollable._$container;
    this._$content = scrollable._$content;
    this._direction = scrollable.option("direction");
    this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
    this._showScrollbar = scrollable.option("showScrollbar");
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
    this._isScrollInverted = scrollable._isScrollInverted.bind(scrollable);
  },
  render: function() {
    var device = devices.real();
    var deviceType = device.platform;
    this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + "-" + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._showScrollbar);
    if (this._showScrollbar && this._useSimulatedScrollbar) {
      this._renderScrollbars();
    }
  },
  updateRtlPosition: function(isFirstRender) {
    if (isFirstRender && this.option("rtlEnabled")) {
      if (this._showScrollbar && this._useSimulatedScrollbar) {
        this._moveScrollbars();
      }
    }
  },
  _renderScrollbars: function() {
    this._scrollbars = {};
    this._hideScrollbarTimeout = 0;
    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
    this._renderScrollbar(VERTICAL$1);
    this._renderScrollbar(HORIZONTAL$1);
  },
  _renderScrollbar: function(direction) {
    if (!this._isDirection(direction)) {
      return;
    }
    this._scrollbars[direction] = new Scrollbar($("<div>").appendTo(this._$element), {
      direction,
      expandable: this._component.option("scrollByThumb")
    });
  },
  handleInit: noop,
  handleStart: noop,
  handleMove: function(e) {
    if (this._isLocked()) {
      e.cancel = true;
      return;
    }
    if (this._allowedDirection()) {
      e.originalEvent.isScrollingEvent = true;
    }
  },
  handleEnd: noop,
  handleCancel: noop,
  handleStop: noop,
  _eachScrollbar: function(callback) {
    callback = callback.bind(this);
    each(this._scrollbars || {}, function(direction, scrollbar) {
      callback(scrollbar, direction);
    });
  },
  createActions: function() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._updateAction = this._createActionByOption("onUpdated");
  },
  _createActionArgs: function() {
    var {
      left,
      top
    } = this.location();
    return {
      event: this._eventForUserAction,
      scrollOffset: this._getScrollOffset(),
      reachedLeft: this._isScrollInverted() ? this._isReachedRight(-left) : this._isReachedLeft(left),
      reachedRight: this._isScrollInverted() ? this._isReachedLeft(-Math.abs(left)) : this._isReachedRight(left),
      reachedTop: this._isDirection(VERTICAL$1) ? top >= 0 : void 0,
      reachedBottom: this._isDirection(VERTICAL$1) ? Math.abs(top) >= this._getMaxOffset().top : void 0
    };
  },
  _getScrollOffset: function() {
    var {
      top,
      left
    } = this.location();
    return {
      top: -top,
      left: this._normalizeOffsetLeft(-left)
    };
  },
  _normalizeOffsetLeft(scrollLeft) {
    if (this._isScrollInverted()) {
      if (getScrollRtlBehavior().positive) {
        return this._getMaxOffset().left - scrollLeft;
      }
      return this._getMaxOffset().left + scrollLeft;
    }
    return scrollLeft;
  },
  _isReachedLeft: function(left) {
    return this._isDirection(HORIZONTAL$1) ? left >= 0 : void 0;
  },
  _isReachedRight: function(left) {
    return this._isDirection(HORIZONTAL$1) ? Math.abs(left) >= this._getMaxOffset().left : void 0;
  },
  handleScroll: function(e) {
    this._eventForUserAction = e;
    this._moveScrollbars();
    this._scrollAction(this._createActionArgs());
  },
  _moveScrollbars: function() {
    var {
      top,
      left
    } = this._getScrollOffset();
    this._eachScrollbar(function(scrollbar) {
      scrollbar.moveTo({
        top: -top,
        left: -left
      });
      scrollbar.option("visible", true);
    });
    this._hideScrollbars();
  },
  _hideScrollbars: function() {
    clearTimeout(this._hideScrollbarTimeout);
    this._hideScrollbarTimeout = setTimeout(function() {
      this._eachScrollbar(function(scrollbar) {
        scrollbar.option("visible", false);
      });
    }.bind(this), HIDE_SCROLLBAR_TIMEOUT);
  },
  location: function() {
    return {
      left: -this._$container.scrollLeft(),
      top: -this._$container.scrollTop()
    };
  },
  disabledChanged: noop,
  update: function() {
    this._update();
    this._updateAction(this._createActionArgs());
  },
  _update: function() {
    this._updateDimensions();
    this._updateScrollbars();
  },
  _updateDimensions: function() {
    this._containerSize = {
      height: this._$container.height(),
      width: this._$container.width()
    };
    this._componentContentSize = {
      height: this._component.$content().height(),
      width: this._component.$content().width()
    };
    this._contentSize = {
      height: this._$content.height(),
      width: this._$content.width()
    };
  },
  _updateScrollbars: function() {
    this._eachScrollbar(function(scrollbar, direction) {
      var dimension = direction === VERTICAL$1 ? "height" : "width";
      scrollbar.option({
        containerSize: this._containerSize[dimension],
        contentSize: this._componentContentSize[dimension]
      });
      scrollbar.update();
    });
  },
  _allowedDirections: function() {
    return {
      vertical: this._isDirection(VERTICAL$1) && this._contentSize.height > this._containerSize.height,
      horizontal: this._isDirection(HORIZONTAL$1) && this._contentSize.width > this._containerSize.width
    };
  },
  dispose: function() {
    var className = this._$element.get(0).className;
    var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + "\\S*", "g");
    if (scrollableNativeRegexp.test(className)) {
      this._$element.removeClass(className.match(scrollableNativeRegexp).join(" "));
    }
    eventsEngine.off(this._$element, "." + SCROLLABLE_NATIVE);
    eventsEngine.off(this._$container, "." + SCROLLABLE_NATIVE);
    this._removeScrollbars();
    clearTimeout(this._hideScrollbarTimeout);
  },
  _removeScrollbars: function() {
    this._eachScrollbar(function(scrollbar) {
      scrollbar.$element().remove();
    });
  },
  scrollBy: function(distance) {
    var location = this.location();
    this._$container.scrollTop(Math.round(-location.top - distance.top));
    this._$container.scrollLeft(Math.round(-location.left - this._getScrollSign() * distance.left));
  },
  _getScrollSign() {
    return this._isScrollInverted() && getScrollRtlBehavior().positive ? -1 : 1;
  },
  validate: function(e) {
    if (this.option("disabled")) {
      return false;
    }
    if (isDxMouseWheelEvent(e) && this._isScrolledInMaxDirection(e)) {
      return false;
    }
    return !!this._allowedDirection();
  },
  _isScrolledInMaxDirection(e) {
    var container = this._$container.get(0);
    var result;
    if (e.delta > 0) {
      result = e.shiftKey ? !container.scrollLeft : !container.scrollTop;
    } else if (e.shiftKey) {
      result = container.scrollLeft >= this._getMaxOffset().left;
    } else {
      result = container.scrollTop >= this._getMaxOffset().top;
    }
    return result;
  },
  getDirection: function() {
    return this._allowedDirection();
  }
});
var deviceDependentOptions = function() {
  return [{
    device: function() {
      return !nativeScrolling;
    },
    options: {
      useNative: false
    }
  }, {
    device: function(_device) {
      return !devices.isSimulator() && devices.real().deviceType === "desktop" && _device.platform === "generic";
    },
    options: {
      bounceEnabled: false,
      scrollByThumb: true,
      scrollByContent: touch,
      showScrollbar: "onHover"
    }
  }];
};
var SCROLLABLE = "dxScrollable";
var SCROLLABLE_STRATEGY = "dxScrollableStrategy";
var SCROLLABLE_CLASS = "dx-scrollable";
var SCROLLABLE_DISABLED_CLASS = "dx-scrollable-disabled";
var SCROLLABLE_CONTAINER_CLASS = "dx-scrollable-container";
var SCROLLABLE_WRAPPER_CLASS = "dx-scrollable-wrapper";
var SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content";
var VERTICAL = "vertical";
var HORIZONTAL = "horizontal";
var BOTH = "both";
var Scrollable = DOMComponent.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      disabled: false,
      onScroll: null,
      direction: VERTICAL,
      showScrollbar: "onScroll",
      useNative: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      onUpdated: null,
      onStart: null,
      onEnd: null,
      onBounce: null,
      useSimulatedScrollbar: false,
      useKeyboard: true,
      inertiaEnabled: true,
      updateManually: false
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat(deviceDependentOptions(), [{
      device: function() {
        return nativeScrolling && devices.real().platform === "android" && !coreBrowserUtils.mozilla;
      },
      options: {
        useSimulatedScrollbar: true
      }
    }]);
  },
  _initOptions: function(options) {
    this.callBase(options);
    if (!("useSimulatedScrollbar" in options)) {
      this._setUseSimulatedScrollbar();
    }
  },
  _setUseSimulatedScrollbar: function() {
    if (!this.initialOption("useSimulatedScrollbar")) {
      this.option("useSimulatedScrollbar", !this.option("useNative"));
    }
  },
  _init: function() {
    this.callBase();
    this._initScrollableMarkup();
    this._locked = false;
  },
  _visibilityChanged: function(visible2) {
    if (visible2) {
      this.update();
      this._updateRtlPosition();
      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
      delete this._savedScrollOffset;
    } else {
      this._savedScrollOffset = this.scrollOffset();
    }
  },
  _initScrollableMarkup: function() {
    var $element = this.$element().addClass(SCROLLABLE_CLASS);
    var $container = this._$container = $("<div>").addClass(SCROLLABLE_CONTAINER_CLASS);
    var $wrapper = this._$wrapper = $("<div>").addClass(SCROLLABLE_WRAPPER_CLASS);
    var $content = this._$content = $("<div>").addClass(SCROLLABLE_CONTENT_CLASS);
    if (domAdapter.hasDocumentProperty("onbeforeactivate") && coreBrowserUtils.msie && coreBrowserUtils.version < 12) {
      eventsEngine.on($element, addNamespace$1("beforeactivate", SCROLLABLE), function(e) {
        if (!$(e.target).is(focusable)) {
          e.preventDefault();
        }
      });
    }
    $content.append($element.contents()).appendTo($container);
    $container.appendTo($wrapper);
    $wrapper.appendTo($element);
  },
  _dimensionChanged: function() {
    this.update();
    this._updateRtlPosition();
  },
  _initMarkup: function() {
    this.callBase();
    this._renderDirection();
  },
  _render: function() {
    this._renderStrategy();
    this._attachEventHandlers();
    this._renderDisabledState();
    this._createActions();
    this.update();
    this.callBase();
    this._updateRtlPosition(true);
  },
  _updateRtlPosition: function(needInitializeRtlConfig) {
    this._strategy.updateRtlPosition(needInitializeRtlConfig);
  },
  _getMaxOffset: function() {
    var {
      scrollWidth,
      clientWidth,
      scrollHeight,
      clientHeight
    } = this._container().get(0);
    return {
      left: scrollWidth - clientWidth,
      top: scrollHeight - clientHeight
    };
  },
  _attachEventHandlers: function() {
    var strategy2 = this._strategy;
    var initEventData = {
      getDirection: strategy2.getDirection.bind(strategy2),
      validate: this._validate.bind(this),
      isNative: this.option("useNative"),
      scrollTarget: this._$container
    };
    eventsEngine.off(this._$wrapper, "." + SCROLLABLE);
    eventsEngine.on(this._$wrapper, addNamespace$1(scrollEvents.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
    eventsEngine.on(this._$wrapper, addNamespace$1(scrollEvents.start, SCROLLABLE), strategy2.handleStart.bind(strategy2));
    eventsEngine.on(this._$wrapper, addNamespace$1(scrollEvents.move, SCROLLABLE), strategy2.handleMove.bind(strategy2));
    eventsEngine.on(this._$wrapper, addNamespace$1(scrollEvents.end, SCROLLABLE), strategy2.handleEnd.bind(strategy2));
    eventsEngine.on(this._$wrapper, addNamespace$1(scrollEvents.cancel, SCROLLABLE), strategy2.handleCancel.bind(strategy2));
    eventsEngine.on(this._$wrapper, addNamespace$1(scrollEvents.stop, SCROLLABLE), strategy2.handleStop.bind(strategy2));
    eventsEngine.off(this._$container, "." + SCROLLABLE);
    eventsEngine.on(this._$container, addNamespace$1("scroll", SCROLLABLE), strategy2.handleScroll.bind(strategy2));
  },
  _validate: function(e) {
    if (this._isLocked()) {
      return false;
    }
    this._updateIfNeed();
    return this._strategy.validate(e);
  },
  _initHandler: function() {
    var strategy2 = this._strategy;
    strategy2.handleInit.apply(strategy2, arguments);
  },
  _renderDisabledState: function() {
    this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option("disabled"));
    if (this.option("disabled")) {
      this._lock();
    } else {
      this._unlock();
    }
  },
  _renderDirection: function() {
    this.$element().removeClass("dx-scrollable-" + HORIZONTAL).removeClass("dx-scrollable-" + VERTICAL).removeClass("dx-scrollable-" + BOTH).addClass("dx-scrollable-" + this.option("direction"));
  },
  _renderStrategy: function() {
    this._createStrategy();
    this._strategy.render();
    this.$element().data(SCROLLABLE_STRATEGY, this._strategy);
  },
  _createStrategy: function() {
    this._strategy = this.option("useNative") ? new NativeStrategy(this) : new SimulatedStrategy(this);
  },
  _createActions: function() {
    this._strategy && this._strategy.createActions();
  },
  _clean: function() {
    this._strategy && this._strategy.dispose();
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "onStart":
      case "onEnd":
      case "onUpdated":
      case "onScroll":
      case "onBounce":
        this._createActions();
        break;
      case "direction":
        this._resetInactiveDirection();
        this._invalidate();
        break;
      case "useNative":
        this._setUseSimulatedScrollbar();
        this._invalidate();
        break;
      case "inertiaEnabled":
      case "scrollByContent":
      case "scrollByThumb":
      case "bounceEnabled":
      case "useKeyboard":
      case "showScrollbar":
      case "useSimulatedScrollbar":
        this._invalidate();
        break;
      case "disabled":
        this._renderDisabledState();
        this._strategy && this._strategy.disabledChanged();
        break;
      case "updateManually":
        break;
      case "width":
        this.callBase(args);
        this._updateRtlPosition();
        break;
      default:
        this.callBase(args);
    }
  },
  _resetInactiveDirection: function() {
    var inactiveProp = this._getInactiveProp();
    if (!inactiveProp || !hasWindow$1()) {
      return;
    }
    var scrollOffset = this.scrollOffset();
    scrollOffset[inactiveProp] = 0;
    this.scrollTo(scrollOffset);
  },
  _getInactiveProp: function() {
    var direction = this.option("direction");
    if (direction === VERTICAL) {
      return "left";
    }
    if (direction === HORIZONTAL) {
      return "top";
    }
  },
  _location: function() {
    return this._strategy.location();
  },
  _normalizeLocation: function(location) {
    if (isPlainObject(location)) {
      var left = ensureDefined(location.left, location.x);
      var top = ensureDefined(location.top, location.y);
      return {
        left: isDefined(left) ? -left : void 0,
        top: isDefined(top) ? -top : void 0
      };
    } else {
      var direction = this.option("direction");
      return {
        left: direction !== VERTICAL ? -location : void 0,
        top: direction !== HORIZONTAL ? -location : void 0
      };
    }
  },
  _isLocked: function() {
    return this._locked;
  },
  _lock: function() {
    this._locked = true;
  },
  _unlock: function() {
    if (!this.option("disabled")) {
      this._locked = false;
    }
  },
  _isDirection: function(direction) {
    var current2 = this.option("direction");
    if (direction === VERTICAL) {
      return current2 !== HORIZONTAL;
    }
    if (direction === HORIZONTAL) {
      return current2 !== VERTICAL;
    }
    return current2 === direction;
  },
  _updateAllowedDirection: function() {
    var allowedDirections = this._strategy._allowedDirections();
    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
      this._allowedDirectionValue = BOTH;
    } else if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {
      this._allowedDirectionValue = HORIZONTAL;
    } else if (this._isDirection(VERTICAL) && allowedDirections.vertical) {
      this._allowedDirectionValue = VERTICAL;
    } else {
      this._allowedDirectionValue = null;
    }
  },
  _allowedDirection: function() {
    return this._allowedDirectionValue;
  },
  _container: function() {
    return this._$container;
  },
  $content: function() {
    return this._$content;
  },
  content: function() {
    return getPublicElement(this._$content);
  },
  scrollOffset: function() {
    return this._strategy._getScrollOffset();
  },
  _isRtlNativeStrategy: function() {
    var {
      useNative,
      rtlEnabled
    } = this.option();
    return useNative && rtlEnabled;
  },
  scrollTop: function() {
    return this.scrollOffset().top;
  },
  scrollLeft: function() {
    return this.scrollOffset().left;
  },
  clientHeight: function() {
    return this._$container.height();
  },
  scrollHeight: function() {
    return this.$content().outerHeight();
  },
  clientWidth: function() {
    return this._$container.width();
  },
  scrollWidth: function() {
    return this.$content().outerWidth();
  },
  update: function() {
    if (!this._strategy) {
      return;
    }
    return when(this._strategy.update()).done(function() {
      this._updateAllowedDirection();
    }.bind(this));
  },
  scrollBy: function(distance) {
    distance = this._normalizeLocation(distance);
    if (!distance.top && !distance.left) {
      return;
    }
    this._updateIfNeed();
    this._strategy.scrollBy(distance);
  },
  scrollTo: function(targetLocation) {
    targetLocation = this._normalizeLocation(targetLocation);
    this._updateIfNeed();
    var location = this._location();
    if (!this.option("useNative")) {
      targetLocation = this._strategy._applyScaleRatio(targetLocation);
      location = this._strategy._applyScaleRatio(location);
    }
    if (this._isScrollInverted()) {
      location.left = this._getScrollSign() * location.left - this._getMaxOffset().left;
    }
    var distance = this._normalizeLocation({
      left: location.left - ensureDefined(targetLocation.left, location.left),
      top: location.top - ensureDefined(targetLocation.top, location.top)
    });
    if (!distance.top && !distance.left) {
      return;
    }
    this._strategy.scrollBy(distance);
  },
  _getScrollSign: () => getScrollRtlBehavior().positive ? -1 : 1,
  _isScrollInverted: function() {
    var {
      rtlEnabled,
      useNative
    } = this.option();
    var {
      decreasing,
      positive
    } = getScrollRtlBehavior();
    return useNative && rtlEnabled && decreasing ^ positive;
  },
  scrollToElement: function(element, offset2) {
    var $element = $(element);
    var elementInsideContent = this.$content().find(element).length;
    var elementIsInsideContent = $element.parents("." + SCROLLABLE_CLASS).length - $element.parents("." + SCROLLABLE_CONTENT_CLASS).length === 0;
    if (!elementInsideContent || !elementIsInsideContent) {
      return;
    }
    var scrollPosition = {
      top: 0,
      left: 0
    };
    var direction = this.option("direction");
    if (direction !== VERTICAL) {
      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL, offset2);
    }
    if (direction !== HORIZONTAL) {
      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL, offset2);
    }
    this.scrollTo(scrollPosition);
  },
  scrollToElementTopLeft: function(element) {
    var $element = $(element);
    var elementInsideContent = this.$content().find(element).length;
    var elementIsInsideContent = $element.parents("." + SCROLLABLE_CLASS).length - $element.parents("." + SCROLLABLE_CONTENT_CLASS).length === 0;
    if (!elementInsideContent || !elementIsInsideContent) {
      return;
    }
    var scrollPosition = {
      top: 0,
      left: 0
    };
    var direction = this.option("direction");
    if (direction !== VERTICAL) {
      var leftPosition = this._elementPositionRelativeToContent($element, "left");
      scrollPosition.left = this.option("rtlEnabled") === true ? leftPosition + $element.outerWidth() - this.clientWidth() : leftPosition;
      if (this._isRtlNativeStrategy()) {
        scrollPosition.left += this._container().get(0).offsetWidth - this._container().get(0).clientWidth;
      }
    }
    if (direction !== HORIZONTAL) {
      scrollPosition.top = this._elementPositionRelativeToContent($element, "top");
    }
    this.scrollTo(scrollPosition);
  },
  getScrollElementPosition: function($element, direction, offset2) {
    offset2 = offset2 || {};
    var isVertical = direction === VERTICAL;
    var startOffset = (isVertical ? offset2.top : offset2.left) || 0;
    var endOffset = (isVertical ? offset2.bottom : offset2.right) || 0;
    var elementPositionRelativeToContent = this._elementPositionRelativeToContent($element, isVertical ? "top" : "left");
    var elementPosition = elementPositionRelativeToContent;
    var elementSize = $element[isVertical ? "outerHeight" : "outerWidth"]();
    var scrollLocation = isVertical ? this.scrollTop() : this.scrollLeft();
    var clientSize = this._container().get(0)[isVertical ? "clientHeight" : "clientWidth"];
    var startDistance = scrollLocation - elementPosition + startOffset;
    var endDistance = scrollLocation - elementPosition - elementSize + clientSize - endOffset;
    if (startDistance <= 0 && endDistance >= 0) {
      return scrollLocation;
    }
    return scrollLocation - (Math.abs(startDistance) > Math.abs(endDistance) ? endDistance : startDistance);
  },
  _elementPositionRelativeToContent: function($element, prop) {
    var result = 0;
    while (this._hasScrollContent($element)) {
      result += $element.position()[prop];
      $element = $element.offsetParent();
    }
    return result;
  },
  _hasScrollContent: function($element) {
    var $content = this.$content();
    return $element.closest($content).length && !$element.is($content);
  },
  _updateIfNeed: function() {
    if (!this.option("updateManually")) {
      this.update();
    }
  },
  _useTemplates: function() {
    return false;
  }
});
registerComponent(SCROLLABLE, Scrollable);
var WIDGET_CLASS$1 = "dx-treeview";
var NODE_CLASS = "".concat(WIDGET_CLASS$1, "-node");
var NODE_CONTAINER_CLASS$1 = "".concat(NODE_CLASS, "-container");
var NODE_LOAD_INDICATOR_CLASS = "".concat(NODE_CLASS, "-loadindicator");
var OPENED_NODE_CONTAINER_CLASS = "".concat(NODE_CLASS, "-container-opened");
var IS_LEAF = "".concat(NODE_CLASS, "-is-leaf");
var ITEM_CLASS$1 = "".concat(WIDGET_CLASS$1, "-item");
var ITEM_WITH_CHECKBOX_CLASS = "".concat(ITEM_CLASS$1, "-with-checkbox");
var ITEM_WITHOUT_CHECKBOX_CLASS = "".concat(ITEM_CLASS$1, "-without-checkbox");
var ITEM_DATA_KEY = "".concat(ITEM_CLASS$1, "-data");
var TOGGLE_ITEM_VISIBILITY_CLASS = "".concat(WIDGET_CLASS$1, "-toggle-item-visibility");
var LOAD_INDICATOR_CLASS = "".concat(WIDGET_CLASS$1, "-loadindicator");
var LOAD_INDICATOR_WRAPPER_CLASS = "".concat(WIDGET_CLASS$1, "-loadindicator-wrapper");
var TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "".concat(WIDGET_CLASS$1, "-toggle-item-visibility-opened");
var SELECT_ALL_ITEM_CLASS = "".concat(WIDGET_CLASS$1, "-select-all-item");
var INVISIBLE_STATE_CLASS = "dx-state-invisible";
var DISABLED_STATE_CLASS = "dx-state-disabled";
var SELECTED_ITEM_CLASS = "dx-state-selected";
var EXPAND_EVENT_NAMESPACE = "dxTreeView_expand";
var DATA_ITEM_ID = "data-item-id";
var TreeViewBase = HierarchicalCollectionWidget.inherit({
  _supportedKeys: function(e) {
    var click2 = (e2) => {
      var $itemElement = $(this.option("focusedElement"));
      if (!$itemElement.length) {
        return;
      }
      e2.target = $itemElement;
      e2.currentTarget = $itemElement;
      this._itemClickHandler(e2, $itemElement.children("." + ITEM_CLASS$1));
      var expandEventName = this._getEventNameByOption(this.option("expandEvent"));
      var expandByClick = expandEventName === addNamespace$1(CLICK_EVENT_NAME$2, EXPAND_EVENT_NAMESPACE);
      if (expandByClick) {
        this._expandEventHandler(e2);
      }
    };
    var select = (e2) => {
      e2.preventDefault();
      var $focusedElement = $(this.option("focusedElement"));
      var checkboxInstance = this._getCheckBoxInstance($focusedElement);
      if (!checkboxInstance.option("disabled")) {
        var currentState = checkboxInstance.option("value");
        this._updateItemSelection(!currentState, $focusedElement.find("." + ITEM_CLASS$1).get(0), true);
      }
    };
    var toggleExpandedNestedItems = function(state, e2) {
      if (!this.option("expandAllEnabled")) {
        return;
      }
      e2.preventDefault();
      var $rootElement = $(this.option("focusedElement"));
      if (!$rootElement.length) {
        return;
      }
      var rootItem = this._getItemData($rootElement.find(".".concat(ITEM_CLASS$1)));
      this._toggleExpandedNestedItems([rootItem], state);
    };
    return extend(this.callBase(), {
      enter: this._showCheckboxes() ? select : click2,
      space: this._showCheckboxes() ? select : click2,
      asterisk: toggleExpandedNestedItems.bind(this, true),
      minus: toggleExpandedNestedItems.bind(this, false)
    });
  },
  _toggleExpandedNestedItems: function(items, state) {
    if (!items) {
      return;
    }
    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];
      var node = this._dataAdapter.getNodeByItem(item);
      this._toggleExpandedState(node, state);
      this._toggleExpandedNestedItems(item.items, state);
    }
  },
  _getNodeElement: function(node, cache) {
    var key = this._encodeString(node.internalFields.key);
    if (cache) {
      if (!cache.$nodeByKey) {
        cache.$nodeByKey = {};
        this.$element().find(".".concat(NODE_CLASS)).each(function() {
          var $node = $(this);
          var key2 = $node.attr(DATA_ITEM_ID);
          cache.$nodeByKey[key2] = $node;
        });
      }
      return cache.$nodeByKey[key] || $();
    }
    var element = this.$element().get(0).querySelector("[".concat(DATA_ITEM_ID, '="').concat(key, '"]'));
    return $(element);
  },
  _activeStateUnit: "." + ITEM_CLASS$1,
  _widgetClass: function() {
    return WIDGET_CLASS$1;
  },
  _getDefaultOptions: function() {
    var defaultOptions = extend(this.callBase(), {
      animationEnabled: true,
      dataStructure: "tree",
      deferRendering: true,
      expandAllEnabled: false,
      hasItemsExpr: "hasItems",
      selectNodesRecursive: true,
      expandNodesRecursive: true,
      showCheckBoxesMode: "none",
      selectAllText: messageLocalization.format("dxList-selectAll"),
      onItemSelectionChanged: null,
      onItemExpanded: null,
      onItemCollapsed: null,
      scrollDirection: "vertical",
      virtualModeEnabled: false,
      rootValue: 0,
      focusStateEnabled: false,
      selectionMode: "multiple",
      expandEvent: "dblclick",
      selectByClick: false,
      createChildren: null,
      onSelectAllValueChanged: null
    });
    return extend(true, defaultOptions, {
      integrationOptions: {
        useDeferUpdateForTemplates: false
      }
    });
  },
  _initSelectedItems: noop,
  _syncSelectionOptions: asyncNoop,
  _fireSelectionChanged: function() {
    var selectionChangePromise = this._selectionChangePromise;
    when(selectionChangePromise).done(function() {
      this._createActionByOption("onSelectionChanged", {
        excludeValidators: ["disabled", "readOnly"]
      })();
    }.bind(this));
  },
  _createSelectAllValueChangedAction: function() {
    this._selectAllValueChangedAction = this._createActionByOption("onSelectAllValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  },
  _fireSelectAllValueChanged: function(value2) {
    this._selectAllValueChangedAction({
      value: value2
    });
  },
  _checkBoxModeChange: function(value2, previousValue) {
    if (previousValue === "none" || value2 === "none") {
      this.repaint();
      return;
    }
    var selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
    switch (value2) {
      case "selectAll":
        if (!selectAllExists) {
          this._createSelectAllValueChangedAction();
          this._renderSelectAllItem();
        }
        break;
      case "normal":
        if (selectAllExists) {
          this._$selectAllItem.remove();
          delete this._$selectAllItem;
        }
    }
  },
  _removeSelection: function() {
    var that = this;
    each(this._dataAdapter.getFullData(), function(_2, node) {
      if (!that._hasChildren(node)) {
        return;
      }
      that._dataAdapter.toggleSelection(node.internalFields.key, false, true);
    });
  },
  _optionChanged: function(args) {
    var {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "selectAllText":
        if (this._$selectAllItem) {
          this._$selectAllItem.dxCheckBox("instance").option("text", value2);
        }
        break;
      case "showCheckBoxesMode":
        this._checkBoxModeChange(value2, previousValue);
        break;
      case "scrollDirection":
        this._scrollableContainer.option("direction", value2);
        break;
      case "items":
        delete this._$selectAllItem;
        this.callBase(args);
        break;
      case "dataSource":
        this.callBase(args);
        this._initDataAdapter();
        this._filter = {};
        break;
      case "hasItemsExpr":
        this._initAccessors();
        this.repaint();
        break;
      case "expandEvent":
        this._initExpandEvent();
        break;
      case "deferRendering":
      case "dataStructure":
      case "rootValue":
      case "createChildren":
      case "expandNodesRecursive":
      case "onItemSelectionChanged":
      case "onItemExpanded":
      case "onItemCollapsed":
      case "expandAllEnabled":
      case "animationEnabled":
      case "virtualModeEnabled":
      case "selectByClick":
        break;
      case "selectionMode":
        this._initDataAdapter();
        this.callBase(args);
        break;
      case "onSelectAllValueChanged":
        this._createSelectAllValueChangedAction();
        break;
      case "selectNodesRecursive":
        this._dataAdapter.setOption("recursiveSelection", args.value);
        this.repaint();
        break;
      default:
        this.callBase(args);
    }
  },
  _initDataSource: function() {
    if (this._useCustomChildrenLoader()) {
      this._loadChildrenByCustomLoader(null).done(function(newItems) {
        if (newItems && newItems.length) {
          this.option("items", newItems);
        }
      }.bind(this));
    } else {
      this.callBase();
      this._isVirtualMode() && this._initVirtualMode();
    }
  },
  _initVirtualMode: function() {
    var filter = this._filter;
    if (!filter.custom) {
      filter.custom = this._dataSource.filter();
    }
    if (!filter.internal) {
      filter.internal = [this.option("parentIdExpr"), this.option("rootValue")];
    }
  },
  _useCustomChildrenLoader: function() {
    return isFunction$1(this.option("createChildren")) && this._isDataStructurePlain();
  },
  _loadChildrenByCustomLoader: function(parentNode) {
    var invocationResult = this.option("createChildren").call(this, parentNode);
    if (Array.isArray(invocationResult)) {
      return new Deferred().resolve(invocationResult).promise();
    }
    if (invocationResult && isFunction$1(invocationResult.then)) {
      return fromPromise(invocationResult);
    }
    return new Deferred().resolve([]).promise();
  },
  _combineFilter: function() {
    if (!this._filter.custom || !this._filter.custom.length) {
      return this._filter.internal;
    }
    return [this._filter.custom, this._filter.internal];
  },
  _dataSourceLoadErrorHandler: function() {
    this._renderEmptyMessage();
  },
  _init: function() {
    this._filter = {};
    this.callBase();
    this._initStoreChangeHandlers();
  },
  _dataSourceChangedHandler: function(newItems) {
    var items = this.option("items");
    if (this._initialized && this._isVirtualMode() && items.length) {
      return;
    }
    this.option("items", newItems);
  },
  _removeTreeViewLoadIndicator: function() {
    if (!this._treeViewLoadIndicator) {
      return;
    }
    this._treeViewLoadIndicator.remove();
    this._treeViewLoadIndicator = null;
  },
  _createTreeViewLoadIndicator: function() {
    this._treeViewLoadIndicator = $("<div>").addClass(LOAD_INDICATOR_CLASS);
    this._createComponent(this._treeViewLoadIndicator, LoadIndicator, {});
    return this._treeViewLoadIndicator;
  },
  _dataSourceLoadingChangedHandler: function(isLoading) {
    var resultFilter;
    if (this._isVirtualMode()) {
      resultFilter = this._combineFilter();
      this._dataSource.filter(resultFilter);
    }
    if (isLoading && !this._dataSource.isLoaded()) {
      this.option("items", []);
      var $wrapper = $("<div>").addClass(LOAD_INDICATOR_WRAPPER_CLASS);
      this._createTreeViewLoadIndicator().appendTo($wrapper);
      this.itemsContainer().append($wrapper);
      if (this._isVirtualMode() && this._dataSource.filter() !== resultFilter) {
        this._dataSource.filter([]);
      }
    } else {
      this._removeTreeViewLoadIndicator();
    }
  },
  _initStoreChangeHandlers: function() {
    if (this.option("dataStructure") !== "plain") {
      return;
    }
    this._dataSource && this._dataSource.store().on("inserted", (newItem) => {
      this.option().items = this.option("items").concat(newItem);
      this._dataAdapter.addItem(newItem);
      if (!this._dataAdapter.isFiltered(newItem)) {
        return;
      }
      this._updateLevel(this._parentIdGetter(newItem));
    }).on("removed", (removedKey) => {
      var node = this._dataAdapter.getNodeByKey(removedKey);
      if (isDefined(node)) {
        this.option("items")[this._dataAdapter.getIndexByKey(node.internalFields.key)] = 0;
        this._markChildrenItemsToRemove(node);
        this._removeItems();
        this._dataAdapter.removeItem(removedKey);
        this._updateLevel(this._parentIdGetter(node));
      }
    });
  },
  _markChildrenItemsToRemove: function(node) {
    var keys2 = node.internalFields.childrenKeys;
    each(keys2, (_2, key) => {
      this.option("items")[this._dataAdapter.getIndexByKey(key)] = 0;
      this._markChildrenItemsToRemove(this._dataAdapter.getNodeByKey(key));
    });
  },
  _removeItems: function() {
    var items = extend(true, [], this.option("items"));
    var counter = 0;
    each(items, (index2, item) => {
      if (!item) {
        this.option("items").splice(index2 - counter, 1);
        counter++;
      }
    });
  },
  _updateLevel: function(parentId) {
    var $container = this._getContainerByParentKey(parentId);
    this._renderItems($container, this._dataAdapter.getChildrenNodes(parentId));
  },
  _getOldContainer: function($itemElement) {
    if ($itemElement.length) {
      return $itemElement.children(".".concat(NODE_CONTAINER_CLASS$1));
    }
    if (this._scrollableContainer) {
      return this._scrollableContainer.$content().children();
    }
    return $();
  },
  _getContainerByParentKey: function(parentId) {
    var node = this._dataAdapter.getNodeByKey(parentId);
    var $itemElement = node ? this._getNodeElement(node) : [];
    this._getOldContainer($itemElement).remove();
    var $container = this._renderNodeContainer($itemElement);
    if (this._isRootLevel(parentId)) {
      if (!this._scrollableContainer) {
        this._renderScrollableContainer();
      }
      this._scrollableContainer.$content().append($container);
    }
    return $container;
  },
  _isRootLevel: function(parentId) {
    return parentId === this.option("rootValue");
  },
  _getAccessors: function() {
    var accessors = this.callBase();
    accessors.push("hasItems");
    return accessors;
  },
  _getDataAdapterOptions: function() {
    return {
      rootValue: this.option("rootValue"),
      multipleSelection: !this._isSingleSelection(),
      recursiveSelection: this._isRecursiveSelection(),
      recursiveExpansion: this.option("expandNodesRecursive"),
      selectionRequired: this.option("selectionRequired"),
      dataType: this.option("dataStructure"),
      sort: this._dataSource && this._dataSource.sort()
    };
  },
  _initMarkup: function() {
    this._renderScrollableContainer();
    this._renderEmptyMessage(this._dataAdapter.getRootNodes());
    this.callBase();
    this.setAria("role", "tree");
  },
  _renderContentImpl: function() {
    var $nodeContainer = this._renderNodeContainer();
    this._scrollableContainer.$content().append($nodeContainer);
    if (!this.option("items") || !this.option("items").length) {
      return;
    }
    this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
    this._initExpandEvent();
    if (this._selectAllEnabled()) {
      this._createSelectAllValueChangedAction();
      this._renderSelectAllItem($nodeContainer);
    }
  },
  _isVirtualMode: function() {
    return this.option("virtualModeEnabled") && this._isDataStructurePlain() && !!this.option("dataSource");
  },
  _isDataStructurePlain: function() {
    return this.option("dataStructure") === "plain";
  },
  _fireContentReadyAction: function() {
    var dataSource = this.getDataSource();
    var skipContentReadyAction = dataSource && !dataSource.isLoaded();
    if (this._scrollableContainer && hasWindow$1()) {
      this._scrollableContainer.update();
    }
    if (!skipContentReadyAction) {
      this.callBase();
    }
    if (this._scrollableContainer && hasWindow$1()) {
      this._scrollableContainer.update();
    }
  },
  _renderScrollableContainer: function() {
    this._scrollableContainer = this._createComponent($("<div>").appendTo(this.$element()), Scrollable, {
      direction: this.option("scrollDirection"),
      useKeyboard: false
    });
  },
  _renderNodeContainer: function($parent) {
    var $container = $("<ul>").addClass(NODE_CONTAINER_CLASS$1);
    this.setAria("role", "group", $container);
    if ($parent && $parent.length) {
      var itemData = this._getItemData($parent.children("." + ITEM_CLASS$1));
      if (this._expandedGetter(itemData)) {
        $container.addClass(OPENED_NODE_CONTAINER_CLASS);
      }
      $container.appendTo($parent);
    }
    return $container;
  },
  _createDOMElement: function($nodeContainer, node) {
    var $node = $("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, this._encodeString(node.internalFields.key)).prependTo($nodeContainer);
    this.setAria({
      role: "treeitem",
      label: this._displayGetter(node.internalFields.item) || "",
      expanded: node.internalFields.expanded || false,
      level: this._getLevel($nodeContainer)
    }, $node);
    return $node;
  },
  _getLevel: function($nodeContainer) {
    var parent = $nodeContainer.parent();
    return parent.hasClass("dx-scrollable-content") ? 1 : parseInt(parent.attr("aria-level")) + 1;
  },
  _showCheckboxes: function() {
    return this.option("showCheckBoxesMode") !== "none";
  },
  _selectAllEnabled: function() {
    return this.option("showCheckBoxesMode") === "selectAll" && !this._isSingleSelection();
  },
  _renderItems: function($nodeContainer, nodes) {
    var length = nodes.length - 1;
    for (var i = length; i >= 0; i--) {
      this._renderItem(i, nodes[i], $nodeContainer);
    }
    this._renderedItemsCount += nodes.length;
  },
  _renderItem: function(nodeIndex, node, $nodeContainer) {
    var $node = this._createDOMElement($nodeContainer, node);
    var nodeData = node.internalFields;
    var showCheckBox = this._showCheckboxes();
    $node.addClass(showCheckBox ? ITEM_WITH_CHECKBOX_CLASS : ITEM_WITHOUT_CHECKBOX_CLASS);
    $node.toggleClass(INVISIBLE_STATE_CLASS, nodeData.item.visible === false);
    showCheckBox && this._renderCheckBox($node, node);
    this.setAria("selected", nodeData.selected, $node);
    this._toggleSelectedClass($node, nodeData.selected);
    this.callBase(this._renderedItemsCount + nodeIndex, nodeData.item, $node);
    if (nodeData.item.visible !== false) {
      this._renderChildren($node, node);
    }
  },
  _setAriaSelected: function() {
  },
  _renderChildren: function($node, node) {
    if (!this._hasChildren(node)) {
      this._addLeafClass($node);
      return;
    }
    this._renderToggleItemVisibilityIcon($node, node);
    if (this.option("deferRendering") && !node.internalFields.expanded) {
      return;
    }
    this._loadSublevel(node).done((childNodes) => {
      this._renderSublevel($node, this._getActualNode(node), childNodes);
    });
  },
  _getActualNode: function(cachedNode) {
    return this._dataAdapter.getNodeByKey(cachedNode.internalFields.key);
  },
  _hasChildren: function(node) {
    if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
      return this._hasItemsGetter(node.internalFields.item) !== false;
    }
    return this.callBase(node);
  },
  _loadSublevel: function(node) {
    var deferred = new Deferred();
    var childrenNodes = this._getChildNodes(node);
    if (childrenNodes.length) {
      deferred.resolve(childrenNodes);
    } else {
      this._loadNestedItems(node).done((items) => {
        deferred.resolve(this._dataAdapter.getNodesByItems(items));
      });
    }
    return deferred.promise();
  },
  _renderSublevel: function($node, node, childNodes) {
    var $nestedNodeContainer = this._renderNodeContainer($node, node);
    var childNodesByChildrenKeys = childNodes.filter((childNode) => node.internalFields.childrenKeys.indexOf(childNode.internalFields.key) !== -1);
    this._renderItems($nestedNodeContainer, childNodesByChildrenKeys);
    if (childNodesByChildrenKeys.length && !node.internalFields.selected) {
      var firstChild = childNodesByChildrenKeys[0];
      this._updateParentsState(firstChild, this._getNodeElement(firstChild));
    }
    this._normalizeIconState($node, childNodesByChildrenKeys.length);
    if (node.internalFields.expanded) {
      $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
    }
  },
  _executeItemRenderAction: function(itemIndex, itemData, itemElement) {
    var node = this._getNode(itemElement);
    this._getItemRenderAction()({
      itemElement,
      itemIndex,
      itemData,
      node: this._dataAdapter.getPublicNode(node)
    });
  },
  _addLeafClass: function($node) {
    $node.addClass(IS_LEAF);
  },
  _expandEventHandler: function(e) {
    var $nodeElement = $(e.currentTarget.parentNode);
    if (!$nodeElement.hasClass(IS_LEAF)) {
      this._toggleExpandedState(e.currentTarget, void 0, e);
    }
  },
  _initExpandEvent: function() {
    var expandedEventName = this._getEventNameByOption(this.option("expandEvent"));
    var $itemsContainer = this._itemContainer();
    var itemSelector = this._itemSelector();
    eventsEngine.off($itemsContainer, "." + EXPAND_EVENT_NAMESPACE, itemSelector);
    eventsEngine.on($itemsContainer, expandedEventName, itemSelector, this._expandEventHandler.bind(this));
  },
  _getEventNameByOption: function(name2) {
    var event = name2 === "click" ? CLICK_EVENT_NAME$2 : DBLCLICK_EVENT_NAME;
    return addNamespace$1(event, EXPAND_EVENT_NAMESPACE);
  },
  _getNode: function(identifier) {
    if (!isDefined(identifier)) {
      return null;
    }
    if (identifier.internalFields) {
      return identifier;
    }
    if (isPrimitive(identifier)) {
      return this._dataAdapter.getNodeByKey(identifier);
    }
    var itemElement = $(identifier).get(0);
    if (!itemElement) {
      return null;
    }
    if (domAdapter.isElementNode(itemElement)) {
      return this._getNodeByElement(itemElement);
    }
    return this._dataAdapter.getNodeByItem(itemElement);
  },
  _getNodeByElement: function(itemElement) {
    var $node = $(itemElement).closest("." + NODE_CLASS);
    var key = this._decodeString($node.attr(DATA_ITEM_ID));
    return this._dataAdapter.getNodeByKey(key);
  },
  _toggleExpandedState: function(itemElement, state, e) {
    var node = this._getNode(itemElement);
    if (!node) {
      return new Deferred().reject().promise();
    }
    if (node.internalFields.disabled) {
      return new Deferred().reject().promise();
    }
    var currentState = node.internalFields.expanded;
    if (currentState === state) {
      return new Deferred().resolve().promise();
    }
    if (this._hasChildren(node)) {
      var $node = this._getNodeElement(node);
      if ($node.find(".".concat(NODE_LOAD_INDICATOR_CLASS, ":not(.").concat(INVISIBLE_STATE_CLASS, ")")).length) {
        return new Deferred().reject().promise();
      }
      this._createLoadIndicator($node);
    }
    if (!isDefined(state)) {
      state = !currentState;
    }
    this._dataAdapter.toggleExpansion(node.internalFields.key, state);
    return this._updateExpandedItemsUI(node, state, e);
  },
  _createLoadIndicator: function($node) {
    var $icon = $node.children("." + TOGGLE_ITEM_VISIBILITY_CLASS);
    var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS$1));
    if ($icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS) || $nodeContainer.not(":empty").length) {
      return;
    }
    this._createComponent($("<div>").addClass(NODE_LOAD_INDICATOR_CLASS), LoadIndicator, {}).$element().appendTo($node);
    $icon.hide();
  },
  _renderToggleItemVisibilityIcon: function($node, node) {
    var $icon = $("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
    if (node.internalFields.expanded) {
      $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
      $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS);
    }
    if (node.internalFields.disabled) {
      $icon.addClass(DISABLED_STATE_CLASS);
    }
    this._renderToggleItemVisibilityIconClick($icon, node);
  },
  _renderToggleItemVisibilityIconClick: function($icon, node) {
    var eventName = addNamespace$1(CLICK_EVENT_NAME$2, this.NAME);
    eventsEngine.off($icon, eventName);
    eventsEngine.on($icon, eventName, (e) => {
      this._toggleExpandedState(node.internalFields.key, void 0, e);
    });
  },
  _updateExpandedItemsUI: function(node, state, e) {
    var $node = this._getNodeElement(node);
    var isHiddenNode = !$node.length || state && $node.is(":hidden");
    if (this.option("expandNodesRecursive") && isHiddenNode) {
      var parentNode = this._getNode(node.internalFields.parentKey);
      if (parentNode) {
        this._updateExpandedItemsUI(parentNode, state, e);
      }
    }
    var $icon = $node.children("." + TOGGLE_ITEM_VISIBILITY_CLASS);
    var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS$1));
    $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
    var nodeContainerExists = $nodeContainer.length > 0;
    var completionCallback = new Deferred();
    if (!state || nodeContainerExists && !$nodeContainer.is(":empty")) {
      this._animateNodeContainer(node, state, e, completionCallback);
      return completionCallback.promise();
    }
    if (node.internalFields.childrenKeys.length === 0 && (this._isVirtualMode() || this._useCustomChildrenLoader())) {
      this._loadNestedItemsWithUpdate(node, state, e, completionCallback);
      return completionCallback.promise();
    }
    this._renderSublevel($node, node, this._getChildNodes(node));
    this._fireContentReadyAction();
    this._animateNodeContainer(node, state, e, completionCallback);
    return completionCallback.promise();
  },
  _loadNestedItemsWithUpdate: function(node, state, e, completionCallback) {
    var $node = this._getNodeElement(node);
    this._loadNestedItems(node).done((items) => {
      var actualNodeData = this._getActualNode(node);
      this._renderSublevel($node, actualNodeData, this._dataAdapter.getNodesByItems(items));
      if (!items || !items.length) {
        return;
      }
      this._fireContentReadyAction();
      this._animateNodeContainer(actualNodeData, state, e, completionCallback);
    });
  },
  _loadNestedItems: function(node) {
    if (this._useCustomChildrenLoader()) {
      var publicNode = this._dataAdapter.getPublicNode(node);
      return this._loadChildrenByCustomLoader(publicNode).done((newItems) => {
        if (!this._areNodesExists(newItems)) {
          this._appendItems(newItems);
        }
      });
    }
    if (!this._isVirtualMode()) {
      return new Deferred().resolve([]).promise();
    }
    this._filter.internal = [this.option("parentIdExpr"), node.internalFields.key];
    this._dataSource.filter(this._combineFilter());
    return this._dataSource.load().done((newItems) => {
      if (!this._areNodesExists(newItems)) {
        this._appendItems(newItems);
      }
    });
  },
  _areNodesExists: function(newItems, items) {
    var keyOfRootItem = this.keyOf(newItems[0]);
    var fullData = this._dataAdapter.getFullData();
    return !!this._dataAdapter.getNodeByKey(keyOfRootItem, fullData);
  },
  _appendItems: function(newItems) {
    this.option().items = this.option("items").concat(newItems);
    this._initDataAdapter();
  },
  _animateNodeContainer: function(node, state, e, completionCallback) {
    var $node = this._getNodeElement(node);
    var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS$1));
    if (node && completionCallback && $nodeContainer.length === 0) {
      completionCallback.resolve();
    }
    $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
    var nodeHeight = $nodeContainer.height();
    fx.stop($nodeContainer, true);
    fx.animate($nodeContainer, {
      type: "custom",
      duration: this.option("animationEnabled") ? 400 : 0,
      from: {
        maxHeight: state ? 0 : nodeHeight
      },
      to: {
        maxHeight: state ? nodeHeight : 0
      },
      complete: function() {
        $nodeContainer.css("maxHeight", "none");
        $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
        this.setAria("expanded", state, $node);
        this._scrollableContainer.update();
        this._fireExpandedStateUpdatedEvent(state, node, e);
        if (completionCallback) {
          completionCallback.resolve();
        }
      }.bind(this)
    });
  },
  _fireExpandedStateUpdatedEvent: function(isExpanded, node, e) {
    if (!this._hasChildren(node)) {
      return;
    }
    var optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed";
    if (isDefined(e)) {
      this._itemDXEventHandler(e, optionName, {
        node: this._dataAdapter.getPublicNode(node)
      });
    } else {
      var target = this._getNodeElement(node);
      this._itemEventHandler(target, optionName, {
        event: e,
        node: this._dataAdapter.getPublicNode(node)
      });
    }
  },
  _normalizeIconState: function($node, hasNewItems) {
    var $loadIndicator = $node.find(".".concat(NODE_LOAD_INDICATOR_CLASS));
    $loadIndicator.length && LoadIndicator.getInstance($loadIndicator).option("visible", false);
    if (hasNewItems) {
      var $icon = $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS);
      $icon.show();
      return;
    }
    $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS).removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
    $node.addClass(IS_LEAF);
  },
  _emptyMessageContainer: function() {
    return this._scrollableContainer ? this._scrollableContainer.content() : this.callBase();
  },
  _renderContent: function() {
    var items = this.option("items");
    if (items && items.length) {
      this._contentAlreadyRendered = true;
    }
    this.callBase();
  },
  _renderSelectAllItem: function($container) {
    $container = $container || this.$element().find(".".concat(NODE_CONTAINER_CLASS$1)).first();
    this._$selectAllItem = $("<div>").addClass(SELECT_ALL_ITEM_CLASS);
    var value2 = this._dataAdapter.isAllSelected();
    this._createComponent(this._$selectAllItem, CheckBox, {
      value: value2,
      text: this.option("selectAllText"),
      onValueChanged: this._onSelectAllCheckboxValueChanged.bind(this)
    });
    this._toggleSelectedClass(this._$selectAllItem, value2);
    $container.before(this._$selectAllItem);
  },
  _onSelectAllCheckboxValueChanged: function(args) {
    this._toggleSelectAll(args);
    this._fireSelectAllValueChanged(args.value);
  },
  _toggleSelectAll: function(args) {
    this._dataAdapter.toggleSelectAll(args.value);
    this._updateItemsUI();
    this._fireSelectionChanged();
  },
  _renderCheckBox: function($node, node) {
    var $checkbox = $("<div>").appendTo($node);
    this._createComponent($checkbox, CheckBox, {
      value: node.internalFields.selected,
      onValueChanged: this._changeCheckboxValue.bind(this),
      focusStateEnabled: false,
      disabled: this._disabledGetter(node)
    });
  },
  _toggleSelectedClass: function($node, value2) {
    $node.toggleClass(SELECTED_ITEM_CLASS, !!value2);
  },
  _toggleNodeDisabledState: function(node, state) {
    var $node = this._getNodeElement(node);
    var $item = $node.find("." + ITEM_CLASS$1).eq(0);
    this._dataAdapter.toggleNodeDisabledState(node.internalFields.key, state);
    $item.toggleClass(DISABLED_STATE_CLASS, !!state);
    if (this._showCheckboxes()) {
      var checkbox = this._getCheckBoxInstance($node);
      checkbox.option("disabled", !!state);
    }
  },
  _itemOptionChanged: function(item, property, value2) {
    var node = this._dataAdapter.getNodeByItem(item);
    if (property === this.option("disabledExpr")) {
      this._toggleNodeDisabledState(node, value2);
    }
  },
  _changeCheckboxValue: function(e) {
    var $node = $(e.element).parent("." + NODE_CLASS);
    var $item = $node.children("." + ITEM_CLASS$1);
    var item = this._getItemData($item);
    var node = this._getNodeByElement($item);
    var value2 = e.value;
    if (node && node.internalFields.selected === value2) {
      return;
    }
    this._updateItemSelection(value2, item, e.event);
  },
  _isSingleSelection: function() {
    return this.option("selectionMode") === "single";
  },
  _isRecursiveSelection: function() {
    return this.option("selectNodesRecursive") && this.option("selectionMode") !== "single";
  },
  _isLastSelectedBranch: function(publicNode, selectedNodesKeys, deep) {
    var keyIndex = selectedNodesKeys.indexOf(publicNode.key);
    if (keyIndex >= 0) {
      selectedNodesKeys.splice(keyIndex, 1);
    }
    if (deep) {
      each(publicNode.children, function(_2, childNode) {
        this._isLastSelectedBranch(childNode, selectedNodesKeys, true);
      }.bind(this));
    }
    if (publicNode.parent) {
      this._isLastSelectedBranch(publicNode.parent, selectedNodesKeys);
    }
    return selectedNodesKeys.length === 0;
  },
  _isLastRequired: function(node) {
    var selectionRequired = this.option("selectionRequired");
    var isSingleMode = this._isSingleSelection();
    var selectedNodesKeys = this.getSelectedNodeKeys();
    if (!selectionRequired) {
      return;
    }
    if (isSingleMode) {
      return selectedNodesKeys.length === 1;
    } else {
      return this._isLastSelectedBranch(node.internalFields.publicNode, selectedNodesKeys.slice(), true);
    }
  },
  _updateItemSelection: function(value2, itemElement, dxEvent) {
    var node = this._getNode(itemElement);
    if (!node || node.visible === false) {
      return false;
    }
    if (node.internalFields.selected === value2) {
      return true;
    }
    if (!value2 && this._isLastRequired(node)) {
      if (this._showCheckboxes()) {
        var $node = this._getNodeElement(node);
        this._getCheckBoxInstance($node).option("value", true);
      }
      return false;
    }
    if (value2 && this._isSingleSelection()) {
      var selectedKeys = this.getSelectedNodeKeys();
      each(selectedKeys, (index2, key) => {
        this._dataAdapter.toggleSelection(key, false);
        this._updateItemsUI();
        this._fireItemSelectionChanged(this._getNode(key));
      });
    }
    this._dataAdapter.toggleSelection(node.internalFields.key, value2);
    var isAllSelected = this._dataAdapter.isAllSelected();
    var needFireSelectAllChanged = this._selectAllEnabled() && this._$selectAllItem.dxCheckBox("instance").option("value") !== isAllSelected;
    this._updateItemsUI();
    this._fireItemSelectionChanged(node, dxEvent);
    this._fireSelectionChanged();
    if (needFireSelectAllChanged) {
      this._fireSelectAllValueChanged(isAllSelected);
    }
    return true;
  },
  _fireItemSelectionChanged: function(node, dxEvent) {
    var initiator = dxEvent || this._findItemElementByItem(node.internalFields.item);
    var handler = dxEvent ? this._itemDXEventHandler : this._itemEventHandler;
    handler.call(this, initiator, "onItemSelectionChanged", {
      node: this._dataAdapter.getPublicNode(node),
      itemData: node.internalFields.item
    });
  },
  _getCheckBoxInstance: function($node) {
    return $node.children(".dx-checkbox").dxCheckBox("instance");
  },
  _updateItemsUI: function() {
    var cache = {};
    each(this._dataAdapter.getData(), (_2, node) => {
      var $node = this._getNodeElement(node, cache);
      var nodeSelection = node.internalFields.selected;
      if (!$node.length) {
        return;
      }
      this._toggleSelectedClass($node, nodeSelection);
      this.setAria("selected", nodeSelection, $node);
      if (this._showCheckboxes()) {
        this._getCheckBoxInstance($node).option("value", nodeSelection);
      }
    });
    if (this._selectAllEnabled()) {
      var selectAllCheckbox = this._$selectAllItem.dxCheckBox("instance");
      selectAllCheckbox.option("onValueChanged", void 0);
      selectAllCheckbox.option("value", this._dataAdapter.isAllSelected());
      selectAllCheckbox.option("onValueChanged", this._onSelectAllCheckboxValueChanged.bind(this));
    }
  },
  _updateParentsState: function(node, $node) {
    if (!$node) {
      return;
    }
    var parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey);
    var $parentNode = $($node.parents("." + NODE_CLASS)[0]);
    if (this._showCheckboxes()) {
      var parentValue = parentNode.internalFields.selected;
      this._getCheckBoxInstance($parentNode).option("value", parentValue);
      this._toggleSelectedClass($parentNode, parentValue);
    }
    if (parentNode.internalFields.parentKey !== this.option("rootValue")) {
      this._updateParentsState(parentNode, $parentNode);
    }
  },
  _itemEventHandlerImpl: function(initiator, action, actionArgs) {
    var $itemElement = $(initiator).closest("." + NODE_CLASS).children("." + ITEM_CLASS$1);
    return action(extend(this._extendActionArgs($itemElement), actionArgs));
  },
  _itemContextMenuHandler: function(e) {
    this._createEventHandler("onItemContextMenu", e);
  },
  _itemHoldHandler: function(e) {
    this._createEventHandler("onItemHold", e);
  },
  _createEventHandler: function(eventName, e) {
    var node = this._getNodeByElement(e.currentTarget);
    this._itemDXEventHandler(e, eventName, {
      node: this._dataAdapter.getPublicNode(node)
    });
  },
  _itemClass: function() {
    return ITEM_CLASS$1;
  },
  _itemDataKey: function() {
    return ITEM_DATA_KEY;
  },
  _attachClickEvent: function() {
    var clickSelector = "." + this._itemClass();
    var pointerDownSelector = "." + NODE_CLASS + ", ." + SELECT_ALL_ITEM_CLASS;
    var eventName = addNamespace$1(CLICK_EVENT_NAME$2, this.NAME);
    var pointerDownEvent = addNamespace$1(pointer.down, this.NAME);
    var $itemContainer = this._itemContainer();
    var that = this;
    eventsEngine.off($itemContainer, eventName, clickSelector);
    eventsEngine.off($itemContainer, pointerDownEvent, pointerDownSelector);
    eventsEngine.on($itemContainer, eventName, clickSelector, function(e) {
      that._itemClickHandler(e, $(this));
    });
    eventsEngine.on($itemContainer, pointerDownEvent, pointerDownSelector, function(e) {
      that._itemPointerDownHandler(e);
    });
  },
  _itemClickHandler: function(e, $item) {
    var itemData = this._getItemData($item);
    var node = this._getNodeByElement($item);
    this._itemDXEventHandler(e, "onItemClick", {
      node: this._dataAdapter.getPublicNode(node)
    });
    if (this.option("selectByClick") && !e.isDefaultPrevented()) {
      this._updateItemSelection(!node.internalFields.selected, itemData, e);
    }
  },
  _updateSelectionToFirstItem: function($items, startIndex) {
    var itemIndex = startIndex;
    while (itemIndex >= 0) {
      var $item = $($items[itemIndex]);
      this._updateItemSelection(true, $item.find("." + ITEM_CLASS$1).get(0));
      itemIndex--;
    }
  },
  _updateSelectionToLastItem: function($items, startIndex) {
    var length = $items.length;
    var itemIndex = startIndex;
    while (itemIndex < length) {
      var $item = $($items[itemIndex]);
      this._updateItemSelection(true, $item.find("." + ITEM_CLASS$1).get(0));
      itemIndex++;
    }
  },
  _focusInHandler: function(e) {
    this._updateFocusState(e, true);
    if (this.option("focusedElement")) {
      clearTimeout(this._setFocusedItemTimeout);
      this._setFocusedItemTimeout = setTimeout(() => {
        this._setFocusedItem($(this.option("focusedElement")));
      });
      return;
    }
    var $activeItem = this._getActiveItem();
    this.option("focusedElement", getPublicElement($activeItem.closest("." + NODE_CLASS)));
  },
  _setFocusedItem: function($target) {
    if (!$target || !$target.length) {
      return;
    }
    if (!$target.children().hasClass(DISABLED_STATE_CLASS)) {
      this.callBase($target);
    }
  },
  _itemPointerDownHandler: function(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    var $target = $(e.target).closest("." + NODE_CLASS + ", ." + SELECT_ALL_ITEM_CLASS);
    if (!$target.length) {
      return;
    }
    var itemElement = $target.hasClass(DISABLED_STATE_CLASS) ? null : $target;
    this.option("focusedElement", getPublicElement(itemElement));
  },
  _findNonDisabledNodes: function($nodes) {
    return $nodes.not(function() {
      return $(this).children("." + ITEM_CLASS$1).hasClass(DISABLED_STATE_CLASS);
    });
  },
  _moveFocus: function(location, e) {
    var FOCUS_UP2 = "up";
    var FOCUS_DOWN2 = "down";
    var FOCUS_FIRST2 = "first";
    var FOCUS_LAST2 = "last";
    var FOCUS_LEFT2 = this.option("rtlEnabled") ? "right" : "left";
    var FOCUS_RIGHT2 = this.option("rtlEnabled") ? "left" : "right";
    this.$element().find(".".concat(NODE_CONTAINER_CLASS$1)).each(function() {
      fx.stop(this, true);
    });
    var $items = this._findNonDisabledNodes(this._nodeElements());
    if (!$items || !$items.length) {
      return;
    }
    switch (location) {
      case FOCUS_UP2:
        var $prevItem = this._prevItem($items);
        this.option("focusedElement", getPublicElement($prevItem));
        var prevItemElement = this._getNodeItemElement($prevItem);
        this._scrollableContainer.scrollToElement(prevItemElement);
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateItemSelection(true, prevItemElement);
        }
        break;
      case FOCUS_DOWN2:
        var $nextItem = this._nextItem($items);
        this.option("focusedElement", getPublicElement($nextItem));
        var nextItemElement = this._getNodeItemElement($nextItem);
        this._scrollableContainer.scrollToElement(nextItemElement);
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateItemSelection(true, nextItemElement);
        }
        break;
      case FOCUS_FIRST2:
        var $firstItem = $items.first();
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)));
        }
        this.option("focusedElement", getPublicElement($firstItem));
        this._scrollableContainer.scrollToElement(this._getNodeItemElement($firstItem));
        break;
      case FOCUS_LAST2:
        var $lastItem = $items.last();
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)));
        }
        this.option("focusedElement", getPublicElement($lastItem));
        this._scrollableContainer.scrollToElement(this._getNodeItemElement($lastItem));
        break;
      case FOCUS_RIGHT2:
        this._expandFocusedContainer();
        break;
      case FOCUS_LEFT2:
        this._collapseFocusedContainer();
        break;
      default:
        this.callBase.apply(this, arguments);
        return;
    }
  },
  _getNodeItemElement: function($node) {
    return $node.find("." + ITEM_CLASS$1).get(0);
  },
  _nodeElements: function() {
    return this.$element().find("." + NODE_CLASS).not(":hidden");
  },
  _expandFocusedContainer: function() {
    var $focusedNode = $(this.option("focusedElement"));
    if (!$focusedNode.length || $focusedNode.hasClass(IS_LEAF)) {
      return;
    }
    var $node = $focusedNode.find(".".concat(NODE_CONTAINER_CLASS$1)).eq(0);
    if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
      var $nextItem = this._nextItem(this._findNonDisabledNodes(this._nodeElements()));
      this.option("focusedElement", getPublicElement($nextItem));
      this._scrollableContainer.scrollToElement(this._getNodeItemElement($nextItem));
      return;
    }
    var node = this._getNodeByElement($focusedNode.children("." + ITEM_CLASS$1));
    this._toggleExpandedState(node, true);
  },
  _getClosestNonDisabledNode: function($node) {
    do {
      $node = $node.parent().closest("." + NODE_CLASS);
    } while ($node.children(".dx-treeview-item.dx-state-disabled").length);
    return $node;
  },
  _collapseFocusedContainer: function() {
    var $focusedNode = $(this.option("focusedElement"));
    if (!$focusedNode.length) {
      return;
    }
    var nodeElement = $focusedNode.find(".".concat(NODE_CONTAINER_CLASS$1)).eq(0);
    if (!$focusedNode.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
      var node = this._getNodeByElement($focusedNode.children("." + ITEM_CLASS$1));
      this._toggleExpandedState(node, false);
    } else {
      var collapsedNode = this._getClosestNonDisabledNode($focusedNode);
      collapsedNode.length && this.option("focusedElement", getPublicElement(collapsedNode));
      this._scrollableContainer.scrollToElement(this._getNodeItemElement(collapsedNode));
    }
  },
  _encodeString: function(value2) {
    return isString$1(value2) ? encodeURI(value2) : value2;
  },
  _decodeString: function(value2) {
    return isString$1(value2) ? decodeURI(value2) : value2;
  },
  updateDimensions: function() {
    var deferred = new Deferred();
    if (this._scrollableContainer) {
      this._scrollableContainer.update().done(() => {
        deferred.resolveWith(this);
      });
    } else {
      deferred.resolveWith(this);
    }
    return deferred.promise();
  },
  selectItem: function(itemElement) {
    return this._updateItemSelection(true, itemElement);
  },
  unselectItem: function(itemElement) {
    return this._updateItemSelection(false, itemElement);
  },
  expandItem: function(itemElement) {
    return this._toggleExpandedState(itemElement, true);
  },
  collapseItem: function(itemElement) {
    return this._toggleExpandedState(itemElement, false);
  },
  getNodes: function() {
    return this._dataAdapter.getTreeNodes();
  },
  getSelectedNodes: function() {
    return this.getSelectedNodeKeys().map((key) => {
      var node = this._dataAdapter.getNodeByKey(key);
      return this._dataAdapter.getPublicNode(node);
    });
  },
  getSelectedNodesKeys: function() {
    errors$1.log("W0002", "dxTreeView", "getSelectedNodesKeys", "20.1", "Use the 'getSelectedNodeKeys' method instead");
    return this.getSelectedNodeKeys();
  },
  getSelectedNodeKeys: function() {
    return this._dataAdapter.getSelectedNodesKeys();
  },
  selectAll: function() {
    if (this._selectAllEnabled()) {
      this._$selectAllItem.dxCheckBox("instance").option("value", true);
    } else {
      this._toggleSelectAll({
        value: true
      });
    }
  },
  unselectAll: function() {
    if (this._selectAllEnabled()) {
      this._$selectAllItem.dxCheckBox("instance").option("value", false);
    } else {
      this._toggleSelectAll({
        value: false
      });
    }
  },
  expandAll: function() {
    var dataAdapter = this._dataAdapter;
    each(dataAdapter.getData(), (_2, node) => dataAdapter.toggleExpansion(node.internalFields.key, true));
    this.repaint();
  },
  collapseAll: function() {
    each(this._dataAdapter.getExpandedNodesKeys(), function(_2, key) {
      this._toggleExpandedState(key, false);
    }.bind(this));
  },
  scrollToItem: function(keyOrItemOrElement) {
    var node = this._getNode(keyOrItemOrElement);
    if (!node) {
      return new Deferred().reject().promise();
    }
    var nodeKeysToExpand = [];
    var parentNode = node.internalFields.publicNode.parent;
    while (parentNode != null) {
      if (!parentNode.expanded) {
        nodeKeysToExpand.push(parentNode.key);
      }
      parentNode = parentNode.parent;
    }
    var scrollCallback = new Deferred();
    this._expandNodes(nodeKeysToExpand.reverse()).always(() => {
      var $element = this._getNodeElement(node);
      if ($element && $element.length) {
        this._scrollableContainer.scrollToElementTopLeft($element);
        scrollCallback.resolve();
      } else {
        scrollCallback.reject();
      }
    });
    return scrollCallback.promise();
  },
  _expandNodes: function(keysToExpand) {
    if (!keysToExpand || keysToExpand.length === 0) {
      return new Deferred().resolve().promise();
    }
    var resultCallback = new Deferred();
    var callbacksByNodes = keysToExpand.map((key) => this.expandItem(key));
    when.apply($, callbacksByNodes).done(() => resultCallback.resolve()).fail(() => resultCallback.reject());
    return resultCallback.promise();
  },
  _dispose: function() {
    this.callBase();
    clearTimeout(this._setFocusedItemTimeout);
  }
});
var WIDGET_CLASS = "dx-treeview";
var NODE_CONTAINER_CLASS = "".concat(WIDGET_CLASS, "-node-container");
var TreeViewSearch = TreeViewBase.inherit(searchBoxMixin).inherit({
  _addWidgetPrefix: function(className) {
    return "".concat(WIDGET_CLASS, "-").concat(className);
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "searchValue":
        if (this._showCheckboxes() && this._isRecursiveSelection()) {
          this._removeSelection();
        }
        this._initDataAdapter();
        this._updateSearch();
        this._repaintContainer();
        break;
      case "searchExpr":
        this._initDataAdapter();
        this.repaint();
        break;
      case "searchMode":
        this.option("expandNodesRecursive") ? this._updateDataAdapter() : this._initDataAdapter();
        this.repaint();
        break;
      default:
        this.callBase(args);
    }
  },
  _updateDataAdapter: function() {
    this._setOptionWithoutOptionChange("expandNodesRecursive", false);
    this._initDataAdapter();
    this._setOptionWithoutOptionChange("expandNodesRecursive", true);
  },
  _getDataAdapterOptions: function() {
    return extend(this.callBase(), {
      searchValue: this.option("searchValue"),
      searchMode: this.option("searchMode") || "contains",
      searchExpr: this.option("searchExpr")
    });
  },
  _updateSearch: function() {
    if (this._searchEditor) {
      var editorOptions = this._getSearchEditorOptions();
      this._searchEditor.option(editorOptions);
    }
  },
  _repaintContainer: function() {
    var $container = this.$element().find(".".concat(NODE_CONTAINER_CLASS)).first();
    var rootNodes;
    if ($container.length) {
      $container.empty();
      rootNodes = this._dataAdapter.getRootNodes();
      this._renderEmptyMessage(rootNodes);
      this._renderItems($container, rootNodes);
      this._fireContentReadyAction();
    }
  },
  _itemContainer: function(isSearchMode) {
    if (this._scrollableContainer && isSearchMode) {
      return $(this._scrollableContainer.content());
    }
    return this.callBase();
  },
  _addWidgetClass: function() {
    this.$element().addClass(this._widgetClass());
  },
  _clean: function() {
    this.callBase();
    this._removeSearchBox();
  }
});
registerComponent("dxTreeView", TreeViewSearch);
var LIST_ITEM_CLASS$1 = "dx-list-item";
var LIST_GROUP_CLASS$1 = "dx-list-group";
var SELECTION_SHIFT = 20;
var SELECTION_MASK = (1 << SELECTION_SHIFT) - 1;
var combineIndex = function(indices) {
  return (indices.group << SELECTION_SHIFT) + indices.item;
};
var splitIndex = function(combinedIndex) {
  return {
    group: combinedIndex >> SELECTION_SHIFT,
    item: combinedIndex & SELECTION_MASK
  };
};
var GroupedEditStrategy = PlainEditStrategy.inherit({
  _groupElements: function() {
    return this._collectionWidget._itemContainer().find("." + LIST_GROUP_CLASS$1);
  },
  _groupItemElements: function($group) {
    return $group.find("." + LIST_ITEM_CLASS$1);
  },
  getIndexByItemData: function(itemData) {
    var groups = this._collectionWidget.option("items");
    var index2 = false;
    if (!itemData) {
      return false;
    }
    if (itemData.items && itemData.items.length) {
      itemData = itemData.items[0];
    }
    each(groups, function(groupIndex, group) {
      if (!group.items) {
        return false;
      }
      each(group.items, function(itemIndex, item) {
        if (item !== itemData) {
          return true;
        }
        index2 = {
          group: groupIndex,
          item: itemIndex
        };
        return false;
      });
      if (index2) {
        return false;
      }
    });
    return index2;
  },
  getItemDataByIndex: function(index2) {
    var items = this._collectionWidget.option("items");
    if (isNumeric(index2)) {
      return this.itemsGetter()[index2];
    }
    return index2 && items[index2.group] && items[index2.group].items[index2.item] || null;
  },
  itemsGetter: function() {
    var resultItems = [];
    var items = this._collectionWidget.option("items");
    for (var i = 0; i < items.length; i++) {
      if (items[i] && items[i].items) {
        resultItems = resultItems.concat(items[i].items);
      } else {
        resultItems.push(items[i]);
      }
    }
    return resultItems;
  },
  deleteItemAtIndex: function(index2) {
    var indices = splitIndex(index2);
    var itemGroup = this._collectionWidget.option("items")[indices.group].items;
    itemGroup.splice(indices.item, 1);
  },
  getKeysByItems: function(items) {
    var plainItems = [];
    var i;
    for (i = 0; i < items.length; i++) {
      if (items[i] && items[i].items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    var result = [];
    for (i = 0; i < plainItems.length; i++) {
      result.push(this._collectionWidget.keyOf(plainItems[i]));
    }
    return result;
  },
  getIndexByKey: function(key, items) {
    var groups = items || this._collectionWidget.option("items");
    var index2 = -1;
    var that = this;
    each(groups, function(groupIndex, group) {
      if (!group.items) {
        return;
      }
      var keys2 = that.getKeysByItems(group.items);
      each(keys2, function(keyIndex, itemKey) {
        if (that._equalKeys(itemKey, key)) {
          index2 = {
            group: groupIndex,
            item: keyIndex
          };
          return false;
        }
      });
      if (index2 !== -1) {
        return false;
      }
    });
    return index2;
  },
  _getGroups: function(items) {
    var dataSource = this._collectionWidget.getDataSource();
    var group = dataSource && dataSource.group();
    if (group) {
      return storeHelper.queryByOptions(query(items), {
        group
      }).toArray();
    }
    return this._collectionWidget.option("items");
  },
  getItemsByKeys: function(keys2, items) {
    var result = [];
    each(keys2, function(_2, key) {
      var getItemMeta = function(groups) {
        var index2 = this.getIndexByKey(key, groups);
        var group = index2 && groups[index2.group];
        if (!group) {
          return;
        }
        return {
          groupKey: group.key,
          item: group.items[index2.item]
        };
      }.bind(this);
      var itemMeta = getItemMeta(this._getGroups(items));
      if (!itemMeta) {
        return;
      }
      var groupKey = itemMeta.groupKey;
      var item = itemMeta.item;
      var selectedGroup;
      each(result, function(_3, item2) {
        if (item2.key === groupKey) {
          selectedGroup = item2;
          return false;
        }
      });
      if (!selectedGroup) {
        selectedGroup = {
          key: groupKey,
          items: []
        };
        result.push(selectedGroup);
      }
      selectedGroup.items.push(item);
    }.bind(this));
    return result;
  },
  moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
    var items = this._collectionWidget.option("items");
    var movingIndices = splitIndex(movingIndex);
    var destinationIndices = splitIndex(destinationIndex);
    var movingItemGroup = items[movingIndices.group].items;
    var destinationItemGroup = items[destinationIndices.group].items;
    var movedItemData = movingItemGroup[movingIndices.item];
    movingItemGroup.splice(movingIndices.item, 1);
    destinationItemGroup.splice(destinationIndices.item, 0, movedItemData);
  },
  _isItemIndex: function(index2) {
    return index2 && isNumeric(index2.group) && isNumeric(index2.item);
  },
  _getNormalizedItemIndex: function(itemElement) {
    var $item = $(itemElement);
    var $group = $item.closest("." + LIST_GROUP_CLASS$1);
    if (!$group.length) {
      return -1;
    }
    return combineIndex({
      group: this._groupElements().index($group),
      item: this._groupItemElements($group).index($item)
    });
  },
  _normalizeItemIndex: function(index2) {
    return combineIndex(index2);
  },
  _denormalizeItemIndex: function(index2) {
    return splitIndex(index2);
  },
  _getItemByNormalizedIndex: function(index2) {
    var indices = splitIndex(index2);
    var $group = this._groupElements().eq(indices.group);
    return this._groupItemElements($group).eq(indices.item);
  },
  _itemsFromSameParent: function(firstIndex, secondIndex) {
    return splitIndex(firstIndex).group === splitIndex(secondIndex).group;
  }
});
var registry = {};
function register(option, type2, decoratorClass) {
  var decoratorsRegistry = registry;
  var decoratorConfig = {};
  decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
  decoratorConfig[option][type2] = decoratorClass;
  extend(decoratorsRegistry, decoratorConfig);
}
var SWIPE_START_EVENT = "dxswipestart";
var SWIPE_EVENT = "dxswipe";
var SWIPE_END_EVENT = "dxswipeend";
var HorizontalStrategy = {
  defaultItemSizeFunc: function() {
    return this.getElement().width();
  },
  getBounds: function() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio: function(e) {
    var endEventData = eventData(e);
    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function(e) {
    var endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
  }
};
var VerticalStrategy = {
  defaultItemSizeFunc: function() {
    return this.getElement().height();
  },
  getBounds: function() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio: function(e) {
    var endEventData = eventData(e);
    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function(e) {
    var endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
  }
};
var STRATEGIES = {
  horizontal: HorizontalStrategy,
  vertical: VerticalStrategy
};
var SwipeEmitter = GestureEmitter.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor: function(element) {
    this.callBase(element);
    this.direction = "horizontal";
    this.elastic = true;
  },
  _getStrategy: function() {
    return STRATEGIES[this.direction];
  },
  _defaultItemSizeFunc: function() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc: function() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init: function(e) {
    this._tickData = eventData(e);
  },
  _start: function(e) {
    this._savedEventData = eventData(e);
    e = this._fireEvent(SWIPE_START_EVENT, e);
    if (!e.cancel) {
      this._maxLeftOffset = e.maxLeftOffset;
      this._maxRightOffset = e.maxRightOffset;
      this._maxTopOffset = e.maxTopOffset;
      this._maxBottomOffset = e.maxBottomOffset;
    }
  },
  _move: function(e) {
    var strategy2 = this._getStrategy();
    var moveEventData = eventData(e);
    var offset2 = strategy2.calcOffsetRatio.call(this, e);
    offset2 = this._fitOffset(offset2, this.elastic);
    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
      this._tickData = moveEventData;
    }
    this._fireEvent(SWIPE_EVENT, e, {
      offset: offset2
    });
    e.preventDefault();
  },
  _end: function(e) {
    var strategy2 = this._getStrategy();
    var offsetRatio = strategy2.calcOffsetRatio.call(this, e);
    var isFast = strategy2.isFastSwipe.call(this, e);
    var startOffset = offsetRatio;
    var targetOffset = this._calcTargetOffset(offsetRatio, isFast);
    startOffset = this._fitOffset(startOffset, this.elastic);
    targetOffset = this._fitOffset(targetOffset, false);
    this._fireEvent(SWIPE_END_EVENT, e, {
      offset: startOffset,
      targetOffset
    });
  },
  _fitOffset: function(offset2, elastic) {
    var strategy2 = this._getStrategy();
    var bounds = strategy2.getBounds.call(this);
    if (offset2 < -bounds[0]) {
      return elastic ? (-2 * bounds[0] + offset2) / 3 : -bounds[0];
    }
    if (offset2 > bounds[1]) {
      return elastic ? (2 * bounds[1] + offset2) / 3 : bounds[1];
    }
    return offset2;
  },
  _calcTargetOffset: function(offsetRatio, isFast) {
    var result;
    if (isFast) {
      result = Math.ceil(Math.abs(offsetRatio));
      if (offsetRatio < 0) {
        result = -result;
      }
    } else {
      result = Math.round(offsetRatio);
    }
    return result;
  }
});
registerEmitter({
  emitter: SwipeEmitter,
  events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
});
var LIST_EDIT_DECORATOR$2 = "dxListEditDecorator";
var SWIPE_START_EVENT_NAME = addNamespace$1(SWIPE_START_EVENT, LIST_EDIT_DECORATOR$2);
var SWIPE_UPDATE_EVENT_NAME = addNamespace$1(SWIPE_EVENT, LIST_EDIT_DECORATOR$2);
var SWIPE_END_EVENT_NAME = addNamespace$1(SWIPE_END_EVENT, LIST_EDIT_DECORATOR$2);
var EditDecorator = classImpl.inherit({
  ctor: function(list) {
    this._list = list;
    this._init();
  },
  _init: noop,
  _shouldHandleSwipe: false,
  _attachSwipeEvent: function(config2) {
    var swipeConfig = {
      itemSizeFunc: function() {
        if (this._clearSwipeCache) {
          this._itemWidthCache = this._list.$element().width();
          this._clearSwipeCache = false;
        }
        return this._itemWidthCache;
      }.bind(this)
    };
    eventsEngine.on(config2.$itemElement, SWIPE_START_EVENT_NAME, swipeConfig, this._itemSwipeStartHandler.bind(this));
    eventsEngine.on(config2.$itemElement, SWIPE_UPDATE_EVENT_NAME, this._itemSwipeUpdateHandler.bind(this));
    eventsEngine.on(config2.$itemElement, SWIPE_END_EVENT_NAME, this._itemSwipeEndHandler.bind(this));
  },
  _itemSwipeStartHandler: function(e) {
    var $itemElement = $(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    clearTimeout(this._list._inkRippleTimer);
    this._swipeStartHandler($itemElement, e);
  },
  _itemSwipeUpdateHandler: function(e) {
    var $itemElement = $(e.currentTarget);
    this._swipeUpdateHandler($itemElement, e);
  },
  _itemSwipeEndHandler: function(e) {
    var $itemElement = $(e.currentTarget);
    this._swipeEndHandler($itemElement, e);
    this._clearSwipeCache = true;
  },
  beforeBag: noop,
  afterBag: noop,
  _commonOptions: function() {
    return {
      activeStateEnabled: this._list.option("activeStateEnabled"),
      hoverStateEnabled: this._list.option("hoverStateEnabled"),
      focusStateEnabled: this._list.option("focusStateEnabled")
    };
  },
  modifyElement: function(config2) {
    if (this._shouldHandleSwipe) {
      this._attachSwipeEvent(config2);
      this._clearSwipeCache = true;
    }
  },
  afterRender: noop,
  handleClick: noop,
  handleKeyboardEvents: noop,
  handleEnterPressing: noop,
  handleContextMenu: noop,
  _swipeStartHandler: noop,
  _swipeUpdateHandler: noop,
  _swipeEndHandler: noop,
  visibilityChange: noop,
  getExcludedSelectors: noop,
  dispose: noop
});
var STATIC_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-static-delete-button-container";
var STATIC_DELETE_BUTTON_CLASS = "dx-list-static-delete-button";
register("delete", "static", EditDecorator.inherit({
  afterBag: function(config2) {
    var $itemElement = config2.$itemElement;
    var $container = config2.$container;
    var $button = $("<div>").addClass(STATIC_DELETE_BUTTON_CLASS);
    this._list._createComponent($button, Button, {
      icon: "remove",
      onClick: function(args) {
        args.event.stopPropagation();
        this._deleteItem($itemElement);
      }.bind(this),
      integrationOptions: {}
    });
    $container.addClass(STATIC_DELETE_BUTTON_CONTAINER_CLASS).append($button);
  },
  _deleteItem: function($itemElement) {
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    this._list.deleteItem($itemElement);
  }
}));
var abstract = EditDecorator.abstract;
var LIST_EDIT_DECORATOR$1 = "dxListEditDecorator";
var POINTER_DOWN_EVENT_NAME = addNamespace$1(pointer.down, LIST_EDIT_DECORATOR$1);
var ACTIVE_EVENT_NAME$1 = addNamespace$1(ACTIVE_EVENT_NAME$2, LIST_EDIT_DECORATOR$1);
var LIST_ITEM_CONTENT_CLASS = "dx-list-item-content";
var SWITCHABLE_DELETE_READY_CLASS = "dx-list-switchable-delete-ready";
var SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-shield-positioning";
var SWITCHABLE_DELETE_TOP_SHIELD_CLASS = "dx-list-switchable-delete-top-shield";
var SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS = "dx-list-switchable-delete-bottom-shield";
var SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-item-shield-positioning";
var SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS = "dx-list-switchable-delete-item-content-shield";
var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS$1 = "dx-list-switchable-delete-button-container";
var SwitchableEditDecorator = EditDecorator.inherit({
  _init: function() {
    this._$topShield = $("<div>").addClass(SWITCHABLE_DELETE_TOP_SHIELD_CLASS);
    this._$bottomShield = $("<div>").addClass(SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS);
    this._$itemContentShield = $("<div>").addClass(SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS);
    eventsEngine.on(this._$topShield, POINTER_DOWN_EVENT_NAME, this._cancelDeleteReadyItem.bind(this));
    eventsEngine.on(this._$bottomShield, POINTER_DOWN_EVENT_NAME, this._cancelDeleteReadyItem.bind(this));
    this._list.$element().append(this._$topShield.toggle(false)).append(this._$bottomShield.toggle(false));
  },
  handleClick: function() {
    return this._cancelDeleteReadyItem();
  },
  _cancelDeleteReadyItem: function() {
    if (!this._$readyToDeleteItem) {
      return false;
    }
    this._cancelDelete(this._$readyToDeleteItem);
    return true;
  },
  _cancelDelete: function($itemElement) {
    this._toggleDeleteReady($itemElement, false);
  },
  _toggleDeleteReady: function($itemElement, readyToDelete) {
    if (readyToDelete === void 0) {
      readyToDelete = !this._isReadyToDelete($itemElement);
    }
    this._toggleShields($itemElement, readyToDelete);
    this._toggleScrolling(readyToDelete);
    this._cacheReadyToDeleteItem($itemElement, readyToDelete);
    this._animateToggleDelete($itemElement, readyToDelete);
  },
  _isReadyToDelete: function($itemElement) {
    return $itemElement.hasClass(SWITCHABLE_DELETE_READY_CLASS);
  },
  _toggleShields: function($itemElement, enabled) {
    this._list.$element().toggleClass(SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS, enabled);
    this._$topShield.toggle(enabled);
    this._$bottomShield.toggle(enabled);
    if (enabled) {
      this._updateShieldsHeight($itemElement);
    }
    this._toggleContentShield($itemElement, enabled);
  },
  _updateShieldsHeight: function($itemElement) {
    var $list = this._list.$element();
    var listTopOffset = $list.offset().top;
    var listHeight = $list.outerHeight();
    var itemTopOffset = $itemElement.offset().top;
    var itemHeight = $itemElement.outerHeight();
    var dirtyTopShieldHeight = itemTopOffset - listTopOffset;
    var dirtyBottomShieldHeight = listHeight - itemHeight - dirtyTopShieldHeight;
    this._$topShield.height(Math.max(dirtyTopShieldHeight, 0));
    this._$bottomShield.height(Math.max(dirtyBottomShieldHeight, 0));
  },
  _toggleContentShield: function($itemElement, enabled) {
    if (enabled) {
      $itemElement.find("." + LIST_ITEM_CONTENT_CLASS).first().append(this._$itemContentShield);
    } else {
      this._$itemContentShield.detach();
    }
  },
  _toggleScrolling: function(readyToDelete) {
    var scrollView = this._list.$element().dxScrollView("instance");
    if (readyToDelete) {
      scrollView.on("start", this._cancelScrolling);
    } else {
      scrollView.off("start", this._cancelScrolling);
    }
  },
  _cancelScrolling: function(args) {
    args.event.cancel = true;
  },
  _cacheReadyToDeleteItem: function($itemElement, cache) {
    if (cache) {
      this._$readyToDeleteItem = $itemElement;
    } else {
      delete this._$readyToDeleteItem;
    }
  },
  _animateToggleDelete: function($itemElement, readyToDelete) {
    if (readyToDelete) {
      this._enablePositioning($itemElement);
      this._prepareDeleteReady($itemElement);
      this._animatePrepareDeleteReady($itemElement);
      eventsEngine.off($itemElement, pointer.up);
    } else {
      this._forgetDeleteReady($itemElement);
      this._animateForgetDeleteReady($itemElement).done(this._disablePositioning.bind(this, $itemElement));
    }
  },
  _enablePositioning: function($itemElement) {
    $itemElement.addClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
    eventsEngine.on($itemElement, ACTIVE_EVENT_NAME$1, noop);
    eventsEngine.one($itemElement, pointer.up, this._disablePositioning.bind(this, $itemElement));
  },
  _disablePositioning: function($itemElement) {
    $itemElement.removeClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
    eventsEngine.off($itemElement, ACTIVE_EVENT_NAME$1);
  },
  _prepareDeleteReady: function($itemElement) {
    $itemElement.addClass(SWITCHABLE_DELETE_READY_CLASS);
  },
  _forgetDeleteReady: function($itemElement) {
    $itemElement.removeClass(SWITCHABLE_DELETE_READY_CLASS);
  },
  _animatePrepareDeleteReady: abstract,
  _animateForgetDeleteReady: abstract,
  _getDeleteButtonContainer: function($itemElement) {
    $itemElement = $itemElement || this._$readyToDeleteItem;
    return $itemElement.children("." + SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS$1);
  },
  _deleteItem: function($itemElement) {
    $itemElement = $itemElement || this._$readyToDeleteItem;
    this._getDeleteButtonContainer($itemElement).detach();
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    this._list.deleteItem($itemElement).always(this._cancelDelete.bind(this, $itemElement));
  },
  _isRtlEnabled: function() {
    return this._list.option("rtlEnabled");
  },
  dispose: function() {
    if (this._$topShield) {
      this._$topShield.remove();
    }
    if (this._$bottomShield) {
      this._$bottomShield.remove();
    }
    this.callBase.apply(this, arguments);
  }
});
var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-switchable-delete-button-container";
var SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS = "dx-list-switchable-delete-button-wrapper";
var SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS = "dx-list-switchable-delete-button-inner-wrapper";
var SWITCHABLE_DELETE_BUTTON_CLASS = "dx-list-switchable-delete-button";
var SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION = 200;
var SwitchableButtonEditDecorator = SwitchableEditDecorator.inherit({
  _init: function() {
    this.callBase.apply(this, arguments);
    var $buttonContainer = $("<div>").addClass(SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS);
    var $buttonWrapper = $("<div>").addClass(SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS);
    var $buttonInnerWrapper = $("<div>").addClass(SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS);
    var $button = $("<div>").addClass(SWITCHABLE_DELETE_BUTTON_CLASS);
    this._list._createComponent($button, Button, {
      text: messageLocalization.format("dxListEditDecorator-delete"),
      type: "danger",
      onClick: function(e) {
        this._deleteItem();
        e.event.stopPropagation();
      }.bind(this),
      integrationOptions: {}
    });
    $buttonContainer.append($buttonWrapper);
    $buttonWrapper.append($buttonInnerWrapper);
    $buttonInnerWrapper.append($button);
    this._$buttonContainer = $buttonContainer;
  },
  _enablePositioning: function($itemElement) {
    this.callBase.apply(this, arguments);
    fx.stop(this._$buttonContainer, true);
    this._$buttonContainer.appendTo($itemElement);
  },
  _disablePositioning: function() {
    this.callBase.apply(this, arguments);
    this._$buttonContainer.detach();
  },
  _animatePrepareDeleteReady: function() {
    var rtl = this._isRtlEnabled();
    var listWidth = this._list.$element().width();
    var buttonWidth = this._buttonWidth();
    var fromValue = rtl ? listWidth : -buttonWidth;
    var toValue = rtl ? listWidth - buttonWidth : 0;
    return fx.animate(this._$buttonContainer, {
      type: "custom",
      duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
      from: {
        right: fromValue
      },
      to: {
        right: toValue
      }
    });
  },
  _animateForgetDeleteReady: function() {
    var rtl = this._isRtlEnabled();
    var listWidth = this._list.$element().width();
    var buttonWidth = this._buttonWidth();
    var fromValue = rtl ? listWidth - buttonWidth : 0;
    var toValue = rtl ? listWidth : -buttonWidth;
    return fx.animate(this._$buttonContainer, {
      type: "custom",
      duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
      from: {
        right: fromValue
      },
      to: {
        right: toValue
      }
    });
  },
  _buttonWidth: function() {
    if (!this._buttonContainerWidth) {
      this._buttonContainerWidth = this._$buttonContainer.outerWidth();
    }
    return this._buttonContainerWidth;
  },
  dispose: function() {
    if (this._$buttonContainer) {
      this._$buttonContainer.remove();
    }
    this.callBase.apply(this, arguments);
  }
});
var TOGGLE_DELETE_SWITCH_CONTAINER_CLASS = "dx-list-toggle-delete-switch-container";
var TOGGLE_DELETE_SWITCH_CLASS = "dx-list-toggle-delete-switch";
register("delete", "toggle", SwitchableButtonEditDecorator.inherit({
  beforeBag: function(config2) {
    var $itemElement = config2.$itemElement;
    var $container = config2.$container;
    var $toggle = $("<div>").addClass(TOGGLE_DELETE_SWITCH_CLASS);
    this._list._createComponent($toggle, Button, {
      icon: "toggle-delete",
      onClick: function(e) {
        fx.stop(this._$buttonContainer, false);
        this._toggleDeleteReady($itemElement);
        e.event.stopPropagation();
      }.bind(this),
      integrationOptions: {}
    });
    $container.addClass(TOGGLE_DELETE_SWITCH_CONTAINER_CLASS);
    $container.append($toggle);
  }
}));
register("delete", "slideButton", SwitchableButtonEditDecorator.inherit({
  _shouldHandleSwipe: true,
  _swipeEndHandler: function($itemElement, args) {
    if (args.targetOffset !== 0) {
      fx.stop(this._$buttonContainer, false);
      this._toggleDeleteReady($itemElement);
    }
    return true;
  }
}));
var EditDecoratorMenuHelperMixin = {
  _menuEnabled: function() {
    return !!this._menuItems().length;
  },
  _menuItems: function() {
    return this._list.option("menuItems");
  },
  _deleteEnabled: function() {
    return this._list.option("allowItemDeleting");
  },
  _fireMenuAction: function($itemElement, action) {
    this._list._itemEventHandlerByHandler($itemElement, action, {}, {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
};
var POPOVER_BOUNDARY_OFFSET = 10;
var window$6 = getWindow();
var POPOVER_CLASS = "dx-popover";
var POPOVER_WRAPPER_CLASS = "dx-popover-wrapper";
var POPOVER_ARROW_CLASS = "dx-popover-arrow";
var POPOVER_WITHOUT_TITLE_CLASS = "dx-popover-without-title";
var POSITION_FLIP_MAP = {
  left: "right",
  top: "bottom",
  right: "left",
  bottom: "top",
  center: "center"
};
var WEIGHT_OF_SIDES = {
  left: -1,
  top: -1,
  center: 0,
  right: 1,
  bottom: 1
};
var POSITION_ALIASES = {
  top: {
    my: "bottom center",
    at: "top center",
    collision: "fit flip"
  },
  bottom: {
    my: "top center",
    at: "bottom center",
    collision: "fit flip"
  },
  right: {
    my: "left center",
    at: "right center",
    collision: "flip fit"
  },
  left: {
    my: "right center",
    at: "left center",
    collision: "flip fit"
  }
};
var SIDE_BORDER_WIDTH_STYLES = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};
var getEventNameByOption = function(optionValue) {
  return isObject$1(optionValue) ? optionValue.name : optionValue;
};
var getEventName = function(that, optionName) {
  var optionValue = that.option(optionName);
  return getEventNameByOption(optionValue);
};
var getEventDelay = function(that, optionName) {
  var optionValue = that.option(optionName);
  return isObject$1(optionValue) && optionValue.delay;
};
var attachEvent = function(that, name2) {
  var target = that.option("target");
  var isSelector = isString$1(target);
  var event = getEventName(that, name2 + "Event");
  if (!event || that.option("disabled")) {
    return;
  }
  var eventName = addNamespace$1(event, that.NAME);
  var action = that._createAction(function() {
    var delay = getEventDelay(that, name2 + "Event");
    this._clearEventsTimeouts();
    if (delay) {
      this._timeouts[name2] = setTimeout(function() {
        that[name2]();
      }, delay);
    } else {
      that[name2]();
    }
  }.bind(that), {
    validatingTargetName: "target"
  });
  var handler = function(e) {
    action({
      event: e,
      target: $(e.currentTarget)
    });
  };
  var EVENT_HANDLER_NAME = "_" + name2 + "EventHandler";
  if (isSelector) {
    that[EVENT_HANDLER_NAME] = handler;
    eventsEngine.on(domAdapter.getDocument(), eventName, target, handler);
  } else {
    var targetElement = getPublicElement($(target));
    that[EVENT_HANDLER_NAME] = void 0;
    eventsEngine.on(targetElement, eventName, handler);
  }
};
var detachEvent = function(that, target, name2, event) {
  var eventName = event || getEventName(that, name2 + "Event");
  if (!eventName) {
    return;
  }
  eventName = addNamespace$1(eventName, that.NAME);
  var EVENT_HANDLER_NAME = "_" + name2 + "EventHandler";
  if (that[EVENT_HANDLER_NAME]) {
    eventsEngine.off(domAdapter.getDocument(), eventName, target, that[EVENT_HANDLER_NAME]);
  } else {
    eventsEngine.off(getPublicElement($(target)), eventName);
  }
};
var Popover = Popup.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      target: window$6,
      shading: false,
      position: "bottom",
      closeOnOutsideClick: true,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          to: 0
        }
      },
      showTitle: false,
      width: "auto",
      height: "auto",
      dragEnabled: false,
      resizeEnabled: false,
      fullScreen: false,
      closeOnTargetScroll: true,
      arrowPosition: "",
      arrowOffset: 0,
      boundaryOffset: {
        h: POPOVER_BOUNDARY_OFFSET,
        v: POPOVER_BOUNDARY_OFFSET
      },
      _fixedPosition: true
    });
  },
  _defaultOptionsRules: function() {
    return [{
      device: {
        platform: "ios"
      },
      options: {
        arrowPosition: {
          boundaryOffset: {
            h: 20,
            v: -10
          },
          collision: "fit"
        }
      }
    }, {
      device: function() {
        return !hasWindow$1();
      },
      options: {
        animation: null
      }
    }];
  },
  _init: function() {
    this.callBase();
    this._renderArrow();
    this._timeouts = {};
    this.$element().addClass(POPOVER_CLASS);
    this.$wrapper().addClass(POPOVER_WRAPPER_CLASS);
  },
  _render: function() {
    this.callBase.apply(this, arguments);
    this._detachEvents(this.option("target"));
    this._attachEvents();
  },
  _detachEvents: function(target) {
    detachEvent(this, target, "show");
    detachEvent(this, target, "hide");
  },
  _attachEvents: function() {
    attachEvent(this, "show");
    attachEvent(this, "hide");
  },
  _renderArrow: function() {
    this._$arrow = $("<div>").addClass(POPOVER_ARROW_CLASS).prependTo(this.$overlayContent());
  },
  _documentDownHandler: function(e) {
    if (this._isOutsideClick(e)) {
      return this.callBase(e);
    }
    return true;
  },
  _isOutsideClick: function(e) {
    return !$(e.target).closest(this.option("target")).length;
  },
  _animate: function(animation2) {
    if (animation2 && animation2.to && typeof animation2.to === "object") {
      extend(animation2.to, {
        position: this._getContainerPosition()
      });
    }
    this.callBase.apply(this, arguments);
  },
  _stopAnimation: function() {
    this.callBase.apply(this, arguments);
  },
  _renderTitle: function() {
    this.$wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
    this.callBase();
  },
  _renderPosition: function() {
    this.callBase();
    this._renderOverlayPosition();
  },
  _renderOverlayBoundaryOffset: noop,
  _renderOverlayPosition: function() {
    this._resetOverlayPosition();
    this._updateContentSize();
    var contentPosition = this._getContainerPosition();
    var resultLocation = animationPosition.setup(this.$overlayContent(), contentPosition);
    var positionSide = this._getSideByLocation(resultLocation);
    this._togglePositionClass("dx-position-" + positionSide);
    this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
    var isArrowVisible = this._isHorizontalSide() || this._isVerticalSide();
    if (isArrowVisible) {
      this._renderArrowPosition(positionSide);
    }
  },
  _resetOverlayPosition: function() {
    this._setContentHeight(true);
    this._togglePositionClass("dx-position-" + this._positionSide);
    move(this.$overlayContent(), {
      left: 0,
      top: 0
    });
    this._$arrow.css({
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    });
  },
  _updateContentSize: function() {
    if (!this.$content()) {
      return;
    }
    var containerLocation = animationPosition.calculate(this.$overlayContent(), this._getContainerPosition());
    if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
      var newContainerWidth = this.$overlayContent().width() - containerLocation.h.oversize;
      this.$overlayContent().width(newContainerWidth);
    }
    if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
      var newOverlayContentHeight = this.$overlayContent().height() - containerLocation.v.oversize;
      var newPopupContentHeight = this.$content().height() - containerLocation.v.oversize;
      this.$overlayContent().height(newOverlayContentHeight);
      this.$content().height(newPopupContentHeight);
    }
  },
  _getContainerPosition: function() {
    var offset2 = pairToObject(this._position.offset || "");
    var hOffset = offset2.h;
    var vOffset = offset2.v;
    var isVerticalSide = this._isVerticalSide();
    var isHorizontalSide = this._isHorizontalSide();
    if (isVerticalSide || isHorizontalSide) {
      var isPopoverInside = this._isPopoverInside();
      var sign2 = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
      var arrowSize = isVerticalSide ? this._$arrow.height() : this._$arrow.width();
      var arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
      var arrowOffset = sign2 * (arrowSize - arrowSizeCorrection);
      isVerticalSide ? vOffset += arrowOffset : hOffset += arrowOffset;
    }
    return extend({}, this._position, {
      offset: hOffset + " " + vOffset
    });
  },
  _getContentBorderWidth: function(side) {
    var borderWidth = this.$overlayContent().css(SIDE_BORDER_WIDTH_STYLES[side]);
    return parseInt(borderWidth) || 0;
  },
  _getSideByLocation: function(location) {
    var isFlippedByVertical = location.v.flip;
    var isFlippedByHorizontal = location.h.flip;
    return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionSide] : this._positionSide;
  },
  _togglePositionClass: function(positionClass) {
    this.$wrapper().removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass);
  },
  _toggleFlippedClass: function(isFlippedHorizontal, isFlippedVertical) {
    this.$wrapper().toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical);
  },
  _renderArrowPosition: function(side) {
    var arrowRect = getBoundingRect(this._$arrow.get(0));
    var arrowFlip = -(this._isVerticalSide(side) ? arrowRect.height : arrowRect.width);
    this._$arrow.css(POSITION_FLIP_MAP[side], arrowFlip);
    var axis = this._isVerticalSide(side) ? "left" : "top";
    var sizeProperty = this._isVerticalSide(side) ? "width" : "height";
    var $target = $(this._position.of);
    var targetOffset = animationPosition.offset($target) || {
      top: 0,
      left: 0
    };
    var contentOffset = animationPosition.offset(this.$overlayContent());
    var arrowSize = arrowRect[sizeProperty];
    var contentLocation = contentOffset[axis];
    var contentSize = getBoundingRect(this.$overlayContent().get(0))[sizeProperty];
    var targetLocation = targetOffset[axis];
    var targetSize = $target.get(0).preventDefault ? 0 : getBoundingRect($target.get(0))[sizeProperty];
    var min = Math.max(contentLocation, targetLocation);
    var max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
    var arrowLocation;
    if (this.option("arrowPosition") === "start") {
      arrowLocation = min - contentLocation;
    } else if (this.option("arrowPosition") === "end") {
      arrowLocation = max - contentLocation - arrowSize;
    } else {
      arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2;
    }
    var borderWidth = this._getContentBorderWidth(side);
    var finalArrowLocation = fitIntoRange(arrowLocation - borderWidth + this.option("arrowOffset"), borderWidth, contentSize - arrowSize - 2 * borderWidth);
    this._$arrow.css(axis, finalArrowLocation);
  },
  _isPopoverInside: function() {
    var position2 = this._transformStringPosition(this.option("position"), POSITION_ALIASES);
    var my = animationPosition.setup.normalizeAlign(position2.my);
    var at = animationPosition.setup.normalizeAlign(position2.at);
    return my.h === at.h && my.v === at.v;
  },
  _setContentHeight: function(fullUpdate) {
    if (fullUpdate) {
      this.callBase();
    }
  },
  _renderWrapperPosition: function() {
    if (this.option("shading")) {
      this.$wrapper().css({
        top: 0,
        left: 0
      });
    }
  },
  _renderWrapperDimensions: function() {
    if (this.option("shading")) {
      this.$wrapper().css({
        width: "100%",
        height: "100%"
      });
    }
  },
  _normalizePosition: function() {
    var position2 = extend({}, this._transformStringPosition(this.option("position"), POSITION_ALIASES));
    if (!position2.of) {
      position2.of = this.option("target");
    }
    if (!position2.collision) {
      position2.collision = "flip";
    }
    if (!position2.boundaryOffset) {
      position2.boundaryOffset = this.option("boundaryOffset");
    }
    this._positionSide = this._getDisplaySide(position2);
    this._position = position2;
  },
  _getDisplaySide: function(position2) {
    var my = animationPosition.setup.normalizeAlign(position2.my);
    var at = animationPosition.setup.normalizeAlign(position2.at);
    var weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1;
    var horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]);
    var verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
    return horizontalWeight > verticalWeight ? at.h : at.v;
  },
  _isVerticalSide: function(side) {
    side = side || this._positionSide;
    return side === "top" || side === "bottom";
  },
  _isHorizontalSide: function(side) {
    side = side || this._positionSide;
    return side === "left" || side === "right";
  },
  _clearEventTimeout: function(name2) {
    clearTimeout(this._timeouts[name2]);
  },
  _clearEventsTimeouts: function() {
    this._clearEventTimeout("show");
    this._clearEventTimeout("hide");
  },
  _clean: function() {
    this._detachEvents(this.option("target"));
    this.callBase.apply(this, arguments);
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "boundaryOffset":
      case "arrowPosition":
      case "arrowOffset":
        this._renderGeometry();
        break;
      case "fullScreen":
        if (args.value) {
          this.option("fullScreen", false);
        }
        break;
      case "target":
        args.previousValue && this._detachEvents(args.previousValue);
        this.callBase(args);
        break;
      case "showEvent":
      case "hideEvent":
        var name2 = args.name.substring(0, 4);
        var event = getEventNameByOption(args.previousValue);
        this.hide();
        detachEvent(this, this.option("target"), name2, event);
        attachEvent(this, name2);
        break;
      case "visible":
        this._clearEventTimeout(args.value ? "show" : "hide");
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  },
  show: function(target) {
    if (target) {
      this.option("target", target);
    }
    return this.callBase();
  }
});
registerComponent("dxPopover", Popover);
var window$5 = getWindow();
var ACTION_SHEET_CLASS = "dx-actionsheet";
var ACTION_SHEET_CONTAINER_CLASS = "dx-actionsheet-container";
var ACTION_SHEET_POPUP_WRAPPER_CLASS = "dx-actionsheet-popup-wrapper";
var ACTION_SHEET_POPOVER_WRAPPER_CLASS = "dx-actionsheet-popover-wrapper";
var ACTION_SHEET_CANCEL_BUTTON_CLASS = "dx-actionsheet-cancel";
var ACTION_SHEET_ITEM_CLASS = "dx-actionsheet-item";
var ACTION_SHEET_ITEM_DATA_KEY = "dxActionSheetItemData";
var ACTION_SHEET_WITHOUT_TITLE_CLASS = "dx-actionsheet-without-title";
var ActionSheet = CollectionWidget$1.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      usePopover: false,
      target: null,
      title: "",
      showTitle: true,
      showCancelButton: true,
      cancelText: messageLocalization.format("Cancel"),
      onCancelClick: null,
      visible: false,
      noDataText: "",
      focusStateEnabled: false,
      selectionByClick: false
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: {
        platform: "ios",
        tablet: true
      },
      options: {
        usePopover: true
      }
    }]);
  },
  _initTemplates: function() {
    this.callBase();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(function($container, data2) {
        var button = new Button($("<div>"), extend({
          onClick: data2 && data2.click
        }, data2));
        $container.append(button.$element());
      }, ["disabled", "icon", "text", "type", "onClick", "click"], this.option("integrationOptions.watchMethod"))
    });
  },
  _itemContainer: function() {
    return this._$itemContainer;
  },
  _itemClass: function() {
    return ACTION_SHEET_ITEM_CLASS;
  },
  _itemDataKey: function() {
    return ACTION_SHEET_ITEM_DATA_KEY;
  },
  _toggleVisibility: noop,
  _renderDimensions: noop,
  _initMarkup: function() {
    this.callBase();
    this.$element().addClass(ACTION_SHEET_CLASS);
    this._createItemContainer();
  },
  _render: function() {
    this._renderPopup();
  },
  _createItemContainer: function() {
    this._$itemContainer = $("<div>").addClass(ACTION_SHEET_CONTAINER_CLASS);
    this._renderDisabled();
  },
  _renderDisabled: function() {
    this._$itemContainer.toggleClass("dx-state-disabled", this.option("disabled"));
  },
  _renderPopup: function() {
    this._$popup = $("<div>").appendTo(this.$element());
    this._isPopoverMode() ? this._createPopover() : this._createPopup();
    this._renderPopupTitle();
    this._mapPopupOption("visible");
  },
  _mapPopupOption: function(optionName) {
    this._popup && this._popup.option(optionName, this.option(optionName));
  },
  _isPopoverMode: function() {
    return this.option("usePopover") && this.option("target");
  },
  _renderPopupTitle: function() {
    this._mapPopupOption("showTitle");
    this._popup && this._popup.$wrapper().toggleClass(ACTION_SHEET_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
  },
  _clean: function() {
    if (this._$popup) {
      this._$popup.remove();
    }
    this.callBase();
  },
  _overlayConfig: function() {
    return {
      onInitialized: function(args) {
        this._popup = args.component;
      }.bind(this),
      disabled: false,
      showTitle: true,
      title: this.option("title"),
      deferRendering: !window$5.angular,
      onContentReady: this._popupContentReadyAction.bind(this),
      onHidden: this.hide.bind(this)
    };
  },
  _createPopover: function() {
    this._createComponent(this._$popup, Popover, extend(this._overlayConfig(), {
      width: this.option("width") || 200,
      height: this.option("height") || "auto",
      target: this.option("target")
    }));
    this._popup.$wrapper().addClass(ACTION_SHEET_POPOVER_WRAPPER_CLASS);
  },
  _createPopup: function() {
    this._createComponent(this._$popup, Popup, extend(this._overlayConfig(), {
      dragEnabled: false,
      width: this.option("width") || "100%",
      height: this.option("height") || "auto",
      showCloseButton: false,
      position: {
        my: "bottom",
        at: "bottom",
        of: window$5
      },
      animation: {
        show: {
          type: "slide",
          duration: 400,
          from: {
            position: {
              my: "top",
              at: "bottom",
              of: window$5
            }
          },
          to: {
            position: {
              my: "bottom",
              at: "bottom",
              of: window$5
            }
          }
        },
        hide: {
          type: "slide",
          duration: 400,
          from: {
            position: {
              my: "bottom",
              at: "bottom",
              of: window$5
            }
          },
          to: {
            position: {
              my: "top",
              at: "bottom",
              of: window$5
            }
          }
        }
      }
    }));
    this._popup.$wrapper().addClass(ACTION_SHEET_POPUP_WRAPPER_CLASS);
  },
  _popupContentReadyAction: function() {
    this._popup.$content().append(this._$itemContainer);
    this._attachClickEvent();
    this._attachHoldEvent();
    this._prepareContent();
    this._renderContent();
    this._renderCancelButton();
  },
  _renderCancelButton: function() {
    if (this._isPopoverMode()) {
      return;
    }
    if (this._$cancelButton) {
      this._$cancelButton.remove();
    }
    if (this.option("showCancelButton")) {
      var cancelClickAction = this._createActionByOption("onCancelClick") || noop;
      var that = this;
      this._$cancelButton = $("<div>").addClass(ACTION_SHEET_CANCEL_BUTTON_CLASS).appendTo(this._popup && this._popup.$content());
      this._createComponent(this._$cancelButton, Button, {
        disabled: false,
        text: this.option("cancelText"),
        onClick: function(e) {
          var hidingArgs = {
            event: e,
            cancel: false
          };
          cancelClickAction(hidingArgs);
          if (!hidingArgs.cancel) {
            that.hide();
          }
        },
        integrationOptions: {}
      });
    }
  },
  _attachItemClickEvent: noop,
  _itemClickHandler: function(e) {
    this.callBase(e);
    if (!$(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
      this.hide();
    }
  },
  _itemHoldHandler: function(e) {
    this.callBase(e);
    if (!$(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
      this.hide();
    }
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "width":
      case "height":
      case "visible":
      case "title":
        this._mapPopupOption(args.name);
        break;
      case "disabled":
        this._renderDisabled();
        break;
      case "showTitle":
        this._renderPopupTitle();
        break;
      case "showCancelButton":
      case "onCancelClick":
      case "cancelText":
        this._renderCancelButton();
        break;
      case "target":
      case "usePopover":
      case "items":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  toggle: function(showing) {
    var that = this;
    var d = new Deferred();
    that._popup.toggle(showing).done(function() {
      that.option("visible", showing);
      d.resolveWith(that);
    });
    return d.promise();
  },
  show: function() {
    return this.toggle(true);
  },
  hide: function() {
    return this.toggle(false);
  }
});
registerComponent("dxActionSheet", ActionSheet);
var LIST_EDIT_DECORATOR = "dxListEditDecorator";
var CLICK_EVENT_NAME$1 = addNamespace$1(CLICK_EVENT_NAME$2, LIST_EDIT_DECORATOR);
var ACTIVE_EVENT_NAME = addNamespace$1(ACTIVE_EVENT_NAME$2, LIST_EDIT_DECORATOR);
var SLIDE_MENU_CLASS = "dx-list-slide-menu";
var SLIDE_MENU_WRAPPER_CLASS = "dx-list-slide-menu-wrapper";
var SLIDE_MENU_CONTENT_CLASS = "dx-list-slide-menu-content";
var SLIDE_MENU_BUTTONS_CONTAINER_CLASS = "dx-list-slide-menu-buttons-container";
var SLIDE_MENU_BUTTONS_CLASS = "dx-list-slide-menu-buttons";
var SLIDE_MENU_BUTTON_CLASS = "dx-list-slide-menu-button";
var SLIDE_MENU_BUTTON_MENU_CLASS = "dx-list-slide-menu-button-menu";
var SLIDE_MENU_BUTTON_DELETE_CLASS = "dx-list-slide-menu-button-delete";
var SLIDE_MENU_ANIMATION_DURATION = 400;
var SLIDE_MENU_ANIMATION_EASING = "cubic-bezier(0.075, 0.82, 0.165, 1)";
register("menu", "slide", SwitchableEditDecorator.inherit({
  _shouldHandleSwipe: true,
  _init: function() {
    this.callBase.apply(this, arguments);
    this._$buttonsContainer = $("<div>").addClass(SLIDE_MENU_BUTTONS_CONTAINER_CLASS);
    eventsEngine.on(this._$buttonsContainer, ACTIVE_EVENT_NAME, noop);
    this._$buttons = $("<div>").addClass(SLIDE_MENU_BUTTONS_CLASS).appendTo(this._$buttonsContainer);
    this._renderMenu();
    this._renderDeleteButton();
  },
  _renderMenu: function() {
    if (!this._menuEnabled()) {
      return;
    }
    var menuItems = this._menuItems();
    if (menuItems.length === 1) {
      var menuItem = menuItems[0];
      this._renderMenuButton(menuItem.text, function(e) {
        e.stopPropagation();
        this._fireAction(menuItem);
      }.bind(this));
    } else {
      var $menu = $("<div>").addClass(SLIDE_MENU_CLASS);
      this._menu = this._list._createComponent($menu, ActionSheet, {
        showTitle: false,
        items: menuItems,
        onItemClick: function(args) {
          this._fireAction(args.itemData);
        }.bind(this),
        integrationOptions: {}
      });
      $menu.appendTo(this._list.$element());
      var $menuButton = this._renderMenuButton(messageLocalization.format("dxListEditDecorator-more"), function(e) {
        e.stopPropagation();
        this._menu.show();
      }.bind(this));
      this._menu.option("target", $menuButton);
    }
  },
  _renderMenuButton: function(text, action) {
    var $menuButton = $("<div>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_MENU_CLASS).text(text);
    this._$buttons.append($menuButton);
    eventsEngine.on($menuButton, CLICK_EVENT_NAME$1, action);
    return $menuButton;
  },
  _renderDeleteButton: function() {
    if (!this._deleteEnabled()) {
      return;
    }
    var $deleteButton = $("<div>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_DELETE_CLASS).text(isMaterial() ? "" : messageLocalization.format("dxListEditDecorator-delete"));
    eventsEngine.on($deleteButton, CLICK_EVENT_NAME$1, function(e) {
      e.stopPropagation();
      this._deleteItem();
    }.bind(this));
    this._$buttons.append($deleteButton);
  },
  _fireAction: function(menuItem) {
    this._fireMenuAction($(this._cachedNode), menuItem.action);
    this._cancelDeleteReadyItem();
  },
  modifyElement: function(config2) {
    this.callBase.apply(this, arguments);
    var $itemElement = config2.$itemElement;
    $itemElement.addClass(SLIDE_MENU_WRAPPER_CLASS);
    var $slideMenuContent = $("<div>").addClass(SLIDE_MENU_CONTENT_CLASS);
    $itemElement.wrapInner($slideMenuContent);
  },
  _getDeleteButtonContainer: function() {
    return this._$buttonsContainer;
  },
  handleClick: function(_2, e) {
    if ($(e.target).closest("." + SLIDE_MENU_CONTENT_CLASS).length) {
      return this.callBase.apply(this, arguments);
    }
    return false;
  },
  _swipeStartHandler: function($itemElement) {
    this._enablePositioning($itemElement);
    this._cacheItemData($itemElement);
    this._setPositions(this._getPositions(0));
  },
  _swipeUpdateHandler: function($itemElement, args) {
    var rtl = this._isRtlEnabled();
    var signCorrection = rtl ? -1 : 1;
    var isItemReadyToDelete = this._isReadyToDelete($itemElement);
    var moveJustStarted = this._getCurrentPositions().content === this._getStartPositions().content;
    if (moveJustStarted && !isItemReadyToDelete && args.offset * signCorrection > 0) {
      args.cancel = true;
      return;
    }
    var offset2 = this._cachedItemWidth * args.offset;
    var startOffset = isItemReadyToDelete ? -this._cachedButtonWidth * signCorrection : 0;
    var correctedOffset = (offset2 + startOffset) * signCorrection;
    var percent = correctedOffset < 0 ? Math.abs((offset2 + startOffset) / this._cachedButtonWidth) : 0;
    this._setPositions(this._getPositions(percent));
    return true;
  },
  _getStartPositions: function() {
    var rtl = this._isRtlEnabled();
    var signCorrection = rtl ? -1 : 1;
    return {
      content: 0,
      buttonsContainer: rtl ? -this._cachedButtonWidth : this._cachedItemWidth,
      buttons: -this._cachedButtonWidth * signCorrection
    };
  },
  _getPositions: function(percent) {
    var rtl = this._isRtlEnabled();
    var signCorrection = rtl ? -1 : 1;
    var startPositions = this._getStartPositions();
    return {
      content: startPositions.content - percent * this._cachedButtonWidth * signCorrection,
      buttonsContainer: startPositions.buttonsContainer - Math.min(percent, 1) * this._cachedButtonWidth * signCorrection,
      buttons: startPositions.buttons + Math.min(percent, 1) * this._cachedButtonWidth * signCorrection
    };
  },
  _getCurrentPositions: function() {
    return {
      content: locate(this._$cachedContent).left,
      buttonsContainer: locate(this._$buttonsContainer).left,
      buttons: locate(this._$buttons).left
    };
  },
  _setPositions: function(positions) {
    move(this._$cachedContent, {
      left: positions.content
    });
    move(this._$buttonsContainer, {
      left: positions.buttonsContainer
    });
    move(this._$buttons, {
      left: positions.buttons
    });
  },
  _cacheItemData: function($itemElement) {
    if ($itemElement[0] === this._cachedNode) {
      return;
    }
    this._$cachedContent = $itemElement.find("." + SLIDE_MENU_CONTENT_CLASS);
    this._cachedItemWidth = $itemElement.outerWidth();
    this._cachedButtonWidth = this._cachedButtonWidth || this._$buttons.outerWidth();
    this._$buttonsContainer.width(this._cachedButtonWidth);
    if (this._$cachedContent.length) {
      this._cachedNode = $itemElement[0];
    }
  },
  _minButtonContainerLeftOffset: function() {
    return this._cachedItemWidth - this._cachedButtonWidth;
  },
  _swipeEndHandler: function($itemElement, args) {
    this._cacheItemData($itemElement);
    var signCorrection = this._isRtlEnabled() ? 1 : -1;
    var offset2 = this._cachedItemWidth * args.offset;
    var endedAtReadyToDelete = !this._isReadyToDelete($itemElement) && offset2 * signCorrection > 0.2 * this._cachedButtonWidth;
    var readyToDelete = args.targetOffset === signCorrection && endedAtReadyToDelete;
    this._toggleDeleteReady($itemElement, readyToDelete);
    return true;
  },
  _enablePositioning: function($itemElement) {
    fx.stop(this._$cachedContent, true);
    this.callBase.apply(this, arguments);
    this._$buttonsContainer.appendTo($itemElement);
  },
  _disablePositioning: function() {
    this.callBase.apply(this, arguments);
    this._$buttonsContainer.detach();
  },
  _animatePrepareDeleteReady: function() {
    return this._animateToPositions(this._getPositions(1));
  },
  _animateForgetDeleteReady: function($itemElement) {
    this._cacheItemData($itemElement);
    return this._animateToPositions(this._getPositions(0));
  },
  _animateToPositions: function(positions) {
    var that = this;
    var currentPosition = this._getCurrentPositions();
    var durationTimePart = Math.min(Math.abs(currentPosition.content - positions.content) / this._cachedButtonWidth, 1);
    return fx.animate(this._$cachedContent, {
      from: currentPosition,
      to: positions,
      easing: SLIDE_MENU_ANIMATION_EASING,
      duration: SLIDE_MENU_ANIMATION_DURATION * durationTimePart,
      strategy: "frame",
      draw: function(positions2) {
        that._setPositions(positions2);
      }
    });
  },
  dispose: function() {
    if (this._menu) {
      this._menu.$element().remove();
    }
    if (this._$buttonsContainer) {
      this._$buttonsContainer.remove();
    }
    this.callBase.apply(this, arguments);
  }
}).include(EditDecoratorMenuHelperMixin));
register("delete", "swipe", EditDecorator.inherit({
  _shouldHandleSwipe: true,
  _renderItemPosition: function($itemElement, offset2, animate2) {
    var deferred = new Deferred();
    var itemOffset = offset2 * this._itemElementWidth;
    if (animate2) {
      fx.animate($itemElement, {
        to: {
          left: itemOffset
        },
        type: "slide",
        complete: function() {
          deferred.resolve($itemElement, offset2);
        }
      });
    } else {
      move($itemElement, {
        left: itemOffset
      });
      deferred.resolve();
    }
    return deferred.promise();
  },
  _swipeStartHandler: function($itemElement) {
    this._itemElementWidth = $itemElement.width();
    return true;
  },
  _swipeUpdateHandler: function($itemElement, args) {
    this._renderItemPosition($itemElement, args.offset);
    return true;
  },
  _swipeEndHandler: function($itemElement, args) {
    var offset2 = args.targetOffset;
    this._renderItemPosition($itemElement, offset2, true).done(function($itemElement2, offset3) {
      if (Math.abs(offset3)) {
        this._list.deleteItem($itemElement2).fail(function() {
          this._renderItemPosition($itemElement2, 0, true);
        }.bind(this));
      }
    }.bind(this));
    return true;
  }
}));
var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container";
var LIST_ITEM_BADGE_CLASS = "dx-list-item-badge";
var BADGE_CLASS = "dx-badge";
var LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container";
var LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
var ListItem = CollectionItem.inherit({
  _renderWatchers: function() {
    this.callBase();
    this._startWatcher("badge", this._renderBadge.bind(this));
    this._startWatcher("showChevron", this._renderShowChevron.bind(this));
  },
  _renderBadge: function(badge) {
    this._$element.children("." + LIST_ITEM_BADGE_CONTAINER_CLASS).remove();
    if (!badge) {
      return;
    }
    var $badge = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS).append($("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).text(badge));
    var $chevron = this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).first();
    $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element);
  },
  _renderShowChevron: function(showChevron) {
    this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).remove();
    if (!showChevron) {
      return;
    }
    var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS);
    var $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
    $chevronContainer.append($chevron).appendTo(this._$element);
  }
});
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS$2 = "dx-scrollview-pull-down-loading";
var SCROLLVIEW_PULLDOWN_READY_CLASS$1 = "dx-scrollview-pull-down-ready";
var SCROLLVIEW_PULLDOWN_IMAGE_CLASS$1 = "dx-scrollview-pull-down-image";
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS$2 = "dx-scrollview-pull-down-indicator";
var SCROLLVIEW_PULLDOWN_TEXT_CLASS$1 = "dx-scrollview-pull-down-text";
var SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS$1 = "dx-scrollview-pull-down-text-visible";
var STATE_RELEASED$2 = 0;
var STATE_READY$2 = 1;
var STATE_REFRESHING$2 = 2;
var STATE_LOADING$1 = 3;
var PULLDOWN_RELEASE_TIME = 400;
var PullDownNativeScrollViewStrategy = NativeStrategy.inherit({
  _init: function(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._$refreshingText = scrollView._$refreshingText;
    this._$scrollViewContent = $(scrollView.content());
    this._initCallbacks();
  },
  _initCallbacks: function() {
    this.pullDownCallbacks = Callbacks();
    this.releaseCallbacks = Callbacks();
    this.reachBottomCallbacks = Callbacks();
  },
  render: function() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown: function() {
    var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS$1);
    var $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS$2);
    var $loadIndicator = new LoadIndicator($("<div>")).$element();
    var $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS$1);
    this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  _releaseState: function() {
    this._state = STATE_RELEASED$2;
    this._refreshPullDownText();
  },
  _refreshPullDownText: function() {
    var that = this;
    var pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: STATE_RELEASED$2
    }, {
      element: this._$pulledDownText,
      visibleState: STATE_READY$2
    }, {
      element: this._$refreshingText,
      visibleState: STATE_REFRESHING$2
    }];
    each(pullDownTextItems, function(_2, item) {
      var action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS$1);
    });
  },
  update: function() {
    this.callBase();
    this._setTopPocketOffset();
  },
  _updateDimensions: function() {
    this.callBase();
    this._topPocketSize = this._$topPocket.height();
    this._bottomPocketSize = this._$bottomPocket.height();
    if (coreBrowserUtils.msie) {
      this._scrollOffset = Math.round(100 * (this._$container.height() - this._$content.height())) / 100;
    } else {
      this._scrollOffset = this._$container.height() - this._$content.height();
    }
  },
  _allowedDirections: function() {
    var allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  _setTopPocketOffset: function() {
    this._$topPocket.css({
      top: -this._topPocketSize
    });
  },
  handleEnd: function() {
    this.callBase();
    this._complete();
  },
  handleStop: function() {
    this.callBase();
    this._complete();
  },
  _complete: function() {
    if (this._state === STATE_READY$2) {
      this._setPullDownOffset(this._topPocketSize);
      clearTimeout(this._pullDownRefreshTimeout);
      this._pullDownRefreshTimeout = setTimeout(function() {
        this._pullDownRefreshing();
      }.bind(this), 400);
    }
  },
  _setPullDownOffset: function(offset2) {
    move(this._$topPocket, {
      top: offset2
    });
    move(this._$scrollViewContent, {
      top: offset2
    });
  },
  handleScroll: function(e) {
    this.callBase(e);
    if (this._state === STATE_REFRESHING$2) {
      return;
    }
    var currentLocation = this.location().top;
    var scrollDelta = (this._location || 0) - currentLocation;
    this._location = currentLocation;
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isPullDown: function() {
    return this._pullDownEnabled && this._location >= this._topPocketSize;
  },
  _isReachBottom: function() {
    return this._reachBottomEnabled && this._location - (this._scrollOffset + this._bottomPocketSize) <= 0.5;
  },
  _reachBottom: function() {
    if (this._state === STATE_LOADING$1) {
      return;
    }
    this._state = STATE_LOADING$1;
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady: function() {
    if (this._state === STATE_READY$2) {
      return;
    }
    this._state = STATE_READY$2;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS$1);
    this._refreshPullDownText();
  },
  _stateReleased: function() {
    if (this._state === STATE_RELEASED$2) {
      return;
    }
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS$2).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS$1);
    this._releaseState();
  },
  _pullDownRefreshing: function() {
    if (this._state === STATE_REFRESHING$2) {
      return;
    }
    this._state = STATE_REFRESHING$2;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS$2).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS$1);
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  pullDownEnable: function(enabled) {
    if (enabled) {
      this._updateDimensions();
      this._setTopPocketOffset();
    }
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable: function(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease: function() {
    this._state = STATE_READY$2;
  },
  release: function() {
    var deferred = new Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    if (this._state === STATE_LOADING$1) {
      this._state = STATE_RELEASED$2;
    }
    this._releaseTimeout = setTimeout(function() {
      this._setPullDownOffset(0);
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }.bind(this), PULLDOWN_RELEASE_TIME);
    return deferred.promise();
  },
  dispose: function() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS = "dx-scrollview-pull-down-loading";
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS$1 = "dx-scrollview-pull-down-indicator";
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS$1 = "dx-scrollview-pull-down-refreshing";
var PULLDOWN_ICON_CLASS = "dx-icon-pulldown";
var STATE_RELEASED$1 = 0;
var STATE_READY$1 = 1;
var STATE_REFRESHING$1 = 2;
var STATE_TOUCHED = 4;
var STATE_PULLED = 5;
var SwipeDownNativeScrollViewStrategy = NativeStrategy.inherit({
  _init: function(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$scrollViewContent = scrollView.content();
    this._initCallbacks();
    this._location = 0;
  },
  _initCallbacks: function() {
    this.pullDownCallbacks = Callbacks();
    this.releaseCallbacks = Callbacks();
    this.reachBottomCallbacks = Callbacks();
  },
  render: function() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown: function() {
    var $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS$1);
    var $loadIndicator = new LoadIndicator($("<div>")).$element();
    this._$icon = $("<div>").addClass(PULLDOWN_ICON_CLASS);
    this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator));
  },
  _releaseState: function() {
    this._state = STATE_RELEASED$1;
    this._releasePullDown();
    this._updateDimensions();
  },
  _releasePullDown: function() {
    this._$pullDown.css({
      opacity: 0
    });
  },
  _updateDimensions: function() {
    this.callBase();
    this._topPocketSize = this._$topPocket.height();
    this._bottomPocketSize = this._$bottomPocket.height();
    this._scrollOffset = this._$container.height() - this._$content.height();
  },
  _allowedDirections: function() {
    var allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  handleInit: function(e) {
    this.callBase(e);
    if (this._state === STATE_RELEASED$1 && this._location === 0) {
      this._startClientY = eventData(e.originalEvent).y;
      this._state = STATE_TOUCHED;
    }
  },
  handleMove: function(e) {
    this.callBase(e);
    this._deltaY = eventData(e.originalEvent).y - this._startClientY;
    if (this._state === STATE_TOUCHED) {
      if (this._pullDownEnabled && this._deltaY > 0) {
        this._state = STATE_PULLED;
      } else {
        this._complete();
      }
    }
    if (this._state === STATE_PULLED) {
      e.preventDefault();
      this._movePullDown();
    }
  },
  _movePullDown: function() {
    var pullDownHeight = this._getPullDownHeight();
    var top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition());
    var angle = 180 * top / pullDownHeight / 3;
    this._$pullDown.css({
      opacity: 1
    }).toggleClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS$1, top < pullDownHeight);
    move(this._$pullDown, {
      top
    });
    this._$icon.css({
      transform: "rotate(" + angle + "deg)"
    });
  },
  _isPullDown: function() {
    return this._pullDownEnabled && this._state === STATE_PULLED && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
  },
  _getPullDownHeight: function() {
    return Math.round(0.05 * this._$element.outerHeight());
  },
  _getPullDownStartPosition: function() {
    return -Math.round(1.5 * this._$pullDown.outerHeight());
  },
  handleEnd: function() {
    if (this._isPullDown()) {
      this._pullDownRefreshing();
    }
    this._complete();
  },
  handleStop: function() {
    this._complete();
  },
  _complete: function() {
    if (this._state === STATE_TOUCHED || this._state === STATE_PULLED) {
      this._releaseState();
    }
  },
  handleScroll: function(e) {
    this.callBase(e);
    if (this._state === STATE_REFRESHING$1) {
      return;
    }
    var currentLocation = this.location().top;
    var scrollDelta = this._location - currentLocation;
    this._location = currentLocation;
    if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isReachBottom: function() {
    return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize;
  },
  _reachBottom: function() {
    this.reachBottomCallbacks.fire();
  },
  _stateReleased: function() {
    if (this._state === STATE_RELEASED$1) {
      return;
    }
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
    this._releaseState();
  },
  _pullDownRefreshing: function() {
    this._state = STATE_REFRESHING$1;
    this._pullDownRefreshHandler();
  },
  _pullDownRefreshHandler: function() {
    this._refreshPullDown();
    this.pullDownCallbacks.fire();
  },
  _refreshPullDown: function() {
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
    move(this._$pullDown, {
      top: this._getPullDownHeight()
    });
  },
  pullDownEnable: function(enabled) {
    this._$topPocket.toggle(enabled);
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable: function(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease: function() {
    this._state = STATE_READY$1;
  },
  release: function() {
    var deferred = new Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    this._releaseTimeout = setTimeout(function() {
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }.bind(this), 800);
    return deferred.promise();
  },
  dispose: function() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var math = Math;
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading";
var SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready";
var SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image";
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator";
var SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text";
var SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = "dx-scrollview-pull-down-text-visible";
var STATE_RELEASED = 0;
var STATE_READY = 1;
var STATE_REFRESHING = 2;
var STATE_LOADING = 3;
var ScrollViewScroller = Scroller.inherit({
  ctor: function() {
    this._topPocketSize = 0;
    this.callBase.apply(this, arguments);
    this._initCallbacks();
    this._releaseState();
  },
  _releaseState: function() {
    this._state = STATE_RELEASED;
    this._refreshPullDownText();
  },
  _refreshPullDownText: function() {
    var that = this;
    var pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: STATE_RELEASED
    }, {
      element: this._$pulledDownText,
      visibleState: STATE_READY
    }, {
      element: this._$refreshingText,
      visibleState: STATE_REFRESHING
    }];
    each(pullDownTextItems, function(_2, item) {
      var action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS);
    });
  },
  _initCallbacks: function() {
    this.pullDownCallbacks = Callbacks();
    this.releaseCallbacks = Callbacks();
    this.reachBottomCallbacks = Callbacks();
  },
  _updateBounds: function() {
    var considerPockets = this._direction !== "horizontal";
    this._topPocketSize = considerPockets ? Math.round(this._$topPocket[this._dimension]()) : 0;
    this._bottomPocketSize = considerPockets ? Math.round(this._$bottomPocket[this._dimension]()) : 0;
    this.callBase();
    this._bottomBound = this._minOffset + this._bottomPocketSize;
  },
  _updateScrollbar: function() {
    this._scrollbar.option({
      containerSize: this._containerSize(),
      contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
      scaleRatio: this._getScaleRatio()
    });
  },
  _moveContent: function() {
    this.callBase();
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (this._isReachBottom()) {
      this._reachBottomReady();
    } else if (this._state !== STATE_RELEASED) {
      this._stateReleased();
    }
  },
  _moveScrollbar: function() {
    this._scrollbar.moveTo(this._topPocketSize + this._location);
  },
  _isPullDown: function() {
    return this._pullDownEnabled && this._location >= 0;
  },
  _isReachBottom: function() {
    return this._reachBottomEnabled && this._location - this._bottomBound <= 0.5;
  },
  _scrollComplete: function() {
    if (this._inBounds() && this._state === STATE_READY) {
      this._pullDownRefreshing();
    } else if (this._inBounds() && this._state === STATE_LOADING) {
      this._reachBottomLoading();
    } else {
      this.callBase();
    }
  },
  _reachBottomReady: function() {
    if (this._state === STATE_LOADING) {
      return;
    }
    this._state = STATE_LOADING;
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset: function() {
    return -this._topPocketSize;
  },
  _getMinOffset: function() {
    return math.min(this.callBase(), -this._topPocketSize);
  },
  _reachBottomLoading: function() {
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady: function() {
    if (this._state === STATE_READY) {
      return;
    }
    this._state = STATE_READY;
    this._maxOffset = 0;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
  },
  _stateReleased: function() {
    if (this._state === STATE_RELEASED) {
      return;
    }
    this._releaseState();
    this._updateBounds();
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this.releaseCallbacks.fire();
  },
  _pullDownRefreshing: function() {
    if (this._state === STATE_REFRESHING) {
      return;
    }
    this._state = STATE_REFRESHING;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  _releaseHandler: function() {
    if (this._state === STATE_RELEASED) {
      this._moveToBounds();
    }
    this._update();
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this._releaseTask = executeAsync(this._release.bind(this));
    return this._releaseTask.promise;
  },
  _release: function() {
    this._stateReleased();
    this._scrollComplete();
  },
  _reachBottomEnablingHandler: function(enabled) {
    if (this._reachBottomEnabled === enabled) {
      return;
    }
    this._reachBottomEnabled = enabled;
    this._updateBounds();
  },
  _pullDownEnablingHandler: function(enabled) {
    if (this._pullDownEnabled === enabled) {
      return;
    }
    this._pullDownEnabled = enabled;
    this._considerTopPocketChange();
    this._updateHandler();
  },
  _considerTopPocketChange: function() {
    this._location -= this._$topPocket.height() || -this._topPocketSize;
    this._maxOffset = 0;
    this._move();
  },
  _pendingReleaseHandler: function() {
    this._state = STATE_READY;
  },
  dispose: function() {
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this.callBase();
  }
});
var SimulatedScrollViewStrategy = SimulatedStrategy.inherit({
  _init: function(scrollView) {
    this.callBase(scrollView);
    this._$pullDown = scrollView._$pullDown;
    this._$topPocket = scrollView._$topPocket;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._initCallbacks();
  },
  _initCallbacks: function() {
    this.pullDownCallbacks = Callbacks();
    this.releaseCallbacks = Callbacks();
    this.reachBottomCallbacks = Callbacks();
  },
  render: function() {
    this._renderPullDown();
    this.callBase();
  },
  _renderPullDown: function() {
    var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS);
    var $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
    var $loadIndicator = new LoadIndicator($("<div>")).$element();
    var $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
    this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  pullDownEnable: function(enabled) {
    this._eventHandler("pullDownEnabling", enabled);
  },
  reachBottomEnable: function(enabled) {
    this._eventHandler("reachBottomEnabling", enabled);
  },
  _createScroller: function(direction) {
    var that = this;
    var scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
    scroller.pullDownCallbacks.add(function() {
      that.pullDownCallbacks.fire();
    });
    scroller.releaseCallbacks.add(function() {
      that.releaseCallbacks.fire();
    });
    scroller.reachBottomCallbacks.add(function() {
      that.reachBottomCallbacks.fire();
    });
  },
  _scrollerOptions: function(direction) {
    return extend(this.callBase(direction), {
      $topPocket: this._$topPocket,
      $bottomPocket: this._$bottomPocket,
      $pullDown: this._$pullDown,
      $pullDownText: this._$pullDownText,
      $pullingDownText: this._$pullingDownText,
      $pulledDownText: this._$pulledDownText,
      $refreshingText: this._$refreshingText
    });
  },
  pendingRelease: function() {
    this._eventHandler("pendingRelease");
  },
  release: function() {
    return this._eventHandler("release").done(this._updateAction);
  },
  location: function() {
    var location = this.callBase();
    location.top += this._$topPocket.height();
    return location;
  },
  dispose: function() {
    each(this._scrollers, function() {
      this.dispose();
    });
    this.callBase();
  }
});
var SCROLLVIEW_CLASS = "dx-scrollview";
var SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CLASS + "-content";
var SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + "-top-pocket";
var SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + "-bottom-pocket";
var SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + "-pull-down";
var SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_CLASS + "-scrollbottom";
var SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-indicator";
var SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-text";
var SCROLLVIEW_LOADPANEL = SCROLLVIEW_CLASS + "-loadpanel";
var refreshStrategies = {
  pullDown: PullDownNativeScrollViewStrategy,
  swipeDown: SwipeDownNativeScrollViewStrategy,
  simulated: SimulatedScrollViewStrategy
};
var isServerSide = !hasWindow$1();
var scrollViewServerConfig = {
  finishLoading: noop,
  release: noop,
  refresh: noop,
  _optionChanged: function(args) {
    if (args.name !== "onUpdated") {
      return this.callBase.apply(this, arguments);
    }
  }
};
var ScrollView = Scrollable.inherit(isServerSide ? scrollViewServerConfig : {
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      pullingDownText: messageLocalization.format("dxScrollView-pullingDownText"),
      pulledDownText: messageLocalization.format("dxScrollView-pulledDownText"),
      refreshingText: messageLocalization.format("dxScrollView-refreshingText"),
      reachBottomText: messageLocalization.format("dxScrollView-reachBottomText"),
      onPullDown: null,
      onReachBottom: null,
      refreshStrategy: "pullDown"
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function() {
        var realDevice2 = devices.real();
        return realDevice2.platform === "android";
      },
      options: {
        refreshStrategy: "swipeDown"
      }
    }, {
      device: function() {
        return isMaterial();
      },
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        reachBottomText: ""
      }
    }]);
  },
  _init: function() {
    this.callBase();
    this._loadingIndicatorEnabled = true;
  },
  _initScrollableMarkup: function() {
    this.callBase();
    this.$element().addClass(SCROLLVIEW_CLASS);
    this._initContent();
    this._initTopPocket();
    this._initBottomPocket();
    this._initLoadPanel();
  },
  _initContent: function() {
    var $content = $("<div>").addClass(SCROLLVIEW_CONTENT_CLASS);
    this._$content.wrapInner($content);
  },
  _initTopPocket: function() {
    var $topPocket = this._$topPocket = $("<div>").addClass(SCROLLVIEW_TOP_POCKET_CLASS);
    var $pullDown = this._$pullDown = $("<div>").addClass(SCROLLVIEW_PULLDOWN_CLASS);
    $topPocket.append($pullDown);
    this._$content.prepend($topPocket);
  },
  _initBottomPocket: function() {
    var $bottomPocket = this._$bottomPocket = $("<div>").addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS);
    var $reachBottom = this._$reachBottom = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_CLASS);
    var $loadContainer = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS);
    var $loadIndicator = new LoadIndicator($("<div>")).$element();
    var $text = this._$reachBottomText = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
    this._updateReachBottomText();
    $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
    $bottomPocket.append($reachBottom);
    this._$content.append($bottomPocket);
  },
  _initLoadPanel: function() {
    var $loadPanelElement = $("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
    var loadPanelOptions = {
      shading: false,
      delay: 400,
      message: this.option("refreshingText"),
      position: {
        of: this.$element()
      }
    };
    this._loadPanel = this._createComponent($loadPanelElement, LoadPanel, loadPanelOptions);
  },
  _updateReachBottomText: function() {
    this._$reachBottomText.text(this.option("reachBottomText"));
  },
  _createStrategy: function() {
    var strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
    var strategyClass = refreshStrategies[strategyName];
    this._strategy = new strategyClass(this);
    this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
    this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
    this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
  },
  _createActions: function() {
    this.callBase();
    this._pullDownAction = this._createActionByOption("onPullDown");
    this._reachBottomAction = this._createActionByOption("onReachBottom");
    this._tryRefreshPocketState();
  },
  _tryRefreshPocketState: function() {
    this._pullDownEnable(this.hasActionSubscription("onPullDown"));
    this._reachBottomEnable(this.hasActionSubscription("onReachBottom"));
  },
  on: function(eventName) {
    var result = this.callBase.apply(this, arguments);
    if (eventName === "pullDown" || eventName === "reachBottom") {
      this._tryRefreshPocketState();
    }
    return result;
  },
  _pullDownEnable: function(enabled) {
    if (arguments.length === 0) {
      return this._pullDownEnabled;
    }
    if (this._$pullDown && this._strategy) {
      this._$pullDown.toggle(enabled);
      this._strategy.pullDownEnable(enabled);
      this._pullDownEnabled = enabled;
    }
  },
  _reachBottomEnable: function(enabled) {
    if (arguments.length === 0) {
      return this._reachBottomEnabled;
    }
    if (this._$reachBottom && this._strategy) {
      this._$reachBottom.toggle(enabled);
      this._strategy.reachBottomEnable(enabled);
      this._reachBottomEnabled = enabled;
    }
  },
  _pullDownHandler: function() {
    this._loadingIndicator(false);
    this._pullDownLoading();
  },
  _loadingIndicator: function(value2) {
    if (arguments.length < 1) {
      return this._loadingIndicatorEnabled;
    }
    this._loadingIndicatorEnabled = value2;
  },
  _pullDownLoading: function() {
    this.startLoading();
    this._pullDownAction();
  },
  _reachBottomHandler: function() {
    this._loadingIndicator(false);
    this._reachBottomLoading();
  },
  _reachBottomLoading: function() {
    this.startLoading();
    this._reachBottomAction();
  },
  _releaseHandler: function() {
    this.finishLoading();
    this._loadingIndicator(true);
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "onPullDown":
      case "onReachBottom":
        this._createActions();
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "refreshStrategy":
        this._invalidate();
        break;
      case "reachBottomText":
        this._updateReachBottomText();
        break;
      default:
        this.callBase(args);
    }
  },
  content: function() {
    return getPublicElement(this._$content.children().eq(1));
  },
  release: function(preventReachBottom) {
    if (preventReachBottom !== void 0) {
      this.toggleLoading(!preventReachBottom);
    }
    return this._strategy.release();
  },
  toggleLoading: function(showOrHide) {
    this._reachBottomEnable(showOrHide);
  },
  isFull: function() {
    return $(this.content()).height() > this._$container.height();
  },
  refresh: function() {
    if (!this.hasActionSubscription("onPullDown")) {
      return;
    }
    this._strategy.pendingRelease();
    this._pullDownLoading();
  },
  startLoading: function() {
    if (this._loadingIndicator() && this.$element().is(":visible")) {
      this._loadPanel.show();
    }
    this._lock();
  },
  finishLoading: function() {
    this._loadPanel.hide();
    this._unlock();
  },
  _dispose: function() {
    this._strategy.dispose();
    this.callBase();
    if (this._loadPanel) {
      this._loadPanel.$element().remove();
    }
  }
});
registerComponent("dxScrollView", ScrollView);
var PRIVATE_KEY_FIELD = "__dx_key__";
var CollectionWidget = CollectionWidget$1.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      repaintChangesOnly: false
    });
  },
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._customizeStoreLoadOptions = (e) => {
      var dataSource = this._dataSource;
      if (dataSource && !dataSource.isLoaded()) {
        this._correctionIndex = 0;
      }
      if (this._correctionIndex && e.storeLoadOptions) {
        e.storeLoadOptions.skip += this._correctionIndex;
      }
    }, this._dataSource && this._dataSource.on("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
  },
  reload: function() {
    this._correctionIndex = 0;
  },
  _init: function() {
    this.callBase();
    this._refreshItemsCache();
    this._correctionIndex = 0;
  },
  _findItemElementByKey: function(key) {
    var result = $();
    var keyExpr = this.key();
    this.itemElements().each((_2, item) => {
      var $item = $(item);
      var itemData = this._getItemData($item);
      if (keyExpr ? keysEqual(keyExpr, this.keyOf(itemData), key) : this._isItemEquals(itemData, key)) {
        result = $item;
        return false;
      }
    });
    return result;
  },
  _dataSourceChangedHandler: function(newItems, e) {
    if (e !== null && e !== void 0 && e.changes) {
      this._modifyByChanges(e.changes);
    } else {
      this.callBase(newItems, e);
      this._refreshItemsCache();
    }
  },
  _isItemEquals: function(item1, item2) {
    if (item1 && item1[PRIVATE_KEY_FIELD]) {
      item1 = item1.data;
    }
    try {
      return JSON.stringify(item1) === JSON.stringify(item2);
    } catch (e) {
      return item1 === item2;
    }
  },
  _isItemStrictEquals: function(item1, item2) {
    return this._isItemEquals(item1, item2);
  },
  _shouldAddNewGroup: function(changes, items) {
    var result = false;
    if (this.option("grouped")) {
      each(changes, (i, change) => {
        if (change.type === "insert") {
          result = true;
          each(items, (_2, item) => {
            if (change.data.key === item.key) {
              result = false;
              return false;
            }
          });
        }
      });
    }
    return result;
  },
  _partialRefresh: function() {
    if (this.option("repaintChangesOnly")) {
      var result = findChanges(this._itemsCache, this._editStrategy.itemsGetter(), (data2) => {
        if (data2 && data2[PRIVATE_KEY_FIELD] !== void 0) {
          return data2[PRIVATE_KEY_FIELD];
        }
        return this.keyOf(data2);
      }, this._isItemStrictEquals.bind(this));
      if (result && this._itemsCache.length && !this._shouldAddNewGroup(result, this._itemsCache)) {
        this._modifyByChanges(result, true);
        this._renderEmptyMessage();
        return true;
      } else {
        this._refreshItemsCache();
      }
    }
    return false;
  },
  _refreshItemsCache: function() {
    if (this.option("repaintChangesOnly")) {
      var items = this._editStrategy.itemsGetter();
      try {
        this._itemsCache = extend(true, [], items);
        if (!this.key()) {
          this._itemsCache = this._itemsCache.map((itemCache, index2) => ({
            [PRIVATE_KEY_FIELD]: items[index2],
            data: itemCache
          }));
        }
      } catch (e) {
        this._itemsCache = extend([], items);
      }
    }
  },
  _dispose: function() {
    this._dataSource && this._dataSource.off("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
    this.callBase();
  },
  _updateByChange: function(keyInfo, items, change, isPartialRefresh) {
    if (isPartialRefresh) {
      this._renderItem(change.index, change.data, null, this._findItemElementByKey(change.key));
    } else {
      var changedItem = items[indexByKey(keyInfo, items, change.key)];
      if (changedItem) {
        update(keyInfo, items, change.key, change.data).done(() => {
          this._renderItem(items.indexOf(changedItem), changedItem, null, this._findItemElementByKey(change.key));
        });
      }
    }
  },
  _insertByChange: function(keyInfo, items, change, isPartialRefresh) {
    when(isPartialRefresh || insert(keyInfo, items, change.data, change.index)).done(() => {
      var _change$index;
      this._beforeItemElementInserted(change);
      var $itemContainer = this._getItemContainer(change.data);
      this._renderItem((_change$index = change.index) !== null && _change$index !== void 0 ? _change$index : items.length, change.data, $itemContainer);
      this._afterItemElementInserted();
      this._correctionIndex++;
    });
  },
  _getItemContainer: function(changeData) {
    return this._itemContainer();
  },
  _updateSelectionAfterRemoveByChange: function(removeIndex) {
    var selectedIndex = this.option("selectedIndex");
    if (selectedIndex > removeIndex) {
      this.option("selectedIndex", selectedIndex - 1);
    } else if (selectedIndex === removeIndex && this.option("selectedItems").length === 1) {
      this.option("selectedItems", []);
    } else {
      this._normalizeSelectedItems();
    }
  },
  _beforeItemElementInserted: function(change) {
    var selectedIndex = this.option("selectedIndex");
    if (change.index <= selectedIndex) {
      this.option("selectedIndex", selectedIndex + 1);
    }
  },
  _afterItemElementInserted: noop,
  _removeByChange: function(keyInfo, items, change, isPartialRefresh) {
    var index2 = isPartialRefresh ? change.index : indexByKey(keyInfo, items, change.key);
    var removedItem = isPartialRefresh ? change.oldItem : items[index2];
    if (removedItem) {
      var $removedItemElement = this._findItemElementByKey(change.key);
      var deletedActionArgs = this._extendActionArgs($removedItemElement);
      this._waitDeletingPrepare($removedItemElement).done(() => {
        if (isPartialRefresh) {
          this._updateIndicesAfterIndex(index2 - 1);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
          this._updateSelectionAfterRemoveByChange(index2);
        } else {
          this._deleteItemElementByIndex(index2);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
        }
      });
      this._correctionIndex--;
    }
  },
  _modifyByChanges: function(changes, isPartialRefresh) {
    var items = this._editStrategy.itemsGetter();
    var keyInfo = {
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this)
    };
    var dataSource = this._dataSource;
    var paginate = dataSource && dataSource.paginate();
    var group = dataSource && dataSource.group();
    if (paginate || group) {
      changes = changes.filter((item) => item.type !== "insert" || item.index !== void 0);
    }
    changes.forEach((change) => this["_".concat(change.type, "ByChange")](keyInfo, items, change, isPartialRefresh));
    this._renderedItemsCount = items.length;
    this._refreshItemsCache();
    this._fireContentReadyAction();
  },
  _appendItemToContainer: function($container, $itemFrame, index2) {
    var nextSiblingElement = $container.children(this._itemSelector()).get(index2);
    domAdapter.insertElement($container.get(0), $itemFrame.get(0), nextSiblingElement);
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "items":
        var isItemsUpdated = this._partialRefresh(args.value);
        if (!isItemsUpdated) {
          this.callBase(args);
        }
        break;
      case "dataSource":
        if (!this.option("repaintChangesOnly") || !args.value) {
          this.option("items", []);
        }
        this.callBase(args);
        break;
      case "repaintChangesOnly":
        break;
      default:
        this.callBase(args);
    }
  }
});
var isCorrectStructure = (data2) => Array.isArray(data2) && data2.every((item) => {
  var hasTwoFields = Object.keys(item).length === 2;
  var hasCorrectFields = "key" in item && "items" in item;
  return hasTwoFields && hasCorrectFields && Array.isArray(item.items);
});
var DataConverterMixin = {
  _getSpecificDataSourceOption: function() {
    var dataSource = this.option("dataSource");
    var hasSimpleItems = false;
    var data2 = {};
    if (this._getGroupedOption() && isCorrectStructure(dataSource)) {
      data2 = dataSource.reduce((accumulator, item) => {
        var items = item.items.map((innerItem) => {
          if (!isObject$1(innerItem)) {
            innerItem = {
              text: innerItem
            };
            hasSimpleItems = true;
          }
          if (!("key" in innerItem)) {
            innerItem.key = item.key;
          }
          return innerItem;
        });
        return accumulator.concat(items);
      }, []);
      dataSource = {
        store: {
          type: "array",
          data: data2
        },
        group: {
          selector: "key",
          keepInitialKeyOrder: true
        }
      };
      if (hasSimpleItems) {
        dataSource.searchExpr = "text";
      }
    }
    return dataSource;
  }
};
var LIST_CLASS = "dx-list";
var LIST_ITEM_CLASS = "dx-list-item";
var LIST_ITEM_SELECTOR = "." + LIST_ITEM_CLASS;
var LIST_ITEM_ICON_CONTAINER_CLASS = "dx-list-item-icon-container";
var LIST_ITEM_ICON_CLASS = "dx-list-item-icon";
var LIST_GROUP_CLASS = "dx-list-group";
var LIST_GROUP_HEADER_CLASS = "dx-list-group-header";
var LIST_GROUP_BODY_CLASS = "dx-list-group-body";
var LIST_COLLAPSIBLE_GROUPS_CLASS = "dx-list-collapsible-groups";
var LIST_GROUP_COLLAPSED_CLASS = "dx-list-group-collapsed";
var LIST_GROUP_HEADER_INDICATOR_CLASS = "dx-list-group-header-indicator";
var LIST_HAS_NEXT_CLASS = "dx-has-next";
var LIST_NEXT_BUTTON_CLASS = "dx-list-next-button";
var WRAP_ITEM_TEXT_CLASS = "dx-wrap-item-text";
var SELECT_ALL_ITEM_SELECTOR = ".dx-list-select-all";
var LIST_ITEM_DATA_KEY = "dxListItemData";
var LIST_FEEDBACK_SHOW_TIMEOUT = 70;
var groupItemsGetter = compileGetter("items");
var ListBase = CollectionWidget.inherit({
  _activeStateUnit: [LIST_ITEM_SELECTOR, SELECT_ALL_ITEM_SELECTOR].join(","),
  _supportedKeys: function() {
    var that = this;
    var moveFocusPerPage = function(direction) {
      var $item = getEdgeVisibleItem(direction);
      var isFocusedItem = $item.is(that.option("focusedElement"));
      if (isFocusedItem) {
        !function($item2, direction2) {
          var resultPosition = $item2.position().top;
          if (direction2 === "prev") {
            resultPosition = $item2.position().top - that.$element().height() + $item2.outerHeight();
          }
          that.scrollTo(resultPosition);
        }($item, direction);
        $item = getEdgeVisibleItem(direction);
      }
      that.option("focusedElement", getPublicElement($item));
      that.scrollToItem($item);
    };
    function getEdgeVisibleItem(direction) {
      var scrollTop = that.scrollTop();
      var containerHeight = that.$element().height();
      var $item = $(that.option("focusedElement"));
      var isItemVisible = true;
      if (!$item.length) {
        return $();
      }
      while (isItemVisible) {
        var $nextItem = $item[direction]();
        if (!$nextItem.length) {
          break;
        }
        var nextItemLocation = $nextItem.position().top + $nextItem.outerHeight() / 2;
        isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
        if (isItemVisible) {
          $item = $nextItem;
        }
      }
      return $item;
    }
    return extend(this.callBase(), {
      leftArrow: noop,
      rightArrow: noop,
      pageUp: function() {
        moveFocusPerPage("prev");
        return false;
      },
      pageDown: function() {
        moveFocusPerPage("next");
        return false;
      }
    });
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      pullRefreshEnabled: false,
      scrollingEnabled: true,
      showScrollbar: "onScroll",
      useNativeScrolling: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      pullingDownText: messageLocalization.format("dxList-pullingDownText"),
      pulledDownText: messageLocalization.format("dxList-pulledDownText"),
      refreshingText: messageLocalization.format("dxList-refreshingText"),
      pageLoadingText: messageLocalization.format("dxList-pageLoadingText"),
      onScroll: null,
      onPullRefresh: null,
      onPageLoading: null,
      pageLoadMode: "scrollBottom",
      nextButtonText: messageLocalization.format("dxList-nextButtonText"),
      onItemSwipe: null,
      grouped: false,
      onGroupRendered: null,
      collapsibleGroups: false,
      groupTemplate: "group",
      indicateLoading: true,
      activeStateEnabled: true,
      _itemAttributes: {
        role: "option"
      },
      _listAttributes: {
        role: "listbox"
      },
      useInkRipple: false,
      wrapItemText: false,
      _swipeEnabled: true,
      _revertPageOnEmptyLoad: false,
      showChevronExpr: function(data2) {
        return data2 ? data2.showChevron : void 0;
      },
      badgeExpr: function(data2) {
        return data2 ? data2.badge : void 0;
      }
    });
  },
  _defaultOptionsRules: function() {
    var themeName = current();
    return this.callBase().concat(deviceDependentOptions(), [{
      device: function() {
        return !nativeScrolling;
      },
      options: {
        useNativeScrolling: false
      }
    }, {
      device: function(_device) {
        return !nativeScrolling && !devices.isSimulator() && devices.real().deviceType === "desktop" && _device.platform === "generic";
      },
      options: {
        showScrollbar: "onHover",
        pageLoadMode: "nextButton"
      }
    }, {
      device: function() {
        return devices.real().deviceType === "desktop" && !devices.isSimulator();
      },
      options: {
        focusStateEnabled: true
      }
    }, {
      device: function() {
        return isMaterial(themeName);
      },
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        pageLoadingText: "",
        useInkRipple: true
      }
    }]);
  },
  _visibilityChanged: function(visible2) {
    if (visible2) {
      this._updateLoadingState(true);
    }
  },
  _itemClass: function() {
    return LIST_ITEM_CLASS;
  },
  _itemDataKey: function() {
    return LIST_ITEM_DATA_KEY;
  },
  _itemContainer: function() {
    return this._$container;
  },
  _saveSelectionChangeEvent: function(e) {
    this._selectionChangeEventInstance = e;
  },
  _getSelectionChangeEvent: function() {
    return this._selectionChangeEventInstance;
  },
  _refreshItemElements: function() {
    if (!this.option("grouped")) {
      this._itemElementsCache = this._itemContainer().children(this._itemSelector());
    } else {
      this._itemElementsCache = this._itemContainer().children("." + LIST_GROUP_CLASS).children("." + LIST_GROUP_BODY_CLASS).children(this._itemSelector());
    }
  },
  _modifyByChanges: function() {
    this.callBase.apply(this, arguments);
    this._refreshItemElements();
    this._updateLoadingState(true);
  },
  reorderItem: function(itemElement, toItemElement) {
    var promise2 = this.callBase(itemElement, toItemElement);
    return promise2.done(function() {
      this._refreshItemElements();
    });
  },
  deleteItem: function(itemElement) {
    var promise2 = this.callBase(itemElement);
    return promise2.done(function() {
      this._refreshItemElements();
    });
  },
  _itemElements: function() {
    return this._itemElementsCache;
  },
  _itemSelectHandler: function(e) {
    if (this.option("selectionMode") === "single" && this.isItemSelected(e.currentTarget)) {
      return;
    }
    this.callBase(e);
  },
  _allowDynamicItemsAppend: function() {
    return true;
  },
  _resetDataSourcePageIndex: function() {
    var currentDataSource = this.getDataSource();
    if (currentDataSource && currentDataSource.pageIndex() !== 0) {
      currentDataSource.pageIndex(0);
      currentDataSource.load();
    }
  },
  _init: function() {
    this.callBase();
    this._resetDataSourcePageIndex();
    this._$container = this.$element();
    this._initScrollView();
    this._feedbackShowTimeout = LIST_FEEDBACK_SHOW_TIMEOUT;
    this._createGroupRenderAction();
  },
  _scrollBottomMode: function() {
    return this.option("pageLoadMode") === "scrollBottom";
  },
  _nextButtonMode: function() {
    return this.option("pageLoadMode") === "nextButton";
  },
  _dataSourceOptions: function() {
    var scrollBottom = this._scrollBottomMode();
    var nextButton = this._nextButtonMode();
    return extend(this.callBase(), {
      paginate: ensureDefined(scrollBottom || nextButton, true)
    });
  },
  _getGroupedOption: function() {
    return this.option("grouped");
  },
  _getGroupContainerByIndex: function(groupIndex) {
    return this._itemContainer().find(".".concat(LIST_GROUP_CLASS)).eq(groupIndex).find(".".concat(LIST_GROUP_BODY_CLASS));
  },
  _dataSourceFromUrlLoadMode: function() {
    return "raw";
  },
  _initScrollView: function() {
    var scrollingEnabled = this.option("scrollingEnabled");
    var pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled");
    var autoPagingEnabled = scrollingEnabled && this._scrollBottomMode() && !!this._dataSource;
    this._scrollView = this._createComponent(this.$element(), getScrollView(), {
      disabled: this.option("disabled") || !scrollingEnabled,
      onScroll: this._scrollHandler.bind(this),
      onPullDown: pullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
      onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
      showScrollbar: this.option("showScrollbar"),
      useNative: this.option("useNativeScrolling"),
      bounceEnabled: this.option("bounceEnabled"),
      scrollByContent: this.option("scrollByContent"),
      scrollByThumb: this.option("scrollByThumb"),
      pullingDownText: this.option("pullingDownText"),
      pulledDownText: this.option("pulledDownText"),
      refreshingText: this.option("refreshingText"),
      reachBottomText: this.option("pageLoadingText"),
      useKeyboard: false
    });
    this._$container = $(this._scrollView.content());
    if (this.option("wrapItemText")) {
      this._$container.addClass(WRAP_ITEM_TEXT_CLASS);
    }
    this._createScrollViewActions();
  },
  _createScrollViewActions: function() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._pullRefreshAction = this._createActionByOption("onPullRefresh");
    this._pageLoadingAction = this._createActionByOption("onPageLoading");
  },
  _scrollHandler: function(e) {
    this._scrollAction && this._scrollAction(e);
  },
  _initTemplates: function() {
    this._templateManager.addDefaultTemplates({
      group: new BindableTemplate(function($container, data2) {
        if (isPlainObject(data2)) {
          if (data2.key) {
            $container.text(data2.key);
          }
        } else {
          $container.text(String(data2));
        }
      }, ["key"], this.option("integrationOptions.watchMethod"))
    });
    this.callBase();
  },
  _prepareDefaultItemTemplate: function(data2, $container) {
    this.callBase(data2, $container);
    if (data2.icon) {
      var $icon = getImageContainer(data2.icon).addClass(LIST_ITEM_ICON_CLASS);
      var $iconContainer = $("<div>").addClass(LIST_ITEM_ICON_CONTAINER_CLASS);
      $iconContainer.append($icon);
      $container.prepend($iconContainer);
    }
  },
  _getBindableFields: function() {
    return ["text", "html", "icon"];
  },
  _updateLoadingState: function(tryLoadMore) {
    var isDataLoaded = !tryLoadMore || this._isLastPage();
    var scrollBottomMode = this._scrollBottomMode();
    var stopLoading = isDataLoaded || !scrollBottomMode;
    var hideLoadIndicator = stopLoading && !this._isDataSourceLoading();
    if (stopLoading || this._scrollViewIsFull()) {
      this._scrollView.release(hideLoadIndicator);
      this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
      this._loadIndicationSuppressed(false);
    } else {
      this._infiniteDataLoading();
    }
  },
  _shouldRenderNextButton: function() {
    return this._nextButtonMode() && this._dataSource && this._dataSource.isLoaded();
  },
  _isDataSourceFirstLoadCompleted: function(newValue) {
    if (isDefined(newValue)) {
      this._isFirstLoadCompleted = newValue;
    }
    return this._isFirstLoadCompleted;
  },
  _dataSourceLoadingChangedHandler: function(isLoading) {
    if (this._loadIndicationSuppressed()) {
      return;
    }
    if (isLoading && this.option("indicateLoading")) {
      this._showLoadingIndicatorTimer = setTimeout(function() {
        var isEmpty2 = !this._itemElements().length;
        var shouldIndicateLoading = !isEmpty2 || this._isDataSourceFirstLoadCompleted();
        if (shouldIndicateLoading) {
          var _this$_scrollView;
          (_this$_scrollView = this._scrollView) === null || _this$_scrollView === void 0 ? void 0 : _this$_scrollView.startLoading();
        }
      }.bind(this));
    } else {
      clearTimeout(this._showLoadingIndicatorTimer);
      this._scrollView && this._scrollView.finishLoading();
    }
    if (!isLoading) {
      this._isDataSourceFirstLoadCompleted(false);
    }
  },
  _dataSourceChangedHandler: function() {
    if (!this._shouldAppendItems() && hasWindow$1()) {
      this._scrollView && this._scrollView.scrollTo(0);
    }
    this.callBase.apply(this, arguments);
    this._isDataSourceFirstLoadCompleted(true);
  },
  _refreshContent: function() {
    this._prepareContent();
    this._fireContentReadyAction();
  },
  _hideLoadingIfLoadIndicationOff: function() {
    if (!this.option("indicateLoading")) {
      this._dataSourceLoadingChangedHandler(false);
    }
  },
  _loadIndicationSuppressed: function(value2) {
    if (!arguments.length) {
      return this._isLoadIndicationSuppressed;
    }
    this._isLoadIndicationSuppressed = value2;
  },
  _scrollViewIsFull: function() {
    return !this._scrollView || this._scrollView.isFull();
  },
  _pullDownHandler: function(e) {
    this._pullRefreshAction(e);
    if (this._dataSource && !this._isDataSourceLoading()) {
      this._clearSelectedItems();
      this._dataSource.pageIndex(0);
      this._dataSource.reload();
    } else {
      this._updateLoadingState();
    }
  },
  _infiniteDataLoading: function() {
    var isElementVisible2 = this.$element().is(":visible");
    if (isElementVisible2 && !this._scrollViewIsFull() && !this._isDataSourceLoading() && !this._isLastPage()) {
      clearTimeout(this._loadNextPageTimer);
      this._loadNextPageTimer = setTimeout(() => {
        this._loadNextPage().done(this._setPreviousPageIfNewIsEmpty.bind(this));
      });
    }
  },
  _setPreviousPageIfNewIsEmpty: function(result) {
    if (this.option("_revertPageOnEmptyLoad")) {
      var dataSource = this.getDataSource();
      var pageIndex = dataSource === null || dataSource === void 0 ? void 0 : dataSource.pageIndex();
      if ((result === null || result === void 0 ? void 0 : result.length) === 0 && pageIndex > 0) {
        this._fireContentReadyAction();
        dataSource.pageIndex(pageIndex - 1);
      }
    }
  },
  _scrollBottomHandler: function(e) {
    this._pageLoadingAction(e);
    if (!this._isDataSourceLoading() && !this._isLastPage()) {
      this._loadNextPage();
    } else {
      this._updateLoadingState();
    }
  },
  _renderItems: function(items) {
    if (this.option("grouped")) {
      each(items, this._renderGroup.bind(this));
      this._attachGroupCollapseEvent();
      this._renderEmptyMessage();
      if (isMaterial()) {
        this.attachGroupHeaderInkRippleEvents();
      }
    } else {
      this.callBase.apply(this, arguments);
    }
    this._refreshItemElements();
    this._updateLoadingState(true);
  },
  _attachGroupCollapseEvent: function() {
    var eventName = addNamespace$1(CLICK_EVENT_NAME$2, this.NAME);
    var selector = "." + LIST_GROUP_HEADER_CLASS;
    var $element = this.$element();
    var collapsibleGroups = this.option("collapsibleGroups");
    $element.toggleClass(LIST_COLLAPSIBLE_GROUPS_CLASS, collapsibleGroups);
    eventsEngine.off($element, eventName, selector);
    if (collapsibleGroups) {
      eventsEngine.on($element, eventName, selector, function(e) {
        this._createAction(function(e2) {
          var $group = $(e2.event.currentTarget).parent();
          this._collapseGroupHandler($group);
          if (this.option("focusStateEnabled")) {
            this.option("focusedElement", getPublicElement($group.find("." + LIST_ITEM_CLASS).eq(0)));
          }
        }.bind(this), {
          validatingTargetName: "element"
        })({
          event: e
        });
      }.bind(this));
    }
  },
  _collapseGroupHandler: function($group, toggle) {
    var deferred = new Deferred();
    if ($group.hasClass(LIST_GROUP_COLLAPSED_CLASS) === toggle) {
      return deferred.resolve();
    }
    var $groupBody = $group.children("." + LIST_GROUP_BODY_CLASS);
    var startHeight = $groupBody.outerHeight();
    var endHeight = startHeight === 0 ? $groupBody.height("auto").outerHeight() : 0;
    $group.toggleClass(LIST_GROUP_COLLAPSED_CLASS, toggle);
    fx.animate($groupBody, {
      type: "custom",
      from: {
        height: startHeight
      },
      to: {
        height: endHeight
      },
      duration: 200,
      complete: function() {
        this.updateDimensions();
        this._updateLoadingState();
        deferred.resolve();
      }.bind(this)
    });
    return deferred.promise();
  },
  _dataSourceLoadErrorHandler: function() {
    this._forgetNextPageLoading();
    if (this._initialized) {
      this._renderEmptyMessage();
      this._updateLoadingState();
    }
  },
  _initMarkup: function() {
    this._itemElementsCache = $();
    this.$element().addClass(LIST_CLASS);
    this.callBase();
    this.option("useInkRipple") && this._renderInkRipple();
    this.setAria("role", this.option("_listAttributes").role);
  },
  _renderInkRipple: function() {
    this._inkRipple = render();
  },
  _toggleActiveState: function($element, value2, e) {
    this.callBase.apply(this, arguments);
    var that = this;
    if (!this._inkRipple) {
      return;
    }
    var config2 = {
      element: $element,
      event: e
    };
    if (value2) {
      if (isMaterial()) {
        this._inkRippleTimer = setTimeout(function() {
          that._inkRipple.showWave(config2);
        }, LIST_FEEDBACK_SHOW_TIMEOUT / 2);
      } else {
        that._inkRipple.showWave(config2);
      }
    } else {
      clearTimeout(this._inkRippleTimer);
      this._inkRipple.hideWave(config2);
    }
  },
  _postprocessRenderItem: function(args) {
    this._refreshItemElements();
    this.callBase.apply(this, arguments);
    if (this.option("_swipeEnabled")) {
      this._attachSwipeEvent($(args.itemElement));
    }
  },
  _attachSwipeEvent: function($itemElement) {
    var endEventName = addNamespace$1(SWIPE_END_EVENT, this.NAME);
    eventsEngine.on($itemElement, endEventName, this._itemSwipeEndHandler.bind(this));
  },
  _itemSwipeEndHandler: function(e) {
    this._itemDXEventHandler(e, "onItemSwipe", {
      direction: e.offset < 0 ? "left" : "right"
    });
  },
  _nextButtonHandler: function(e) {
    this._pageLoadingAction(e);
    var source = this._dataSource;
    if (source && !source.isLoading()) {
      this._scrollView.toggleLoading(true);
      this._$nextButton.detach();
      this._loadIndicationSuppressed(true);
      this._loadNextPage();
    }
  },
  _renderGroup: function(index2, group) {
    var $groupElement = $("<div>").addClass(LIST_GROUP_CLASS).appendTo(this._itemContainer());
    var $groupHeaderElement = $("<div>").addClass(LIST_GROUP_HEADER_CLASS).appendTo($groupElement);
    var groupTemplateName = this.option("groupTemplate");
    var groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index2, $groupHeaderElement);
    var renderArgs = {
      index: index2,
      itemData: group,
      container: getPublicElement($groupHeaderElement)
    };
    this._createItemByTemplate(groupTemplate, renderArgs);
    if (isMaterial()) {
      $("<div>").addClass(LIST_GROUP_HEADER_INDICATOR_CLASS).prependTo($groupHeaderElement);
    }
    this._renderingGroupIndex = index2;
    var $groupBody = $("<div>").addClass(LIST_GROUP_BODY_CLASS).appendTo($groupElement);
    each(groupItemsGetter(group) || [], function(index3, item) {
      this._renderItem(index3, item, $groupBody);
    }.bind(this));
    this._groupRenderAction({
      groupElement: getPublicElement($groupElement),
      groupIndex: index2,
      groupData: group
    });
  },
  downInkRippleHandler: function(e) {
    this._toggleActiveState($(e.currentTarget), true, e);
  },
  upInkRippleHandler: function(e) {
    this._toggleActiveState($(e.currentTarget), false);
  },
  attachGroupHeaderInkRippleEvents: function() {
    var selector = "." + LIST_GROUP_HEADER_CLASS;
    var $element = this.$element();
    this._downInkRippleHandler = this._downInkRippleHandler || this.downInkRippleHandler.bind(this);
    this._upInkRippleHandler = this._upInkRippleHandler || this.upInkRippleHandler.bind(this);
    var downArguments = [$element, "dxpointerdown", selector, this._downInkRippleHandler];
    var upArguments = [$element, "dxpointerup dxpointerout", selector, this._upInkRippleHandler];
    eventsEngine.off(...downArguments);
    eventsEngine.on(...downArguments);
    eventsEngine.off(...upArguments);
    eventsEngine.on(...upArguments);
  },
  _createGroupRenderAction: function() {
    this._groupRenderAction = this._createActionByOption("onGroupRendered");
  },
  _clean: function() {
    clearTimeout(this._inkRippleTimer);
    if (this._$nextButton) {
      this._$nextButton.remove();
      this._$nextButton = null;
    }
    delete this._inkRipple;
    this.callBase.apply(this, arguments);
  },
  _dispose: function() {
    this._isDataSourceFirstLoadCompleted(false);
    clearTimeout(this._holdTimer);
    clearTimeout(this._loadNextPageTimer);
    clearTimeout(this._showLoadingIndicatorTimer);
    this.callBase();
  },
  _toggleDisabledState: function(value2) {
    this.callBase(value2);
    this._scrollView.option("disabled", value2 || !this.option("scrollingEnabled"));
  },
  _toggleNextButton: function(value2) {
    var dataSource = this._dataSource;
    var $nextButton = this._getNextButton();
    this.$element().toggleClass(LIST_HAS_NEXT_CLASS, value2);
    if (value2 && dataSource && dataSource.isLoaded()) {
      $nextButton.appendTo(this._itemContainer());
    }
    if (!value2) {
      $nextButton.detach();
    }
  },
  _getNextButton: function() {
    if (!this._$nextButton) {
      this._$nextButton = this._createNextButton();
    }
    return this._$nextButton;
  },
  _createNextButton: function() {
    var $result = $("<div>").addClass(LIST_NEXT_BUTTON_CLASS);
    var $button = $("<div>").appendTo($result);
    this._createComponent($button, Button, {
      text: this.option("nextButtonText"),
      onClick: this._nextButtonHandler.bind(this),
      type: isMaterial() ? "default" : void 0,
      integrationOptions: {}
    });
    return $result;
  },
  _moveFocus: function() {
    this.callBase.apply(this, arguments);
    this.scrollToItem(this.option("focusedElement"));
  },
  _refresh: function() {
    if (!hasWindow$1()) {
      this.callBase();
    } else {
      var scrollTop = this._scrollView.scrollTop();
      this.callBase();
      scrollTop && this._scrollView.scrollTo(scrollTop);
    }
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "pageLoadMode":
        this._toggleNextButton(args.value);
        this._initScrollView();
        break;
      case "dataSource":
        this.callBase(args);
        this._initScrollView();
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "items":
        this.callBase(args);
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "pageLoadingText":
      case "showScrollbar":
      case "bounceEnabled":
      case "scrollByContent":
      case "scrollByThumb":
      case "useNativeScrolling":
      case "scrollingEnabled":
      case "pullRefreshEnabled":
        this._initScrollView();
        this._updateLoadingState();
        break;
      case "nextButtonText":
      case "onItemSwipe":
      case "useInkRipple":
        this._invalidate();
        break;
      case "onScroll":
      case "onPullRefresh":
      case "onPageLoading":
        this._createScrollViewActions();
        break;
      case "grouped":
      case "collapsibleGroups":
      case "groupTemplate":
        this._invalidate();
        break;
      case "wrapItemText":
        this._$container.toggleClass(WRAP_ITEM_TEXT_CLASS, args.value);
        break;
      case "onGroupRendered":
        this._createGroupRenderAction();
        break;
      case "width":
      case "height":
        this.callBase(args);
        this._scrollView.update();
        break;
      case "indicateLoading":
        this._hideLoadingIfLoadIndicationOff();
        break;
      case "visible":
        this.callBase(args);
        this._scrollView.update();
        break;
      case "rtlEnabled":
        this._initScrollView();
        this.callBase(args);
        break;
      case "showChevronExpr":
      case "badgeExpr":
        this._invalidate();
        break;
      case "_swipeEnabled":
      case "_revertPageOnEmptyLoad":
      case "_listAttributes":
        break;
      default:
        this.callBase(args);
    }
  },
  _extendActionArgs: function($itemElement) {
    if (!this.option("grouped")) {
      return this.callBase($itemElement);
    }
    var $group = $itemElement.closest("." + LIST_GROUP_CLASS);
    var $item = $group.find("." + LIST_ITEM_CLASS);
    return extend(this.callBase($itemElement), {
      itemIndex: {
        group: $group.index(),
        item: $item.index($itemElement)
      }
    });
  },
  expandGroup: function(groupIndex) {
    var deferred = new Deferred();
    var $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
    this._collapseGroupHandler($group, false).done(function() {
      deferred.resolveWith(this);
    }.bind(this));
    return deferred.promise();
  },
  collapseGroup: function(groupIndex) {
    var deferred = new Deferred();
    var $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
    this._collapseGroupHandler($group, true).done(function() {
      deferred.resolveWith(this);
    }.bind(this));
    return deferred;
  },
  updateDimensions: function() {
    var that = this;
    var deferred = new Deferred();
    if (that._scrollView) {
      that._scrollView.update().done(function() {
        !that._scrollViewIsFull() && that._updateLoadingState(true);
        deferred.resolveWith(that);
      });
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  },
  reload: function() {
    this.callBase();
    this.scrollTo(0);
    this._pullDownHandler();
  },
  repaint: function() {
    this.scrollTo(0);
    this.callBase();
  },
  scrollTop: function() {
    return this._scrollView.scrollOffset().top;
  },
  clientHeight: function() {
    return this._scrollView.clientHeight();
  },
  scrollHeight: function() {
    return this._scrollView.scrollHeight();
  },
  scrollBy: function(distance) {
    this._scrollView.scrollBy(distance);
  },
  scrollTo: function(location) {
    this._scrollView.scrollTo(location);
  },
  scrollToItem: function(itemElement) {
    var $item = this._editStrategy.getItemElement(itemElement);
    this._scrollView.scrollToElement($item);
  },
  _dimensionChanged: function() {
    this.updateDimensions();
  }
}).include(DataConverterMixin);
ListBase.ItemClass = ListItem;
function getScrollView() {
  return ScrollView;
}
var CONTEXTMENU_CLASS = "dx-list-context-menu";
var CONTEXTMENU_MENUCONTENT_CLASS = "dx-list-context-menucontent";
register("menu", "context", EditDecorator.inherit({
  _init: function() {
    var $menu = $("<div>").addClass(CONTEXTMENU_CLASS);
    this._list.$element().append($menu);
    this._menu = this._renderOverlay($menu);
  },
  _renderOverlay: function($element) {
    return this._list._createComponent($element, Overlay, {
      shading: false,
      deferRendering: true,
      closeOnTargetScroll: true,
      closeOnOutsideClick: function(e) {
        return !$(e.target).closest("." + CONTEXTMENU_CLASS).length;
      },
      animation: {
        show: {
          type: "slide",
          duration: 300,
          from: {
            height: 0,
            opacity: 1
          },
          to: {
            height: function() {
              return this._$menuList.outerHeight();
            }.bind(this),
            opacity: 1
          }
        },
        hide: {
          type: "slide",
          duration: 0,
          from: {
            opacity: 1
          },
          to: {
            opacity: 0
          }
        }
      },
      height: function() {
        return this._$menuList ? this._$menuList.outerHeight() : 0;
      }.bind(this),
      width: function() {
        return this._list.$element().outerWidth();
      }.bind(this),
      onContentReady: this._renderMenuContent.bind(this)
    });
  },
  _renderMenuContent: function(e) {
    var $overlayContent = e.component.$content();
    var items = this._menuItems().slice();
    if (this._deleteEnabled()) {
      items.push({
        text: messageLocalization.format("dxListEditDecorator-delete"),
        action: this._deleteItem.bind(this)
      });
    }
    this._$menuList = $("<div>");
    this._list._createComponent(this._$menuList, ListBase, {
      items,
      onItemClick: this._menuItemClickHandler.bind(this),
      height: "auto",
      integrationOptions: {}
    });
    $overlayContent.addClass(CONTEXTMENU_MENUCONTENT_CLASS);
    $overlayContent.append(this._$menuList);
  },
  _menuItemClickHandler: function(args) {
    this._menu.hide();
    this._fireMenuAction(this._$itemWithMenu, args.itemData.action);
  },
  _deleteItem: function() {
    this._list.deleteItem(this._$itemWithMenu);
  },
  handleContextMenu: function($itemElement) {
    this._$itemWithMenu = $itemElement;
    this._menu.option({
      position: {
        my: "top",
        at: "bottom",
        of: $itemElement,
        collision: "flip"
      }
    });
    this._menu.show();
    return true;
  },
  dispose: function() {
    if (this._menu) {
      this._menu.$element().remove();
    }
    this.callBase.apply(this, arguments);
  }
}).include(EditDecoratorMenuHelperMixin));
var RADIO_BUTTON_CLASS = "dx-radiobutton";
var RADIO_BUTTON_ICON_CLASS = "dx-radiobutton-icon";
var RADIO_BUTTON_ICON_DOT_CLASS = "dx-radiobutton-icon-dot";
var RADIO_BUTTON_CHECKED_CLASS = "dx-radiobutton-checked";
var RADIO_BUTTON_ICON_CHECKED_CLASS = "dx-radiobutton-icon-checked";
var RadioButton = Editor.inherit({
  _supportedKeys: function() {
    return extend(this.callBase(), {
      space: function(e) {
        e.preventDefault();
        this._clickAction({
          event: e
        });
      }
    });
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      value: false,
      useInkRipple: false
    });
  },
  _canValueBeChangedByClick: function() {
    return true;
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function() {
        return devices.real().deviceType === "desktop" && !devices.isSimulator();
      },
      options: {
        focusStateEnabled: true
      }
    }]);
  },
  _init: function() {
    this.callBase();
    this.$element().addClass(RADIO_BUTTON_CLASS);
  },
  _initMarkup: function() {
    this.callBase();
    this._renderIcon();
    this.option("useInkRipple") && this._renderInkRipple();
    this._renderCheckedState(this.option("value"));
    this._renderClick();
    this.setAria("role", "radio");
  },
  _renderInkRipple: function() {
    this._inkRipple = render({
      waveSizeCoefficient: 3.3,
      useHoldAnimation: false,
      wavesNumber: 2,
      isCentered: true
    });
  },
  _renderInkWave: function(element, dxEvent, doRender, waveIndex) {
    if (!this._inkRipple) {
      return;
    }
    var config2 = {
      element,
      event: dxEvent,
      wave: waveIndex
    };
    if (doRender) {
      this._inkRipple.showWave(config2);
    } else {
      this._inkRipple.hideWave(config2);
    }
  },
  _updateFocusState: function(e, value2) {
    this.callBase.apply(this, arguments);
    this._renderInkWave(this._$icon, e, value2, 0);
  },
  _toggleActiveState: function($element, value2, e) {
    this.callBase.apply(this, arguments);
    this._renderInkWave(this._$icon, e, value2, 1);
  },
  _renderIcon: function() {
    this._$icon = $("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
    $("<div>").addClass(RADIO_BUTTON_ICON_DOT_CLASS).appendTo(this._$icon);
    this.$element().append(this._$icon);
  },
  _renderCheckedState: function(checked) {
    this.$element().toggleClass(RADIO_BUTTON_CHECKED_CLASS, checked).find("." + RADIO_BUTTON_ICON_CLASS).toggleClass(RADIO_BUTTON_ICON_CHECKED_CLASS, checked);
    this.setAria("checked", checked);
  },
  _renderClick: function() {
    var eventName = addNamespace$1(CLICK_EVENT_NAME$2, this.NAME);
    this._clickAction = this._createAction(function(args) {
      this._clickHandler(args.event);
    }.bind(this));
    eventsEngine.off(this.$element(), eventName);
    eventsEngine.on(this.$element(), eventName, function(e) {
      this._clickAction({
        event: e
      });
    }.bind(this));
  },
  _clickHandler: function(e) {
    this._saveValueChangeEvent(e);
    this.option("value", true);
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "useInkRipple":
        this._invalidate();
        break;
      case "value":
        this._renderCheckedState(args.value);
        this.callBase(args);
        break;
      default:
        this.callBase(args);
    }
  },
  _clean: function() {
    delete this._inkRipple;
    this.callBase();
  }
});
registerComponent("dxRadioButton", RadioButton);
var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled";
var SELECT_DECORATOR_SELECT_ALL_CLASS = "dx-list-select-all";
var SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS = "dx-list-select-all-checkbox";
var SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS = "dx-list-select-all-label";
var SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container";
var SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox";
var SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container";
var SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
var FOCUSED_STATE_CLASS = "dx-state-focused";
var CLICK_EVENT_NAME = addNamespace$1(CLICK_EVENT_NAME$2, "dxListEditDecorator");
register("selection", "default", EditDecorator.inherit({
  _init: function() {
    this.callBase.apply(this, arguments);
    var selectionMode = this._list.option("selectionMode");
    this._singleStrategy = selectionMode === "single";
    this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
    this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
    this._controlWidget = this._singleStrategy ? RadioButton : CheckBox;
    this._list.$element().addClass(SELECT_DECORATOR_ENABLED_CLASS);
  },
  beforeBag: function(config2) {
    var $itemElement = config2.$itemElement;
    var $container = config2.$container.addClass(this._containerClass);
    var $control = $("<div>").addClass(this._controlClass).appendTo($container);
    new this._controlWidget($control, extend(this._commonOptions(), {
      value: this._isSelected($itemElement),
      focusStateEnabled: false,
      hoverStateEnabled: false,
      onValueChanged: function(e) {
        e.event && this._list._saveSelectionChangeEvent(e.event);
        this._processCheckedState($itemElement, e.value);
        e.event && e.event.stopPropagation();
      }.bind(this)
    }));
  },
  modifyElement: function(config2) {
    this.callBase.apply(this, arguments);
    var $itemElement = config2.$itemElement;
    var control = this._controlWidget.getInstance($itemElement.find("." + this._controlClass));
    eventsEngine.on($itemElement, "stateChanged", function(e, state) {
      control.option("value", state);
    }.bind(this));
  },
  _updateSelectAllState: function() {
    if (!this._$selectAll) {
      return;
    }
    this._selectAllCheckBox.option("value", this._list.isSelectAll());
  },
  afterRender: function() {
    if (this._list.option("selectionMode") !== "all") {
      return;
    }
    if (!this._$selectAll) {
      this._renderSelectAll();
    } else {
      this._updateSelectAllState();
    }
  },
  handleKeyboardEvents: function(currentFocusedIndex, moveFocusUp) {
    var moveFocusDown = !moveFocusUp;
    var list = this._list;
    var $selectAll = this._$selectAll;
    var lastItemIndex = list._getLastItemIndex();
    var isFocusOutOfList = moveFocusUp && currentFocusedIndex === 0 || moveFocusDown && currentFocusedIndex === lastItemIndex;
    var hasSelectAllItem = !!$selectAll;
    if (hasSelectAllItem && isFocusOutOfList) {
      list.option("focusedElement", $selectAll);
      list.scrollToItem(list.option("focusedElement"));
      return true;
    }
    return false;
  },
  handleEnterPressing: function(e) {
    if (this._$selectAll && this._$selectAll.hasClass(FOCUSED_STATE_CLASS)) {
      e.target = this._$selectAll.get(0);
      this._list._saveSelectionChangeEvent(e);
      this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
      return true;
    }
  },
  _renderSelectAll: function() {
    var $selectAll = this._$selectAll = $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CLASS);
    var list = this._list;
    var downArrowHandler = list._supportedKeys().downArrow.bind(list);
    this._selectAllCheckBox = list._createComponent($("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS).appendTo($selectAll), CheckBox, {
      focusStateEnabled: false,
      hoverStateEnabled: false
    });
    this._selectAllCheckBox.registerKeyHandler("downArrow", downArrowHandler);
    $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS).text(this._list.option("selectAllText")).appendTo($selectAll);
    this._list.itemsContainer().prepend($selectAll);
    this._updateSelectAllState();
    this._attachSelectAllHandler();
  },
  _attachSelectAllHandler: function() {
    this._selectAllCheckBox.option("onValueChanged", this._selectAllHandler.bind(this));
    eventsEngine.off(this._$selectAll, CLICK_EVENT_NAME);
    eventsEngine.on(this._$selectAll, CLICK_EVENT_NAME, this._selectAllClickHandler.bind(this));
  },
  _selectAllHandler: function(e) {
    e.event && e.event.stopPropagation();
    var isSelectedAll = this._selectAllCheckBox.option("value");
    var result = this._list._createActionByOption("onSelectAllValueChanged")({
      value: isSelectedAll
    });
    if (result === false) {
      return;
    }
    e.event && this._list._saveSelectionChangeEvent(e.event);
    if (isSelectedAll === true) {
      this._selectAllItems();
    } else if (isSelectedAll === false) {
      this._unselectAllItems();
    }
  },
  _checkSelectAllCapability: function() {
    var list = this._list;
    var dataSource = list.getDataSource();
    if (list.option("selectAllMode") === "allPages" && list.option("grouped") && (!dataSource || !dataSource.group())) {
      errors$1.log("W1010");
      return false;
    }
    return true;
  },
  _selectAllItems: function() {
    if (!this._checkSelectAllCapability()) {
      return;
    }
    this._list._selection.selectAll(this._list.option("selectAllMode") === "page");
  },
  _unselectAllItems: function() {
    if (!this._checkSelectAllCapability()) {
      return;
    }
    this._list._selection.deselectAll(this._list.option("selectAllMode") === "page");
  },
  _selectAllClickHandler: function(e) {
    this._list._saveSelectionChangeEvent(e);
    this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
  },
  _isSelected: function($itemElement) {
    return this._list.isItemSelected($itemElement);
  },
  _processCheckedState: function($itemElement, checked) {
    if (checked) {
      this._list.selectItem($itemElement);
    } else {
      this._list.unselectItem($itemElement);
    }
  },
  dispose: function() {
    this._disposeSelectAll();
    this._list.$element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
    this.callBase.apply(this, arguments);
  },
  _disposeSelectAll: function() {
    if (this._$selectAll) {
      this._$selectAll.remove();
      this._$selectAll = null;
    }
  }
}));
var window$4 = getWindow();
var DRAGGABLE = "dxDraggable";
var DRAGSTART_EVENT_NAME = addNamespace$1(DRAG_START_EVENT, DRAGGABLE);
var DRAG_EVENT_NAME = addNamespace$1(DRAG_EVENT, DRAGGABLE);
var DRAGEND_EVENT_NAME = addNamespace$1(DRAG_END_EVENT, DRAGGABLE);
var DRAG_ENTER_EVENT_NAME = addNamespace$1(DRAG_ENTER_EVENT, DRAGGABLE);
var DRAGEND_LEAVE_EVENT_NAME = addNamespace$1(DRAG_LEAVE_EVENT, DRAGGABLE);
var POINTERDOWN_EVENT_NAME = addNamespace$1(pointer.down, DRAGGABLE);
var CLONE_CLASS$1 = "clone";
var targetDraggable;
var sourceDraggable;
var ANONYMOUS_TEMPLATE_NAME = "content";
var getMousePosition = (event) => ({
  x: event.pageX - $(window$4).scrollLeft(),
  y: event.pageY - $(window$4).scrollTop()
});
var GESTURE_COVER_CLASS = "dx-gesture-cover";
var OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper";
var OVERLAY_CONTENT_CLASS = "dx-overlay-content";
class ScrollHelper {
  constructor(orientation, component) {
    this._preventScroll = true;
    this._component = component;
    if (orientation === "vertical") {
      this._scrollValue = "scrollTop";
      this._overFlowAttr = "overflowY";
      this._sizeAttr = "height";
      this._scrollSizeProp = "scrollHeight";
      this._clientSizeProp = "clientHeight";
      this._limitProps = {
        start: "top",
        end: "bottom"
      };
    } else {
      this._scrollValue = "scrollLeft";
      this._overFlowAttr = "overflowX";
      this._sizeAttr = "width";
      this._scrollSizeProp = "scrollWidth";
      this._clientSizeProp = "clientWidth";
      this._limitProps = {
        start: "left",
        end: "right"
      };
    }
  }
  updateScrollable(elements, mousePosition) {
    var isScrollableFound = false;
    elements.some((element) => {
      var $element = $(element);
      var isTargetOverOverlayWrapper = $element.hasClass(OVERLAY_WRAPPER_CLASS) && $element.css("pointerEvents") !== "none";
      var isTargetOverOverlayContent = $element.hasClass(OVERLAY_CONTENT_CLASS);
      if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
        return true;
      }
      isScrollableFound = this._trySetScrollable(element, mousePosition);
      return isScrollableFound;
    });
    if (!isScrollableFound) {
      this._$scrollableAtPointer = null;
      this._scrollSpeed = 0;
    }
  }
  isScrolling() {
    return !!this._scrollSpeed;
  }
  isScrollable($element) {
    return ($element.css(this._overFlowAttr) === "auto" || $element.hasClass("dx-scrollable-container")) && $element.prop(this._scrollSizeProp) > $element[this._sizeAttr]();
  }
  _trySetScrollable(element, mousePosition) {
    var $element = $(element);
    var distanceToBorders;
    var sensitivity = this._component.option("scrollSensitivity");
    var isScrollable = this.isScrollable($element);
    if (isScrollable) {
      distanceToBorders = this._calculateDistanceToBorders($element, mousePosition);
      if (sensitivity > distanceToBorders[this._limitProps.start]) {
        if (!this._preventScroll) {
          this._scrollSpeed = -this._calculateScrollSpeed(distanceToBorders[this._limitProps.start]);
          this._$scrollableAtPointer = $element;
        }
      } else if (sensitivity > distanceToBorders[this._limitProps.end]) {
        if (!this._preventScroll) {
          this._scrollSpeed = this._calculateScrollSpeed(distanceToBorders[this._limitProps.end]);
          this._$scrollableAtPointer = $element;
        }
      } else {
        isScrollable = false;
        this._preventScroll = false;
      }
    }
    return isScrollable;
  }
  _calculateDistanceToBorders($area, mousePosition) {
    var area = $area.get(0);
    var areaBoundingRect;
    if (area) {
      areaBoundingRect = getBoundingRect(area);
      return {
        left: mousePosition.x - areaBoundingRect.left,
        top: mousePosition.y - areaBoundingRect.top,
        right: areaBoundingRect.right - mousePosition.x,
        bottom: areaBoundingRect.bottom - mousePosition.y
      };
    } else {
      return {};
    }
  }
  _calculateScrollSpeed(distance) {
    var component = this._component;
    var sensitivity = component.option("scrollSensitivity");
    var maxSpeed = component.option("scrollSpeed");
    return Math.ceil(Math.pow((sensitivity - distance) / sensitivity, 2) * maxSpeed);
  }
  scrollByStep() {
    if (this._$scrollableAtPointer && this._scrollSpeed) {
      if (this._$scrollableAtPointer.hasClass("dx-scrollable-container")) {
        var $scrollable = this._$scrollableAtPointer.closest(".dx-scrollable");
        var scrollableInstance = $scrollable.data("dxScrollable") || $scrollable.data("dxScrollView");
        if (scrollableInstance) {
          var nextScrollPosition = scrollableInstance.scrollOffset()[this._limitProps.start] + this._scrollSpeed;
          scrollableInstance.scrollTo({
            [this._limitProps.start]: nextScrollPosition
          });
        }
      } else {
        var _nextScrollPosition = this._$scrollableAtPointer[this._scrollValue]() + this._scrollSpeed;
        this._$scrollableAtPointer[this._scrollValue](_nextScrollPosition);
      }
      var dragMoveArgs = this._component._dragMoveArgs;
      if (dragMoveArgs) {
        this._component._dragMoveHandler(dragMoveArgs);
      }
    }
  }
  reset() {
    this._$scrollableAtPointer = null;
    this._scrollSpeed = 0;
    this._preventScroll = true;
  }
  isOutsideScrollable($scrollable, event) {
    if (!$scrollable) {
      return false;
    }
    var scrollableSize = getBoundingRect($scrollable.get(0));
    var start = scrollableSize[this._limitProps.start];
    var size = scrollableSize[this._sizeAttr];
    var mousePosition = getMousePosition(event);
    var location = this._sizeAttr === "width" ? mousePosition.x : mousePosition.y;
    return location < start || location > start + size;
  }
}
var ScrollAnimator = Animator.inherit({
  ctor: function(strategy2) {
    this.callBase();
    this._strategy = strategy2;
  },
  _step: function() {
    var horizontalScrollHelper = this._strategy._horizontalScrollHelper;
    var verticalScrollHelper = this._strategy._verticalScrollHelper;
    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();
    verticalScrollHelper && verticalScrollHelper.scrollByStep();
  }
});
var Draggable = DOMComponent.inherit({
  reset: noop,
  dragMove: noop,
  dragEnter: noop,
  dragLeave: noop,
  dragEnd: function(sourceEvent) {
    var sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2._fireRemoveEvent(sourceEvent);
    return new Deferred().resolve();
  },
  _fireRemoveEvent: noop,
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,
      onDrop: null,
      immediate: true,
      dragDirection: "both",
      boundary: void 0,
      boundOffset: 0,
      allowMoveByClick: false,
      itemData: null,
      container: void 0,
      dragTemplate: void 0,
      contentTemplate: "content",
      handle: "",
      filter: "",
      clone: false,
      autoScroll: true,
      scrollSpeed: 30,
      scrollSensitivity: 60,
      group: void 0,
      data: void 0
    });
  },
  _setOptionsByReference: function() {
    this.callBase.apply(this, arguments);
    extend(this._optionsByReference, {
      component: true,
      group: true,
      itemData: true,
      data: true
    });
  },
  _init: function() {
    this.callBase();
    this._attachEventHandlers();
    this._scrollAnimator = new ScrollAnimator(this);
    this._horizontalScrollHelper = new ScrollHelper("horizontal", this);
    this._verticalScrollHelper = new ScrollHelper("vertical", this);
  },
  _normalizeCursorOffset: function(offset2) {
    if (isObject$1(offset2)) {
      offset2 = {
        h: offset2.x,
        v: offset2.y
      };
    }
    offset2 = splitPair(offset2).map((value2) => parseFloat(value2));
    return {
      left: offset2[0],
      top: offset2.length === 1 ? offset2[0] : offset2[1]
    };
  },
  _getNormalizedCursorOffset: function(offset2, options) {
    if (isFunction$1(offset2)) {
      offset2 = offset2.call(this, options);
    }
    return this._normalizeCursorOffset(offset2);
  },
  _calculateElementOffset: function(options) {
    var elementOffset;
    var dragElementOffset;
    var event = options.event;
    var $element = $(options.itemElement);
    var $dragElement = $(options.dragElement);
    var isCloned = this._dragElementIsCloned();
    var cursorOffset = this.option("cursorOffset");
    var normalizedCursorOffset = {
      left: 0,
      top: 0
    };
    var currentLocate = this._initialLocate = locate($dragElement);
    if (isCloned || options.initialOffset || cursorOffset) {
      elementOffset = options.initialOffset || $element.offset();
      if (cursorOffset) {
        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options);
        if (isFinite(normalizedCursorOffset.left)) {
          elementOffset.left = event.pageX;
        }
        if (isFinite(normalizedCursorOffset.top)) {
          elementOffset.top = event.pageY;
        }
      }
      dragElementOffset = $dragElement.offset();
      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
    }
    return elementOffset;
  },
  _initPosition: function(options) {
    var $dragElement = $(options.dragElement);
    var elementOffset = this._calculateElementOffset(options);
    if (elementOffset) {
      this._move(elementOffset, $dragElement);
    }
    this._startPosition = locate($dragElement);
  },
  _startAnimator: function() {
    if (!this._scrollAnimator.inProgress()) {
      this._scrollAnimator.start();
    }
  },
  _stopAnimator: function() {
    this._scrollAnimator.stop();
  },
  _addWidgetPrefix: function(className) {
    var componentName = this.NAME;
    return dasherize(componentName) + (className ? "-" + className : "");
  },
  _getItemsSelector: function() {
    return this.option("filter") || "";
  },
  _$content: function() {
    var $element = this.$element();
    var $wrapper = $element.children(".dx-template-wrapper");
    return $wrapper.length ? $wrapper : $element;
  },
  _attachEventHandlers: function() {
    if (this.option("disabled")) {
      return;
    }
    var $element = this._$content();
    var itemsSelector = this._getItemsSelector();
    var allowMoveByClick = this.option("allowMoveByClick");
    var data2 = {
      direction: this.option("dragDirection"),
      immediate: this.option("immediate"),
      checkDropTarget: ($target, event) => {
        var targetGroup = this.option("group");
        var sourceGroup = this._getSourceDraggable().option("group");
        var $scrollable = this._getScrollable($target);
        if (this._verticalScrollHelper.isOutsideScrollable($scrollable, event) || this._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
          return false;
        }
        return sourceGroup && sourceGroup === targetGroup;
      }
    };
    if (allowMoveByClick) {
      $element = this._getArea();
      eventsEngine.on($element, POINTERDOWN_EVENT_NAME, data2, this._pointerDownHandler.bind(this));
    }
    if (itemsSelector[0] === ">") {
      itemsSelector = itemsSelector.slice(1);
    }
    eventsEngine.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data2, this._dragStartHandler.bind(this));
    eventsEngine.on($element, DRAG_EVENT_NAME, data2, this._dragMoveHandler.bind(this));
    eventsEngine.on($element, DRAGEND_EVENT_NAME, data2, this._dragEndHandler.bind(this));
    eventsEngine.on($element, DRAG_ENTER_EVENT_NAME, data2, this._dragEnterHandler.bind(this));
    eventsEngine.on($element, DRAGEND_LEAVE_EVENT_NAME, data2, this._dragLeaveHandler.bind(this));
  },
  _dragElementIsCloned: function() {
    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS$1));
  },
  _getDragTemplateArgs: function($element, $container) {
    return {
      container: getPublicElement($container),
      model: {
        itemData: this.option("itemData"),
        itemElement: getPublicElement($element)
      }
    };
  },
  _createDragElement: function($element) {
    var result = $element;
    var clone = this.option("clone");
    var $container = this._getContainer();
    var template = this.option("dragTemplate");
    if (template) {
      template = this._getTemplate(template);
      result = $("<div>").appendTo($container);
      template.render(this._getDragTemplateArgs($element, result));
    } else if (clone) {
      result = $("<div>").appendTo($container);
      $element.clone().css({
        width: $element.css("width"),
        height: $element.css("height")
      }).appendTo(result);
    }
    return result.toggleClass(this._addWidgetPrefix(CLONE_CLASS$1), result.get(0) !== $element.get(0)).toggleClass("dx-rtl", this.option("rtlEnabled"));
  },
  _resetDragElement: function() {
    if (this._dragElementIsCloned()) {
      this._$dragElement.remove();
    } else {
      this._toggleDraggingClass(false);
    }
    this._$dragElement = null;
  },
  _resetSourceElement: function() {
    this._toggleDragSourceClass(false);
    this._$sourceElement = null;
  },
  _detachEventHandlers: function() {
    eventsEngine.off(this._$content(), "." + DRAGGABLE);
    eventsEngine.off(this._getArea(), "." + DRAGGABLE);
  },
  _move: function(position2, $element) {
    move($element || this._$dragElement, position2);
  },
  _getDraggableElement: function(e) {
    var $sourceElement = this._getSourceElement();
    if ($sourceElement) {
      return $sourceElement;
    }
    var allowMoveByClick = this.option("allowMoveByClick");
    if (allowMoveByClick) {
      return this.$element();
    }
    var $target = $(e && e.target);
    var itemsSelector = this._getItemsSelector();
    if (itemsSelector[0] === ">") {
      var $items = this._$content().find(itemsSelector);
      if (!$items.is($target)) {
        $target = $target.closest($items);
      }
    }
    return $target;
  },
  _getSourceElement: function() {
    var draggable = this._getSourceDraggable();
    return draggable._$sourceElement;
  },
  _pointerDownHandler: function(e) {
    if (needSkipEvent(e)) {
      return;
    }
    var position2 = {};
    var $element = this.$element();
    var dragDirection = this.option("dragDirection");
    if (dragDirection === "horizontal" || dragDirection === "both") {
      position2.left = e.pageX - $element.offset().left + locate($element).left - $element.width() / 2;
    }
    if (dragDirection === "vertical" || dragDirection === "both") {
      position2.top = e.pageY - $element.offset().top + locate($element).top - $element.height() / 2;
    }
    this._move(position2, $element);
    this._getAction("onDragMove")(this._getEventArgs(e));
  },
  _isValidElement: function(event, $element) {
    var handle = this.option("handle");
    var $target = $(event.originalEvent && event.originalEvent.target);
    if (handle && !$target.closest(handle).length) {
      return false;
    }
    if (!$element.length) {
      return false;
    }
    return !$element.is(".dx-state-disabled, .dx-state-disabled *");
  },
  _dragStartHandler: function(e) {
    var $element = this._getDraggableElement(e);
    if (this._$sourceElement) {
      return;
    }
    if (!this._isValidElement(e, $element)) {
      e.cancel = true;
      return;
    }
    var dragStartArgs = this._getDragStartArgs(e, $element);
    this._getAction("onDragStart")(dragStartArgs);
    if (dragStartArgs.cancel) {
      e.cancel = true;
      return;
    }
    this.option("itemData", dragStartArgs.itemData);
    this._setSourceDraggable();
    this._$sourceElement = $element;
    var initialOffset = $element.offset();
    var $dragElement = this._$dragElement = this._createDragElement($element);
    this._toggleDraggingClass(true);
    this._toggleDragSourceClass(true);
    this._setGestureCoverCursor($dragElement.children());
    var isFixedPosition = $dragElement.css("position") === "fixed";
    this._initPosition(extend({}, dragStartArgs, {
      dragElement: $dragElement.get(0),
      initialOffset: isFixedPosition && initialOffset
    }));
    var $area = this._getArea();
    var areaOffset = this._getAreaOffset($area);
    var boundOffset = this._getBoundOffset();
    var areaWidth = $area.outerWidth();
    var areaHeight = $area.outerHeight();
    var elementWidth = $dragElement.width();
    var elementHeight = $dragElement.height();
    var startOffset_left = $dragElement.offset().left - areaOffset.left, startOffset_top = $dragElement.offset().top - areaOffset.top;
    if ($area.length) {
      e.maxLeftOffset = startOffset_left - boundOffset.left;
      e.maxRightOffset = areaWidth - startOffset_left - elementWidth - boundOffset.right;
      e.maxTopOffset = startOffset_top - boundOffset.top;
      e.maxBottomOffset = areaHeight - startOffset_top - elementHeight - boundOffset.bottom;
    }
    if (this.option("autoScroll")) {
      this._startAnimator();
    }
  },
  _getAreaOffset: function($area) {
    var offset2 = $area && animationPosition.offset($area);
    return offset2 ? offset2 : {
      left: 0,
      top: 0
    };
  },
  _toggleDraggingClass: function(value2) {
    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix("dragging"), value2);
  },
  _toggleDragSourceClass: function(value2, $element) {
    var $sourceElement = $element || this._$sourceElement;
    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix("source"), value2);
  },
  _setGestureCoverCursor: function($element) {
    $(".".concat(GESTURE_COVER_CLASS)).css("cursor", $element.css("cursor"));
  },
  _getBoundOffset: function() {
    var boundOffset = this.option("boundOffset");
    if (isFunction$1(boundOffset)) {
      boundOffset = boundOffset.call(this);
    }
    return quadToObject(boundOffset);
  },
  _getArea: function() {
    var area = this.option("boundary");
    if (isFunction$1(area)) {
      area = area.call(this);
    }
    return $(area);
  },
  _getContainer: function() {
    var container = this.option("container");
    if (container === void 0) {
      container = value();
    }
    return $(container);
  },
  _dragMoveHandler: function(e, scrollBy) {
    this._dragMoveArgs = e;
    if (!this._$dragElement) {
      e.cancel = true;
      return;
    }
    var offset2 = e.offset;
    var startPosition = this._startPosition;
    this._move({
      left: startPosition.left + offset2.x,
      top: startPosition.top + offset2.y
    });
    if (!scrollBy) {
      this._updateScrollable(e);
    }
    var eventArgs = this._getEventArgs(e);
    this._getAction("onDragMove")(eventArgs);
    if (eventArgs.cancel === true) {
      return;
    }
    var targetDraggable2 = this._getTargetDraggable();
    targetDraggable2.dragMove(e, scrollBy);
  },
  _updateScrollable: function(e) {
    if (this.option("autoScroll")) {
      var mousePosition = getMousePosition(e);
      var allObjects = getElementsFromPoint(mousePosition.x, mousePosition.y);
      this._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
      this._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
    }
  },
  _getScrollable: function($element) {
    var $scrollable;
    $element.parents().toArray().some((parent) => {
      var $parent = $(parent);
      if (this._horizontalScrollHelper.isScrollable($parent) || this._verticalScrollHelper.isScrollable($parent)) {
        $scrollable = $parent;
        return true;
      }
    });
    return $scrollable;
  },
  _defaultActionArgs: function() {
    var args = this.callBase.apply(this, arguments);
    var component = this.option("component");
    if (component) {
      args.component = component;
      args.element = component.element();
    }
    return args;
  },
  _getEventArgs: function(e) {
    var sourceDraggable2 = this._getSourceDraggable();
    var targetDraggable2 = this._getTargetDraggable();
    return {
      event: e,
      itemData: sourceDraggable2.option("itemData"),
      itemElement: getPublicElement(sourceDraggable2._$sourceElement),
      fromComponent: sourceDraggable2.option("component") || sourceDraggable2,
      toComponent: targetDraggable2.option("component") || targetDraggable2,
      fromData: sourceDraggable2.option("data"),
      toData: targetDraggable2.option("data")
    };
  },
  _getDragStartArgs: function(e, $itemElement) {
    var args = this._getEventArgs(e);
    return {
      event: args.event,
      itemData: args.itemData,
      itemElement: $itemElement,
      fromData: args.fromData
    };
  },
  _revertItemToInitialPosition: function() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  },
  _dragEndHandler: function(e) {
    var d = new Deferred();
    var dragEndEventArgs = this._getEventArgs(e);
    var dropEventArgs = this._getEventArgs(e);
    var targetDraggable2 = this._getTargetDraggable();
    var needRevertPosition = true;
    try {
      this._getAction("onDragEnd")(dragEndEventArgs);
    } finally {
      when(fromPromise(dragEndEventArgs.cancel)).done((cancel2) => {
        if (!cancel2) {
          if (targetDraggable2 !== this) {
            targetDraggable2._getAction("onDrop")(dropEventArgs);
          }
          if (!dropEventArgs.cancel) {
            needRevertPosition = false;
            when(fromPromise(targetDraggable2.dragEnd(dragEndEventArgs))).always(d.resolve);
            return;
          }
        }
        d.resolve();
      }).fail(d.resolve);
      d.done(() => {
        if (needRevertPosition) {
          this._revertItemToInitialPosition();
        }
        this.reset();
        targetDraggable2.reset();
        this._stopAnimator();
        this._horizontalScrollHelper.reset();
        this._verticalScrollHelper.reset();
        this._resetDragElement();
        this._resetSourceElement();
        this._resetTargetDraggable();
        this._resetSourceDraggable();
      });
    }
  },
  _isTargetOverAnotherDraggable: function(e) {
    var sourceDraggable2 = this._getSourceDraggable();
    if (this === sourceDraggable2) {
      return false;
    }
    var $dragElement = sourceDraggable2._$dragElement;
    var $sourceDraggableElement = sourceDraggable2.$element();
    var $targetDraggableElement = this.$element();
    var mousePosition = getMousePosition(e);
    var elements = getElementsFromPoint(mousePosition.x, mousePosition.y);
    var firstWidgetElement = elements.filter((element) => {
      var $element = $(element);
      if ($element.hasClass(this._addWidgetPrefix())) {
        return !$element.closest($dragElement).length;
      }
    })[0];
    var $sourceElement = this._getSourceElement();
    var isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
    var isTargetOverNestedDraggable = $(firstWidgetElement).closest($sourceElement).length;
    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
  },
  _dragEnterHandler: function(e) {
    this._fireDragEnterEvent(e);
    if (this._isTargetOverAnotherDraggable(e)) {
      this._setTargetDraggable();
    }
    var sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragEnter(e);
  },
  _dragLeaveHandler: function(e) {
    this._fireDragLeaveEvent(e);
    this._resetTargetDraggable();
    if (this !== this._getSourceDraggable()) {
      this.reset();
    }
    var sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragLeave(e);
  },
  _getAction: function(name2) {
    return this["_" + name2 + "Action"] || this._createActionByOption(name2);
  },
  _getAnonymousTemplateName: function() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initTemplates: function() {
    if (!this.option("contentTemplate")) {
      return;
    }
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    this.callBase.apply(this, arguments);
  },
  _render: function() {
    this.callBase();
    this.$element().addClass(this._addWidgetPrefix());
    var transclude = this._templateManager.anonymousTemplateName === this.option("contentTemplate");
    var template = this._getTemplateByOption("contentTemplate");
    if (template) {
      $(template.render({
        container: this.element(),
        transclude
      }));
    }
  },
  _optionChanged: function(args) {
    var name2 = args.name;
    switch (name2) {
      case "onDragStart":
      case "onDragMove":
      case "onDragEnd":
      case "onDrop":
      case "onDragEnter":
      case "onDragLeave":
        this["_" + name2 + "Action"] = this._createActionByOption(name2);
        break;
      case "dragTemplate":
      case "contentTemplate":
      case "container":
      case "clone":
        break;
      case "allowMoveByClick":
      case "dragDirection":
      case "disabled":
      case "boundary":
      case "filter":
      case "immediate":
        this._resetDragElement();
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "autoScroll":
        this._verticalScrollHelper.reset();
        this._horizontalScrollHelper.reset();
        break;
      case "scrollSensitivity":
      case "scrollSpeed":
      case "boundOffset":
      case "handle":
      case "group":
      case "data":
      case "itemData":
        break;
      default:
        this.callBase(args);
    }
  },
  _getTargetDraggable: function() {
    return targetDraggable || this;
  },
  _getSourceDraggable: function() {
    return sourceDraggable || this;
  },
  _setTargetDraggable: function() {
    var currentGroup = this.option("group");
    var sourceDraggable2 = this._getSourceDraggable();
    if (currentGroup && currentGroup === sourceDraggable2.option("group")) {
      targetDraggable = this;
    }
  },
  _setSourceDraggable: function() {
    sourceDraggable = this;
  },
  _resetSourceDraggable: function() {
    sourceDraggable = null;
  },
  _resetTargetDraggable: function() {
    targetDraggable = null;
  },
  _dispose: function() {
    this.callBase();
    this._detachEventHandlers();
    this._resetDragElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
    this._$sourceElement = null;
    this._stopAnimator();
  },
  _fireDragEnterEvent: function(sourceEvent) {
    var args = this._getEventArgs(sourceEvent);
    this._getAction("onDragEnter")(args);
  },
  _fireDragLeaveEvent: function(sourceEvent) {
    var args = this._getEventArgs(sourceEvent);
    this._getAction("onDragLeave")(args);
  }
});
registerComponent(DRAGGABLE, Draggable);
var window$3 = getWindow();
var SORTABLE = "dxSortable";
var PLACEHOLDER_CLASS = "placeholder";
var CLONE_CLASS = "clone";
var isElementVisible = (itemElement) => $(itemElement).is(":visible");
var animate = (element, config2) => {
  var _config$to, _config$to2;
  if (!element) {
    return;
  }
  var left = ((_config$to = config2.to) === null || _config$to === void 0 ? void 0 : _config$to.left) || 0;
  var top = ((_config$to2 = config2.to) === null || _config$to2 === void 0 ? void 0 : _config$to2.top) || 0;
  element.style.transform = "translate(".concat(left, "px,").concat(top, "px)");
  element.style.transition = "transform ".concat(config2.duration, "ms ").concat(config2.easing);
};
var stopAnimation = (element) => {
  if (!element) {
    return;
  }
  element.style.transform = "";
  element.style.transition = "";
};
function getScrollableBoundary($scrollable) {
  var offset2 = $scrollable.offset();
  var style = $scrollable[0].style;
  var paddingLeft = parseFloat(style.paddingLeft) || 0;
  var paddingRight = parseFloat(style.paddingRight) || 0;
  var paddingTop = parseFloat(style.paddingTop) || 0;
  var width = $scrollable[0].clientWidth - (paddingLeft + paddingRight);
  var height = $scrollable.height();
  var left = offset2.left + paddingLeft;
  var top = offset2.top + paddingTop;
  return {
    left,
    right: left + width,
    top,
    bottom: top + height
  };
}
var Sortable$1 = Draggable.inherit({
  _init: function() {
    this.callBase();
    this._sourceScrollHandler = this._handleSourceScroll.bind(this);
    this._sourceScrollableInfo = null;
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      clone: true,
      filter: "> *",
      itemOrientation: "vertical",
      dropFeedbackMode: "push",
      allowDropInsideItem: false,
      allowReordering: true,
      moveItemOnDrop: false,
      onDragChange: null,
      onAdd: null,
      onRemove: null,
      onReorder: null,
      onPlaceholderPrepared: null,
      animation: {
        type: "slide",
        duration: 300,
        easing: "ease"
      },
      fromIndex: null,
      toIndex: null,
      dropInsideItem: false,
      itemPoints: null,
      fromIndexOffset: 0,
      offset: 0,
      autoUpdate: false,
      draggableElementSize: 0
    });
  },
  reset: function() {
    this.option({
      dropInsideItem: false,
      toIndex: null,
      fromIndex: null,
      itemPoints: null,
      fromIndexOffset: 0,
      draggableElementSize: 0
    });
    if (this._$placeholderElement) {
      this._$placeholderElement.remove();
    }
    this._$placeholderElement = null;
    if (!this._isIndicateMode() && this._$modifiedItem) {
      this._$modifiedItem.css("marginBottom", this._modifiedItemMargin);
      this._$modifiedItem = null;
    }
  },
  _getPrevVisibleItem: function(items, index2) {
    return items.slice(0, index2).reverse().filter(isElementVisible)[0];
  },
  _dragStartHandler: function(e) {
    this.callBase.apply(this, arguments);
    if (e.cancel === true) {
      return;
    }
    var $sourceElement = this._getSourceElement();
    this._updateItemPoints();
    this._subscribeToSourceScroll(e);
    this.option("fromIndex", this._getElementIndex($sourceElement));
    this.option("fromIndexOffset", this.option("offset"));
  },
  _dragEndHandler: function() {
    this.callBase.apply(this, arguments);
    this._unsubscribeFromSourceScroll();
  },
  _subscribeToSourceScroll: function(e) {
    var $scrollable = this._getScrollable($(e.target));
    if ($scrollable) {
      this._sourceScrollableInfo = {
        element: $scrollable,
        scrollLeft: $scrollable.scrollLeft(),
        scrollTop: $scrollable.scrollTop()
      };
      eventsEngine.on($scrollable, "scroll", this._sourceScrollHandler);
    }
  },
  _unsubscribeFromSourceScroll: function() {
    if (this._sourceScrollableInfo) {
      eventsEngine.off(this._sourceScrollableInfo.element, "scroll", this._sourceScrollHandler);
      this._sourceScrollableInfo = null;
    }
  },
  _handleSourceScroll: function(e) {
    var sourceScrollableInfo = this._sourceScrollableInfo;
    if (sourceScrollableInfo) {
      ["scrollLeft", "scrollTop"].forEach((scrollProp) => {
        if (e.target[scrollProp] !== sourceScrollableInfo[scrollProp]) {
          var scrollBy = e.target[scrollProp] - sourceScrollableInfo[scrollProp];
          this._correctItemPoints(scrollBy);
          sourceScrollableInfo[scrollProp] = e.target[scrollProp];
        }
      });
    }
  },
  _dragEnterHandler: function() {
    this.callBase.apply(this, arguments);
    if (this === this._getSourceDraggable()) {
      return;
    }
    this._updateItemPoints();
    this.option("fromIndex", -1);
    if (!this._isIndicateMode()) {
      var itemPoints = this.option("itemPoints");
      var lastItemPoint = itemPoints[itemPoints.length - 1];
      if (lastItemPoint) {
        var $element = this.$element();
        var $sourceElement = this._getSourceElement();
        var isVertical = this._isVerticalOrientation();
        var sourceElementSize = isVertical ? $sourceElement.outerHeight(true) : $sourceElement.outerWidth(true);
        var scrollSize = $element.get(0)[isVertical ? "scrollHeight" : "scrollWidth"];
        var scrollPosition = $element.get(0)[isVertical ? "scrollTop" : "scrollLeft"];
        var positionProp = isVertical ? "top" : "left";
        var lastPointPosition = lastItemPoint[positionProp];
        var elementPosition = $element.offset()[positionProp];
        var freeSize = elementPosition + scrollSize - scrollPosition - lastPointPosition;
        if (freeSize < sourceElementSize) {
          if (isVertical) {
            var items = this._getItems();
            var $lastItem = $(this._getPrevVisibleItem(items));
            this._$modifiedItem = $lastItem;
            this._modifiedItemMargin = $lastItem.get(0).style.marginBottom;
            $lastItem.css("marginBottom", sourceElementSize - freeSize);
            var $sortable = $lastItem.closest(".dx-sortable");
            var sortable = $sortable.data("dxScrollable") || $sortable.data("dxScrollView");
            sortable && sortable.update();
          }
        }
      }
    }
  },
  dragEnter: function() {
    if (this !== this._getTargetDraggable()) {
      this.option("toIndex", -1);
    }
  },
  dragLeave: function() {
    if (this !== this._getTargetDraggable()) {
      this.option("toIndex", this.option("fromIndex"));
    }
  },
  _isInsideTargetDraggable: function(event) {
    var $targetDraggable = this._getTargetDraggable().$element();
    var $scrollable = this._getScrollable($targetDraggable);
    if ($scrollable) {
      var {
        left,
        right,
        top,
        bottom
      } = getScrollableBoundary($scrollable);
      var validX = left <= event.pageX && event.pageX <= right;
      var validY = top <= event.pageY && event.pageY <= bottom;
      return validY && validX;
    }
    return true;
  },
  dragEnd: function(sourceEvent) {
    var $sourceElement = this._getSourceElement();
    var sourceDraggable2 = this._getSourceDraggable();
    var isSourceDraggable = sourceDraggable2.NAME !== this.NAME;
    var toIndex = this.option("toIndex");
    var isInsideTargetDraggable = this._isInsideTargetDraggable(sourceEvent.event);
    if (toIndex !== null && toIndex >= 0 && isInsideTargetDraggable) {
      var cancelAdd;
      var cancelRemove;
      if (sourceDraggable2 !== this) {
        cancelAdd = this._fireAddEvent(sourceEvent);
        if (!cancelAdd) {
          cancelRemove = this._fireRemoveEvent(sourceEvent);
        }
      }
      if (isSourceDraggable) {
        resetPosition($sourceElement);
      }
      if (this.option("moveItemOnDrop")) {
        !cancelAdd && this._moveItem($sourceElement, toIndex, cancelRemove);
      }
      if (sourceDraggable2 === this) {
        return this._fireReorderEvent(sourceEvent);
      }
    }
    return new Deferred().resolve();
  },
  dragMove: function(e) {
    var itemPoints = this.option("itemPoints");
    if (!itemPoints) {
      return;
    }
    var isVertical = this._isVerticalOrientation();
    var axisName = isVertical ? "top" : "left";
    var cursorPosition = isVertical ? e.pageY : e.pageX;
    var rtlEnabled = this.option("rtlEnabled");
    var itemPoint;
    for (var i = itemPoints.length - 1; i >= 0; i--) {
      var centerPosition = itemPoints[i + 1] && (itemPoints[i][axisName] + itemPoints[i + 1][axisName]) / 2;
      if ((!isVertical && rtlEnabled ? cursorPosition > centerPosition : centerPosition > cursorPosition) || centerPosition === void 0) {
        itemPoint = itemPoints[i];
      } else {
        break;
      }
    }
    if (itemPoint) {
      this._updatePlaceholderPosition(e, itemPoint);
      if (this._verticalScrollHelper.isScrolling() && this._isIndicateMode()) {
        this._movePlaceholder();
      }
    }
  },
  _isIndicateMode: function() {
    return this.option("dropFeedbackMode") === "indicate" || this.option("allowDropInsideItem");
  },
  _createPlaceholder: function() {
    var $placeholderContainer;
    if (this._isIndicateMode()) {
      $placeholderContainer = $("<div>").addClass(this._addWidgetPrefix(PLACEHOLDER_CLASS)).insertBefore(this._getSourceDraggable()._$dragElement);
    }
    this._$placeholderElement = $placeholderContainer;
    return $placeholderContainer;
  },
  _getItems: function() {
    var itemsSelector = this._getItemsSelector();
    return this._$content().find(itemsSelector).not("." + this._addWidgetPrefix(PLACEHOLDER_CLASS)).not("." + this._addWidgetPrefix(CLONE_CLASS)).toArray();
  },
  _allowReordering: function() {
    var sourceDraggable2 = this._getSourceDraggable();
    var targetDraggable2 = this._getTargetDraggable();
    return sourceDraggable2 !== targetDraggable2 || this.option("allowReordering");
  },
  _isValidPoint: function(visibleIndex, draggableVisibleIndex, dropInsideItem) {
    var allowDropInsideItem = this.option("allowDropInsideItem");
    var allowReordering = dropInsideItem || this._allowReordering();
    if (!allowReordering && (visibleIndex !== 0 || !allowDropInsideItem)) {
      return false;
    }
    if (!this._isIndicateMode()) {
      return true;
    }
    return draggableVisibleIndex === -1 || visibleIndex !== draggableVisibleIndex && (dropInsideItem || visibleIndex !== draggableVisibleIndex + 1);
  },
  _getItemPoints: function() {
    var result = [];
    var $item;
    var offset2;
    var itemWidth;
    var rtlEnabled = this.option("rtlEnabled");
    var isVertical = this._isVerticalOrientation();
    var itemElements = this._getItems();
    var visibleItemElements = itemElements.filter(isElementVisible);
    var visibleItemCount = visibleItemElements.length;
    var $draggableItem = this._getDraggableElement();
    var draggableVisibleIndex = visibleItemElements.indexOf($draggableItem.get(0));
    if (visibleItemCount) {
      for (var i = 0; i <= visibleItemCount; i++) {
        var needCorrectLeftPosition = !isVertical && rtlEnabled ^ i === visibleItemCount;
        var needCorrectTopPosition = isVertical && i === visibleItemCount;
        if (i < visibleItemCount) {
          $item = $(visibleItemElements[i]);
          offset2 = $item.offset();
          itemWidth = $item.outerWidth();
        }
        result.push({
          dropInsideItem: false,
          left: offset2.left + (needCorrectLeftPosition ? itemWidth : 0),
          top: offset2.top + (needCorrectTopPosition ? result[i - 1].height : 0),
          index: i === visibleItemCount ? itemElements.length : itemElements.indexOf($item.get(0)),
          $item,
          width: $item.outerWidth(),
          height: $item.outerHeight(),
          isValid: this._isValidPoint(i, draggableVisibleIndex)
        });
      }
      if (this.option("allowDropInsideItem")) {
        var points = result;
        result = [];
        for (var _i = 0; _i < points.length; _i++) {
          result.push(points[_i]);
          if (points[_i + 1]) {
            result.push(extend({}, points[_i], {
              dropInsideItem: true,
              top: Math.floor((points[_i].top + points[_i + 1].top) / 2),
              left: Math.floor((points[_i].left + points[_i + 1].left) / 2),
              isValid: this._isValidPoint(_i, draggableVisibleIndex, true)
            }));
          }
        }
      }
    } else {
      result.push({
        dropInsideItem: false,
        index: 0,
        isValid: true
      });
    }
    return result;
  },
  _updateItemPoints: function(forceUpdate) {
    if (forceUpdate || this.option("autoUpdate") || !this.option("itemPoints")) {
      this.option("itemPoints", this._getItemPoints());
    }
  },
  _correctItemPoints: function(scrollBy) {
    var itemPoints = this.option("itemPoints");
    if (scrollBy && itemPoints && !this.option("autoUpdate")) {
      var isVertical = this._isVerticalOrientation();
      var positionPropName = isVertical ? "top" : "left";
      itemPoints.forEach((itemPoint) => {
        itemPoint[positionPropName] -= scrollBy;
      });
    }
  },
  _getElementIndex: function($itemElement) {
    return this._getItems().indexOf($itemElement.get(0));
  },
  _getDragTemplateArgs: function($element) {
    var args = this.callBase.apply(this, arguments);
    args.model.fromIndex = this._getElementIndex($element);
    return args;
  },
  _togglePlaceholder: function(value2) {
    this._$placeholderElement && this._$placeholderElement.toggle(value2);
  },
  _isVerticalOrientation: function() {
    return this.option("itemOrientation") === "vertical";
  },
  _normalizeToIndex: function(toIndex, dropInsideItem) {
    var isAnotherDraggable = this._getSourceDraggable() !== this._getTargetDraggable();
    var fromIndex = this.option("fromIndex");
    if (toIndex === null) {
      return fromIndex;
    }
    return Math.max(isAnotherDraggable || fromIndex >= toIndex || dropInsideItem ? toIndex : toIndex - 1, 0);
  },
  _updatePlaceholderPosition: function(e, itemPoint) {
    var sourceDraggable2 = this._getSourceDraggable();
    var toIndex = this._normalizeToIndex(itemPoint.index, itemPoint.dropInsideItem);
    var eventArgs = extend(this._getEventArgs(e), {
      toIndex,
      dropInsideItem: itemPoint.dropInsideItem
    });
    itemPoint.isValid && this._getAction("onDragChange")(eventArgs);
    if (eventArgs.cancel || !itemPoint.isValid) {
      if (!itemPoint.isValid) {
        this.option({
          dropInsideItem: false,
          toIndex: null
        });
      }
      return;
    }
    this.option({
      dropInsideItem: itemPoint.dropInsideItem,
      toIndex: itemPoint.index
    });
    this._getAction("onPlaceholderPrepared")(extend(this._getEventArgs(e), {
      placeholderElement: getPublicElement(this._$placeholderElement),
      dragElement: getPublicElement(sourceDraggable2._$dragElement)
    }));
    this._updateItemPoints();
  },
  _makeWidthCorrection: function($item, width) {
    this._$scrollable = this._getScrollable($item);
    if (this._$scrollable && this._$scrollable.width() < width) {
      var scrollableWidth = this._$scrollable.width();
      var offsetLeft = $item.offset().left - this._$scrollable.offset().left;
      var offsetRight = scrollableWidth - $item.outerWidth() - offsetLeft;
      if (offsetLeft > 0) {
        width = scrollableWidth - offsetLeft;
      } else if (offsetRight > 0) {
        width = scrollableWidth - offsetRight;
      } else {
        width = scrollableWidth;
      }
    }
    return width;
  },
  _updatePlaceholderSizes: function($placeholderElement, itemElement) {
    var dropInsideItem = this.option("dropInsideItem");
    var $item = $(itemElement);
    var isVertical = this._isVerticalOrientation();
    var width = "";
    var height = "";
    $placeholderElement.toggleClass(this._addWidgetPrefix("placeholder-inside"), dropInsideItem);
    if (isVertical || dropInsideItem) {
      width = $item.outerWidth();
    }
    if (!isVertical || dropInsideItem) {
      height = $item.outerHeight();
    }
    width = this._makeWidthCorrection($item, width);
    $placeholderElement.css({
      width,
      height
    });
  },
  _moveItem: function($itemElement, index2, cancelRemove) {
    var $prevTargetItemElement;
    var $itemElements = this._getItems();
    var $targetItemElement = $itemElements[index2];
    var sourceDraggable2 = this._getSourceDraggable();
    if (cancelRemove) {
      $itemElement = $itemElement.clone();
      sourceDraggable2._toggleDragSourceClass(false, $itemElement);
    }
    if (!$targetItemElement) {
      $prevTargetItemElement = $itemElements[index2 - 1];
    }
    this._moveItemCore($itemElement, $targetItemElement, $prevTargetItemElement);
  },
  _moveItemCore: function($targetItem, item, prevItem) {
    if (!item && !prevItem) {
      $targetItem.appendTo(this.$element());
    } else if (prevItem) {
      $targetItem.insertAfter($(prevItem));
    } else {
      $targetItem.insertBefore($(item));
    }
  },
  _getDragStartArgs: function(e, $itemElement) {
    return extend(this.callBase.apply(this, arguments), {
      fromIndex: this._getElementIndex($itemElement)
    });
  },
  _getEventArgs: function(e) {
    var sourceDraggable2 = this._getSourceDraggable();
    var targetDraggable2 = this._getTargetDraggable();
    var dropInsideItem = targetDraggable2.option("dropInsideItem");
    return extend(this.callBase.apply(this, arguments), {
      fromIndex: sourceDraggable2.option("fromIndex"),
      toIndex: this._normalizeToIndex(targetDraggable2.option("toIndex"), dropInsideItem),
      dropInsideItem
    });
  },
  _optionChanged: function(args) {
    var name2 = args.name;
    switch (name2) {
      case "onDragChange":
      case "onPlaceholderPrepared":
      case "onAdd":
      case "onRemove":
      case "onReorder":
        this["_" + name2 + "Action"] = this._createActionByOption(name2);
        break;
      case "itemOrientation":
      case "allowDropInsideItem":
      case "moveItemOnDrop":
      case "dropFeedbackMode":
      case "itemPoints":
      case "animation":
      case "allowReordering":
      case "fromIndexOffset":
      case "offset":
      case "draggableElementSize":
      case "autoUpdate":
        break;
      case "fromIndex":
        [false, true].forEach((isDragSource) => {
          var fromIndex = isDragSource ? args.value : args.previousValue;
          if (fromIndex !== null) {
            var $fromElement = $(this._getItems()[fromIndex]);
            this._toggleDragSourceClass(isDragSource, $fromElement);
          }
        });
        break;
      case "dropInsideItem":
        this._optionChangedDropInsideItem(args);
        break;
      case "toIndex":
        this._optionChangedToIndex(args);
        break;
      default:
        this.callBase(args);
    }
  },
  _optionChangedDropInsideItem: function() {
    if (this._isIndicateMode() && this._$placeholderElement) {
      this._movePlaceholder();
    }
  },
  _isPositionVisible: function(position2) {
    var $element = this.$element();
    var scrollContainer;
    if ($element.css("overflow") !== "hidden") {
      scrollContainer = $element.get(0);
    } else {
      $element.parents().each(function() {
        if ($(this).css("overflow") !== "visible") {
          scrollContainer = this;
          return false;
        }
      });
    }
    if (scrollContainer) {
      var clientRect = getBoundingRect(scrollContainer);
      var isVerticalOrientation = this._isVerticalOrientation();
      var start = isVerticalOrientation ? "top" : "left";
      var end = isVerticalOrientation ? "bottom" : "right";
      var pageOffset = isVerticalOrientation ? window$3.pageYOffset : window$3.pageXOffset;
      if (position2[start] < clientRect[start] + pageOffset || position2[start] > clientRect[end] + pageOffset) {
        return false;
      }
    }
    return true;
  },
  _optionChangedToIndex: function(args) {
    var toIndex = args.value;
    if (this._isIndicateMode()) {
      var showPlaceholder = toIndex !== null && toIndex >= 0;
      this._togglePlaceholder(showPlaceholder);
      if (showPlaceholder) {
        this._movePlaceholder();
      }
    } else {
      this._moveItems(args.previousValue, args.value, args.fullUpdate);
    }
  },
  update: function() {
    if (this.option("fromIndex") === null && this.option("toIndex") === null) {
      return;
    }
    this._updateItemPoints(true);
    this._updateDragSourceClass();
    var toIndex = this.option("toIndex");
    this._optionChangedToIndex({
      value: toIndex,
      fullUpdate: true
    });
  },
  _updateDragSourceClass: function() {
    var fromIndex = this._getActualFromIndex();
    var $fromElement = $(this._getItems()[fromIndex]);
    if ($fromElement.length) {
      this._$sourceElement = $fromElement;
      this._toggleDragSourceClass(true, $fromElement);
    }
  },
  _makeLeftCorrection: function(left, leftMargin) {
    var $scrollable = this._$scrollable;
    if ($scrollable && this._isVerticalOrientation() && $scrollable.scrollLeft() > leftMargin) {
      left += $scrollable.scrollLeft() - leftMargin;
    }
    return left;
  },
  _movePlaceholder: function() {
    var $placeholderElement = this._$placeholderElement || this._createPlaceholder();
    var items = this._getItems();
    var toIndex = this.option("toIndex");
    var isVerticalOrientation = this._isVerticalOrientation();
    var rtlEnabled = this.option("rtlEnabled");
    var dropInsideItem = this.option("dropInsideItem");
    var position2 = null;
    var leftMargin = 0;
    var itemElement = items[toIndex];
    if (itemElement) {
      var $itemElement = $(itemElement);
      position2 = $itemElement.offset();
      leftMargin = parseFloat($itemElement.css("marginLeft"));
      if (!isVerticalOrientation && rtlEnabled && !dropInsideItem) {
        position2.left += $itemElement.outerWidth(true);
      }
    } else {
      var prevVisibleItemElement = itemElement = this._getPrevVisibleItem(items, toIndex);
      if (prevVisibleItemElement) {
        position2 = $(prevVisibleItemElement).offset();
        if (isVerticalOrientation) {
          position2.top += $(prevVisibleItemElement).outerHeight(true);
        } else if (!rtlEnabled) {
          position2.left += $(prevVisibleItemElement).outerWidth(true);
        }
      }
    }
    this._updatePlaceholderSizes($placeholderElement, itemElement);
    if (position2 && !this._isPositionVisible(position2)) {
      position2 = null;
    }
    if (position2) {
      position2.left = this._makeLeftCorrection(position2.left, leftMargin);
      this._move(position2, $placeholderElement);
    }
    $placeholderElement.toggle(!!position2);
  },
  _getPositions: function(items, elementSize, fromIndex, toIndex) {
    var positions = [];
    for (var i = 0; i < items.length; i++) {
      var position2 = 0;
      if (toIndex === null || fromIndex === null) {
        positions.push(position2);
        continue;
      }
      if (fromIndex === -1) {
        if (i >= toIndex) {
          position2 = elementSize;
        }
      } else if (toIndex === -1) {
        if (i > fromIndex) {
          position2 = -elementSize;
        }
      } else if (fromIndex < toIndex) {
        if (i > fromIndex && i < toIndex) {
          position2 = -elementSize;
        }
      } else if (fromIndex > toIndex) {
        if (i >= toIndex && i < fromIndex) {
          position2 = elementSize;
        }
      }
      positions.push(position2);
    }
    return positions;
  },
  _getDraggableElementSize: function(isVerticalOrientation) {
    var $draggableItem = this._getDraggableElement();
    var size = this.option("draggableElementSize");
    if (!size) {
      size = isVerticalOrientation ? ($draggableItem.outerHeight() + $draggableItem.outerHeight(true)) / 2 : ($draggableItem.outerWidth() + $draggableItem.outerWidth(true)) / 2;
      if (!this.option("autoUpdate")) {
        this.option("draggableElementSize", size);
      }
    }
    return size;
  },
  _getActualFromIndex: function() {
    var {
      fromIndex,
      fromIndexOffset,
      offset: offset2
    } = this.option();
    return fromIndex == null ? null : fromIndex + fromIndexOffset - offset2;
  },
  _moveItems: function(prevToIndex, toIndex, fullUpdate) {
    var fromIndex = this._getActualFromIndex();
    var isVerticalOrientation = this._isVerticalOrientation();
    var positionPropName = isVerticalOrientation ? "top" : "left";
    var elementSize = this._getDraggableElementSize(isVerticalOrientation);
    var items = this._getItems();
    var prevPositions = this._getPositions(items, elementSize, fromIndex, prevToIndex);
    var positions = this._getPositions(items, elementSize, fromIndex, toIndex);
    var animationConfig = this.option("animation");
    var rtlEnabled = this.option("rtlEnabled");
    for (var i = 0; i < items.length; i++) {
      var itemElement = items[i];
      var prevPosition = prevPositions[i];
      var position2 = positions[i];
      if (toIndex === null || fromIndex === null) {
        stopAnimation(itemElement);
      } else if (prevPosition !== position2 || fullUpdate && position2) {
        animate(itemElement, extend({}, animationConfig, {
          to: {
            [positionPropName]: !isVerticalOrientation && rtlEnabled ? -position2 : position2
          }
        }));
      }
    }
  },
  _toggleDragSourceClass: function(value2, $element) {
    var $sourceElement = $element || this._$sourceElement;
    this.callBase.apply(this, arguments);
    if (!this._isIndicateMode()) {
      $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix("source-hidden"), value2);
    }
  },
  _dispose: function() {
    this.reset();
    this.callBase();
  },
  _fireAddEvent: function(sourceEvent) {
    var args = this._getEventArgs(sourceEvent);
    this._getAction("onAdd")(args);
    return args.cancel;
  },
  _fireRemoveEvent: function(sourceEvent) {
    var sourceDraggable2 = this._getSourceDraggable();
    var args = this._getEventArgs(sourceEvent);
    sourceDraggable2._getAction("onRemove")(args);
    return args.cancel;
  },
  _fireReorderEvent: function(sourceEvent) {
    var args = this._getEventArgs(sourceEvent);
    this._getAction("onReorder")(args);
    return args.promise || new Deferred().resolve();
  }
});
registerComponent(SORTABLE, Sortable$1);
var REORDER_HANDLE_CONTAINER_CLASS = "dx-list-reorder-handle-container";
var REORDER_HANDLE_CLASS = "dx-list-reorder-handle";
var REORDERING_ITEM_GHOST_CLASS = "dx-list-item-ghost-reordering";
var STATE_HOVER_CLASS = "dx-state-hover";
register("reorder", "default", EditDecorator.inherit({
  _init: function() {
    var list = this._list;
    this._groupedEnabled = this._list.option("grouped");
    this._lockedDrag = false;
    var filter = this._groupedEnabled ? "> .dx-list-group > .dx-list-group-body > .dx-list-item" : "> .dx-list-item";
    this._sortable = list._createComponent(list._scrollView.content(), Sortable$1, extend({
      component: list,
      contentTemplate: null,
      allowReordering: false,
      filter,
      container: list.$element(),
      dragDirection: list.option("itemDragging.group") ? "both" : "vertical",
      handle: ".".concat(REORDER_HANDLE_CLASS),
      dragTemplate: this._dragTemplate,
      onDragStart: this._dragStartHandler.bind(this),
      onDragChange: this._dragChangeHandler.bind(this),
      onReorder: this._reorderHandler.bind(this)
    }, list.option("itemDragging")));
  },
  afterRender: function() {
    this._sortable.update();
  },
  _dragTemplate: function(e) {
    return $(e.itemElement).clone().width($(e.itemElement).width()).addClass(REORDERING_ITEM_GHOST_CLASS).addClass(STATE_HOVER_CLASS);
  },
  _dragStartHandler: function(e) {
    if (this._lockedDrag) {
      e.cancel = true;
      return;
    }
  },
  _dragChangeHandler: function(e) {
    if (this._groupedEnabled && !this._sameParent(e.fromIndex, e.toIndex)) {
      e.cancel = true;
      return;
    }
  },
  _sameParent: function(fromIndex, toIndex) {
    var $dragging = this._list.getItemElementByFlatIndex(fromIndex);
    var $over = this._list.getItemElementByFlatIndex(toIndex);
    return $over.parent().get(0) === $dragging.parent().get(0);
  },
  _reorderHandler: function(e) {
    var $targetElement = this._list.getItemElementByFlatIndex(e.toIndex);
    this._list.reorderItem($(e.itemElement), $targetElement);
  },
  afterBag: function(config2) {
    var $handle = $("<div>").addClass(REORDER_HANDLE_CLASS);
    eventsEngine.on($handle, "dxpointerdown", (e) => {
      this._lockedDrag = !isMouseEvent(e);
    });
    eventsEngine.on($handle, "dxhold", {
      timeout: 30
    }, (e) => {
      e.cancel = true;
      this._lockedDrag = false;
    });
    config2.$container.addClass(REORDER_HANDLE_CONTAINER_CLASS).append($handle);
  }
}));
var editOptionsRegistry = [];
var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
  editOptionsRegistry.push({
    enabled: enabledFunc,
    decoratorType: decoratorTypeFunc,
    decoratorSubType: decoratorSubTypeFunc
  });
};
registerOption(function() {
  return this.option("menuItems").length;
}, function() {
  return "menu";
}, function() {
  return this.option("menuMode");
});
registerOption(function() {
  return !this.option("menuItems").length && this.option("allowItemDeleting");
}, function() {
  var mode = this.option("itemDeleteMode");
  return mode === "toggle" || mode === "slideButton" || mode === "swipe" || mode === "static" ? "delete" : "menu";
}, function() {
  var mode = this.option("itemDeleteMode");
  if (mode === "slideItem") {
    mode = "slide";
  }
  if (mode === "hold") {
    mode = "context";
  }
  return mode;
});
registerOption(function() {
  return this.option("selectionMode") !== "none" && this.option("showSelectionControls");
}, function() {
  return "selection";
}, function() {
  return "default";
});
registerOption(function() {
  return this.option("itemDragging.allowReordering") || this.option("itemDragging.allowDropInsideItem") || this.option("itemDragging.group");
}, function() {
  return "reorder";
}, function() {
  return "default";
});
var LIST_ITEM_BEFORE_BAG_CLASS = "dx-list-item-before-bag";
var LIST_ITEM_AFTER_BAG_CLASS = "dx-list-item-after-bag";
var DECORATOR_BEFORE_BAG_CREATE_METHOD = "beforeBag";
var DECORATOR_AFTER_BAG_CREATE_METHOD = "afterBag";
var DECORATOR_MODIFY_ELEMENT_METHOD = "modifyElement";
var DECORATOR_AFTER_RENDER_METHOD = "afterRender";
var DECORATOR_GET_EXCLUDED_SELECTORS_METHOD = "getExcludedSelectors";
var EditProvider = classImpl.inherit({
  ctor: function(list) {
    this._list = list;
    this._fetchRequiredDecorators();
  },
  dispose: function() {
    if (this._decorators && this._decorators.length) {
      each(this._decorators, function(_2, decorator) {
        decorator.dispose();
      });
    }
  },
  _fetchRequiredDecorators: function() {
    this._decorators = [];
    each(editOptionsRegistry, function(_2, option) {
      var optionEnabled = option.enabled.call(this._list);
      if (optionEnabled) {
        var decoratorType = option.decoratorType.call(this._list);
        var decoratorSubType = option.decoratorSubType.call(this._list);
        var decorator = this._createDecorator(decoratorType, decoratorSubType);
        this._decorators.push(decorator);
      }
    }.bind(this));
  },
  _createDecorator: function(type2, subType) {
    var decoratorClass = this._findDecorator(type2, subType);
    return new decoratorClass(this._list);
  },
  _findDecorator: function(type2, subType) {
    var foundDecorator = registry[type2][subType];
    if (!foundDecorator) {
      throw errors$1.Error("E1012", type2, subType);
    }
    return foundDecorator;
  },
  modifyItemElement: function(args) {
    var $itemElement = $(args.itemElement);
    var config2 = {
      $itemElement
    };
    this._prependBeforeBags($itemElement, config2);
    this._appendAfterBags($itemElement, config2);
    this._applyDecorators(DECORATOR_MODIFY_ELEMENT_METHOD, config2);
  },
  afterItemsRendered: function() {
    this._applyDecorators(DECORATOR_AFTER_RENDER_METHOD);
  },
  _prependBeforeBags: function($itemElement, config2) {
    var $beforeBags = this._collectDecoratorsMarkup(DECORATOR_BEFORE_BAG_CREATE_METHOD, config2, LIST_ITEM_BEFORE_BAG_CLASS);
    $itemElement.prepend($beforeBags);
  },
  _appendAfterBags: function($itemElement, config2) {
    var $afterBags = this._collectDecoratorsMarkup(DECORATOR_AFTER_BAG_CREATE_METHOD, config2, LIST_ITEM_AFTER_BAG_CLASS);
    $itemElement.append($afterBags);
  },
  _collectDecoratorsMarkup: function(method, config2, containerClass) {
    var $collector = $("<div>");
    each(this._decorators, function() {
      var $container = $("<div>").addClass(containerClass);
      this[method](extend({
        $container
      }, config2));
      if ($container.children().length) {
        $collector.append($container);
      }
    });
    return $collector.children();
  },
  _applyDecorators: function(method, config2) {
    each(this._decorators, function() {
      this[method](config2);
    });
  },
  _handlerExists: function(name2) {
    if (!this._decorators) {
      return false;
    }
    var decorators = this._decorators;
    var length = decorators.length;
    for (var i = 0; i < length; i++) {
      if (decorators[i][name2] !== noop) {
        return true;
      }
    }
    return false;
  },
  _eventHandler: function(name2, $itemElement, e) {
    if (!this._decorators) {
      return false;
    }
    var response = false;
    var decorators = this._decorators;
    var length = decorators.length;
    for (var i = 0; i < length; i++) {
      response = decorators[i][name2]($itemElement, e);
      if (response) {
        break;
      }
    }
    return response;
  },
  handleClick: function($itemElement, e) {
    return this._eventHandler("handleClick", $itemElement, e);
  },
  handleKeyboardEvents: function(currentFocusedIndex, moveFocusUp) {
    return this._eventHandler("handleKeyboardEvents", currentFocusedIndex, moveFocusUp);
  },
  handleEnterPressing: function(e) {
    return this._eventHandler("handleEnterPressing", e);
  },
  contextMenuHandlerExists: function() {
    return this._handlerExists("handleContextMenu");
  },
  handleContextMenu: function($itemElement, e) {
    return this._eventHandler("handleContextMenu", $itemElement, e);
  },
  getExcludedItemSelectors: function() {
    var excludedSelectors = [];
    this._applyDecorators(DECORATOR_GET_EXCLUDED_SELECTORS_METHOD, excludedSelectors);
    return excludedSelectors.join(",");
  }
});
var LIST_ITEM_SELECTED_CLASS = "dx-list-item-selected";
var LIST_ITEM_RESPONSE_WAIT_CLASS = "dx-list-item-response-wait";
var ListEdit = ListBase.inherit({
  _supportedKeys() {
    var that = this;
    var parent = this.callBase();
    var moveFocusedItem = (e, moveUp) => {
      var editStrategy = this._editStrategy;
      var focusedElement = this.option("focusedElement");
      var focusedItemIndex = editStrategy.getNormalizedIndex(focusedElement);
      var isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
      if (isLastIndexFocused && this._isDataSourceLoading()) {
        return;
      }
      if (e.shiftKey && that.option("itemDragging.allowReordering")) {
        var nextItemIndex = focusedItemIndex + (moveUp ? -1 : 1);
        var $nextItem = editStrategy.getItemElement(nextItemIndex);
        this.reorderItem(focusedElement, $nextItem);
        this.scrollToItem(focusedElement);
        e.preventDefault();
      } else {
        var editProvider = this._editProvider;
        var isInternalMoving = editProvider.handleKeyboardEvents(focusedItemIndex, moveUp);
        if (!isInternalMoving) {
          moveUp ? parent.upArrow(e) : parent.downArrow(e);
        }
      }
    };
    return extend({}, parent, {
      del: (e) => {
        if (that.option("allowItemDeleting")) {
          e.preventDefault();
          that.deleteItem(that.option("focusedElement"));
        }
      },
      upArrow: (e) => moveFocusedItem(e, true),
      downArrow: (e) => moveFocusedItem(e),
      enter: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.enter.apply(this, arguments);
        }
      },
      space: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.space.apply(this, arguments);
        }
      }
    });
  },
  _updateSelection() {
    this._editProvider.afterItemsRendered();
    this.callBase();
  },
  _getLastItemIndex() {
    return this._itemElements().length - 1;
  },
  _refreshItemElements() {
    this.callBase();
    var excludedSelectors = this._editProvider.getExcludedItemSelectors();
    if (excludedSelectors.length) {
      this._itemElementsCache = this._itemElementsCache.not(excludedSelectors);
    }
  },
  _isItemStrictEquals: function(item1, item2) {
    var privateKey = item1 && item1.__dx_key__;
    if (privateKey && !this.key() && this._selection.isItemSelected(privateKey)) {
      return false;
    }
    return this.callBase(item1, item2);
  },
  _getDefaultOptions() {
    return extend(this.callBase(), {
      showSelectionControls: false,
      selectionMode: "none",
      selectAllMode: "page",
      onSelectAllValueChanged: null,
      selectAllText: messageLocalization.format("dxList-selectAll"),
      menuItems: [],
      menuMode: "context",
      allowItemDeleting: false,
      itemDeleteMode: "static",
      itemDragging: {}
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: (_device) => _device.platform === "ios",
      options: {
        menuMode: "slide",
        itemDeleteMode: "slideItem"
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        itemDeleteMode: "swipe"
      }
    }]);
  },
  _init() {
    this.callBase();
    this._initEditProvider();
  },
  _initDataSource() {
    this.callBase();
    if (!this._isPageSelectAll()) {
      this._dataSource && this._dataSource.requireTotalCount(true);
    }
  },
  _isPageSelectAll() {
    return this.option("selectAllMode") === "page";
  },
  _initEditProvider() {
    this._editProvider = new EditProvider(this);
  },
  _disposeEditProvider() {
    if (this._editProvider) {
      this._editProvider.dispose();
    }
  },
  _refreshEditProvider() {
    this._disposeEditProvider();
    this._initEditProvider();
  },
  _initEditStrategy() {
    if (this.option("grouped")) {
      this._editStrategy = new GroupedEditStrategy(this);
    } else {
      this.callBase();
    }
  },
  _initMarkup() {
    this._refreshEditProvider();
    this.callBase();
  },
  _renderItems() {
    this.callBase(...arguments);
    this._editProvider.afterItemsRendered();
  },
  _selectedItemClass: () => LIST_ITEM_SELECTED_CLASS,
  _itemResponseWaitClass: () => LIST_ITEM_RESPONSE_WAIT_CLASS,
  _itemClickHandler(e) {
    var $itemElement = $(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    var handledByEditProvider = this._editProvider.handleClick($itemElement, e);
    if (handledByEditProvider) {
      return;
    }
    this._saveSelectionChangeEvent(e);
    this.callBase(...arguments);
  },
  _shouldFireContextMenuEvent() {
    return this.callBase(...arguments) || this._editProvider.contextMenuHandlerExists();
  },
  _itemHoldHandler(e) {
    var $itemElement = $(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    var handledByEditProvider = isTouchEvent(e) && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.handledByEditProvider = true;
      return;
    }
    this.callBase(...arguments);
  },
  _getItemContainer: function(changeData) {
    if (this.option("grouped")) {
      var _this$_editStrategy$g;
      var groupIndex = (_this$_editStrategy$g = this._editStrategy.getIndexByItemData(changeData)) === null || _this$_editStrategy$g === void 0 ? void 0 : _this$_editStrategy$g.group;
      return this._getGroupContainerByIndex(groupIndex);
    } else {
      return this.callBase(changeData);
    }
  },
  _itemContextMenuHandler(e) {
    var $itemElement = $(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    var handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.preventDefault();
      return;
    }
    this.callBase(...arguments);
  },
  _postprocessRenderItem(args) {
    this.callBase(...arguments);
    this._editProvider.modifyItemElement(args);
  },
  _clean() {
    this._disposeEditProvider();
    this.callBase();
  },
  focusListItem(index2) {
    var $item = this._editStrategy.getItemElement(index2);
    this.option("focusedElement", $item);
    this.focus();
    this.scrollToItem(this.option("focusedElement"));
  },
  _optionChanged(args) {
    switch (args.name) {
      case "selectAllMode":
        this._initDataSource();
        this._dataSource.pageIndex(0);
        this._dataSource.load();
        break;
      case "grouped":
        this._clearSelectedItems();
        delete this._renderingGroupIndex;
        this._initEditStrategy();
        this.callBase(args);
        break;
      case "showSelectionControls":
      case "menuItems":
      case "menuMode":
      case "allowItemDeleting":
      case "itemDeleteMode":
      case "itemDragging":
      case "selectAllText":
        this._invalidate();
        break;
      case "onSelectAllValueChanged":
        break;
      default:
        this.callBase(args);
    }
  },
  selectAll() {
    return this._selection.selectAll(this._isPageSelectAll());
  },
  unselectAll() {
    return this._selection.deselectAll(this._isPageSelectAll());
  },
  isSelectAll() {
    return this._selection.getSelectAllState(this._isPageSelectAll());
  },
  getFlatIndexByItemElement(itemElement) {
    return this._itemElements().index(itemElement);
  },
  getItemElementByFlatIndex(flatIndex) {
    var $itemElements = this._itemElements();
    if (flatIndex < 0 || flatIndex >= $itemElements.length) {
      return $();
    }
    return $itemElements.eq(flatIndex);
  },
  getItemByIndex(index2) {
    return this._editStrategy.getItemDataByIndex(index2);
  }
});
var ListSearch = ListEdit.inherit(searchBoxMixin).inherit({
  _addWidgetPrefix: function(className) {
    return "dx-list-" + className;
  },
  _getCombinedFilter: function() {
    var filter;
    var storeLoadOptions;
    var dataSource = this._dataSource;
    if (dataSource) {
      storeLoadOptions = {
        filter: dataSource.filter()
      };
      dataSource._addSearchFilter(storeLoadOptions);
      filter = storeLoadOptions.filter;
    }
    return filter;
  },
  _initDataSource: function() {
    var value2 = this.option("searchValue");
    var expr = this.option("searchExpr");
    var mode = this.option("searchMode");
    this.callBase();
    if (this._dataSource) {
      value2 && value2.length && this._dataSource.searchValue(value2);
      mode.length && this._dataSource.searchOperation(searchBoxMixin.getOperationBySearchMode(mode));
      expr && this._dataSource.searchExpr(expr);
    }
  }
});
registerComponent("dxList", ListSearch);
var HEADER_FILTER_CLASS = "dx-header-filter";
var HEADER_FILTER_MENU_CLASS = "dx-header-filter-menu";
var DEFAULT_SEARCH_EXPRESSION = "text";
function resetChildrenItemSelection(items) {
  items = items || [];
  for (var i = 0; i < items.length; i++) {
    items[i].selected = false;
    resetChildrenItemSelection(items[i].items);
  }
}
function updateSelectAllState(e, filterValues) {
  if (e.component.option("searchValue")) {
    return;
  }
  var selectAllCheckBox = $(e.element).find(".dx-list-select-all-checkbox").data("dxCheckBox");
  if (selectAllCheckBox && filterValues && filterValues.length) {
    selectAllCheckBox.option("value", void 0);
  }
}
function isSearchEnabled(that, options) {
  var headerFilter = options.headerFilter;
  if (headerFilter && isDefined(headerFilter.allowSearch)) {
    return headerFilter.allowSearch;
  }
  return that.option("headerFilter.allowSearch");
}
function updateHeaderFilterItemSelectionState(item, filterValuesMatch, isExcludeFilter) {
  if (filterValuesMatch ^ isExcludeFilter) {
    item.selected = true;
    if (isExcludeFilter && item.items) {
      for (var j = 0; j < item.items.length; j++) {
        if (!item.items[j].selected) {
          item.selected = void 0;
          break;
        }
      }
    }
  } else if (isExcludeFilter || item.selected) {
    item.selected = false;
    resetChildrenItemSelection(item.items);
  }
}
var HeaderFilterView$1 = modules.View.inherit({
  getPopupContainer: function() {
    return this._popupContainer;
  },
  getListContainer: function() {
    return this._listContainer;
  },
  applyHeaderFilter: function(options) {
    var list = this.getListContainer();
    var searchValue = list.option("searchValue");
    var isSelectAll = !searchValue && !options.isFilterBuilder && list.$element().find(".dx-checkbox").eq(0).hasClass("dx-checkbox-checked");
    var filterValues = [];
    if (!isSelectAll) {
      if (options.type === "tree") {
        if (options.filterType) {
          options.filterType = "include";
        }
        !function fillSelectedItemKeys(filterValues2, items, isExclude) {
          each(items, function(_2, item) {
            if (item.selected !== void 0 && !!item.selected ^ isExclude) {
              var node = list._getNode(item);
              var hasChildren = list._hasChildren(node);
              var hasChildrenWithSelection = hasChildren && item.items && item.items.some((item2) => item2.selected);
              if (!searchValue || !hasChildrenWithSelection) {
                filterValues2.push(item.value);
                return;
              }
            }
            if (item.items && item.items.length) {
              fillSelectedItemKeys(filterValues2, item.items, isExclude);
            }
          });
        }(filterValues, list.option("items"), false);
        options.filterValues = filterValues;
      }
    } else {
      if (options.type === "tree") {
        options.filterType = "exclude";
      }
      if (Array.isArray(options.filterValues)) {
        options.filterValues = [];
      }
    }
    if (options.filterValues && !options.filterValues.length) {
      options.filterValues = null;
    }
    options.apply();
    this.hideHeaderFilterMenu();
  },
  showHeaderFilterMenu: function($columnElement, options) {
    if (options) {
      this._initializePopupContainer(options);
      var popupContainer = this.getPopupContainer();
      this.hideHeaderFilterMenu();
      this.updatePopup($columnElement, options);
      popupContainer.show();
    }
  },
  hideHeaderFilterMenu: function() {
    var headerFilterMenu = this.getPopupContainer();
    headerFilterMenu && headerFilterMenu.hide();
  },
  updatePopup: function($element, options) {
    var alignment = options.alignment === "right" ? "left" : "right";
    if (this._popupContainer) {
      this._cleanPopupContent();
      this._popupContainer.option("position", {
        my: alignment + " top",
        at: alignment + " bottom",
        of: $element,
        collision: "flip fit"
      });
    }
  },
  _getSearchExpr: function(options) {
    var lookup = options.lookup;
    var useDefaultSearchExpr = options.useDefaultSearchExpr;
    var headerFilterDataSource = options.headerFilter && options.headerFilter.dataSource;
    if (useDefaultSearchExpr || isDefined(headerFilterDataSource) && !isFunction$1(headerFilterDataSource)) {
      return DEFAULT_SEARCH_EXPRESSION;
    }
    if (lookup) {
      return lookup.displayExpr || "this";
    }
    if (options.dataSource) {
      var group = options.dataSource.group;
      if (Array.isArray(group) && group.length > 0) {
        return group[0].selector;
      } else if (isFunction$1(group) && !options.remoteFiltering) {
        return group;
      }
    }
    return options.dataField || options.selector;
  },
  _cleanPopupContent: function() {
    this._popupContainer && this._popupContainer.$content().empty();
  },
  _initializePopupContainer: function(options) {
    var that = this;
    var $element = that.element();
    var headerFilterOptions = that.option("headerFilter");
    var width = options.headerFilter && options.headerFilter.width || headerFilterOptions && headerFilterOptions.width;
    var height = options.headerFilter && options.headerFilter.height || headerFilterOptions && headerFilterOptions.height;
    var dxPopupOptions = {
      width,
      height,
      visible: false,
      shading: false,
      showTitle: false,
      showCloseButton: false,
      closeOnTargetScroll: false,
      dragEnabled: false,
      closeOnOutsideClick: true,
      focusStateEnabled: false,
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: headerFilterOptions.texts.ok,
          onClick: function() {
            that.applyHeaderFilter(options);
          }
        }
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: headerFilterOptions.texts.cancel,
          onClick: function() {
            that.hideHeaderFilterMenu();
          }
        }
      }],
      resizeEnabled: true,
      onShowing: function(e) {
        e.component.$content().parent().addClass("dx-dropdowneditor-overlay");
        that._initializeListContainer(options);
        options.onShowing && options.onShowing(e);
      },
      onShown: function() {
        that.getListContainer().focus();
      },
      onHidden: options.onHidden,
      onInitialized: function(e) {
        var component = e.component;
        component.option("animation", component._getDefaultOptions().animation);
      }
    };
    if (!isDefined(that._popupContainer)) {
      that._popupContainer = that._createComponent($element, Popup, dxPopupOptions);
    } else {
      that._popupContainer.option(dxPopupOptions);
    }
  },
  _initializeListContainer: function(options) {
    var that = this;
    var $content = that._popupContainer.$content();
    var widgetOptions = {
      searchEnabled: isSearchEnabled(that, options),
      searchTimeout: that.option("headerFilter.searchTimeout"),
      searchMode: options.headerFilter && options.headerFilter.searchMode || "",
      dataSource: options.dataSource,
      onContentReady: function() {
        that.renderCompleted.fire();
      },
      itemTemplate: function(data2, _2, element) {
        var $element = $(element);
        if (options.encodeHtml) {
          return $element.text(data2.text);
        }
        return $element.html(data2.text);
      }
    };
    function onOptionChanged(e) {
      if (e.fullName === "searchValue" && !options.isFilterBuilder && that.option("headerFilter.hideSelectAllOnSearch") !== false) {
        if (options.type === "tree") {
          e.component.option("showCheckBoxesMode", e.value ? "normal" : "selectAll");
        } else {
          e.component.option("selectionMode", e.value ? "multiple" : "all");
        }
      }
    }
    if (options.type === "tree") {
      that._listContainer = that._createComponent($("<div>").appendTo($content), TreeViewSearch, extend(widgetOptions, {
        showCheckBoxesMode: options.isFilterBuilder ? "normal" : "selectAll",
        onOptionChanged,
        keyExpr: "id"
      }));
    } else {
      that._listContainer = that._createComponent($("<div>").appendTo($content), ListSearch, extend(widgetOptions, {
        searchExpr: that._getSearchExpr(options),
        pageLoadMode: "scrollBottom",
        showSelectionControls: true,
        selectionMode: options.isFilterBuilder ? "multiple" : "all",
        onOptionChanged,
        onSelectionChanged: function(e) {
          var items = e.component.option("items");
          var selectedItems = e.component.option("selectedItems");
          if (!e.component._selectedItemsUpdating && !e.component.option("searchValue") && !options.isFilterBuilder) {
            var filterValues = options.filterValues || [];
            var isExclude = options.filterType === "exclude";
            if (selectedItems.length === 0 && items.length && (filterValues.length <= 1 || isExclude && filterValues.length === items.length - 1)) {
              options.filterType = "include";
              options.filterValues = [];
            } else if (selectedItems.length === items.length) {
              options.filterType = "exclude";
              options.filterValues = [];
            }
          }
          each(items, function(index2, item) {
            var selected = gridCoreUtils.getIndexByKey(item, selectedItems, null) >= 0;
            var oldSelected = !!item.selected;
            if (oldSelected !== selected) {
              item.selected = selected;
              options.filterValues = options.filterValues || [];
              var filterValueIndex = gridCoreUtils.getIndexByKey(item.value, options.filterValues, null);
              if (filterValueIndex >= 0) {
                options.filterValues.splice(filterValueIndex, 1);
              }
              if (selected ^ options.filterType === "exclude") {
                options.filterValues.push(item.value);
              }
            }
          });
          updateSelectAllState(e, options.filterValues);
        },
        onContentReady: function(e) {
          var component = e.component;
          var items = component.option("items");
          var selectedItems = [];
          each(items, function() {
            if (this.selected) {
              selectedItems.push(this);
            }
          });
          component._selectedItemsUpdating = true;
          component.option("selectedItems", selectedItems);
          component._selectedItemsUpdating = false;
          updateSelectAllState(e, options.filterValues);
        }
      }));
    }
  },
  _renderCore: function() {
    this.element().addClass(HEADER_FILTER_MENU_CLASS);
  }
});
var allowHeaderFiltering = function(column) {
  return isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering;
};
var headerFilterMixin = {
  _applyColumnState: function(options) {
    var $headerFilterIndicator;
    var rootElement = options.rootElement;
    var column = options.column;
    if (options.name === "headerFilter") {
      rootElement.find("." + HEADER_FILTER_CLASS).remove();
      if (allowHeaderFiltering(column)) {
        $headerFilterIndicator = this.callBase(options).toggleClass("dx-header-filter-empty", this._isHeaderFilterEmpty(column));
        if (!this.option("useLegacyKeyboardNavigation")) {
          $headerFilterIndicator.attr("tabindex", this.option("tabindex") || 0);
        }
      }
      return $headerFilterIndicator;
    }
    return this.callBase(options);
  },
  _isHeaderFilterEmpty: function(column) {
    return !column.filterValues || !column.filterValues.length;
  },
  _getIndicatorClassName: function(name2) {
    if (name2 === "headerFilter") {
      return HEADER_FILTER_CLASS;
    }
    return this.callBase(name2);
  },
  _renderIndicator: function(options) {
    var $container = options.container;
    var $indicator = options.indicator;
    if (options.name === "headerFilter") {
      var rtlEnabled = this.option("rtlEnabled");
      if ($container.children().length && (!rtlEnabled && options.columnAlignment === "right" || rtlEnabled && options.columnAlignment === "left")) {
        $container.prepend($indicator);
        return;
      }
    }
    this.callBase(options);
  },
  optionChanged: function(args) {
    if (args.name === "headerFilter") {
      var requireReady = this.name === "columnHeadersView";
      this._invalidate(requireReady, requireReady);
      args.handled = true;
    } else {
      this.callBase(args);
    }
  }
};
var COLUMN_INDICATORS_CLASS = "dx-column-indicators";
var GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item";
var columnStateMixin = {
  _applyColumnState: function(options) {
    var _that$component;
    var rtlEnabled = this.option("rtlEnabled");
    var columnAlignment = this._getColumnAlignment(options.column.alignment, rtlEnabled);
    var parameters = extend(true, {
      columnAlignment
    }, options);
    var isGroupPanelItem = parameters.rootElement.hasClass(GROUP_PANEL_ITEM_CLASS);
    var $indicatorsContainer = this._createIndicatorContainer(parameters, isGroupPanelItem);
    var $span = $("<span>").addClass(this._getIndicatorClassName(options.name));
    var columnsController = (_that$component = this.component) === null || _that$component === void 0 ? void 0 : _that$component.getController("columns");
    var indicatorAlignment = (columnsController === null || columnsController === void 0 ? void 0 : columnsController.getHeaderContentAlignment(columnAlignment)) || columnAlignment;
    parameters.container = $indicatorsContainer;
    parameters.indicator = $span;
    this._renderIndicator(parameters);
    $indicatorsContainer[(isGroupPanelItem || !options.showColumnLines) && indicatorAlignment === "left" ? "appendTo" : "prependTo"](options.rootElement);
    return $span;
  },
  _getIndicatorClassName: noop,
  _getColumnAlignment: function(alignment, rtlEnabled) {
    rtlEnabled = rtlEnabled || this.option("rtlEnabled");
    return alignment && alignment !== "center" ? alignment : getDefaultAlignment(rtlEnabled);
  },
  _createIndicatorContainer: function(options, ignoreIndicatorAlignment) {
    var $indicatorsContainer = this._getIndicatorContainer(options.rootElement);
    var indicatorAlignment = options.columnAlignment === "left" ? "right" : "left";
    if (!$indicatorsContainer.length) {
      $indicatorsContainer = $("<div>").addClass(COLUMN_INDICATORS_CLASS);
    }
    this.setAria("role", "presentation", $indicatorsContainer);
    return $indicatorsContainer.css("float", options.showColumnLines && !ignoreIndicatorAlignment ? indicatorAlignment : null);
  },
  _getIndicatorContainer: function($cell) {
    return $cell && $cell.find("." + COLUMN_INDICATORS_CLASS);
  },
  _getIndicatorElements: function($cell) {
    var $indicatorContainer = this._getIndicatorContainer($cell);
    return $indicatorContainer && $indicatorContainer.children();
  },
  _renderIndicator: function(options) {
    var $container = options.container;
    var $indicator = options.indicator;
    $container && $indicator && $container.append($indicator);
  },
  _updateIndicators: function(indicatorName) {
    var columns = this.getColumns();
    var $cells = this.getColumnElements();
    var $cell;
    if (!$cells || columns.length !== $cells.length) {
      return;
    }
    for (var i = 0; i < columns.length; i++) {
      $cell = $cells.eq(i);
      this._updateIndicator($cell, columns[i], indicatorName);
      var rowOptions = $cell.parent().data("options");
      if (rowOptions && rowOptions.cells) {
        rowOptions.cells[$cell.index()].column = columns[i];
      }
    }
  },
  _updateIndicator: function($cell, column, indicatorName) {
    if (!column.command) {
      return this._applyColumnState({
        name: indicatorName,
        rootElement: $cell,
        column,
        showColumnLines: this.option("showColumnLines")
      });
    }
  }
};
var SORT_CLASS = "dx-sort";
var SORT_NONE_CLASS = "dx-sort-none";
var SORTUP_CLASS = "dx-sort-up";
var SORTDOWN_CLASS = "dx-sort-down";
var SORT_INDEX_CLASS = "dx-sort-index";
var SORT_INDEX_ICON_CLASS = "dx-sort-index-icon";
var HEADERS_ACTION_CLASS = "action";
var sortingMixin = {
  _applyColumnState: function(options) {
    var ariaSortState;
    var $sortIndicator;
    var sortingMode = this.option("sorting.mode");
    var rootElement = options.rootElement;
    var column = options.column;
    var $indicatorsContainer = this._getIndicatorContainer(rootElement);
    if (options.name === "sort") {
      rootElement.find("." + SORT_CLASS).remove();
      !$indicatorsContainer.children().length && $indicatorsContainer.remove();
      var isSortingAllowed = (sortingMode === "single" || sortingMode === "multiple") && column.allowSorting;
      if (!isDefined(column.groupIndex) && (isSortingAllowed || isDefined(column.sortOrder))) {
        ariaSortState = column.sortOrder === "asc" ? "ascending" : "descending";
        $sortIndicator = this.callBase(options).toggleClass(SORTUP_CLASS, column.sortOrder === "asc").toggleClass(SORTDOWN_CLASS, column.sortOrder === "desc");
        var hasSeveralSortIndexes = this.getController && !!this.getController("columns").columnOption("sortIndex:1");
        if (hasSeveralSortIndexes && this.option("sorting.showSortIndexes") && column.sortIndex >= 0) {
          $("<span>").addClass(SORT_INDEX_ICON_CLASS).text(column.sortIndex + 1).appendTo($sortIndicator);
          $sortIndicator.addClass(SORT_INDEX_CLASS);
        }
        options.rootElement.addClass(this.addWidgetPrefix(HEADERS_ACTION_CLASS));
      }
      if (!isDefined(column.sortOrder)) {
        this.setAria("sort", "none", rootElement);
      } else {
        this.setAria("sort", ariaSortState, rootElement);
      }
      return $sortIndicator;
    } else {
      return this.callBase(options);
    }
  },
  _getIndicatorClassName: function(name2) {
    if (name2 === "sort") {
      return SORT_CLASS;
    } else if (name2 === "sortIndex") {
      return SORT_INDEX_ICON_CLASS;
    }
    return this.callBase(name2);
  },
  _renderIndicator: function(options) {
    var column = options.column;
    var $container = options.container;
    var $indicator = options.indicator;
    if (options.name === "sort") {
      var rtlEnabled = this.option("rtlEnabled");
      if (!isDefined(column.sortOrder)) {
        $indicator && $indicator.addClass(SORT_NONE_CLASS);
      }
      if ($container.children().length && (!rtlEnabled && options.columnAlignment === "left" || rtlEnabled && options.columnAlignment === "right")) {
        $container.prepend($indicator);
        return;
      }
    }
    this.callBase(options);
  },
  _updateIndicator: function($cell, column, indicatorName) {
    if (indicatorName === "sort" && isDefined(column.groupIndex)) {
      return;
    }
    return this.callBase.apply(this, arguments);
  },
  _getIndicatorElements: function($cell, returnAll) {
    var $indicatorElements = this.callBase($cell);
    return returnAll ? $indicatorElements : $indicatorElements && $indicatorElements.not("." + SORT_NONE_CLASS);
  }
};
var {
  getSwatchContainer
} = swatchContainer;
var SORTABLE_NAMESPACE = "dxSortable";
var SORTABLE_CLASS = "dx-sortable-old";
var SCROLL_STEP = 2;
var START_SCROLL_OFFSET = 20;
var SCROLL_TIMEOUT = 10;
function elementHasPoint(element, x, y) {
  var $item = $(element);
  var offset2 = $item.offset();
  if (x >= offset2.left && x <= offset2.left + $item.outerWidth(true)) {
    if (y >= offset2.top && y <= offset2.top + $item.outerHeight(true)) {
      return true;
    }
  }
}
function checkHorizontalPosition(position2, itemOffset, rtl) {
  if (isDefined(itemOffset.posHorizontal)) {
    return rtl ? position2 > itemOffset.posHorizontal : position2 < itemOffset.posHorizontal;
  } else {
    return true;
  }
}
function getIndex($items, $item) {
  var index2 = -1;
  var itemElement = $item.get(0);
  each($items, function(elementIndex, element) {
    var $element = $(element);
    if (!($element.attr("item-group") && $element.attr("item-group") === $items.eq(elementIndex - 1).attr("item-group"))) {
      index2++;
    }
    if (element === itemElement) {
      return false;
    }
  });
  return index2 === $items.length ? -1 : index2;
}
function getTargetGroup(e, $groups) {
  var result;
  each($groups, function() {
    if (elementHasPoint(this, e.pageX, e.pageY)) {
      result = $(this);
    }
  });
  return result;
}
function getItemsOffset($elements, isVertical, $itemsContainer) {
  var result = [];
  var $item = [];
  for (var i = 0; i < $elements.length; i += $item.length) {
    $item = $elements.eq(i);
    if ($item.attr("item-group")) {
      $item = $itemsContainer.find("[item-group='" + $item.attr("item-group") + "']");
    }
    if ($item.is(":visible")) {
      var offset2 = {
        item: $item,
        index: result.length,
        posHorizontal: isVertical ? void 0 : ($item.last().outerWidth(true) + $item.last().offset().left + $item.offset().left) / 2
      };
      if (isVertical) {
        offset2.posVertical = ($item.last().offset().top + $item.offset().top + $item.last().outerHeight(true)) / 2;
      } else {
        offset2.posVertical = $item.last().outerHeight(true) + $item.last().offset().top;
      }
      result.push(offset2);
    }
  }
  return result;
}
function getScrollWrapper(scrollable) {
  var timeout = null;
  var scrollTop = scrollable.scrollTop();
  var $element = scrollable.$element();
  var top = $element.offset().top;
  var height = $element.height();
  var delta = 0;
  function onScroll(e) {
    scrollTop = e.scrollOffset.top;
  }
  scrollable.on("scroll", onScroll);
  function move2() {
    stop2();
    scrollable.scrollTo(scrollTop += delta);
    timeout = setTimeout(move2, SCROLL_TIMEOUT);
  }
  function stop2() {
    clearTimeout(timeout);
  }
  return {
    moveIfNeed: function(event) {
      if (event.pageY <= top + START_SCROLL_OFFSET) {
        delta = -SCROLL_STEP;
      } else if (event.pageY >= top + height - START_SCROLL_OFFSET) {
        delta = SCROLL_STEP;
      } else {
        delta = 0;
        stop2();
        return;
      }
      move2();
    },
    element: function() {
      return $element;
    },
    dispose: function() {
      stop2();
      scrollable.off("scroll", onScroll);
    }
  };
}
var Sortable = DOMComponent.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      onChanged: null,
      onDragging: null,
      itemRender: null,
      groupSelector: null,
      itemSelector: ".dx-sort-item",
      itemContainerSelector: ".dx-sortable-old",
      sourceClass: "dx-drag-source",
      dragClass: "dx-drag",
      targetClass: "dx-drag-target",
      direction: "vertical",
      allowDragging: true,
      groupFilter: null,
      useIndicator: false
    });
  },
  _renderItem: function($sourceItem, target) {
    var itemRender = this.option("itemRender");
    var $item;
    if (itemRender) {
      $item = itemRender($sourceItem, target);
    } else {
      $item = $sourceItem.clone();
      $item.css({
        width: $sourceItem.width(),
        height: $sourceItem.height()
      });
    }
    return $item;
  },
  _renderIndicator: function($item, isVertical, $targetGroup, isLast) {
    var height = $item.outerHeight(true);
    var width = $item.outerWidth(true);
    var top = $item.offset().top - $targetGroup.offset().top;
    var left = $item.offset().left - $targetGroup.offset().left;
    this._indicator.css({
      position: "absolute",
      top: isLast && isVertical ? top + height : top,
      left: isLast && !isVertical ? left + width : left
    }).toggleClass("dx-position-indicator-horizontal", !isVertical).toggleClass("dx-position-indicator-vertical", !!isVertical).toggleClass("dx-position-indicator-last", !!isLast).height("").width("").appendTo($targetGroup);
    isVertical ? this._indicator.width(width) : this._indicator.height(height);
  },
  _renderDraggable: function($sourceItem) {
    this._$draggable && this._$draggable.remove();
    this._$draggable = this._renderItem($sourceItem, "drag").addClass(this.option("dragClass")).appendTo(getSwatchContainer($sourceItem)).css({
      zIndex: 1e6,
      position: "absolute"
    });
  },
  _detachEventHandlers: function() {
    var dragEventsString = [DRAG_EVENT, DRAG_START_EVENT, DRAG_END_EVENT, DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].join(" ");
    eventsEngine.off(this._getEventListener(), addNamespace$1(dragEventsString, SORTABLE_NAMESPACE));
  },
  _getItemOffset: function(isVertical, itemsOffset, e) {
    for (var i = 0; i < itemsOffset.length; i++) {
      var shouldInsert = void 0;
      var sameLine = e.pageY < itemsOffset[i].posVertical;
      if (isVertical) {
        shouldInsert = sameLine;
      } else if (sameLine) {
        shouldInsert = checkHorizontalPosition(e.pageX, itemsOffset[i], this.option("rtlEnabled"));
        if (!shouldInsert && itemsOffset[i + 1] && itemsOffset[i + 1].posVertical > itemsOffset[i].posVertical) {
          shouldInsert = true;
        }
      }
      if (shouldInsert) {
        return itemsOffset[i];
      }
    }
  },
  _getEventListener: function() {
    var groupSelector = this.option("groupSelector");
    var element = this.$element();
    return groupSelector ? element.find(groupSelector) : element;
  },
  _attachEventHandlers: function() {
    var that = this;
    var itemSelector = that.option("itemSelector");
    var itemContainerSelector = that.option("itemContainerSelector");
    var groupSelector = that.option("groupSelector");
    var sourceClass = that.option("sourceClass");
    var targetClass = that.option("targetClass");
    var onDragging = that.option("onDragging");
    var groupFilter = that.option("groupFilter");
    var $sourceItem;
    var sourceIndex;
    var $targetItem;
    var $targetGroup;
    var startPositions;
    var sourceGroup;
    var element = that.$element();
    var $groups;
    var scrollWrapper = null;
    var targetIndex = -1;
    var disposeScrollWrapper = function() {
      scrollWrapper && scrollWrapper.dispose();
      scrollWrapper = null;
    };
    that._detachEventHandlers();
    if (that.option("allowDragging")) {
      var $eventListener = that._getEventListener();
      eventsEngine.on($eventListener, addNamespace$1(DRAG_START_EVENT, SORTABLE_NAMESPACE), itemSelector, function(e) {
        $sourceItem = $(e.currentTarget);
        var $sourceGroup = $sourceItem.closest(groupSelector);
        sourceGroup = $sourceGroup.attr("group");
        sourceIndex = getIndex((groupSelector ? $sourceGroup : element).find(itemSelector), $sourceItem);
        if ($sourceItem.attr("item-group")) {
          $sourceItem = $sourceGroup.find("[item-group='" + $sourceItem.attr("item-group") + "']");
        }
        that._renderDraggable($sourceItem);
        $targetItem = that._renderItem($sourceItem, "target").addClass(targetClass);
        $sourceItem.addClass(sourceClass);
        !function() {
          startPositions = [];
          each($sourceItem, function(_2, item) {
            startPositions.push($(item).offset());
          });
        }();
        $groups = function() {
          if (!groupSelector) {
            return element;
          } else {
            return groupFilter ? $(groupSelector).filter(groupFilter) : element.find(groupSelector);
          }
        }();
        that._indicator = $("<div>").addClass("dx-position-indicator");
      });
      eventsEngine.on($eventListener, addNamespace$1(DRAG_EVENT, SORTABLE_NAMESPACE), function(e) {
        var $item;
        var $lastItem;
        var $prevItem;
        if (!$sourceItem) {
          return;
        }
        targetIndex = -1;
        that._indicator.detach();
        each(that._$draggable, function(index2, draggableElement) {
          $(draggableElement).css({
            top: startPositions[index2].top + e.offset.y,
            left: startPositions[index2].left + e.offset.x
          });
        });
        $targetGroup && $targetGroup.removeClass(targetClass);
        $targetGroup = getTargetGroup(e, $groups);
        $targetGroup && function() {
          var draggingArgs = {
            sourceGroup,
            sourceIndex,
            sourceElement: $sourceItem,
            targetGroup: $targetGroup.attr("group"),
            targetIndex: $targetGroup.find(itemSelector).index($targetItem)
          };
          onDragging && onDragging(draggingArgs);
          if (draggingArgs.cancel) {
            $targetGroup = void 0;
          }
        }();
        if ($targetGroup && scrollWrapper && $targetGroup.get(0) !== scrollWrapper.element().get(0)) {
          disposeScrollWrapper();
        }
        scrollWrapper && scrollWrapper.moveIfNeed(e);
        if (!$targetGroup) {
          $targetItem.detach();
          return;
        }
        if (!scrollWrapper && $targetGroup.attr("allow-scrolling")) {
          scrollWrapper = getScrollWrapper($targetGroup.dxScrollable("instance"));
        }
        $targetGroup.addClass(targetClass);
        var $itemContainer = $targetGroup.find(itemContainerSelector);
        var $items = $itemContainer.find(itemSelector);
        var targetSortable = $targetGroup.closest("." + SORTABLE_CLASS).data("dxSortableOld");
        var useIndicator = targetSortable.option("useIndicator");
        var isVertical = (targetSortable || that).option("direction") === "vertical";
        var itemsOffset = getItemsOffset($items, isVertical, $itemContainer);
        var itemOffset = that._getItemOffset(isVertical, itemsOffset, e);
        if (itemOffset) {
          $item = itemOffset.item;
          $prevItem = itemsOffset[itemOffset.index - 1] && itemsOffset[itemOffset.index - 1].item;
          if ($item.hasClass(sourceClass) || $prevItem && $prevItem.hasClass(sourceClass) && $prevItem.is(":visible")) {
            $targetItem.detach();
            return;
          }
          targetIndex = itemOffset.index;
          if (!useIndicator) {
            $targetItem.insertBefore($item);
            return;
          }
          var isAnotherGroup = $targetGroup.attr("group") !== sourceGroup;
          var isSameIndex = targetIndex === sourceIndex;
          var isNextIndex = targetIndex === sourceIndex + 1;
          if (isAnotherGroup) {
            that._renderIndicator($item, isVertical, $targetGroup, that.option("rtlEnabled") && !isVertical);
            return;
          }
          if (!isSameIndex && !isNextIndex) {
            that._renderIndicator($item, isVertical, $targetGroup, that.option("rtlEnabled") && !isVertical);
          }
        } else {
          $lastItem = $items.last();
          if ($lastItem.is(":visible") && $lastItem.hasClass(sourceClass)) {
            return;
          }
          if ($itemContainer.length) {
            targetIndex = itemsOffset.length ? itemsOffset[itemsOffset.length - 1].index + 1 : 0;
          }
          if (useIndicator) {
            $items.length && that._renderIndicator($lastItem, isVertical, $targetGroup, !that.option("rtlEnabled") || isVertical);
          } else {
            $targetItem.appendTo($itemContainer);
          }
        }
      });
      eventsEngine.on($eventListener, addNamespace$1(DRAG_END_EVENT, SORTABLE_NAMESPACE), function() {
        disposeScrollWrapper();
        if (!$sourceItem) {
          return;
        }
        var onChanged = that.option("onChanged");
        var changedArgs = {
          sourceIndex,
          sourceElement: $sourceItem,
          sourceGroup,
          targetIndex,
          removeSourceElement: true,
          removeTargetElement: false,
          removeSourceClass: true
        };
        if ($targetGroup) {
          $targetGroup.removeClass(targetClass);
          changedArgs.targetGroup = $targetGroup.attr("group");
          if (sourceGroup !== changedArgs.targetGroup || targetIndex > -1) {
            onChanged && onChanged(changedArgs);
            changedArgs.removeSourceElement && $sourceItem.remove();
          }
        }
        that._indicator.detach();
        changedArgs.removeSourceClass && $sourceItem.removeClass(sourceClass);
        $sourceItem = null;
        that._$draggable.remove();
        that._$draggable = null;
        changedArgs.removeTargetElement && $targetItem.remove();
        $targetItem.removeClass(targetClass);
        $targetItem = null;
      });
    }
  },
  _init: function() {
    this.callBase();
    this._attachEventHandlers();
  },
  _render: function() {
    this.callBase();
    this.$element().addClass(SORTABLE_CLASS);
  },
  _dispose: function() {
    var that = this;
    that.callBase.apply(that, arguments);
    that._$draggable && that._$draggable.detach();
    that._indicator && that._indicator.detach();
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "onDragging":
      case "onChanged":
      case "itemRender":
      case "groupSelector":
      case "itemSelector":
      case "itemContainerSelector":
      case "sourceClass":
      case "targetClass":
      case "dragClass":
      case "allowDragging":
      case "groupFilter":
      case "useIndicator":
        this._attachEventHandlers();
        break;
      case "direction":
        break;
      default:
        this.callBase(args);
    }
  },
  _useTemplates: function() {
    return false;
  }
});
registerComponent("dxSortableOld", Sortable);
var IE_FIELD_WIDTH_CORRECTION = 1;
var DIV$3 = "<div>";
var HeaderFilterView = HeaderFilterView$1.inherit({
  _getSearchExpr: function(options) {
    options.useDefaultSearchExpr = true;
    return this.callBase(options);
  }
});
var processItems = function(groupItems, field) {
  var filterValues = [];
  var isTree = !!field.groupName;
  var isExcludeFilterType = field.filterType === "exclude";
  if (field.filterValues) {
    each(field.filterValues, function(_2, filterValue) {
      filterValues.push(Array.isArray(filterValue) ? filterValue.join("/") : filterValue && filterValue.valueOf());
    });
  }
  foreachTree(groupItems, function(items) {
    var item = items[0];
    var path = createPath(items);
    var preparedFilterValueByText = isTree ? map(items, function(item2) {
      return item2.text;
    }).reverse().join("/") : item.text;
    item.value = isTree ? path.slice(0) : item.key || item.value;
    var preparedFilterValue = isTree ? path.join("/") : item.value && item.value.valueOf();
    if (item.children) {
      item.items = item.children;
      item.children = null;
    }
    updateHeaderFilterItemSelectionState(item, item.key && inArray(preparedFilterValueByText, filterValues) > -1 || inArray(preparedFilterValue, filterValues) > -1, isExcludeFilterType);
  });
};
function getMainGroupField(dataSource, sourceField) {
  var field = sourceField;
  if (isDefined(sourceField.groupIndex)) {
    field = dataSource.getAreaFields(sourceField.area, true)[sourceField.areaIndex];
  }
  return field;
}
function getStringState(state) {
  state = state || {};
  return JSON.stringify([state.fields, state.columnExpandedPaths, state.rowExpandedPaths]);
}
var FieldChooserBase = Widget.inherit(columnStateMixin).inherit(sortingMixin).inherit(headerFilterMixin).inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      allowFieldDragging: true,
      applyChangesMode: "instantly",
      state: null,
      headerFilter: {
        width: 252,
        height: 325,
        searchTimeout: 500,
        texts: {
          emptyValue: messageLocalization.format("dxDataGrid-headerFilterEmptyValue"),
          ok: messageLocalization.format("dxDataGrid-headerFilterOK"),
          cancel: messageLocalization.format("dxDataGrid-headerFilterCancel")
        }
      }
    });
  },
  _init: function() {
    this.callBase();
    this._headerFilterView = new HeaderFilterView(this);
    this._refreshDataSource();
    this.subscribeToEvents();
  },
  _refreshDataSource: function() {
    var dataSource = this.option("dataSource");
    if (dataSource && dataSource.fields && dataSource.load) {
      this._dataSource = dataSource;
    }
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "dataSource":
        this._refreshDataSource();
        break;
      case "applyChangesMode":
        break;
      case "state":
        if (this._skipStateChange || !this._dataSource) {
          break;
        }
        if (this.option("applyChangesMode") === "instantly" && getStringState(this._dataSource.state()) !== getStringState(args.value)) {
          this._dataSource.state(args.value);
        } else {
          this._clean(true);
          this._renderComponent();
        }
        break;
      case "headerFilter":
      case "allowFieldDragging":
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  renderField: function(field, showColumnLines) {
    var $fieldContent = $(DIV$3).addClass("dx-area-field-content").text(field.caption || field.dataField);
    var $fieldElement = $(DIV$3).addClass("dx-area-field").addClass("dx-area-box").data("field", field).append($fieldContent);
    var mainGroupField = getMainGroupField(this._dataSource, field);
    if (field.area !== "data") {
      if (field.allowSorting) {
        this._applyColumnState({
          name: "sort",
          rootElement: $fieldElement,
          column: {
            alignment: this.option("rtlEnabled") ? "right" : "left",
            sortOrder: field.sortOrder === "desc" ? "desc" : "asc"
          },
          showColumnLines
        });
      }
      this._applyColumnState({
        name: "headerFilter",
        rootElement: $fieldElement,
        column: {
          alignment: this.option("rtlEnabled") ? "right" : "left",
          filterValues: mainGroupField.filterValues,
          allowFiltering: mainGroupField.allowFiltering && !field.groupIndex
        },
        showColumnLines
      });
    }
    if (field.groupName) {
      $fieldElement.attr("item-group", field.groupName);
    }
    return $fieldElement;
  },
  _clean: function() {
  },
  _render: function() {
    this.callBase();
    this._headerFilterView.render(this.$element());
  },
  renderSortable: function() {
    var that = this;
    that._createComponent(that.$element(), Sortable, extend({
      allowDragging: that.option("allowFieldDragging"),
      itemSelector: ".dx-area-field",
      itemContainerSelector: ".dx-area-field-container",
      groupSelector: ".dx-area-fields",
      groupFilter: function() {
        var dataSource = that._dataSource;
        var $sortable = $(this).closest(".dx-sortable-old");
        var pivotGrid = $sortable.data("dxPivotGrid");
        var pivotGridFieldChooser = $sortable.data("dxPivotGridFieldChooser");
        if (pivotGrid) {
          return pivotGrid.getDataSource() === dataSource;
        }
        if (pivotGridFieldChooser) {
          return pivotGridFieldChooser.option("dataSource") === dataSource;
        }
        return false;
      },
      itemRender: function($sourceItem, target) {
        var $item;
        if ($sourceItem.hasClass("dx-area-box")) {
          $item = $sourceItem.clone();
          if (target === "drag") {
            each($sourceItem, function(index2, sourceItem) {
              $item.eq(index2).css("width", parseInt($(sourceItem).outerWidth(), 10) + IE_FIELD_WIDTH_CORRECTION);
            });
          }
        } else {
          $item = $(DIV$3).addClass("dx-area-field").addClass("dx-area-box").text($sourceItem.text());
        }
        if (target === "drag") {
          var wrapperContainer = $(DIV$3);
          each($item, function(_2, item) {
            var wrapper = $("<div>").addClass("dx-pivotgrid-fields-container").addClass("dx-widget").append($(item));
            wrapperContainer.append(wrapper);
          });
          return wrapperContainer.children();
        }
        return $item;
      },
      onDragging: function(e) {
        var field = e.sourceElement.data("field");
        var targetGroup = e.targetGroup;
        e.cancel = false;
        if (field.isMeasure === true) {
          if (targetGroup === "column" || targetGroup === "row" || targetGroup === "filter") {
            e.cancel = true;
          }
        } else if (field.isMeasure === false && targetGroup === "data") {
          e.cancel = true;
        }
      },
      useIndicator: true,
      onChanged: function(e) {
        var dataSource = that._dataSource;
        var field = e.sourceElement.data("field");
        e.removeSourceElement = !!e.sourceGroup;
        that._adjustSortableOnChangedArgs(e);
        if (field) {
          that._applyChanges([getMainGroupField(dataSource, field)], {
            area: e.targetGroup,
            areaIndex: e.targetIndex
          });
        }
      }
    }, that._getSortableOptions()));
  },
  _processDemandState: function(func) {
    var isInstantlyMode = this.option("applyChangesMode") === "instantly";
    var dataSource = this._dataSource;
    if (isInstantlyMode) {
      func(dataSource, isInstantlyMode);
    } else {
      var currentState = dataSource.state();
      var pivotGridState = this.option("state");
      if (pivotGridState) {
        dataSource.state(pivotGridState, true);
      }
      func(dataSource, isInstantlyMode);
      dataSource.state(currentState, true);
    }
  },
  _applyChanges(fields, props) {
    var that = this;
    that._processDemandState(function(dataSource, isInstantlyMode) {
      fields.forEach((_ref) => {
        var {
          index: index2
        } = _ref;
        dataSource.field(index2, props);
      });
      if (isInstantlyMode) {
        dataSource.load();
      } else {
        that._changedHandler();
      }
    });
  },
  _adjustSortableOnChangedArgs: function(e) {
    e.removeSourceElement = false;
    e.removeTargetElement = true;
    e.removeSourceClass = false;
  },
  _getSortableOptions: function() {
    return {
      direction: "auto"
    };
  },
  subscribeToEvents: function(element) {
    var that = this;
    var func = function(e) {
      var field = $(e.currentTarget).data("field");
      var mainGroupField = extend(true, {}, getMainGroupField(that._dataSource, field));
      var isHeaderFilter = $(e.target).hasClass("dx-header-filter");
      var dataSource = that._dataSource;
      var type2 = mainGroupField.groupName ? "tree" : "list";
      var paginate = dataSource.paginate() && type2 === "list";
      if (isHeaderFilter) {
        that._headerFilterView.showHeaderFilterMenu($(e.currentTarget), extend(mainGroupField, {
          type: type2,
          encodeHtml: that.option("encodeHtml"),
          dataSource: {
            useDefaultSearch: !paginate,
            load: function(options) {
              var userData = options.userData;
              if (userData.store) {
                return userData.store.load(options);
              } else {
                var d = new Deferred();
                dataSource.getFieldValues(mainGroupField.index, that.option("headerFilter.showRelevantValues"), paginate ? options : void 0).done(function(data2) {
                  var emptyValue = that.option("headerFilter.texts.emptyValue");
                  data2.forEach((element2) => {
                    if (!element2.text) {
                      element2.text = emptyValue;
                    }
                  });
                  if (paginate) {
                    d.resolve(data2);
                  } else {
                    userData.store = new ArrayStore(data2);
                    userData.store.load(options).done(d.resolve).fail(d.reject);
                  }
                }).fail(d.reject);
                return d;
              }
            },
            postProcess: function(data2) {
              processItems(data2, mainGroupField);
              return data2;
            }
          },
          apply: function() {
            that._applyChanges([mainGroupField], {
              filterValues: this.filterValues,
              filterType: this.filterType
            });
          }
        }));
      } else if (field.allowSorting && field.area !== "data") {
        that._applyChanges([field], {
          sortOrder: field.sortOrder === "desc" ? "asc" : "desc"
        });
      }
    };
    if (element) {
      eventsEngine.on(element, CLICK_EVENT_NAME$2, ".dx-area-field.dx-area-box", func);
      return;
    }
    eventsEngine.on(that.$element(), CLICK_EVENT_NAME$2, ".dx-area-field.dx-area-box", func);
  },
  _initTemplates: noop,
  addWidgetPrefix: function(className) {
    return "dx-pivotgrid-" + className;
  }
});
registerComponent("dxPivotGridFieldChooserBase", FieldChooserBase);
var DIV$2 = "<div>";
var AREA_DRAG_CLASS$1 = "dx-pivotgrid-drag-action";
function renderGroupConnector(field, nextField, prevField, $container) {
  if (prevField && prevField.groupName && prevField.groupName === field.groupName) {
    $(DIV$2).addClass("dx-group-connector").addClass("dx-group-connector-prev").appendTo($container);
  }
  if (nextField && nextField.groupName && nextField.groupName === field.groupName) {
    $(DIV$2).addClass("dx-group-connector").addClass("dx-group-connector-next").appendTo($container);
  }
}
var FieldsArea = AreaItem.inherit({
  ctor: function(component, area) {
    this.callBase(component);
    this._area = area;
  },
  _getAreaName: function() {
    return "fields";
  },
  _createGroupElement: function() {
    return $(DIV$2).addClass("dx-pivotgrid-fields-area").addClass("dx-area-fields").addClass(AREA_DRAG_CLASS$1).attr("group", this._area);
  },
  isVisible: function() {
    return !!this.option("fieldPanel.visible") && this.option("fieldPanel.show" + capitalizeFirstLetter(this._area) + "Fields");
  },
  _renderButton: function(element) {
    var that = this;
    var container = $("<td>").appendTo($("<tr>").appendTo(element));
    var button = that.component._createComponent($(DIV$2).appendTo(container), Button, {
      text: "Fields",
      icon: "menu",
      width: "auto",
      onClick: function() {
        var popup = that.tableElement().find(".dx-fields-area-popup").dxPopup("instance");
        if (!popup.option("visible")) {
          popup.show();
        }
      }
    });
    button.$element().addClass("dx-pivotgrid-fields-area-hamburger");
  },
  _getPopupOptions: function(row, button) {
    return {
      contentTemplate: function() {
        return $("<table>").addClass("dx-area-field-container").append($("<thead>").addClass("dx-pivotgrid-fields-area-head").append(row));
      },
      height: "auto",
      width: "auto",
      position: {
        at: "left",
        my: "left",
        of: button
      },
      dragEnabled: false,
      animation: {
        show: {
          type: "pop",
          duration: 200
        }
      },
      shading: false,
      showTitle: false,
      closeOnOutsideClick: true,
      container: button.parent()
    };
  },
  _renderPopup: function(tableElement, row) {
    var button = tableElement.find(".dx-button");
    var popupOptions = this._getPopupOptions(row, button);
    var FieldChooserBase2 = this.component.$element().dxPivotGridFieldChooserBase("instance");
    if (this._rowPopup) {
      this._rowPopup.$element().remove();
    }
    this._rowPopup = this.component._createComponent($(DIV$2).appendTo(tableElement), Popup, popupOptions);
    this._rowPopup.$element().addClass("dx-fields-area-popup");
    this._rowPopup.content().addClass("dx-pivotgrid-fields-container");
    this._rowPopup.content().parent().attr("group", "row");
    FieldChooserBase2.subscribeToEvents(this._rowPopup.content());
    FieldChooserBase2.renderSortable(this._rowPopup.content());
  },
  _shouldCreateButton: function() {
    return false;
  },
  _renderTableContent: function(tableElement, data2) {
    var that = this;
    var groupElement = this.groupElement();
    var isVisible2 = this.isVisible();
    var fieldChooserBase = that.component.$element().dxPivotGridFieldChooserBase("instance");
    var head = $("<thead>").addClass("dx-pivotgrid-fields-area-head").appendTo(tableElement);
    var area = that._area;
    var row = $("<tr>");
    groupElement.toggleClass("dx-hidden", !isVisible2);
    tableElement.addClass("dx-area-field-container");
    if (!isVisible2) {
      return;
    }
    each(data2, function(index2, field) {
      if (field.area === area && field.visible !== false) {
        var td = $("<td>").append(fieldChooserBase.renderField(field, field.area === "row"));
        var indicators = td.find(".dx-column-indicators");
        if (indicators.length && that._shouldCreateButton()) {
          indicators.insertAfter(indicators.next());
        }
        td.appendTo(row);
        renderGroupConnector(field, data2[index2 + 1], data2[index2 - 1], td);
      }
    });
    if (!row.children().length) {
      $("<td>").append($(DIV$2).addClass("dx-empty-area-text").text(this.option("fieldPanel.texts." + area + "FieldArea"))).appendTo(row);
    }
    if (that._shouldCreateButton()) {
      that._renderButton(head);
      that._renderPopup(tableElement, row);
    } else {
      head.append(row);
    }
  },
  reset: function() {
    this.callBase();
    this.groupElement().css("marginTop", 0);
  },
  _renderVirtualContent: noop
});
class MenuBaseEditStrategy extends PlainEditStrategy {
  _getPlainItems() {
    return map(this._collectionWidget.option("items"), function getMenuItems(item) {
      return item.items ? [item].concat(map(item.items, getMenuItems)) : item;
    });
  }
  _stringifyItem(item) {
    return JSON.stringify(item, (key, value2) => {
      if (key === "template") {
        return this._getTemplateString(value2);
      }
      return value2;
    });
  }
  _getTemplateString(template) {
    var result;
    if (typeof template === "object") {
      result = $(template).text();
    } else {
      result = template.toString();
    }
    return result;
  }
}
var DX_MENU_CLASS$1 = "dx-menu";
var DX_MENU_NO_ICONS_CLASS = DX_MENU_CLASS$1 + "-no-icons";
var DX_MENU_BASE_CLASS = "dx-menu-base";
var ITEM_CLASS = DX_MENU_CLASS$1 + "-item";
var DX_ITEM_CONTENT_CLASS = ITEM_CLASS + "-content";
var DX_MENU_SELECTED_ITEM_CLASS = ITEM_CLASS + "-selected";
var DX_MENU_ITEM_WRAPPER_CLASS$1 = ITEM_CLASS + "-wrapper";
var DX_MENU_ITEMS_CONTAINER_CLASS$1 = DX_MENU_CLASS$1 + "-items-container";
var DX_MENU_ITEM_EXPANDED_CLASS$1 = ITEM_CLASS + "-expanded";
var DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS$1 + "-separator";
var DX_MENU_ITEM_LAST_GROUP_ITEM = DX_MENU_CLASS$1 + "-last-group-item";
var DX_ITEM_HAS_TEXT = ITEM_CLASS + "-has-text";
var DX_ITEM_HAS_ICON = ITEM_CLASS + "-has-icon";
var DX_ITEM_HAS_SUBMENU = ITEM_CLASS + "-has-submenu";
var DX_MENU_ITEM_POPOUT_CLASS = ITEM_CLASS + "-popout";
var DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = DX_MENU_ITEM_POPOUT_CLASS + "-container";
var DX_MENU_ITEM_CAPTION_CLASS = ITEM_CLASS + "-text";
var SINGLE_SELECTION_MODE = "single";
var DEFAULT_DELAY = {
  show: 50,
  hide: 300
};
class MenuBase extends HierarchicalCollectionWidget {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      items: [],
      cssClass: "",
      activeStateEnabled: true,
      showSubmenuMode: {
        name: "onHover",
        delay: {
          show: 50,
          hide: 300
        }
      },
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1,
          duration: 100
        },
        hide: {
          type: "fade",
          from: 1,
          to: 0,
          duration: 100
        }
      },
      selectByClick: false,
      focusOnSelectedItem: false,
      keyExpr: null,
      _itemAttributes: {
        role: "menuitem"
      },
      useInkRipple: false
    });
  }
  _itemDataKey() {
    return "dxMenuItemDataKey";
  }
  _itemClass() {
    return ITEM_CLASS;
  }
  _setAriaSelected() {
  }
  _selectedItemClass() {
    return DX_MENU_SELECTED_ITEM_CLASS;
  }
  _widgetClass() {
    return DX_MENU_BASE_CLASS;
  }
  _focusTarget() {
    return this._itemContainer();
  }
  _clean() {
    this.option("focusedElement", null);
    super._clean();
  }
  _supportedKeys() {
    return extend(super._supportedKeys(), {
      space: () => {
        var $item = $(this.option("focusedElement"));
        if (!$item.length || !this._isSelectionEnabled()) {
          return;
        }
        this.selectItem($item[0]);
      },
      pageUp: noop,
      pageDown: noop
    });
  }
  _isSelectionEnabled() {
    return this.option("selectionMode") === SINGLE_SELECTION_MODE;
  }
  _init() {
    this._activeStateUnit = ".".concat(ITEM_CLASS);
    super._init();
    this._renderSelectedItem();
    this._initActions();
  }
  _getTextContainer(itemData) {
    var itemText = itemData.text;
    var $itemContainer = $("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS);
    var itemContent = isPlainObject(itemData) ? itemText : String(itemData);
    return itemText && $itemContainer.text(itemContent);
  }
  _getPopoutContainer(itemData) {
    var items = itemData.items;
    var $popOutContainer;
    if (items && items.length) {
      var $popOutImage = $("<div>").addClass(DX_MENU_ITEM_POPOUT_CLASS);
      $popOutContainer = $("<span>").addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage);
    }
    return $popOutContainer;
  }
  _getDataAdapterOptions() {
    return {
      rootValue: 0,
      multipleSelection: false,
      recursiveSelection: false,
      recursiveExpansion: false,
      searchValue: ""
    };
  }
  _selectByItem(selectedItem) {
    if (!selectedItem) {
      return;
    }
    var nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
    this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true);
  }
  _renderSelectedItem() {
    var selectedKeys = this._dataAdapter.getSelectedNodesKeys();
    var selectedKey = selectedKeys.length && selectedKeys[0];
    var selectedItem = this.option("selectedItem");
    if (!selectedKey) {
      this._selectByItem(selectedItem);
      return;
    }
    var node = this._dataAdapter.getNodeByKey(selectedKey);
    if (node.selectable === false) {
      return;
    }
    if (!selectedItem) {
      this.option("selectedItem", node.internalFields.item);
      return;
    }
    if (selectedItem !== node.internalFields.item) {
      this._dataAdapter.toggleSelection(selectedKey, false);
      this._selectByItem(selectedItem);
    }
  }
  _initActions() {
  }
  _initMarkup() {
    super._initMarkup();
    this._addCustomCssClass(this.$element());
    this.option("useInkRipple") && this._renderInkRipple();
  }
  _renderInkRipple() {
    this._inkRipple = render();
  }
  _toggleActiveState($element, value2, e) {
    super._toggleActiveState.apply(this, arguments);
    if (!this._inkRipple) {
      return;
    }
    var config2 = {
      element: $element,
      event: e
    };
    if (value2) {
      this._inkRipple.showWave(config2);
    } else {
      this._inkRipple.hideWave(config2);
    }
  }
  _getShowSubmenuMode() {
    var optionValue = this.option("showSubmenuMode");
    optionValue = isObject$1(optionValue) ? optionValue.name : optionValue;
    return this._isDesktopDevice() ? optionValue : "onClick";
  }
  _initSelectedItems() {
  }
  _isDesktopDevice() {
    return devices.real().deviceType === "desktop";
  }
  _initEditStrategy() {
    var Strategy = MenuBaseEditStrategy;
    this._editStrategy = new Strategy(this);
  }
  _addCustomCssClass($element) {
    $element.addClass(this.option("cssClass"));
  }
  _itemWrapperSelector() {
    return ".".concat(DX_MENU_ITEM_WRAPPER_CLASS$1);
  }
  _hoverStartHandler(e) {
    var $itemElement = this._getItemElementByEventArgs(e);
    if (!$itemElement || this._isItemDisabled($itemElement)) {
      return;
    }
    e.stopPropagation();
    if (this._getShowSubmenuMode() === "onHover") {
      clearTimeout(this._showSubmenusTimeout);
      this._showSubmenusTimeout = setTimeout(this._showSubmenu.bind(this, $itemElement), this._getSubmenuDelay("show"));
    }
  }
  _getAvailableItems($itemElements) {
    return super._getAvailableItems($itemElements).filter(function() {
      return $(this).css("visibility") !== "hidden";
    });
  }
  _isItemDisabled($item) {
    return this._disabledGetter($item.data(this._itemDataKey()));
  }
  _showSubmenu($itemElement) {
    this._addExpandedClass($itemElement);
  }
  _addExpandedClass(itemElement) {
    $(itemElement).addClass(DX_MENU_ITEM_EXPANDED_CLASS$1);
  }
  _getSubmenuDelay(action) {
    var {
      delay
    } = this.option("showSubmenuMode");
    if (!isDefined(delay)) {
      return DEFAULT_DELAY[action];
    }
    return isObject$1(delay) ? delay[action] : delay;
  }
  _getItemElementByEventArgs(eventArgs) {
    var $target = $(eventArgs.target);
    if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget) {
      return $target;
    }
    while (!$target.hasClass(this._itemClass())) {
      $target = $target.parent();
      if ($target.hasClass("dx-submenu")) {
        return null;
      }
    }
    return $target;
  }
  _hoverEndHandler() {
    clearTimeout(this._showSubmenusTimeout);
  }
  _hasSubmenu(node) {
    return node && node.internalFields.childrenKeys.length;
  }
  _renderContentImpl() {
    this._renderItems(this._dataAdapter.getRootNodes());
  }
  _renderItems(nodes, submenuContainer) {
    if (nodes.length) {
      this.hasIcons = false;
      var $nodeContainer = this._renderContainer(this.$element(), submenuContainer);
      var firstVisibleIndex = -1;
      var nextGroupFirstIndex = -1;
      each(nodes, (index2, node) => {
        var isVisibleNode = node.visible !== false;
        if (isVisibleNode && firstVisibleIndex < 0) {
          firstVisibleIndex = index2;
        }
        var isBeginGroup = firstVisibleIndex < index2 && (node.beginGroup || index2 === nextGroupFirstIndex);
        if (isBeginGroup) {
          nextGroupFirstIndex = isVisibleNode ? index2 : index2 + 1;
        }
        if (index2 === nextGroupFirstIndex && firstVisibleIndex < index2) {
          this._renderSeparator($nodeContainer);
        }
        this._renderItem(index2, node, $nodeContainer);
      });
      if (!this.hasIcons) {
        $nodeContainer.addClass(DX_MENU_NO_ICONS_CLASS);
      }
    }
  }
  _renderContainer($wrapper) {
    var $container = $("<ul>");
    this.setAria("role", "none", $container);
    return $container.appendTo($wrapper).addClass(DX_MENU_ITEMS_CONTAINER_CLASS$1);
  }
  _createDOMElement($nodeContainer) {
    var $node = $("<li>");
    this.setAria("role", "none", $node);
    return $node.appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS$1);
  }
  _renderItem(index2, node, $nodeContainer, $nodeElement) {
    var items = this.option("items");
    var $node = $nodeElement || this._createDOMElement($nodeContainer);
    if (items[index2 + 1] && items[index2 + 1].beginGroup) {
      $node.addClass(DX_MENU_ITEM_LAST_GROUP_ITEM);
    }
    var $itemFrame = super._renderItem(index2, node.internalFields.item, $node);
    if (node.internalFields.item === this.option("selectedItem")) {
      $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS);
    }
    $itemFrame.attr("tabIndex", -1);
    if (this._hasSubmenu(node)) {
      this.setAria("haspopup", "true", $itemFrame);
    }
  }
  _renderItemFrame(index2, itemData, $itemContainer) {
    var $itemFrame = $itemContainer.children(".".concat(ITEM_CLASS));
    return $itemFrame.length ? $itemFrame : super._renderItemFrame.apply(this, arguments);
  }
  _refreshItem($item, item) {
    var node = this._dataAdapter.getNodeByItem(item);
    var index2 = $item.data(this._itemIndexKey());
    var $nodeContainer = $item.closest("ul");
    var $nodeElement = $item.closest("li");
    this._renderItem(index2, node, $nodeContainer, $nodeElement);
  }
  _addContentClasses(itemData, $itemFrame) {
    var hasText = itemData.text ? !!itemData.text.length : false;
    var hasIcon = !!itemData.icon;
    var hasSubmenu = itemData.items ? !!itemData.items.length : false;
    $itemFrame.toggleClass(DX_ITEM_HAS_TEXT, hasText);
    $itemFrame.toggleClass(DX_ITEM_HAS_ICON, hasIcon);
    if (!this.hasIcons) {
      this.hasIcons = hasIcon;
    }
    $itemFrame.toggleClass(DX_ITEM_HAS_SUBMENU, hasSubmenu);
  }
  _getItemContent($itemFrame) {
    var $itemContent = super._getItemContent($itemFrame);
    if (!$itemContent.length) {
      $itemContent = $itemFrame.children(".".concat(DX_ITEM_CONTENT_CLASS));
    }
    return $itemContent;
  }
  _postprocessRenderItem(args) {
    var $itemElement = $(args.itemElement);
    var selectedIndex = this._dataAdapter.getSelectedNodesKeys();
    if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
      this._setAriaSelected($itemElement, "false");
      return;
    }
    var node = this._dataAdapter.getNodeByItem(args.itemData);
    if (node.internalFields.key === selectedIndex[0]) {
      $itemElement.addClass(this._selectedItemClass());
      this._setAriaSelected($itemElement, "true");
    } else {
      this._setAriaSelected($itemElement, "false");
    }
  }
  _isItemSelectable(item) {
    return item.selectable !== false;
  }
  _renderSeparator($itemsContainer) {
    $("<li>").appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS);
  }
  _itemClickHandler(e) {
    if (e._skipHandling) {
      return;
    }
    var itemClickActionHandler = this._createAction(this._updateSubmenuVisibilityOnClick.bind(this));
    this._itemDXEventHandler(e, "onItemClick", {}, {
      afterExecute: itemClickActionHandler.bind(this)
    });
    e._skipHandling = true;
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    this._updateSelectedItemOnClick(actionArgs);
    if (this._getShowSubmenuMode() === "onClick") {
      this._addExpandedClass(actionArgs.args[0].itemElement);
    }
  }
  _updateSelectedItemOnClick(actionArgs) {
    var args = actionArgs.args ? actionArgs.args[0] : actionArgs;
    if (!this._isItemSelectionAllowed(args.itemData)) {
      return;
    }
    var selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
    var selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
    if (selectedNode) {
      this._toggleItemSelection(selectedNode, false);
    }
    if (!selectedNode || selectedNode.internalFields.item !== args.itemData) {
      this.selectItem(args.itemData);
    } else {
      this._fireSelectionChangeEvent(null, this.option("selectedItem"));
      this._setOptionWithoutOptionChange("selectedItem", null);
    }
  }
  _isItemSelectionAllowed(item) {
    var isSelectionByClickEnabled = this._isSelectionEnabled() && this.option("selectByClick");
    return !this._isContainerEmpty() && isSelectionByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item);
  }
  _isContainerEmpty() {
    return this._itemContainer().is(":empty");
  }
  _syncSelectionOptions() {
    return asyncNoop();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "showSubmenuMode":
        break;
      case "selectedItem":
        var node = this._dataAdapter.getNodeByItem(args.value);
        var selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
        if (node && node.internalFields.key !== selectedKey) {
          if (node.selectable === false) {
            break;
          }
          if (selectedKey) {
            this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
          }
          this._toggleItemSelection(node, true);
          this._updateSelectedItems();
        }
        break;
      case "cssClass":
      case "position":
      case "selectByClick":
      case "animation":
      case "useInkRipple":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _toggleItemSelection(node, value2) {
    var itemElement = this._getElementByItem(node.internalFields.item);
    itemElement && $(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
    this._dataAdapter.toggleSelection(node.internalFields.key, value2);
  }
  _getElementByItem(itemData) {
    var result;
    each(this._itemElements(), (_2, itemElement) => {
      if ($(itemElement).data(this._itemDataKey()) !== itemData) {
        return true;
      }
      result = itemElement;
      return false;
    });
    return result;
  }
  _updateSelectedItems(oldSelection, newSelection) {
    if (oldSelection || newSelection) {
      this._fireSelectionChangeEvent(newSelection, oldSelection);
    }
  }
  _fireSelectionChangeEvent(addedSelection, removedSelection) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems: [addedSelection],
      removedItems: [removedSelection]
    });
  }
  selectItem(itemElement) {
    var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
    var selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
    var selectedItem = this.option("selectedItem");
    var node = this._dataAdapter.getNodeByItem(itemData);
    if (node.internalFields.key !== selectedKey) {
      if (selectedKey) {
        this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
      }
      this._toggleItemSelection(node, true);
      this._updateSelectedItems(selectedItem, itemData);
      this._setOptionWithoutOptionChange("selectedItem", itemData);
    }
  }
  unselectItem(itemElement) {
    var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
    var node = this._dataAdapter.getNodeByItem(itemData);
    var selectedItem = this.option("selectedItem");
    if (node.internalFields.selected) {
      this._toggleItemSelection(node, false);
      this._updateSelectedItems(selectedItem, null);
      this._setOptionWithoutOptionChange("selectedItem", null);
    }
  }
}
MenuBase.ItemClass = CollectionItem;
var DX_MENU_CLASS = "dx-menu";
var DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item";
var DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded";
var DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay";
var DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container";
var DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + "-wrapper";
var DX_SUBMENU_CLASS = "dx-submenu";
var DX_CONTEXT_MENU_CLASS = "dx-context-menu";
var DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu";
var DX_STATE_DISABLED_CLASS = "dx-state-disabled";
var DX_STATE_FOCUSED_CLASS = "dx-state-focused";
var DX_STATE_HOVER_CLASS = "dx-state-hover";
var FOCUS_UP = "up";
var FOCUS_DOWN = "down";
var FOCUS_LEFT = "left";
var FOCUS_RIGHT = "right";
var FOCUS_FIRST = "first";
var FOCUS_LAST = "last";
var ACTIONS = ["onShowing", "onShown", "onSubmenuCreated", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"];
var LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST];
var DEFAULT_SHOW_EVENT = "dxcontextmenu";
class ContextMenu extends MenuBase {
  getShowEvent(showEventOption) {
    var result = null;
    if (isObject$1(showEventOption)) {
      if (showEventOption.name !== null) {
        result = showEventOption.name || DEFAULT_SHOW_EVENT;
      }
    } else {
      result = showEventOption;
    }
    return result;
  }
  getShowDelay(showEventOption) {
    return isObject$1(showEventOption) && showEventOption.delay;
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showEvent: DEFAULT_SHOW_EVENT,
      closeOnOutsideClick: true,
      position: {
        at: "top left",
        my: "top left"
      },
      onShowing: null,
      onShown: null,
      onSubmenuCreated: null,
      onHiding: null,
      onHidden: null,
      onPositioning: null,
      submenuDirection: "auto",
      visible: false,
      target: void 0,
      onLeftFirstItem: null,
      onLeftLastItem: null,
      onCloseRootSubmenu: null,
      onExpandLastSubmenu: null
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !hasWindow$1(),
      options: {
        animation: null
      }
    }]);
  }
  _initActions() {
    this._actions = {};
    each(ACTIONS, (index2, action) => {
      this._actions[action] = this._createActionByOption(action) || noop;
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      animation: true,
      selectedItem: true
    });
  }
  _focusInHandler() {
  }
  _itemContainer() {
    return this._overlay ? this._overlay.$content() : $();
  }
  _eventBindingTarget() {
    return this._itemContainer();
  }
  itemsContainer() {
    return this._overlay ? this._overlay.$content() : void 0;
  }
  _supportedKeys() {
    return extend(super._supportedKeys(), {
      space: () => {
        var $item = $(this.option("focusedElement"));
        this.hide();
        if (!$item.length || !this._isSelectionEnabled()) {
          return;
        }
        this.selectItem($item[0]);
      },
      escape: this.hide
    });
  }
  _getActiveItem() {
    var $availableItems = this._getAvailableItems();
    var $focusedItem = $availableItems.filter(".".concat(DX_STATE_FOCUSED_CLASS));
    var $hoveredItem = $availableItems.filter(".".concat(DX_STATE_HOVER_CLASS));
    var $hoveredItemContainer = $hoveredItem.closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS));
    if ($hoveredItemContainer.find(".".concat(DX_MENU_ITEM_CLASS)).index($focusedItem) >= 0) {
      return $focusedItem;
    }
    if ($hoveredItem.length) {
      return $hoveredItem;
    }
    return super._getActiveItem();
  }
  _moveFocus(location) {
    var $items = this._getItemsByLocation(location);
    var $oldTarget = this._getActiveItem(true);
    var $hoveredItem = this.itemsContainer().find(".".concat(DX_STATE_HOVER_CLASS));
    var $focusedItem = $(this.option("focusedElement"));
    var $activeItemHighlighted = !!($focusedItem.length || $hoveredItem.length);
    var $newTarget;
    switch (location) {
      case FOCUS_UP:
        $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;
        this._setFocusedElement($newTarget);
        if ($oldTarget.is($items.first())) {
          this._actions.onLeftFirstItem($oldTarget);
        }
        break;
      case FOCUS_DOWN:
        $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;
        this._setFocusedElement($newTarget);
        if ($oldTarget.is($items.last())) {
          this._actions.onLeftLastItem($oldTarget);
        }
        break;
      case FOCUS_RIGHT:
        $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);
        this._setFocusedElement($newTarget);
        break;
      case FOCUS_LEFT:
        $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();
        this._setFocusedElement($newTarget);
        break;
      case FOCUS_FIRST:
        $newTarget = $items.first();
        this._setFocusedElement($newTarget);
        break;
      case FOCUS_LAST:
        $newTarget = $items.last();
        this._setFocusedElement($newTarget);
        break;
      default:
        return super._moveFocus(location);
    }
  }
  _setFocusedElement($element) {
    if ($element && $element.length !== 0) {
      this.option("focusedElement", getPublicElement($element));
    }
  }
  _getItemsByLocation(location) {
    var $activeItem = this._getActiveItem(true);
    var $items;
    if (inArray(location, LOCAL_SUBMENU_DIRECTIONS) >= 0) {
      $items = $activeItem.closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS)).children().children();
    }
    $items = this._getAvailableItems($items);
    return $items;
  }
  _getAriaTarget() {
    return this.$element();
  }
  _refreshActiveDescendant() {
    if (isDefined(this._overlay)) {
      var $target = this._overlay.$content();
      super._refreshActiveDescendant($target);
    }
  }
  _hideSubmenuHandler() {
    var $curItem = this._getActiveItem(true);
    var $parentItem = $curItem.parents(".".concat(DX_MENU_ITEM_EXPANDED_CLASS)).first();
    if ($parentItem.length) {
      this._hideSubmenusOnSameLevel($parentItem);
      this._hideSubmenu($curItem.closest(".".concat(DX_SUBMENU_CLASS)));
      return $parentItem;
    }
    this._actions.onCloseRootSubmenu($curItem);
    return $curItem;
  }
  _expandSubmenuHandler($items, location) {
    var $curItem = this._getActiveItem(true);
    var itemData = this._getItemData($curItem);
    var node = this._dataAdapter.getNodeByItem(itemData);
    var isItemHasSubmenu = this._hasSubmenu(node);
    var $submenu = $curItem.children(".".concat(DX_SUBMENU_CLASS));
    if (isItemHasSubmenu && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {
      if (!$submenu.length || $submenu.css("visibility") === "hidden") {
        this._showSubmenu($curItem);
      }
      return this._nextItem(this._getItemsByLocation(location));
    }
    this._actions.onExpandLastSubmenu($curItem);
    return;
  }
  _clean() {
    if (this._overlay) {
      this._overlay.$element().remove();
      this._overlay = null;
    }
    this._detachShowContextMenuEvents(this._getTarget());
    super._clean();
  }
  _initMarkup() {
    this.$element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderVisibility(this.option("visible"));
    this._addWidgetClass();
  }
  _renderContentImpl() {
    this._detachShowContextMenuEvents(this._getTarget());
    this._attachShowContextMenuEvents();
  }
  _attachKeyboardEvents() {
    !this._keyboardListenerId && this._focusTarget().length && super._attachKeyboardEvents();
  }
  _renderContextMenuOverlay() {
    if (this._overlay) {
      return;
    }
    var overlayOptions = this._getOverlayOptions();
    this._overlay = this._createComponent($("<div>").appendTo(this._$element), Overlay, overlayOptions);
    var $overlayContent = this._overlay.$content();
    $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
    this._addCustomCssClass($overlayContent);
    this._addPlatformDependentClass($overlayContent);
    this._attachContextMenuEvent();
  }
  preventShowingDefaultContextMenuAboveOverlay() {
    var $itemContainer = this._itemContainer();
    var eventName = addNamespace$1(name, this.NAME);
    eventsEngine.off($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS));
    eventsEngine.on($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS), ((e) => {
      e.stopPropagation();
      e.preventDefault();
      eventsEngine.off($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS));
    }).bind(this));
  }
  _itemContextMenuHandler(e) {
    super._itemContextMenuHandler(e);
    e.stopPropagation();
  }
  _addPlatformDependentClass($element) {
    if (devices.current().phone) {
      $element.addClass(DX_MENU_PHONE_CLASS);
    }
  }
  _detachShowContextMenuEvents(target) {
    var showEvent = this.getShowEvent(this.option("showEvent"));
    if (!showEvent) {
      return;
    }
    var eventName = addNamespace$1(showEvent, this.NAME);
    if (this._showContextMenuEventHandler) {
      eventsEngine.off(domAdapter.getDocument(), eventName, target, this._showContextMenuEventHandler);
    } else {
      eventsEngine.off($(target), eventName);
    }
  }
  _attachShowContextMenuEvents() {
    var target = this._getTarget();
    var showEvent = this.getShowEvent(this.option("showEvent"));
    if (!showEvent) {
      return;
    }
    var eventName = addNamespace$1(showEvent, this.NAME);
    var contextMenuAction = this._createAction((e) => {
      var delay = this.getShowDelay(this.option("showEvent"));
      if (delay) {
        setTimeout(() => this._show(e.event), delay);
      } else {
        this._show(e.event);
      }
    }, {
      validatingTargetName: "target"
    });
    var handler = (e) => contextMenuAction({
      event: e,
      target: $(e.currentTarget)
    });
    contextMenuAction = this._createAction(contextMenuAction);
    if (isRenderer(target) || target.nodeType || isWindow(target)) {
      this._showContextMenuEventHandler = void 0;
      eventsEngine.on(target, eventName, handler);
    } else {
      this._showContextMenuEventHandler = handler;
      eventsEngine.on(domAdapter.getDocument(), eventName, target, this._showContextMenuEventHandler);
    }
  }
  _hoverEndHandler(e) {
    super._hoverEndHandler(e);
    e.stopPropagation();
  }
  _renderDimensions() {
  }
  _renderContainer($wrapper, submenuContainer) {
    var $holder = submenuContainer || this._itemContainer();
    $wrapper = $("<div>");
    $wrapper.appendTo($holder).addClass(DX_SUBMENU_CLASS).css("visibility", submenuContainer ? "hidden" : "visible");
    var $itemsContainer = super._renderContainer($wrapper);
    if (submenuContainer) {
      return $itemsContainer;
    }
    if (this.option("width")) {
      return $itemsContainer.css("minWidth", this.option("width"));
    }
    if (this.option("height")) {
      return $itemsContainer.css("minHeight", this.option("height"));
    }
    return $itemsContainer;
  }
  _renderSubmenuItems(node, $itemFrame) {
    this._renderItems(this._getChildNodes(node), $itemFrame);
    this._actions.onSubmenuCreated({
      itemElement: getPublicElement($itemFrame),
      itemData: node.internalFields.item,
      submenuElement: getPublicElement($itemFrame.children(".".concat(DX_SUBMENU_CLASS)))
    });
  }
  _getOverlayOptions() {
    var position2 = this.option("position");
    var overlayOptions = {
      focusStateEnabled: this.option("focusStateEnabled"),
      animation: this.option("animation"),
      innerOverlay: true,
      closeOnOutsideClick: this._closeOnOutsideClickHandler.bind(this),
      propagateOutsideClick: true,
      closeOnTargetScroll: true,
      deferRendering: false,
      position: {
        at: position2.at,
        my: position2.my,
        of: this._getTarget(),
        collision: "flipfit"
      },
      shading: false,
      showTitle: false,
      height: "auto",
      width: "auto",
      onShown: this._overlayShownActionHandler.bind(this),
      onHiding: this._overlayHidingActionHandler.bind(this),
      onHidden: this._overlayHiddenActionHandler.bind(this)
    };
    return overlayOptions;
  }
  _overlayShownActionHandler(arg) {
    this._actions.onShown(arg);
  }
  _overlayHidingActionHandler(arg) {
    this._actions.onHiding(arg);
    if (!arg.cancel) {
      this._hideAllShownSubmenus();
      this._setOptionWithoutOptionChange("visible", false);
    }
  }
  _overlayHiddenActionHandler(arg) {
    this._actions.onHidden(arg);
  }
  _closeOnOutsideClickHandler(e) {
    var closeOnOutsideClick = this.option("closeOnOutsideClick");
    if (isFunction$1(closeOnOutsideClick)) {
      return closeOnOutsideClick(e);
    }
    if (!closeOnOutsideClick) {
      return false;
    }
    if (domAdapter.isDocument(e.target)) {
      return true;
    }
    var $activeItemContainer = this._getActiveItemsContainer(e.target);
    var $itemContainers = this._getItemsContainers();
    var $clickedItem = this._searchActiveItem(e.target);
    var $rootItem = this.$element().parents(".".concat(DX_MENU_ITEM_CLASS));
    var isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
    var isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
    if (isInnerOverlayClicked || isRootItemClicked) {
      if (this._getShowSubmenuMode() === "onClick") {
        this._hideAllShownChildSubmenus($clickedItem);
      }
      return false;
    }
    return true;
  }
  _getActiveItemsContainer(target) {
    return $(target).closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS));
  }
  _getItemsContainers() {
    return this._overlay.$content().find(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS));
  }
  _searchActiveItem(target) {
    return $(target).closest(".".concat(DX_MENU_ITEM_CLASS)).eq(0);
  }
  _isIncludeOverlay($activeOverlay, $allOverlays) {
    var isSame = false;
    each($allOverlays, (index2, $overlay) => {
      if ($activeOverlay.is($overlay) && !isSame) {
        isSame = true;
      }
    });
    return isSame;
  }
  _hideAllShownChildSubmenus($clickedItem) {
    var $submenuElements = $clickedItem.find(".".concat(DX_SUBMENU_CLASS));
    var shownSubmenus = extend([], this._shownSubmenus);
    if ($submenuElements.length > 0) {
      each(shownSubmenus, (index2, $submenu) => {
        var $context = this._searchActiveItem($submenu.context).parent();
        if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {
          this._hideSubmenu($submenu);
        }
      });
    }
  }
  _showSubmenu($item) {
    var node = this._dataAdapter.getNodeByItem(this._getItemData($item));
    this._hideSubmenusOnSameLevel($item);
    if (!this._hasSubmenu(node)) {
      return;
    }
    var $submenu = $item.children(".".concat(DX_SUBMENU_CLASS));
    var isSubmenuRendered = $submenu.length;
    super._showSubmenu($item);
    if (!isSubmenuRendered) {
      this._renderSubmenuItems(node, $item);
    }
    if (!this._isSubmenuVisible($submenu)) {
      this._drawSubmenu($item);
    }
  }
  _hideSubmenusOnSameLevel($item) {
    var $expandedItems = $item.parent(".".concat(DX_MENU_ITEM_WRAPPER_CLASS)).siblings().find(".".concat(DX_MENU_ITEM_EXPANDED_CLASS));
    if ($expandedItems.length) {
      $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
      this._hideSubmenu($expandedItems.find(".".concat(DX_SUBMENU_CLASS)));
    }
  }
  _hideSubmenuGroup($submenu) {
    if (this._isSubmenuVisible($submenu)) {
      this._hideSubmenuCore($submenu);
    }
  }
  _isSubmenuVisible($submenu) {
    return $submenu.css("visibility") === "visible";
  }
  _drawSubmenu($itemElement) {
    var animation2 = this.option("animation") ? this.option("animation").show : {};
    var $submenu = $itemElement.children(".".concat(DX_SUBMENU_CLASS));
    var submenuPosition = this._getSubmenuPosition($itemElement);
    if (this._overlay && this._overlay.option("visible")) {
      if (!isDefined(this._shownSubmenus)) {
        this._shownSubmenus = [];
      }
      if (inArray($submenu, this._shownSubmenus)) {
        this._shownSubmenus.push($submenu);
      }
      if (animation2) {
        fx.stop($submenu);
      }
      animationPosition.setup($submenu, submenuPosition);
      if (animation2) {
        if (isPlainObject(animation2.to)) {
          animation2.to.position = submenuPosition;
        }
        this._animate($submenu, animation2);
      }
      $submenu.css("visibility", "visible");
    }
  }
  _animate($container, options) {
    fx.animate($container, options);
  }
  _getSubmenuPosition($rootItem) {
    var submenuDirection = this.option("submenuDirection").toLowerCase();
    var $rootItemWrapper = $rootItem.parent(".".concat(DX_MENU_ITEM_WRAPPER_CLASS));
    var position2 = {
      collision: "flip",
      of: $rootItemWrapper,
      offset: {
        h: 0,
        v: -1
      }
    };
    switch (submenuDirection) {
      case "left":
        position2.at = "left top";
        position2.my = "right top";
        break;
      case "right":
        position2.at = "right top";
        position2.my = "left top";
        break;
      default:
        if (this.option("rtlEnabled")) {
          position2.at = "left top";
          position2.my = "right top";
        } else {
          position2.at = "right top";
          position2.my = "left top";
        }
    }
    return position2;
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    if (!actionArgs.args.length) {
      return;
    }
    var itemData = actionArgs.args[0].itemData;
    var node = this._dataAdapter.getNodeByItem(itemData);
    if (!node) {
      return;
    }
    var $itemElement = $(actionArgs.args[0].itemElement);
    var $submenu = $itemElement.find(".".concat(DX_SUBMENU_CLASS));
    var shouldRenderSubmenu = this._hasSubmenu(node) && !$submenu.length;
    if (shouldRenderSubmenu) {
      this._renderSubmenuItems(node, $itemElement);
      $submenu = $itemElement.find(".".concat(DX_SUBMENU_CLASS));
    }
    if ($itemElement.context === $submenu.context && $submenu.css("visibility") === "visible") {
      return;
    }
    var notCloseMenuOnItemClick = itemData && itemData.closeMenuOnClick === false;
    if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {
      return;
    }
    this._updateSelectedItemOnClick(actionArgs);
    if ($submenu.length === 0) {
      var $prevSubmenu = $($itemElement.parents(".".concat(DX_SUBMENU_CLASS))[0]);
      this._hideSubmenu($prevSubmenu);
      if (!actionArgs.canceled && this._overlay && this._overlay.option("visible")) {
        this.option("visible", false);
      }
    } else {
      if (this._shownSubmenus && this._shownSubmenus.length > 0) {
        if (this._shownSubmenus[0].is($submenu)) {
          this._hideSubmenu($submenu);
        }
      }
      this._showSubmenu($itemElement);
    }
  }
  _hideSubmenu($curSubmenu) {
    var shownSubmenus = extend([], this._shownSubmenus);
    each(shownSubmenus, (index2, $submenu) => {
      if ($curSubmenu.is($submenu) || contains($curSubmenu[0], $submenu[0])) {
        $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
        this._hideSubmenuCore($submenu);
      }
    });
  }
  _hideSubmenuCore($submenu) {
    var index2 = inArray($submenu, this._shownSubmenus);
    var animation2 = this.option("animation") ? this.option("animation").hide : null;
    if (index2 >= 0) {
      this._shownSubmenus.splice(index2, 1);
    }
    this._stopAnimate($submenu);
    animation2 && this._animate($submenu, animation2);
    $submenu.css("visibility", "hidden");
  }
  _stopAnimate($container) {
    fx.stop($container, true);
  }
  _hideAllShownSubmenus() {
    var shownSubmenus = extend([], this._shownSubmenus);
    var $expandedItems = this._overlay.$content().find(".".concat(DX_MENU_ITEM_EXPANDED_CLASS));
    $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
    each(shownSubmenus, (_2, $submenu) => {
      this._hideSubmenu($submenu);
    });
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._renderContentImpl();
    }
  }
  _optionChanged(args) {
    if (inArray(args.name, ACTIONS) > -1) {
      this._initActions();
      return;
    }
    switch (args.name) {
      case "visible":
        this._renderVisibility(args.value);
        break;
      case "showEvent":
      case "position":
      case "submenuDirection":
        this._invalidate();
        break;
      case "target":
        args.previousValue && this._detachShowContextMenuEvents(args.previousValue);
        this._invalidate();
        break;
      case "closeOnOutsideClick":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _renderVisibility(showing) {
    return showing ? this._show() : this._hide();
  }
  _toggleVisibility() {
  }
  _show(event) {
    var args = {
      jQEvent: event
    };
    var promise2 = new Deferred().reject().promise();
    this._actions.onShowing(args);
    if (args.cancel) {
      return promise2;
    }
    var position2 = this._positionContextMenu(event);
    if (position2) {
      var _event$originalEvent;
      if (!this._overlay) {
        this._renderContextMenuOverlay();
        this._overlay.$content().addClass(this._widgetClass());
        this._renderFocusState();
        this._attachHoverEvents();
        this._attachClickEvent();
        this._renderItems(this._dataAdapter.getRootNodes());
      }
      this._setOptionWithoutOptionChange("visible", true);
      this._overlay.option("position", position2);
      promise2 = this._overlay.show();
      event && event.stopPropagation();
      this._setAriaAttributes();
      if ((event === null || event === void 0 ? void 0 : (_event$originalEvent = event.originalEvent) === null || _event$originalEvent === void 0 ? void 0 : _event$originalEvent.type) === holdEvent.name) {
        this.preventShowingDefaultContextMenuAboveOverlay();
      }
    }
    return promise2;
  }
  _setAriaAttributes() {
    this._overlayContentId = "dx-".concat(new Guid());
    this.setAria("owns", this._overlayContentId);
    this.setAria({
      id: this._overlayContentId,
      role: "menu"
    }, this._overlay.$content());
  }
  _cleanAriaAttributes() {
    this._overlay && this.setAria("id", null, this._overlay.$content());
    this.setAria("owns", void 0);
  }
  _getTarget() {
    return this.option("target") || this.option("position").of || $(domAdapter.getDocument());
  }
  _getContextMenuPosition() {
    return extend({}, this.option("position"), {
      of: this._getTarget()
    });
  }
  _positionContextMenu(jQEvent) {
    var position2 = this._getContextMenuPosition();
    var isInitialPosition = this._isInitialOptionValue("position");
    var positioningAction = this._createActionByOption("onPositioning", actionArgs);
    if (jQEvent && jQEvent.preventDefault && isInitialPosition) {
      position2.of = jQEvent;
    }
    var actionArgs = {
      position: position2,
      event: jQEvent
    };
    positioningAction(actionArgs);
    if (actionArgs.cancel) {
      position2 = null;
    } else if (actionArgs.event) {
      actionArgs.event.cancel = true;
      jQEvent.preventDefault();
    }
    return position2;
  }
  _refresh() {
    if (!hasWindow$1()) {
      super._refresh();
    } else if (this._overlay) {
      var lastPosition = this._overlay.option("position");
      super._refresh();
      this._overlay && this._overlay.option("position", lastPosition);
    } else {
      super._refresh();
    }
  }
  _hide() {
    var promise2;
    if (this._overlay) {
      promise2 = this._overlay.hide();
      this._setOptionWithoutOptionChange("visible", false);
    }
    this._cleanAriaAttributes();
    this.option("focusedElement", null);
    return promise2 || new Deferred().reject().promise();
  }
  toggle(showing) {
    var visible2 = this.option("visible");
    showing = showing === void 0 ? !visible2 : showing;
    return this._renderVisibility(showing);
  }
  show() {
    return this.toggle(true);
  }
  hide() {
    return this.toggle(false);
  }
}
registerComponent("dxContextMenu", ContextMenu);
var DIV$1 = "<div>";
var hasWindow = hasWindow$1();
var FIELDCHOOSER_CLASS = "dx-pivotgridfieldchooser";
var FIELDCHOOSER_CONTAINER_CLASS = "dx-pivotgridfieldchooser-container";
var FIELDS_CONTAINER_CLASS$1 = "dx-pivotgrid-fields-container";
var AREA_DRAG_CLASS = "dx-pivotgrid-drag-action";
function getDimensionFields(item, fields) {
  var result = [];
  if (item.items) {
    for (var i = 0; i < item.items.length; i++) {
      result.push.apply(result, getDimensionFields(item.items[i], fields));
    }
  } else if (isDefined(item.index)) {
    result.push(fields[item.index]);
  }
  return result;
}
function getFirstItem(item, condition) {
  if (item.items) {
    for (var i = 0; i < item.items.length; i++) {
      var childrenItem = getFirstItem(item.items[i], condition);
      if (childrenItem) {
        return childrenItem;
      }
    }
  }
  if (condition(item)) {
    return item;
  }
}
var compareOrder = [function(a, b) {
  var aValue = -!!a.isMeasure;
  var bValue = +!!b.isMeasure;
  return aValue + bValue;
}, function(a, b) {
  var aValue = -!!(a.items && a.items.length);
  var bValue = +!!(b.items && b.items.length);
  return aValue + bValue;
}, function(a, b) {
  var aValue = +!!(a.isMeasure === false && a.field && a.field.levels && a.field.levels.length);
  var bValue = -!!(b.isMeasure === false && b.field && b.field.levels && b.field.levels.length);
  return aValue + bValue;
}, getCompareFunction(function(item) {
  return item.text;
})];
function compareItems(a, b) {
  var result = 0;
  var i = 0;
  while (!result && compareOrder[i]) {
    result = compareOrder[i++](a, b);
  }
  return result;
}
function getScrollable(container) {
  return container.find(".dx-scrollable").dxScrollable("instance");
}
var FieldChooser = FieldChooserBase.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      height: 400,
      layout: 0,
      dataSource: null,
      onContextMenuPreparing: null,
      allowSearch: false,
      searchTimeout: 500,
      texts: {
        columnFields: messageLocalization.format("dxPivotGrid-columnFields"),
        rowFields: messageLocalization.format("dxPivotGrid-rowFields"),
        dataFields: messageLocalization.format("dxPivotGrid-dataFields"),
        filterFields: messageLocalization.format("dxPivotGrid-filterFields"),
        allFields: messageLocalization.format("dxPivotGrid-allFields")
      }
    });
  },
  _refreshDataSource: function() {
    var that = this;
    that._expandedPaths = [];
    that._changedHandler = that._changedHandler || function() {
      each(that._dataChangedHandlers, function(_2, func) {
        func();
      });
      that._fireContentReadyAction();
      that._skipStateChange = true;
      that.option("state", that._dataSource.state());
      that._skipStateChange = false;
    };
    that._disposeDataSource();
    that.callBase();
    that._dataSource && that._dataSource.on("changed", that._changedHandler);
  },
  _disposeDataSource: function() {
    var dataSource = this._dataSource;
    if (dataSource) {
      dataSource.off("changed", this._changedHandler);
      this._dataSource = void 0;
    }
  },
  _dispose: function() {
    this._disposeDataSource();
    this.callBase.apply(this, arguments);
  },
  _init: function() {
    this.callBase();
    this._refreshDataSource();
    this._dataChangedHandlers = [];
    this._initActions();
  },
  _initActions: function() {
    this._actions = {
      onContextMenuPreparing: this._createActionByOption("onContextMenuPreparing")
    };
  },
  _trigger: function(eventName, eventArg) {
    this._actions[eventName](eventArg);
  },
  _setOptionsByReference: function() {
    this.callBase();
    extend(this._optionsByReference, {
      dataSource: true
    });
  },
  _optionChanged: function(args) {
    switch (args.name) {
      case "dataSource":
        this._refreshDataSource();
        this._invalidate();
        break;
      case "layout":
      case "texts":
      case "allowSearch":
      case "searchTimeout":
        this._invalidate();
        break;
      case "onContextMenuPreparing":
        this._actions[args.name] = this._createActionByOption(args.name);
        break;
      default:
        this.callBase(args);
    }
  },
  _clean: function(skipStateSetting) {
    !skipStateSetting && this._dataSource && this.option("state", this._dataSource.state());
    this.$element().children("." + FIELDCHOOSER_CONTAINER_CLASS).remove();
  },
  _renderLayout0: function($container) {
    $container.addClass("dx-layout-0");
    var $row1 = $(DIV$1).addClass("dx-row").appendTo($container);
    var $row2 = $(DIV$1).addClass("dx-row").appendTo($container);
    var $col1 = $(DIV$1).addClass("dx-col").appendTo($row1);
    var $col2 = $(DIV$1).addClass("dx-col").appendTo($row1);
    var $col3 = $(DIV$1).addClass("dx-col").appendTo($row2);
    var $col4 = $(DIV$1).addClass("dx-col").appendTo($row2);
    this._renderArea($col1, "all");
    this._renderArea($col2, "row");
    this._renderArea($col2, "column");
    this._renderArea($col3, "filter");
    this._renderArea($col4, "data");
  },
  _renderLayout1: function($container) {
    var $col1 = $(DIV$1).addClass("dx-col").appendTo($container);
    var $col2 = $(DIV$1).addClass("dx-col").appendTo($container);
    this._renderArea($col1, "all");
    this._renderArea($col2, "filter");
    this._renderArea($col2, "row");
    this._renderArea($col2, "column");
    this._renderArea($col2, "data");
  },
  _renderLayout2: function($container) {
    $container.addClass("dx-layout-2");
    var $row1 = $(DIV$1).addClass("dx-row").appendTo($container);
    this._renderArea($row1, "all");
    var $row2 = $(DIV$1).addClass("dx-row").appendTo($container);
    var $col1 = $(DIV$1).addClass("dx-col").appendTo($row2);
    var $col2 = $(DIV$1).addClass("dx-col").appendTo($row2);
    this._renderArea($col1, "filter");
    this._renderArea($col1, "row");
    this._renderArea($col2, "column");
    this._renderArea($col2, "data");
  },
  _initMarkup: function() {
    var $element = this.$element();
    var $container = $(DIV$1).addClass(FIELDCHOOSER_CONTAINER_CLASS).appendTo($element);
    var layout = this.option("layout");
    this.callBase();
    $element.addClass(FIELDCHOOSER_CLASS).addClass(FIELDS_CONTAINER_CLASS$1);
    this._dataChangedHandlers = [];
    var dataSource = this._dataSource;
    var currentState = this.option("applyChangesMode") !== "instantly" && dataSource && dataSource.state();
    currentState && this.option("state") && dataSource.state(this.option("state"), true);
    if (layout === 0) {
      this._renderLayout0($container);
    } else if (layout === 1) {
      this._renderLayout1($container);
    } else {
      this._renderLayout2($container);
    }
    currentState && dataSource.state(currentState, true);
  },
  _renderContentImpl: function() {
    this.callBase();
    this.renderSortable();
    this._renderContextMenu();
    this.updateDimensions();
  },
  _fireContentReadyAction: function() {
    if (!this._dataSource || !this._dataSource.isLoading()) {
      this.callBase();
    }
  },
  _getContextMenuArgs: function(dxEvent) {
    var targetFieldElement = $(dxEvent.target).closest(".dx-area-field");
    var targetGroupElement = $(dxEvent.target).closest(".dx-area-fields");
    var field;
    var area;
    if (targetFieldElement.length) {
      var fieldCopy = targetFieldElement.data("field");
      if (fieldCopy) {
        field = this.getDataSource().field(fieldCopy.index) || fieldCopy;
      }
    }
    if (targetGroupElement.length) {
      area = targetGroupElement.attr("group");
    }
    return {
      event: dxEvent,
      field,
      area,
      items: []
    };
  },
  _renderContextMenu: function() {
    var that = this;
    var $container = that.$element();
    if (that._contextMenu) {
      that._contextMenu.$element().remove();
    }
    that._contextMenu = that._createComponent($(DIV$1).appendTo($container), ContextMenu, {
      onPositioning: function(actionArgs) {
        var event = actionArgs.event;
        if (!event) {
          return;
        }
        var args = that._getContextMenuArgs(event);
        that._trigger("onContextMenuPreparing", args);
        if (args.items && args.items.length) {
          actionArgs.component.option("items", args.items);
        } else {
          actionArgs.cancel = true;
        }
      },
      target: $container,
      onItemClick: function(params) {
        params.itemData.onItemClick && params.itemData.onItemClick(params);
      },
      cssClass: "dx-pivotgridfieldchooser-context-menu"
    });
  },
  _createTreeItems: function(fields, groupFieldNames, path) {
    var that = this;
    var isMeasure;
    var resultItems = [];
    var groupedItems = [];
    var groupFieldName = groupFieldNames[0];
    var fieldsByGroup = {};
    if (!groupFieldName) {
      each(fields, function(index2, field) {
        var icon;
        if (field.isMeasure === true) {
          icon = "measure";
        }
        if (field.isMeasure === false) {
          icon = field.groupName ? "hierarchy" : "dimension";
        }
        resultItems.push({
          index: field.index,
          field,
          key: field.dataField,
          selected: isDefined(field.area),
          text: field.caption || field.dataField,
          icon,
          isMeasure: field.isMeasure,
          isDefault: field.isDefault
        });
      });
    } else {
      each(fields, function(index2, field) {
        var groupName = field[groupFieldName] || "";
        fieldsByGroup[groupName] = fieldsByGroup[groupName] || [];
        fieldsByGroup[groupName].push(field);
        if (isMeasure === void 0) {
          isMeasure = true;
        }
        isMeasure = isMeasure && field.isMeasure === true;
      });
      each(fieldsByGroup, function(groupName, fields2) {
        var currentPath = path ? path + "." + groupName : groupName;
        var items = that._createTreeItems(fields2, groupFieldNames.slice(1), currentPath);
        if (groupName) {
          groupedItems.push({
            key: groupName,
            text: groupName,
            path: currentPath,
            isMeasure: items.isMeasure,
            expanded: inArray(currentPath, that._expandedPaths) >= 0,
            items
          });
        } else {
          resultItems = items;
        }
      });
      resultItems = groupedItems.concat(resultItems);
      resultItems.isMeasure = isMeasure;
    }
    return resultItems;
  },
  _createFieldsDataSource: function(dataSource) {
    var fields = dataSource && dataSource.fields() || [];
    fields = fields.filter((field) => field.visible !== false && !isDefined(field.groupIndex));
    var treeItems = this._createTreeItems(fields, ["dimension", "displayFolder"]);
    foreachDataLevel(treeItems, function(items) {
      items.sort(compareItems);
    }, 0, "items");
    return treeItems;
  },
  _renderFieldsTreeView: function(container) {
    var that = this;
    var dataSource = that._dataSource;
    var treeView = that._createComponent(container, TreeViewSearch, {
      dataSource: that._createFieldsDataSource(dataSource),
      showCheckBoxesMode: "normal",
      expandNodesRecursive: false,
      searchEnabled: that.option("allowSearch"),
      searchTimeout: that.option("searchTimeout"),
      itemTemplate: function(itemData, itemIndex, itemElement) {
        if (itemData.icon) {
          getImageContainer(itemData.icon).appendTo(itemElement);
        }
        $("<span>").toggleClass("dx-area-field", !itemData.items).data("field", itemData.field).text(itemData.text).appendTo(itemElement);
      },
      onItemCollapsed: function(e) {
        var index2 = inArray(e.itemData.path, that._expandedPaths);
        if (index2 >= 0) {
          that._expandedPaths.splice(index2, 1);
        }
      },
      onItemExpanded: function(e) {
        var index2 = inArray(e.itemData.path, that._expandedPaths);
        if (index2 < 0) {
          that._expandedPaths.push(e.itemData.path);
        }
      },
      onItemSelectionChanged: function(e) {
        var data2 = e.itemData;
        var field;
        var fields;
        var needSelectDefaultItem = true;
        var area;
        if (data2.items) {
          if (data2.selected) {
            treeView.unselectItem(data2);
            return;
          }
          that._processDemandState(() => {
            fields = getDimensionFields(data2, dataSource.fields());
            for (var i = 0; i < fields.length; i++) {
              if (fields[i].area) {
                needSelectDefaultItem = false;
                break;
              }
            }
          });
          if (needSelectDefaultItem) {
            var item = getFirstItem(data2, function(item2) {
              return item2.isDefault;
            }) || getFirstItem(data2, function(item2) {
              return isDefined(item2.index);
            });
            item && treeView.selectItem(item);
            return;
          }
        } else {
          field = dataSource.fields()[data2.index];
          if (data2.selected) {
            area = field.isMeasure ? "data" : "column";
          }
          if (field) {
            fields = [field];
          }
        }
        that._applyChanges(fields, {
          area,
          areaIndex: void 0
        });
      }
    });
    that._dataChangedHandlers.push(function() {
      var scrollable = getScrollable(container);
      var scrollTop = scrollable ? scrollable.scrollTop() : 0;
      treeView.option({
        dataSource: that._createFieldsDataSource(dataSource)
      });
      scrollable = getScrollable(container);
      if (scrollable) {
        scrollable.scrollTo({
          y: scrollTop
        });
        scrollable.update();
      }
    });
  },
  _renderAreaFields: function($container, area) {
    var that = this;
    var dataSource = that._dataSource;
    var fields = dataSource ? extend(true, [], dataSource.getAreaFields(area, true)) : [];
    $container.empty();
    each(fields, function(_2, field) {
      if (field.visible !== false) {
        that.renderField(field, true).appendTo($container);
      }
    });
  },
  _renderArea: function(container, area) {
    var that = this;
    var $areaContainer = $(DIV$1).addClass("dx-area").appendTo(container);
    var $fieldsHeaderContainer = $(DIV$1).addClass("dx-area-fields-header").appendTo($areaContainer);
    var caption = that.option("texts." + area + "Fields");
    var $fieldsContent;
    var render2;
    $("<span>").addClass("dx-area-icon").addClass("dx-area-icon-" + area).appendTo($fieldsHeaderContainer);
    $("<span>").html("&nbsp;").appendTo($fieldsHeaderContainer);
    $("<span>").addClass("dx-area-caption").text(caption).appendTo($fieldsHeaderContainer);
    var $fieldsContainer = $(DIV$1).addClass("dx-area-fields").addClass(AREA_DRAG_CLASS).appendTo($areaContainer);
    if (area !== "all") {
      $fieldsContainer.attr("group", area).attr("allow-scrolling", true);
      $fieldsContent = $(DIV$1).addClass("dx-area-field-container").appendTo($fieldsContainer);
      render2 = function() {
        that._renderAreaFields($fieldsContent, area);
      };
      that._dataChangedHandlers.push(render2);
      render2();
      $fieldsContainer.dxScrollable();
    } else {
      $areaContainer.addClass("dx-all-fields");
      $fieldsContainer.addClass("dx-treeview-border-visible");
      that._renderFieldsTreeView($fieldsContainer);
    }
  },
  _getSortableOptions: function() {
    return {};
  },
  _adjustSortableOnChangedArgs: function() {
  },
  resetTreeView: function() {
    var treeView = this.$element().find(".dx-treeview").dxTreeView("instance");
    if (treeView) {
      treeView.option("searchValue", "");
      treeView.collapseAll();
    }
  },
  applyChanges: function() {
    var state = this.option("state");
    if (isDefined(state)) {
      this._dataSource.state(state);
    }
  },
  cancelChanges: function() {
    var dataSource = this._dataSource;
    if (!dataSource.isLoading()) {
      this.option("state", dataSource.state());
      return true;
    }
    return false;
  },
  getDataSource: function() {
    return this._dataSource;
  },
  updateDimensions: function() {
    var $scrollableElements = this.$element().find(".dx-area .dx-scrollable");
    $scrollableElements.dxScrollable("update");
  },
  _visibilityChanged: function(visible2) {
    if (visible2 && hasWindow) {
      this.updateDimensions();
    }
  }
});
registerComponent("dxPivotGridFieldChooser", FieldChooser);
var window$2 = getWindow();
var navigator$1 = getNavigator();
var FILE_EXTESIONS = {
  EXCEL: "xlsx",
  CSS: "css",
  PNG: "png",
  JPEG: "jpeg",
  GIF: "gif",
  SVG: "svg",
  PDF: "pdf"
};
var MIME_TYPES = {
  CSS: "text/css",
  EXCEL: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  PNG: "image/png",
  JPEG: "image/jpeg",
  GIF: "image/gif",
  SVG: "image/svg+xml",
  PDF: "application/pdf"
};
var fileSaver = {
  _revokeObjectURLTimeout: 3e4,
  _getDataUri: function(format2, data2) {
    var mimeType = this._getMimeType(format2);
    return "data:".concat(mimeType, ";base64,").concat(data2);
  },
  _getMimeType: function(format2) {
    return MIME_TYPES[format2] || "application/octet-stream";
  },
  _linkDownloader: function(fileName, href) {
    var exportLinkElement = domAdapter.createElement("a");
    exportLinkElement.download = fileName;
    exportLinkElement.href = href;
    exportLinkElement.target = "_blank";
    return exportLinkElement;
  },
  _formDownloader: function(proxyUrl, fileName, contentType, data2) {
    var formAttributes = {
      method: "post",
      action: proxyUrl,
      enctype: "multipart/form-data"
    };
    var exportForm = $("<form>").css({
      display: "none"
    }).attr(formAttributes);
    function setAttributes(element, attributes) {
      for (var key in attributes) {
        element.setAttribute(key, attributes[key]);
      }
      return element;
    }
    exportForm.append(setAttributes(domAdapter.createElement("input"), {
      type: "hidden",
      name: "fileName",
      value: fileName
    }));
    exportForm.append(setAttributes(domAdapter.createElement("input"), {
      type: "hidden",
      name: "contentType",
      value: contentType
    }));
    exportForm.append(setAttributes(domAdapter.createElement("input"), {
      type: "hidden",
      name: "data",
      value: data2
    }));
    exportForm.appendTo("body");
    eventsEngine.trigger(exportForm, "submit");
    if (eventsEngine.trigger(exportForm, "submit")) {
      exportForm.remove();
    }
  },
  _saveByProxy: function(proxyUrl, fileName, format2, data2) {
    var contentType = this._getMimeType(format2);
    return this._formDownloader(proxyUrl, fileName, contentType, data2);
  },
  _winJSBlobSave: function(blob, fileName, format2) {
    var savePicker = new Windows.Storage.Pickers.FileSavePicker();
    savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
    var fileExtension = FILE_EXTESIONS[format2];
    if (fileExtension) {
      var mimeType = this._getMimeType(format2);
      savePicker.fileTypeChoices.insert(mimeType, ["." + fileExtension]);
    }
    savePicker.suggestedFileName = fileName;
    savePicker.pickSaveFileAsync().then(function(file) {
      if (file) {
        file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function(outputStream) {
          var inputStream = blob.msDetachStream();
          Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function() {
            outputStream.flushAsync().done(function() {
              inputStream.close();
              outputStream.close();
            });
          });
        });
      }
    });
  },
  _click: function(link) {
    try {
      link.dispatchEvent(new MouseEvent("click", {
        cancelable: true
      }));
    } catch (e) {
      var event = domAdapter.getDocument().createEvent("MouseEvents");
      event.initMouseEvent("click", true, true, window$2, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      link.dispatchEvent(event);
    }
  },
  _saveBlobAs: function(fileName, format2, data2) {
    this._blobSaved = false;
    if (isDefined(navigator$1.msSaveOrOpenBlob)) {
      navigator$1.msSaveOrOpenBlob(data2, fileName);
      this._blobSaved = true;
    } else if (isDefined(window$2.WinJS)) {
      this._winJSBlobSave(data2, fileName, format2);
      this._blobSaved = true;
    } else {
      var URL = window$2.URL || window$2.webkitURL || window$2.mozURL || window$2.msURL || window$2.oURL;
      if (isDefined(URL)) {
        var objectURL = URL.createObjectURL(data2);
        var downloadLink = this._linkDownloader(fileName, objectURL);
        setTimeout(() => {
          URL.revokeObjectURL(objectURL);
          this._objectUrlRevoked = true;
        }, this._revokeObjectURLTimeout);
        this._click(downloadLink);
      } else {
        logger.warn("window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL is not defined");
      }
    }
  },
  saveAs: function(fileName, format2, data2, proxyURL, forceProxy) {
    var fileExtension = FILE_EXTESIONS[format2];
    if (fileExtension) {
      fileName += "." + fileExtension;
    }
    if (isDefined(proxyURL)) {
      errors$1.log("W0001", "Export", "proxyURL", "19.2", "This option is no longer required");
    }
    if (forceProxy) {
      this._saveByProxy(proxyURL, fileName, format2, data2);
    } else if (isFunction$1(window$2.Blob)) {
      this._saveBlobAs(fileName, format2, data2);
    } else if (isDefined(proxyURL) && !isDefined(navigator$1.userAgent.match(/iPad/i))) {
      this._saveByProxy(proxyURL, fileName, format2, data2);
    } else {
      if (!isDefined(navigator$1.userAgent.match(/iPad/i))) {
        errors$1.log("E1034");
      }
      var downloadLink = this._linkDownloader(fileName, this._getDataUri(format2, data2));
      this._click(downloadLink);
    }
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
/*!

JSZip v3.7.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
(function(module2, exports2) {
  !function(t) {
    module2.exports = t();
  }(function() {
    return function s(a, o, h) {
      function u(r, t2) {
        if (!o[r]) {
          if (!a[r]) {
            var e = typeof commonjsRequire == "function" && commonjsRequire;
            if (!t2 && e)
              return e(r, true);
            if (l)
              return l(r, true);
            var i = new Error("Cannot find module '" + r + "'");
            throw i.code = "MODULE_NOT_FOUND", i;
          }
          var n = o[r] = { exports: {} };
          a[r][0].call(n.exports, function(t3) {
            var e2 = a[r][1][t3];
            return u(e2 || t3);
          }, n, n.exports, s, a, o, h);
        }
        return o[r].exports;
      }
      for (var l = typeof commonjsRequire == "function" && commonjsRequire, t = 0; t < h.length; t++)
        u(h[t]);
      return u;
    }({ 1: [function(t, e, r) {
      var c = t("./utils"), d = t("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(t2) {
        for (var e2, r2, i, n, s, a, o, h = [], u = 0, l = t2.length, f = l, d2 = c.getTypeOf(t2) !== "string"; u < t2.length; )
          f = l - u, i = d2 ? (e2 = t2[u++], r2 = u < l ? t2[u++] : 0, u < l ? t2[u++] : 0) : (e2 = t2.charCodeAt(u++), r2 = u < l ? t2.charCodeAt(u++) : 0, u < l ? t2.charCodeAt(u++) : 0), n = e2 >> 2, s = (3 & e2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | i >> 6 : 64, o = 2 < f ? 63 & i : 64, h.push(p.charAt(n) + p.charAt(s) + p.charAt(a) + p.charAt(o));
        return h.join("");
      }, r.decode = function(t2) {
        var e2, r2, i, n, s, a, o = 0, h = 0, u = "data:";
        if (t2.substr(0, u.length) === u)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l, f = 3 * (t2 = t2.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
        if (t2.charAt(t2.length - 1) === p.charAt(64) && f--, t2.charAt(t2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l = d.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < t2.length; )
          e2 = p.indexOf(t2.charAt(o++)) << 2 | (n = p.indexOf(t2.charAt(o++))) >> 4, r2 = (15 & n) << 4 | (s = p.indexOf(t2.charAt(o++))) >> 2, i = (3 & s) << 6 | (a = p.indexOf(t2.charAt(o++))), l[h++] = e2, s !== 64 && (l[h++] = r2), a !== 64 && (l[h++] = i);
        return l;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(t, e, r) {
      var i = t("./external"), n = t("./stream/DataWorker"), s = t("./stream/Crc32Probe"), a = t("./stream/DataLengthProbe");
      function o(t2, e2, r2, i2, n2) {
        this.compressedSize = t2, this.uncompressedSize = e2, this.crc32 = r2, this.compression = i2, this.compressedContent = n2;
      }
      o.prototype = { getContentWorker: function() {
        var t2 = new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), e2 = this;
        return t2.on("end", function() {
          if (this.streamInfo.data_length !== e2.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), t2;
      }, getCompressedWorker: function() {
        return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o.createWorkerFrom = function(t2, e2, r2) {
        return t2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(e2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", e2);
      }, e.exports = o;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, e, r) {
      var i = t("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function(t2) {
        return new i("STORE compression");
      }, uncompressWorker: function() {
        return new i("STORE decompression");
      } }, r.DEFLATE = t("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, e, r) {
      var i = t("./utils");
      var o = function() {
        for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
          t2 = r2;
          for (var i2 = 0; i2 < 8; i2++)
            t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
          e2[r2] = t2;
        }
        return e2;
      }();
      e.exports = function(t2, e2) {
        return t2 !== void 0 && t2.length ? i.getTypeOf(t2) !== "string" ? function(t3, e3, r2, i2) {
          var n = o, s = i2 + r2;
          t3 ^= -1;
          for (var a = i2; a < s; a++)
            t3 = t3 >>> 8 ^ n[255 & (t3 ^ e3[a])];
          return -1 ^ t3;
        }(0 | e2, t2, t2.length, 0) : function(t3, e3, r2, i2) {
          var n = o, s = i2 + r2;
          t3 ^= -1;
          for (var a = i2; a < s; a++)
            t3 = t3 >>> 8 ^ n[255 & (t3 ^ e3.charCodeAt(a))];
          return -1 ^ t3;
        }(0 | e2, t2, t2.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(t, e, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(t, e, r) {
      var i = null;
      i = typeof Promise != "undefined" ? Promise : t("lie"), e.exports = { Promise: i };
    }, { lie: 37 }], 7: [function(t, e, r) {
      var i = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", n = t("pako"), s = t("./utils"), a = t("./stream/GenericWorker"), o = i ? "uint8array" : "array";
      function h(t2, e2) {
        a.call(this, "FlateWorker/" + t2), this._pako = null, this._pakoAction = t2, this._pakoOptions = e2, this.meta = {};
      }
      r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(t2) {
        this.meta = t2.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(o, t2.data), false);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new n[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var e2 = this;
        this._pako.onData = function(t2) {
          e2.push({ data: t2, meta: e2.meta });
        };
      }, r.compressWorker = function(t2) {
        return new h("Deflate", t2);
      }, r.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, e, r) {
      function A(t2, e2) {
        var r2, i2 = "";
        for (r2 = 0; r2 < e2; r2++)
          i2 += String.fromCharCode(255 & t2), t2 >>>= 8;
        return i2;
      }
      function i(t2, e2, r2, i2, n2, s2) {
        var a, o, h = t2.file, u = t2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), d = I.transformTo("string", O.utf8encode(h.name)), c = h.comment, p = I.transformTo("string", s2(c)), m = I.transformTo("string", O.utf8encode(c)), _2 = d.length !== h.name.length, g = m.length !== c.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        e2 && !r2 || (x.crc32 = t2.crc32, x.compressedSize = t2.compressedSize, x.uncompressedSize = t2.uncompressedSize);
        var S = 0;
        e2 && (S |= 8), l || !_2 && !g || (S |= 2048);
        var z = 0, C = 0;
        w && (z |= 16), n2 === "UNIX" ? (C = 798, z |= function(t3, e3) {
          var r3 = t3;
          return t3 || (r3 = e3 ? 16893 : 33204), (65535 & r3) << 16;
        }(h.unixPermissions, w)) : (C = 20, z |= function(t3) {
          return 63 & (t3 || 0);
        }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _2 && (v = A(1, 1) + A(B(f), 4) + d, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
        var E = "";
        return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(i2, 4) + f + b + p };
      }
      var I = t("../utils"), n = t("../stream/GenericWorker"), O = t("../utf8"), B = t("../crc32"), R = t("../signature");
      function s(t2, e2, r2, i2) {
        n.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = e2, this.zipPlatform = r2, this.encodeFileName = i2, this.streamFiles = t2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I.inherits(s, n), s.prototype.push = function(t2) {
        var e2 = t2.meta.percent || 0, r2 = this.entriesCount, i2 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(t2) : (this.bytesWritten += t2.data.length, n.prototype.push.call(this, { data: t2.data, meta: { currentFile: this.currentFile, percent: r2 ? (e2 + 100 * (r2 - i2 - 1)) / r2 : 100 } }));
      }, s.prototype.openedSource = function(t2) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = t2.file.name;
        var e2 = this.streamFiles && !t2.file.dir;
        if (e2) {
          var r2 = i(t2, e2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s.prototype.closedSource = function(t2) {
        this.accumulate = false;
        var e2 = this.streamFiles && !t2.file.dir, r2 = i(t2, e2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), e2)
          this.push({ data: function(t3) {
            return R.DATA_DESCRIPTOR + A(t3.crc32, 4) + A(t3.compressedSize, 4) + A(t3.uncompressedSize, 4);
          }(t2), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s.prototype.flush = function() {
        for (var t2 = this.bytesWritten, e2 = 0; e2 < this.dirRecords.length; e2++)
          this.push({ data: this.dirRecords[e2], meta: { percent: 100 } });
        var r2 = this.bytesWritten - t2, i2 = function(t3, e3, r3, i3, n2) {
          var s2 = I.transformTo("string", n2(i3));
          return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(t3, 2) + A(t3, 2) + A(e3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
        }(this.dirRecords.length, r2, t2, this.zipComment, this.encodeFileName);
        this.push({ data: i2, meta: { percent: 100 } });
      }, s.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s.prototype.registerPrevious = function(t2) {
        this._sources.push(t2);
        var e2 = this;
        return t2.on("data", function(t3) {
          e2.processChunk(t3);
        }), t2.on("end", function() {
          e2.closedSource(e2.previous.streamInfo), e2._sources.length ? e2.prepareNextSource() : e2.end();
        }), t2.on("error", function(t3) {
          e2.error(t3);
        }), this;
      }, s.prototype.resume = function() {
        return !!n.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s.prototype.error = function(t2) {
        var e2 = this._sources;
        if (!n.prototype.error.call(this, t2))
          return false;
        for (var r2 = 0; r2 < e2.length; r2++)
          try {
            e2[r2].error(t2);
          } catch (t3) {
          }
        return true;
      }, s.prototype.lock = function() {
        n.prototype.lock.call(this);
        for (var t2 = this._sources, e2 = 0; e2 < t2.length; e2++)
          t2[e2].lock();
      }, e.exports = s;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, e, r) {
      var u = t("../compressions"), i = t("./ZipFileWorker");
      r.generateWorker = function(t2, a, e2) {
        var o = new i(a.streamFiles, e2, a.platform, a.encodeFileName), h = 0;
        try {
          t2.forEach(function(t3, e3) {
            h++;
            var r2 = function(t4, e4) {
              var r3 = t4 || e4, i3 = u[r3];
              if (!i3)
                throw new Error(r3 + " is not a valid compression method !");
              return i3;
            }(e3.options.compression, a.compression), i2 = e3.options.compressionOptions || a.compressionOptions || {}, n = e3.dir, s = e3.date;
            e3._compressWorker(r2, i2).withStreamInfo("file", { name: t3, dir: n, date: s, comment: e3.comment || "", unixPermissions: e3.unixPermissions, dosPermissions: e3.dosPermissions }).pipe(o);
          }), o.entriesCount = h;
        } catch (t3) {
          o.error(t3);
        }
        return o;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, e, r) {
      function i() {
        if (!(this instanceof i))
          return new i();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var t2 = new i();
          for (var e2 in this)
            typeof this[e2] != "function" && (t2[e2] = this[e2]);
          return t2;
        };
      }
      (i.prototype = t("./object")).loadAsync = t("./load"), i.support = t("./support"), i.defaults = t("./defaults"), i.version = "3.7.1", i.loadAsync = function(t2, e2) {
        return new i().loadAsync(t2, e2);
      }, i.external = t("./external"), e.exports = i;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, e, r) {
      var i = t("./utils"), n = t("./external"), o = t("./utf8"), h = t("./zipEntries"), s = t("./stream/Crc32Probe"), u = t("./nodejsUtils");
      function l(i2) {
        return new n.Promise(function(t2, e2) {
          var r2 = i2.decompressed.getContentWorker().pipe(new s());
          r2.on("error", function(t3) {
            e2(t3);
          }).on("end", function() {
            r2.streamInfo.crc32 !== i2.decompressed.crc32 ? e2(new Error("Corrupted zip : CRC32 mismatch")) : t2();
          }).resume();
        });
      }
      e.exports = function(t2, s2) {
        var a = this;
        return s2 = i.extend(s2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: o.utf8decode }), u.isNode && u.isStream(t2) ? n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : i.prepareContent("the loaded zip file", t2, true, s2.optimizedBinaryString, s2.base64).then(function(t3) {
          var e2 = new h(s2);
          return e2.load(t3), e2;
        }).then(function(t3) {
          var e2 = [n.Promise.resolve(t3)], r2 = t3.files;
          if (s2.checkCRC32)
            for (var i2 = 0; i2 < r2.length; i2++)
              e2.push(l(r2[i2]));
          return n.Promise.all(e2);
        }).then(function(t3) {
          for (var e2 = t3.shift(), r2 = e2.files, i2 = 0; i2 < r2.length; i2++) {
            var n2 = r2[i2];
            a.file(n2.fileNameStr, n2.decompressed, { binary: true, optimizedBinaryString: true, date: n2.date, dir: n2.dir, comment: n2.fileCommentStr.length ? n2.fileCommentStr : null, unixPermissions: n2.unixPermissions, dosPermissions: n2.dosPermissions, createFolders: s2.createFolders });
          }
          return e2.zipComment.length && (a.comment = e2.zipComment), a;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, e, r) {
      var i = t("../utils"), n = t("../stream/GenericWorker");
      function s(t2, e2) {
        n.call(this, "Nodejs stream input adapter for " + t2), this._upstreamEnded = false, this._bindStream(e2);
      }
      i.inherits(s, n), s.prototype._bindStream = function(t2) {
        var e2 = this;
        (this._stream = t2).pause(), t2.on("data", function(t3) {
          e2.push({ data: t3, meta: { percent: 0 } });
        }).on("error", function(t3) {
          e2.isPaused ? this.generatedError = t3 : e2.error(t3);
        }).on("end", function() {
          e2.isPaused ? e2._upstreamEnded = true : e2.end();
        });
      }, s.prototype.pause = function() {
        return !!n.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s.prototype.resume = function() {
        return !!n.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, e.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, e, r) {
      var n = t("readable-stream").Readable;
      function i(t2, e2, r2) {
        n.call(this, e2), this._helper = t2;
        var i2 = this;
        t2.on("data", function(t3, e3) {
          i2.push(t3) || i2._helper.pause(), r2 && r2(e3);
        }).on("error", function(t3) {
          i2.emit("error", t3);
        }).on("end", function() {
          i2.push(null);
        });
      }
      t("../utils").inherits(i, n), i.prototype._read = function() {
        this._helper.resume();
      }, e.exports = i;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, e, r) {
      e.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(t2, e2) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(t2, e2);
        if (typeof t2 == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(t2, e2);
      }, allocBuffer: function(t2) {
        if (Buffer.alloc)
          return Buffer.alloc(t2);
        var e2 = new Buffer(t2);
        return e2.fill(0), e2;
      }, isBuffer: function(t2) {
        return Buffer.isBuffer(t2);
      }, isStream: function(t2) {
        return t2 && typeof t2.on == "function" && typeof t2.pause == "function" && typeof t2.resume == "function";
      } };
    }, {}], 15: [function(t, e, r) {
      function s(t2, e2, r2) {
        var i2, n2 = u.getTypeOf(e2), s2 = u.extend(r2 || {}, f);
        s2.date = s2.date || new Date(), s2.compression !== null && (s2.compression = s2.compression.toUpperCase()), typeof s2.unixPermissions == "string" && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (t2 = g(t2)), s2.createFolders && (i2 = _2(t2)) && b.call(this, i2, true);
        var a2 = n2 === "string" && s2.binary === false && s2.base64 === false;
        r2 && r2.binary !== void 0 || (s2.binary = !a2), (e2 instanceof d && e2.uncompressedSize === 0 || s2.dir || !e2 || e2.length === 0) && (s2.base64 = false, s2.binary = true, e2 = "", s2.compression = "STORE", n2 = "string");
        var o2 = null;
        o2 = e2 instanceof d || e2 instanceof l ? e2 : p.isNode && p.isStream(e2) ? new m(t2, e2) : u.prepareContent(t2, e2, s2.binary, s2.optimizedBinaryString, s2.base64);
        var h2 = new c(t2, o2, s2);
        this.files[t2] = h2;
      }
      var n = t("./utf8"), u = t("./utils"), l = t("./stream/GenericWorker"), a = t("./stream/StreamHelper"), f = t("./defaults"), d = t("./compressedObject"), c = t("./zipObject"), o = t("./generate"), p = t("./nodejsUtils"), m = t("./nodejs/NodejsStreamInputAdapter"), _2 = function(t2) {
        t2.slice(-1) === "/" && (t2 = t2.substring(0, t2.length - 1));
        var e2 = t2.lastIndexOf("/");
        return 0 < e2 ? t2.substring(0, e2) : "";
      }, g = function(t2) {
        return t2.slice(-1) !== "/" && (t2 += "/"), t2;
      }, b = function(t2, e2) {
        return e2 = e2 !== void 0 ? e2 : f.createFolders, t2 = g(t2), this.files[t2] || s.call(this, t2, null, { dir: true, createFolders: e2 }), this.files[t2];
      };
      function h(t2) {
        return Object.prototype.toString.call(t2) === "[object RegExp]";
      }
      var i = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(t2) {
        var e2, r2, i2;
        for (e2 in this.files)
          i2 = this.files[e2], (r2 = e2.slice(this.root.length, e2.length)) && e2.slice(0, this.root.length) === this.root && t2(r2, i2);
      }, filter: function(r2) {
        var i2 = [];
        return this.forEach(function(t2, e2) {
          r2(t2, e2) && i2.push(e2);
        }), i2;
      }, file: function(t2, e2, r2) {
        if (arguments.length !== 1)
          return t2 = this.root + t2, s.call(this, t2, e2, r2), this;
        if (h(t2)) {
          var i2 = t2;
          return this.filter(function(t3, e3) {
            return !e3.dir && i2.test(t3);
          });
        }
        var n2 = this.files[this.root + t2];
        return n2 && !n2.dir ? n2 : null;
      }, folder: function(r2) {
        if (!r2)
          return this;
        if (h(r2))
          return this.filter(function(t3, e3) {
            return e3.dir && r2.test(t3);
          });
        var t2 = this.root + r2, e2 = b.call(this, t2), i2 = this.clone();
        return i2.root = e2.name, i2;
      }, remove: function(r2) {
        r2 = this.root + r2;
        var t2 = this.files[r2];
        if (t2 || (r2.slice(-1) !== "/" && (r2 += "/"), t2 = this.files[r2]), t2 && !t2.dir)
          delete this.files[r2];
        else
          for (var e2 = this.filter(function(t3, e3) {
            return e3.name.slice(0, r2.length) === r2;
          }), i2 = 0; i2 < e2.length; i2++)
            delete this.files[e2[i2].name];
        return this;
      }, generate: function(t2) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(t2) {
        var e2, r2 = {};
        try {
          if ((r2 = u.extend(t2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: n.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), r2.type === "binarystring" && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          u.checkSupport(r2.type), r2.platform !== "darwin" && r2.platform !== "freebsd" && r2.platform !== "linux" && r2.platform !== "sunos" || (r2.platform = "UNIX"), r2.platform === "win32" && (r2.platform = "DOS");
          var i2 = r2.comment || this.comment || "";
          e2 = o.generateWorker(this, r2, i2);
        } catch (t3) {
          (e2 = new l("error")).error(t3);
        }
        return new a(e2, r2.type || "string", r2.mimeType);
      }, generateAsync: function(t2, e2) {
        return this.generateInternalStream(t2).accumulate(e2);
      }, generateNodeStream: function(t2, e2) {
        return (t2 = t2 || {}).type || (t2.type = "nodebuffer"), this.generateInternalStream(t2).toNodejsStream(e2);
      } };
      e.exports = i;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, e, r) {
      e.exports = t("stream");
    }, { stream: void 0 }], 17: [function(t, e, r) {
      var i = t("./DataReader");
      function n(t2) {
        i.call(this, t2);
        for (var e2 = 0; e2 < this.data.length; e2++)
          t2[e2] = 255 & t2[e2];
      }
      t("../utils").inherits(n, i), n.prototype.byteAt = function(t2) {
        return this.data[this.zero + t2];
      }, n.prototype.lastIndexOfSignature = function(t2) {
        for (var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), i2 = t2.charCodeAt(2), n2 = t2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
          if (this.data[s] === e2 && this.data[s + 1] === r2 && this.data[s + 2] === i2 && this.data[s + 3] === n2)
            return s - this.zero;
        return -1;
      }, n.prototype.readAndCheckSignature = function(t2) {
        var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), i2 = t2.charCodeAt(2), n2 = t2.charCodeAt(3), s = this.readData(4);
        return e2 === s[0] && r2 === s[1] && i2 === s[2] && n2 === s[3];
      }, n.prototype.readData = function(t2) {
        if (this.checkOffset(t2), t2 === 0)
          return [];
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = n;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, e, r) {
      var i = t("../utils");
      function n(t2) {
        this.data = t2, this.length = t2.length, this.index = 0, this.zero = 0;
      }
      n.prototype = { checkOffset: function(t2) {
        this.checkIndex(this.index + t2);
      }, checkIndex: function(t2) {
        if (this.length < this.zero + t2 || t2 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + t2 + "). Corrupted zip ?");
      }, setIndex: function(t2) {
        this.checkIndex(t2), this.index = t2;
      }, skip: function(t2) {
        this.setIndex(this.index + t2);
      }, byteAt: function(t2) {
      }, readInt: function(t2) {
        var e2, r2 = 0;
        for (this.checkOffset(t2), e2 = this.index + t2 - 1; e2 >= this.index; e2--)
          r2 = (r2 << 8) + this.byteAt(e2);
        return this.index += t2, r2;
      }, readString: function(t2) {
        return i.transformTo("string", this.readData(t2));
      }, readData: function(t2) {
      }, lastIndexOfSignature: function(t2) {
      }, readAndCheckSignature: function(t2) {
      }, readDate: function() {
        var t2 = this.readInt(4);
        return new Date(Date.UTC(1980 + (t2 >> 25 & 127), (t2 >> 21 & 15) - 1, t2 >> 16 & 31, t2 >> 11 & 31, t2 >> 5 & 63, (31 & t2) << 1));
      } }, e.exports = n;
    }, { "../utils": 32 }], 19: [function(t, e, r) {
      var i = t("./Uint8ArrayReader");
      function n(t2) {
        i.call(this, t2);
      }
      t("../utils").inherits(n, i), n.prototype.readData = function(t2) {
        this.checkOffset(t2);
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = n;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, e, r) {
      var i = t("./DataReader");
      function n(t2) {
        i.call(this, t2);
      }
      t("../utils").inherits(n, i), n.prototype.byteAt = function(t2) {
        return this.data.charCodeAt(this.zero + t2);
      }, n.prototype.lastIndexOfSignature = function(t2) {
        return this.data.lastIndexOf(t2) - this.zero;
      }, n.prototype.readAndCheckSignature = function(t2) {
        return t2 === this.readData(4);
      }, n.prototype.readData = function(t2) {
        this.checkOffset(t2);
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = n;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, e, r) {
      var i = t("./ArrayReader");
      function n(t2) {
        i.call(this, t2);
      }
      t("../utils").inherits(n, i), n.prototype.readData = function(t2) {
        if (this.checkOffset(t2), t2 === 0)
          return new Uint8Array(0);
        var e2 = this.data.subarray(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = n;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, e, r) {
      var i = t("../utils"), n = t("../support"), s = t("./ArrayReader"), a = t("./StringReader"), o = t("./NodeBufferReader"), h = t("./Uint8ArrayReader");
      e.exports = function(t2) {
        var e2 = i.getTypeOf(t2);
        return i.checkSupport(e2), e2 !== "string" || n.uint8array ? e2 === "nodebuffer" ? new o(t2) : n.uint8array ? new h(i.transformTo("uint8array", t2)) : new s(i.transformTo("array", t2)) : new a(t2);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, e, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(t, e, r) {
      var i = t("./GenericWorker"), n = t("../utils");
      function s(t2) {
        i.call(this, "ConvertWorker to " + t2), this.destType = t2;
      }
      n.inherits(s, i), s.prototype.processChunk = function(t2) {
        this.push({ data: n.transformTo(this.destType, t2.data), meta: t2.meta });
      }, e.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, e, r) {
      var i = t("./GenericWorker"), n = t("../crc32");
      function s() {
        i.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(s, i), s.prototype.processChunk = function(t2) {
        this.streamInfo.crc32 = n(t2.data, this.streamInfo.crc32 || 0), this.push(t2);
      }, e.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, e, r) {
      var i = t("../utils"), n = t("./GenericWorker");
      function s(t2) {
        n.call(this, "DataLengthProbe for " + t2), this.propName = t2, this.withStreamInfo(t2, 0);
      }
      i.inherits(s, n), s.prototype.processChunk = function(t2) {
        if (t2) {
          var e2 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = e2 + t2.data.length;
        }
        n.prototype.processChunk.call(this, t2);
      }, e.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, e, r) {
      var i = t("../utils"), n = t("./GenericWorker");
      function s(t2) {
        n.call(this, "DataWorker");
        var e2 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, t2.then(function(t3) {
          e2.dataIsReady = true, e2.data = t3, e2.max = t3 && t3.length || 0, e2.type = i.getTypeOf(t3), e2.isPaused || e2._tickAndRepeat();
        }, function(t3) {
          e2.error(t3);
        });
      }
      i.inherits(s, n), s.prototype.cleanUp = function() {
        n.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!n.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, i.delay(this._tickAndRepeat, [], this)), true);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var t2 = null, e2 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            t2 = this.data.substring(this.index, e2);
            break;
          case "uint8array":
            t2 = this.data.subarray(this.index, e2);
            break;
          case "array":
          case "nodebuffer":
            t2 = this.data.slice(this.index, e2);
        }
        return this.index = e2, this.push({ data: t2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, e.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, e, r) {
      function i(t2) {
        this.name = t2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      i.prototype = { push: function(t2) {
        this.emit("data", t2);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (t2) {
          this.emit("error", t2);
        }
        return true;
      }, error: function(t2) {
        return !this.isFinished && (this.isPaused ? this.generatedError = t2 : (this.isFinished = true, this.emit("error", t2), this.previous && this.previous.error(t2), this.cleanUp()), true);
      }, on: function(t2, e2) {
        return this._listeners[t2].push(e2), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(t2, e2) {
        if (this._listeners[t2])
          for (var r2 = 0; r2 < this._listeners[t2].length; r2++)
            this._listeners[t2][r2].call(this, e2);
      }, pipe: function(t2) {
        return t2.registerPrevious(this);
      }, registerPrevious: function(t2) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = t2.streamInfo, this.mergeStreamInfo(), this.previous = t2;
        var e2 = this;
        return t2.on("data", function(t3) {
          e2.processChunk(t3);
        }), t2.on("end", function() {
          e2.end();
        }), t2.on("error", function(t3) {
          e2.error(t3);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var t2 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), t2 = true), this.previous && this.previous.resume(), !t2;
      }, flush: function() {
      }, processChunk: function(t2) {
        this.push(t2);
      }, withStreamInfo: function(t2, e2) {
        return this.extraStreamInfo[t2] = e2, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var t2 in this.extraStreamInfo)
          this.extraStreamInfo.hasOwnProperty(t2) && (this.streamInfo[t2] = this.extraStreamInfo[t2]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var t2 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + t2 : t2;
      } }, e.exports = i;
    }, {}], 29: [function(t, e, r) {
      var h = t("../utils"), n = t("./ConvertWorker"), s = t("./GenericWorker"), u = t("../base64"), i = t("../support"), a = t("../external"), o = null;
      if (i.nodestream)
        try {
          o = t("../nodejs/NodejsStreamOutputAdapter");
        } catch (t2) {
        }
      function l(t2, o2) {
        return new a.Promise(function(e2, r2) {
          var i2 = [], n2 = t2._internalType, s2 = t2._outputType, a2 = t2._mimeType;
          t2.on("data", function(t3, e3) {
            i2.push(t3), o2 && o2(e3);
          }).on("error", function(t3) {
            i2 = [], r2(t3);
          }).on("end", function() {
            try {
              var t3 = function(t4, e3, r3) {
                switch (t4) {
                  case "blob":
                    return h.newBlob(h.transformTo("arraybuffer", e3), r3);
                  case "base64":
                    return u.encode(e3);
                  default:
                    return h.transformTo(t4, e3);
                }
              }(s2, function(t4, e3) {
                var r3, i3 = 0, n3 = null, s3 = 0;
                for (r3 = 0; r3 < e3.length; r3++)
                  s3 += e3[r3].length;
                switch (t4) {
                  case "string":
                    return e3.join("");
                  case "array":
                    return Array.prototype.concat.apply([], e3);
                  case "uint8array":
                    for (n3 = new Uint8Array(s3), r3 = 0; r3 < e3.length; r3++)
                      n3.set(e3[r3], i3), i3 += e3[r3].length;
                    return n3;
                  case "nodebuffer":
                    return Buffer.concat(e3);
                  default:
                    throw new Error("concat : unsupported type '" + t4 + "'");
                }
              }(n2, i2), a2);
              e2(t3);
            } catch (t4) {
              r2(t4);
            }
            i2 = [];
          }).resume();
        });
      }
      function f(t2, e2, r2) {
        var i2 = e2;
        switch (e2) {
          case "blob":
          case "arraybuffer":
            i2 = "uint8array";
            break;
          case "base64":
            i2 = "string";
        }
        try {
          this._internalType = i2, this._outputType = e2, this._mimeType = r2, h.checkSupport(i2), this._worker = t2.pipe(new n(i2)), t2.lock();
        } catch (t3) {
          this._worker = new s("error"), this._worker.error(t3);
        }
      }
      f.prototype = { accumulate: function(t2) {
        return l(this, t2);
      }, on: function(t2, e2) {
        var r2 = this;
        return t2 === "data" ? this._worker.on(t2, function(t3) {
          e2.call(r2, t3.data, t3.meta);
        }) : this._worker.on(t2, function() {
          h.delay(e2, arguments, r2);
        }), this;
      }, resume: function() {
        return h.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(t2) {
        if (h.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new o(this, { objectMode: this._outputType !== "nodebuffer" }, t2);
      } }, e.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, e, r) {
      if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", r.nodebuffer = typeof Buffer != "undefined", r.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
        r.blob = false;
      else {
        var i = new ArrayBuffer(0);
        try {
          r.blob = new Blob([i], { type: "application/zip" }).size === 0;
        } catch (t2) {
          try {
            var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            n.append(i), r.blob = n.getBlob("application/zip").size === 0;
          } catch (t3) {
            r.blob = false;
          }
        }
      }
      try {
        r.nodestream = !!t("readable-stream").Readable;
      } catch (t2) {
        r.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(t, e, s) {
      for (var o = t("./utils"), h = t("./support"), r = t("./nodejsUtils"), i = t("./stream/GenericWorker"), u = new Array(256), n = 0; n < 256; n++)
        u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
      u[254] = u[254] = 1;
      function a() {
        i.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l() {
        i.call(this, "utf-8 encode");
      }
      s.utf8encode = function(t2) {
        return h.nodebuffer ? r.newBufferFrom(t2, "utf-8") : function(t3) {
          var e2, r2, i2, n2, s2, a2 = t3.length, o2 = 0;
          for (n2 = 0; n2 < a2; n2++)
            (64512 & (r2 = t3.charCodeAt(n2))) == 55296 && n2 + 1 < a2 && (64512 & (i2 = t3.charCodeAt(n2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (e2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), n2 = s2 = 0; s2 < o2; n2++)
            (64512 & (r2 = t3.charCodeAt(n2))) == 55296 && n2 + 1 < a2 && (64512 & (i2 = t3.charCodeAt(n2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), r2 < 128 ? e2[s2++] = r2 : (r2 < 2048 ? e2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? e2[s2++] = 224 | r2 >>> 12 : (e2[s2++] = 240 | r2 >>> 18, e2[s2++] = 128 | r2 >>> 12 & 63), e2[s2++] = 128 | r2 >>> 6 & 63), e2[s2++] = 128 | 63 & r2);
          return e2;
        }(t2);
      }, s.utf8decode = function(t2) {
        return h.nodebuffer ? o.transformTo("nodebuffer", t2).toString("utf-8") : function(t3) {
          var e2, r2, i2, n2, s2 = t3.length, a2 = new Array(2 * s2);
          for (e2 = r2 = 0; e2 < s2; )
            if ((i2 = t3[e2++]) < 128)
              a2[r2++] = i2;
            else if (4 < (n2 = u[i2]))
              a2[r2++] = 65533, e2 += n2 - 1;
            else {
              for (i2 &= n2 === 2 ? 31 : n2 === 3 ? 15 : 7; 1 < n2 && e2 < s2; )
                i2 = i2 << 6 | 63 & t3[e2++], n2--;
              1 < n2 ? a2[r2++] = 65533 : i2 < 65536 ? a2[r2++] = i2 : (i2 -= 65536, a2[r2++] = 55296 | i2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & i2);
            }
          return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
        }(t2 = o.transformTo(h.uint8array ? "uint8array" : "array", t2));
      }, o.inherits(a, i), a.prototype.processChunk = function(t2) {
        var e2 = o.transformTo(h.uint8array ? "uint8array" : "array", t2.data);
        if (this.leftOver && this.leftOver.length) {
          if (h.uint8array) {
            var r2 = e2;
            (e2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), e2.set(r2, this.leftOver.length);
          } else
            e2 = this.leftOver.concat(e2);
          this.leftOver = null;
        }
        var i2 = function(t3, e3) {
          var r3;
          for ((e3 = e3 || t3.length) > t3.length && (e3 = t3.length), r3 = e3 - 1; 0 <= r3 && (192 & t3[r3]) == 128; )
            r3--;
          return r3 < 0 ? e3 : r3 === 0 ? e3 : r3 + u[t3[r3]] > e3 ? r3 : e3;
        }(e2), n2 = e2;
        i2 !== e2.length && (h.uint8array ? (n2 = e2.subarray(0, i2), this.leftOver = e2.subarray(i2, e2.length)) : (n2 = e2.slice(0, i2), this.leftOver = e2.slice(i2, e2.length))), this.push({ data: s.utf8decode(n2), meta: t2.meta });
      }, a.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = a, o.inherits(l, i), l.prototype.processChunk = function(t2) {
        this.push({ data: s.utf8encode(t2.data), meta: t2.meta });
      }, s.Utf8EncodeWorker = l;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, e, a) {
      var o = t("./support"), h = t("./base64"), r = t("./nodejsUtils"), i = t("set-immediate-shim"), u = t("./external");
      function n(t2) {
        return t2;
      }
      function l(t2, e2) {
        for (var r2 = 0; r2 < t2.length; ++r2)
          e2[r2] = 255 & t2.charCodeAt(r2);
        return e2;
      }
      a.newBlob = function(e2, r2) {
        a.checkSupport("blob");
        try {
          return new Blob([e2], { type: r2 });
        } catch (t2) {
          try {
            var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return i2.append(e2), i2.getBlob(r2);
          } catch (t3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var s = { stringifyByChunk: function(t2, e2, r2) {
        var i2 = [], n2 = 0, s2 = t2.length;
        if (s2 <= r2)
          return String.fromCharCode.apply(null, t2);
        for (; n2 < s2; )
          e2 === "array" || e2 === "nodebuffer" ? i2.push(String.fromCharCode.apply(null, t2.slice(n2, Math.min(n2 + r2, s2)))) : i2.push(String.fromCharCode.apply(null, t2.subarray(n2, Math.min(n2 + r2, s2)))), n2 += r2;
        return i2.join("");
      }, stringifyByChar: function(t2) {
        for (var e2 = "", r2 = 0; r2 < t2.length; r2++)
          e2 += String.fromCharCode(t2[r2]);
        return e2;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (t2) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
        } catch (t2) {
          return false;
        }
      }() } };
      function f(t2) {
        var e2 = 65536, r2 = a.getTypeOf(t2), i2 = true;
        if (r2 === "uint8array" ? i2 = s.applyCanBeUsed.uint8array : r2 === "nodebuffer" && (i2 = s.applyCanBeUsed.nodebuffer), i2)
          for (; 1 < e2; )
            try {
              return s.stringifyByChunk(t2, r2, e2);
            } catch (t3) {
              e2 = Math.floor(e2 / 2);
            }
        return s.stringifyByChar(t2);
      }
      function d(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2[r2] = t2[r2];
        return e2;
      }
      a.applyFromCharCode = f;
      var c = {};
      c.string = { string: n, array: function(t2) {
        return l(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return c.string.uint8array(t2).buffer;
      }, uint8array: function(t2) {
        return l(t2, new Uint8Array(t2.length));
      }, nodebuffer: function(t2) {
        return l(t2, r.allocBuffer(t2.length));
      } }, c.array = { string: f, array: n, arraybuffer: function(t2) {
        return new Uint8Array(t2).buffer;
      }, uint8array: function(t2) {
        return new Uint8Array(t2);
      }, nodebuffer: function(t2) {
        return r.newBufferFrom(t2);
      } }, c.arraybuffer = { string: function(t2) {
        return f(new Uint8Array(t2));
      }, array: function(t2) {
        return d(new Uint8Array(t2), new Array(t2.byteLength));
      }, arraybuffer: n, uint8array: function(t2) {
        return new Uint8Array(t2);
      }, nodebuffer: function(t2) {
        return r.newBufferFrom(new Uint8Array(t2));
      } }, c.uint8array = { string: f, array: function(t2) {
        return d(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return t2.buffer;
      }, uint8array: n, nodebuffer: function(t2) {
        return r.newBufferFrom(t2);
      } }, c.nodebuffer = { string: f, array: function(t2) {
        return d(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return c.nodebuffer.uint8array(t2).buffer;
      }, uint8array: function(t2) {
        return d(t2, new Uint8Array(t2.length));
      }, nodebuffer: n }, a.transformTo = function(t2, e2) {
        if (e2 = e2 || "", !t2)
          return e2;
        a.checkSupport(t2);
        var r2 = a.getTypeOf(e2);
        return c[r2][t2](e2);
      }, a.getTypeOf = function(t2) {
        return typeof t2 == "string" ? "string" : Object.prototype.toString.call(t2) === "[object Array]" ? "array" : o.nodebuffer && r.isBuffer(t2) ? "nodebuffer" : o.uint8array && t2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && t2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(t2) {
        if (!o[t2.toLowerCase()])
          throw new Error(t2 + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(t2) {
        var e2, r2, i2 = "";
        for (r2 = 0; r2 < (t2 || "").length; r2++)
          i2 += "\\x" + ((e2 = t2.charCodeAt(r2)) < 16 ? "0" : "") + e2.toString(16).toUpperCase();
        return i2;
      }, a.delay = function(t2, e2, r2) {
        i(function() {
          t2.apply(r2 || null, e2 || []);
        });
      }, a.inherits = function(t2, e2) {
        function r2() {
        }
        r2.prototype = e2.prototype, t2.prototype = new r2();
      }, a.extend = function() {
        var t2, e2, r2 = {};
        for (t2 = 0; t2 < arguments.length; t2++)
          for (e2 in arguments[t2])
            arguments[t2].hasOwnProperty(e2) && r2[e2] === void 0 && (r2[e2] = arguments[t2][e2]);
        return r2;
      }, a.prepareContent = function(r2, t2, i2, n2, s2) {
        return u.Promise.resolve(t2).then(function(i3) {
          return o.blob && (i3 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(i3)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(e2, r3) {
            var t3 = new FileReader();
            t3.onload = function(t4) {
              e2(t4.target.result);
            }, t3.onerror = function(t4) {
              r3(t4.target.error);
            }, t3.readAsArrayBuffer(i3);
          }) : i3;
        }).then(function(t3) {
          var e2 = a.getTypeOf(t3);
          return e2 ? (e2 === "arraybuffer" ? t3 = a.transformTo("uint8array", t3) : e2 === "string" && (s2 ? t3 = h.decode(t3) : i2 && n2 !== true && (t3 = function(t4) {
            return l(t4, o.uint8array ? new Uint8Array(t4.length) : new Array(t4.length));
          }(t3))), t3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(t, e, r) {
      var i = t("./reader/readerFor"), n = t("./utils"), s = t("./signature"), a = t("./zipEntry"), o = (t("./utf8"), t("./support"));
      function h(t2) {
        this.files = [], this.loadOptions = t2;
      }
      h.prototype = { checkSignature: function(t2) {
        if (!this.reader.readAndCheckSignature(t2)) {
          this.reader.index -= 4;
          var e2 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + n.pretty(e2) + ", expected " + n.pretty(t2) + ")");
        }
      }, isSignature: function(t2, e2) {
        var r2 = this.reader.index;
        this.reader.setIndex(t2);
        var i2 = this.reader.readString(4) === e2;
        return this.reader.setIndex(r2), i2;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var t2 = this.reader.readData(this.zipCommentLength), e2 = o.uint8array ? "uint8array" : "array", r2 = n.transformTo(e2, t2);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var t2, e2, r2, i2 = this.zip64EndOfCentralSize - 44; 0 < i2; )
          t2 = this.reader.readInt(2), e2 = this.reader.readInt(4), r2 = this.reader.readData(e2), this.zip64ExtensibleData[t2] = { id: t2, length: e2, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var t2, e2;
        for (t2 = 0; t2 < this.files.length; t2++)
          e2 = this.files[t2], this.reader.setIndex(e2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), e2.readLocalPart(this.reader), e2.handleUTF8(), e2.processAttributes();
      }, readCentralDir: function() {
        var t2;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (t2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(t2);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var t2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (t2 < 0)
          throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(t2);
        var e2 = t2;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === n.MAX_VALUE_16BITS || this.diskWithCentralDirStart === n.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === n.MAX_VALUE_16BITS || this.centralDirRecords === n.MAX_VALUE_16BITS || this.centralDirSize === n.MAX_VALUE_32BITS || this.centralDirOffset === n.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (t2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(t2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var i2 = e2 - r2;
        if (0 < i2)
          this.isSignature(e2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = i2);
        else if (i2 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(i2) + " bytes.");
      }, prepareReader: function(t2) {
        this.reader = i(t2);
      }, load: function(t2) {
        this.prepareReader(t2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, e.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, e, r) {
      var i = t("./reader/readerFor"), s = t("./utils"), n = t("./compressedObject"), a = t("./crc32"), o = t("./utf8"), h = t("./compressions"), u = t("./support");
      function l(t2, e2) {
        this.options = t2, this.loadOptions = e2;
      }
      l.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(t2) {
        var e2, r2;
        if (t2.skip(22), this.fileNameLength = t2.readInt(2), r2 = t2.readInt(2), this.fileName = t2.readData(this.fileNameLength), t2.skip(r2), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((e2 = function(t3) {
          for (var e3 in h)
            if (h.hasOwnProperty(e3) && h[e3].magic === t3)
              return h[e3];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
        this.decompressed = new n(this.compressedSize, this.uncompressedSize, this.crc32, e2, t2.readData(this.compressedSize));
      }, readCentralPart: function(t2) {
        this.versionMadeBy = t2.readInt(2), t2.skip(2), this.bitFlag = t2.readInt(2), this.compressionMethod = t2.readString(2), this.date = t2.readDate(), this.crc32 = t2.readInt(4), this.compressedSize = t2.readInt(4), this.uncompressedSize = t2.readInt(4);
        var e2 = t2.readInt(2);
        if (this.extraFieldsLength = t2.readInt(2), this.fileCommentLength = t2.readInt(2), this.diskNumberStart = t2.readInt(2), this.internalFileAttributes = t2.readInt(2), this.externalFileAttributes = t2.readInt(4), this.localHeaderOffset = t2.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        t2.skip(e2), this.readExtraFields(t2), this.parseZIP64ExtraField(t2), this.fileComment = t2.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var t2 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), t2 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), t2 == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
      }, parseZIP64ExtraField: function(t2) {
        if (this.extraFields[1]) {
          var e2 = i(this.extraFields[1].value);
          this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
        }
      }, readExtraFields: function(t2) {
        var e2, r2, i2, n2 = t2.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); t2.index + 4 < n2; )
          e2 = t2.readInt(2), r2 = t2.readInt(2), i2 = t2.readData(r2), this.extraFields[e2] = { id: e2, length: r2, value: i2 };
        t2.setIndex(n2);
      }, handleUTF8: function() {
        var t2 = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
        else {
          var e2 = this.findExtraFieldUnicodePath();
          if (e2 !== null)
            this.fileNameStr = e2;
          else {
            var r2 = s.transformTo(t2, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var i2 = this.findExtraFieldUnicodeComment();
          if (i2 !== null)
            this.fileCommentStr = i2;
          else {
            var n2 = s.transformTo(t2, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(n2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var t2 = this.extraFields[28789];
        if (t2) {
          var e2 = i(t2.value);
          return e2.readInt(1) !== 1 ? null : a(this.fileName) !== e2.readInt(4) ? null : o.utf8decode(e2.readData(t2.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var t2 = this.extraFields[25461];
        if (t2) {
          var e2 = i(t2.value);
          return e2.readInt(1) !== 1 ? null : a(this.fileComment) !== e2.readInt(4) ? null : o.utf8decode(e2.readData(t2.length - 5));
        }
        return null;
      } }, e.exports = l;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, e, r) {
      function i(t2, e2, r2) {
        this.name = t2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = e2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      }
      var s = t("./stream/StreamHelper"), n = t("./stream/DataWorker"), a = t("./utf8"), o = t("./compressedObject"), h = t("./stream/GenericWorker");
      i.prototype = { internalStream: function(t2) {
        var e2 = null, r2 = "string";
        try {
          if (!t2)
            throw new Error("No output type specified.");
          var i2 = (r2 = t2.toLowerCase()) === "string" || r2 === "text";
          r2 !== "binarystring" && r2 !== "text" || (r2 = "string"), e2 = this._decompressWorker();
          var n2 = !this._dataBinary;
          n2 && !i2 && (e2 = e2.pipe(new a.Utf8EncodeWorker())), !n2 && i2 && (e2 = e2.pipe(new a.Utf8DecodeWorker()));
        } catch (t3) {
          (e2 = new h("error")).error(t3);
        }
        return new s(e2, r2, "");
      }, async: function(t2, e2) {
        return this.internalStream(t2).accumulate(e2);
      }, nodeStream: function(t2, e2) {
        return this.internalStream(t2 || "nodebuffer").toNodejsStream(e2);
      }, _compressWorker: function(t2, e2) {
        if (this._data instanceof o && this._data.compression.magic === t2.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, t2, e2);
      }, _decompressWorker: function() {
        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new n(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < u.length; f++)
        i.prototype[u[f]] = l;
      e.exports = i;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, l, e) {
      (function(e2) {
        var r, i, t2 = e2.MutationObserver || e2.WebKitMutationObserver;
        if (t2) {
          var n = 0, s = new t2(u), a = e2.document.createTextNode("");
          s.observe(a, { characterData: true }), r = function() {
            a.data = n = ++n % 2;
          };
        } else if (e2.setImmediate || e2.MessageChannel === void 0)
          r = "document" in e2 && "onreadystatechange" in e2.document.createElement("script") ? function() {
            var t3 = e2.document.createElement("script");
            t3.onreadystatechange = function() {
              u(), t3.onreadystatechange = null, t3.parentNode.removeChild(t3), t3 = null;
            }, e2.document.documentElement.appendChild(t3);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var o = new e2.MessageChannel();
          o.port1.onmessage = u, r = function() {
            o.port2.postMessage(0);
          };
        }
        var h = [];
        function u() {
          var t3, e3;
          i = true;
          for (var r2 = h.length; r2; ) {
            for (e3 = h, h = [], t3 = -1; ++t3 < r2; )
              e3[t3]();
            r2 = h.length;
          }
          i = false;
        }
        l.exports = function(t3) {
          h.push(t3) !== 1 || i || r();
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 37: [function(t, e, r) {
      var n = t("immediate");
      function u() {
      }
      var l = {}, s = ["REJECTED"], a = ["FULFILLED"], i = ["PENDING"];
      function o(t2) {
        if (typeof t2 != "function")
          throw new TypeError("resolver must be a function");
        this.state = i, this.queue = [], this.outcome = void 0, t2 !== u && c(this, t2);
      }
      function h(t2, e2, r2) {
        this.promise = t2, typeof e2 == "function" && (this.onFulfilled = e2, this.callFulfilled = this.otherCallFulfilled), typeof r2 == "function" && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function f(e2, r2, i2) {
        n(function() {
          var t2;
          try {
            t2 = r2(i2);
          } catch (t3) {
            return l.reject(e2, t3);
          }
          t2 === e2 ? l.reject(e2, new TypeError("Cannot resolve promise with itself")) : l.resolve(e2, t2);
        });
      }
      function d(t2) {
        var e2 = t2 && t2.then;
        if (t2 && (typeof t2 == "object" || typeof t2 == "function") && typeof e2 == "function")
          return function() {
            e2.apply(t2, arguments);
          };
      }
      function c(e2, t2) {
        var r2 = false;
        function i2(t3) {
          r2 || (r2 = true, l.reject(e2, t3));
        }
        function n2(t3) {
          r2 || (r2 = true, l.resolve(e2, t3));
        }
        var s2 = p(function() {
          t2(n2, i2);
        });
        s2.status === "error" && i2(s2.value);
      }
      function p(t2, e2) {
        var r2 = {};
        try {
          r2.value = t2(e2), r2.status = "success";
        } catch (t3) {
          r2.status = "error", r2.value = t3;
        }
        return r2;
      }
      (e.exports = o).prototype.finally = function(e2) {
        if (typeof e2 != "function")
          return this;
        var r2 = this.constructor;
        return this.then(function(t2) {
          return r2.resolve(e2()).then(function() {
            return t2;
          });
        }, function(t2) {
          return r2.resolve(e2()).then(function() {
            throw t2;
          });
        });
      }, o.prototype.catch = function(t2) {
        return this.then(null, t2);
      }, o.prototype.then = function(t2, e2) {
        if (typeof t2 != "function" && this.state === a || typeof e2 != "function" && this.state === s)
          return this;
        var r2 = new this.constructor(u);
        this.state !== i ? f(r2, this.state === a ? t2 : e2, this.outcome) : this.queue.push(new h(r2, t2, e2));
        return r2;
      }, h.prototype.callFulfilled = function(t2) {
        l.resolve(this.promise, t2);
      }, h.prototype.otherCallFulfilled = function(t2) {
        f(this.promise, this.onFulfilled, t2);
      }, h.prototype.callRejected = function(t2) {
        l.reject(this.promise, t2);
      }, h.prototype.otherCallRejected = function(t2) {
        f(this.promise, this.onRejected, t2);
      }, l.resolve = function(t2, e2) {
        var r2 = p(d, e2);
        if (r2.status === "error")
          return l.reject(t2, r2.value);
        var i2 = r2.value;
        if (i2)
          c(t2, i2);
        else {
          t2.state = a, t2.outcome = e2;
          for (var n2 = -1, s2 = t2.queue.length; ++n2 < s2; )
            t2.queue[n2].callFulfilled(e2);
        }
        return t2;
      }, l.reject = function(t2, e2) {
        t2.state = s, t2.outcome = e2;
        for (var r2 = -1, i2 = t2.queue.length; ++r2 < i2; )
          t2.queue[r2].callRejected(e2);
        return t2;
      }, o.resolve = function(t2) {
        if (t2 instanceof this)
          return t2;
        return l.resolve(new this(u), t2);
      }, o.reject = function(t2) {
        var e2 = new this(u);
        return l.reject(e2, t2);
      }, o.all = function(t2) {
        var r2 = this;
        if (Object.prototype.toString.call(t2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var i2 = t2.length, n2 = false;
        if (!i2)
          return this.resolve([]);
        var s2 = new Array(i2), a2 = 0, e2 = -1, o2 = new this(u);
        for (; ++e2 < i2; )
          h2(t2[e2], e2);
        return o2;
        function h2(t3, e3) {
          r2.resolve(t3).then(function(t4) {
            s2[e3] = t4, ++a2 !== i2 || n2 || (n2 = true, l.resolve(o2, s2));
          }, function(t4) {
            n2 || (n2 = true, l.reject(o2, t4));
          });
        }
      }, o.race = function(t2) {
        var e2 = this;
        if (Object.prototype.toString.call(t2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var r2 = t2.length, i2 = false;
        if (!r2)
          return this.resolve([]);
        var n2 = -1, s2 = new this(u);
        for (; ++n2 < r2; )
          a2 = t2[n2], e2.resolve(a2).then(function(t3) {
            i2 || (i2 = true, l.resolve(s2, t3));
          }, function(t3) {
            i2 || (i2 = true, l.reject(s2, t3));
          });
        var a2;
        return s2;
      };
    }, { immediate: 36 }], 38: [function(t, e, r) {
      var i = {};
      (0, t("./lib/utils/common").assign)(i, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = i;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, e, r) {
      var a = t("./zlib/deflate"), o = t("./utils/common"), h = t("./utils/strings"), n = t("./zlib/messages"), s = t("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, d = 0, c = 8;
      function p(t2) {
        if (!(this instanceof p))
          return new p(t2);
        this.options = o.assign({ level: f, method: c, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, t2 || {});
        var e2 = this.options;
        e2.raw && 0 < e2.windowBits ? e2.windowBits = -e2.windowBits : e2.gzip && 0 < e2.windowBits && e2.windowBits < 16 && (e2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
        var r2 = a.deflateInit2(this.strm, e2.level, e2.method, e2.windowBits, e2.memLevel, e2.strategy);
        if (r2 !== l)
          throw new Error(n[r2]);
        if (e2.header && a.deflateSetHeader(this.strm, e2.header), e2.dictionary) {
          var i2;
          if (i2 = typeof e2.dictionary == "string" ? h.string2buf(e2.dictionary) : u.call(e2.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(e2.dictionary) : e2.dictionary, (r2 = a.deflateSetDictionary(this.strm, i2)) !== l)
            throw new Error(n[r2]);
          this._dict_set = true;
        }
      }
      function i(t2, e2) {
        var r2 = new p(e2);
        if (r2.push(t2, true), r2.err)
          throw r2.msg || n[r2.err];
        return r2.result;
      }
      p.prototype.push = function(t2, e2) {
        var r2, i2, n2 = this.strm, s2 = this.options.chunkSize;
        if (this.ended)
          return false;
        i2 = e2 === ~~e2 ? e2 : e2 === true ? 4 : 0, typeof t2 == "string" ? n2.input = h.string2buf(t2) : u.call(t2) === "[object ArrayBuffer]" ? n2.input = new Uint8Array(t2) : n2.input = t2, n2.next_in = 0, n2.avail_in = n2.input.length;
        do {
          if (n2.avail_out === 0 && (n2.output = new o.Buf8(s2), n2.next_out = 0, n2.avail_out = s2), (r2 = a.deflate(n2, i2)) !== 1 && r2 !== l)
            return this.onEnd(r2), !(this.ended = true);
          n2.avail_out !== 0 && (n2.avail_in !== 0 || i2 !== 4 && i2 !== 2) || (this.options.to === "string" ? this.onData(h.buf2binstring(o.shrinkBuf(n2.output, n2.next_out))) : this.onData(o.shrinkBuf(n2.output, n2.next_out)));
        } while ((0 < n2.avail_in || n2.avail_out === 0) && r2 !== 1);
        return i2 === 4 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : i2 !== 2 || (this.onEnd(l), !(n2.avail_out = 0));
      }, p.prototype.onData = function(t2) {
        this.chunks.push(t2);
      }, p.prototype.onEnd = function(t2) {
        t2 === l && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
      }, r.Deflate = p, r.deflate = i, r.deflateRaw = function(t2, e2) {
        return (e2 = e2 || {}).raw = true, i(t2, e2);
      }, r.gzip = function(t2, e2) {
        return (e2 = e2 || {}).gzip = true, i(t2, e2);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, e, r) {
      var d = t("./zlib/inflate"), c = t("./utils/common"), p = t("./utils/strings"), m = t("./zlib/constants"), i = t("./zlib/messages"), n = t("./zlib/zstream"), s = t("./zlib/gzheader"), _2 = Object.prototype.toString;
      function a(t2) {
        if (!(this instanceof a))
          return new a(t2);
        this.options = c.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t2 || {});
        var e2 = this.options;
        e2.raw && 0 <= e2.windowBits && e2.windowBits < 16 && (e2.windowBits = -e2.windowBits, e2.windowBits === 0 && (e2.windowBits = -15)), !(0 <= e2.windowBits && e2.windowBits < 16) || t2 && t2.windowBits || (e2.windowBits += 32), 15 < e2.windowBits && e2.windowBits < 48 && (15 & e2.windowBits) == 0 && (e2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;
        var r2 = d.inflateInit2(this.strm, e2.windowBits);
        if (r2 !== m.Z_OK)
          throw new Error(i[r2]);
        this.header = new s(), d.inflateGetHeader(this.strm, this.header);
      }
      function o(t2, e2) {
        var r2 = new a(e2);
        if (r2.push(t2, true), r2.err)
          throw r2.msg || i[r2.err];
        return r2.result;
      }
      a.prototype.push = function(t2, e2) {
        var r2, i2, n2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
        if (this.ended)
          return false;
        i2 = e2 === ~~e2 ? e2 : e2 === true ? m.Z_FINISH : m.Z_NO_FLUSH, typeof t2 == "string" ? h.input = p.binstring2buf(t2) : _2.call(t2) === "[object ArrayBuffer]" ? h.input = new Uint8Array(t2) : h.input = t2, h.next_in = 0, h.avail_in = h.input.length;
        do {
          if (h.avail_out === 0 && (h.output = new c.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = d.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = typeof l == "string" ? p.string2buf(l) : _2.call(l) === "[object ArrayBuffer]" ? new Uint8Array(l) : l, r2 = d.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && f === true && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
            return this.onEnd(r2), !(this.ended = true);
          h.next_out && (h.avail_out !== 0 && r2 !== m.Z_STREAM_END && (h.avail_in !== 0 || i2 !== m.Z_FINISH && i2 !== m.Z_SYNC_FLUSH) || (this.options.to === "string" ? (n2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - n2, a2 = p.buf2string(h.output, n2), h.next_out = s2, h.avail_out = u - s2, s2 && c.arraySet(h.output, h.output, n2, s2, 0), this.onData(a2)) : this.onData(c.shrinkBuf(h.output, h.next_out)))), h.avail_in === 0 && h.avail_out === 0 && (f = true);
        } while ((0 < h.avail_in || h.avail_out === 0) && r2 !== m.Z_STREAM_END);
        return r2 === m.Z_STREAM_END && (i2 = m.Z_FINISH), i2 === m.Z_FINISH ? (r2 = d.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : i2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
      }, a.prototype.onData = function(t2) {
        this.chunks.push(t2);
      }, a.prototype.onEnd = function(t2) {
        t2 === m.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = c.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
      }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(t2, e2) {
        return (e2 = e2 || {}).raw = true, o(t2, e2);
      }, r.ungzip = o;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, e, r) {
      var i = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
      r.assign = function(t2) {
        for (var e2 = Array.prototype.slice.call(arguments, 1); e2.length; ) {
          var r2 = e2.shift();
          if (r2) {
            if (typeof r2 != "object")
              throw new TypeError(r2 + "must be non-object");
            for (var i2 in r2)
              r2.hasOwnProperty(i2) && (t2[i2] = r2[i2]);
          }
        }
        return t2;
      }, r.shrinkBuf = function(t2, e2) {
        return t2.length === e2 ? t2 : t2.subarray ? t2.subarray(0, e2) : (t2.length = e2, t2);
      };
      var n = { arraySet: function(t2, e2, r2, i2, n2) {
        if (e2.subarray && t2.subarray)
          t2.set(e2.subarray(r2, r2 + i2), n2);
        else
          for (var s2 = 0; s2 < i2; s2++)
            t2[n2 + s2] = e2[r2 + s2];
      }, flattenChunks: function(t2) {
        var e2, r2, i2, n2, s2, a;
        for (e2 = i2 = 0, r2 = t2.length; e2 < r2; e2++)
          i2 += t2[e2].length;
        for (a = new Uint8Array(i2), e2 = n2 = 0, r2 = t2.length; e2 < r2; e2++)
          s2 = t2[e2], a.set(s2, n2), n2 += s2.length;
        return a;
      } }, s = { arraySet: function(t2, e2, r2, i2, n2) {
        for (var s2 = 0; s2 < i2; s2++)
          t2[n2 + s2] = e2[r2 + s2];
      }, flattenChunks: function(t2) {
        return [].concat.apply([], t2);
      } };
      r.setTyped = function(t2) {
        t2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, n)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(i);
    }, {}], 42: [function(t, e, r) {
      var h = t("./common"), n = true, s = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (t2) {
        n = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (t2) {
        s = false;
      }
      for (var u = new h.Buf8(256), i = 0; i < 256; i++)
        u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
      function l(t2, e2) {
        if (e2 < 65537 && (t2.subarray && s || !t2.subarray && n))
          return String.fromCharCode.apply(null, h.shrinkBuf(t2, e2));
        for (var r2 = "", i2 = 0; i2 < e2; i2++)
          r2 += String.fromCharCode(t2[i2]);
        return r2;
      }
      u[254] = u[254] = 1, r.string2buf = function(t2) {
        var e2, r2, i2, n2, s2, a = t2.length, o = 0;
        for (n2 = 0; n2 < a; n2++)
          (64512 & (r2 = t2.charCodeAt(n2))) == 55296 && n2 + 1 < a && (64512 & (i2 = t2.charCodeAt(n2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (e2 = new h.Buf8(o), n2 = s2 = 0; s2 < o; n2++)
          (64512 & (r2 = t2.charCodeAt(n2))) == 55296 && n2 + 1 < a && (64512 & (i2 = t2.charCodeAt(n2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), r2 < 128 ? e2[s2++] = r2 : (r2 < 2048 ? e2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? e2[s2++] = 224 | r2 >>> 12 : (e2[s2++] = 240 | r2 >>> 18, e2[s2++] = 128 | r2 >>> 12 & 63), e2[s2++] = 128 | r2 >>> 6 & 63), e2[s2++] = 128 | 63 & r2);
        return e2;
      }, r.buf2binstring = function(t2) {
        return l(t2, t2.length);
      }, r.binstring2buf = function(t2) {
        for (var e2 = new h.Buf8(t2.length), r2 = 0, i2 = e2.length; r2 < i2; r2++)
          e2[r2] = t2.charCodeAt(r2);
        return e2;
      }, r.buf2string = function(t2, e2) {
        var r2, i2, n2, s2, a = e2 || t2.length, o = new Array(2 * a);
        for (r2 = i2 = 0; r2 < a; )
          if ((n2 = t2[r2++]) < 128)
            o[i2++] = n2;
          else if (4 < (s2 = u[n2]))
            o[i2++] = 65533, r2 += s2 - 1;
          else {
            for (n2 &= s2 === 2 ? 31 : s2 === 3 ? 15 : 7; 1 < s2 && r2 < a; )
              n2 = n2 << 6 | 63 & t2[r2++], s2--;
            1 < s2 ? o[i2++] = 65533 : n2 < 65536 ? o[i2++] = n2 : (n2 -= 65536, o[i2++] = 55296 | n2 >> 10 & 1023, o[i2++] = 56320 | 1023 & n2);
          }
        return l(o, i2);
      }, r.utf8border = function(t2, e2) {
        var r2;
        for ((e2 = e2 || t2.length) > t2.length && (e2 = t2.length), r2 = e2 - 1; 0 <= r2 && (192 & t2[r2]) == 128; )
          r2--;
        return r2 < 0 ? e2 : r2 === 0 ? e2 : r2 + u[t2[r2]] > e2 ? r2 : e2;
      };
    }, { "./common": 41 }], 43: [function(t, e, r) {
      e.exports = function(t2, e2, r2, i) {
        for (var n = 65535 & t2 | 0, s = t2 >>> 16 & 65535 | 0, a = 0; r2 !== 0; ) {
          for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (n = n + e2[i++] | 0) | 0, --a; )
            ;
          n %= 65521, s %= 65521;
        }
        return n | s << 16 | 0;
      };
    }, {}], 44: [function(t, e, r) {
      e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(t, e, r) {
      var o = function() {
        for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
          t2 = r2;
          for (var i = 0; i < 8; i++)
            t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
          e2[r2] = t2;
        }
        return e2;
      }();
      e.exports = function(t2, e2, r2, i) {
        var n = o, s = i + r2;
        t2 ^= -1;
        for (var a = i; a < s; a++)
          t2 = t2 >>> 8 ^ n[255 & (t2 ^ e2[a])];
        return -1 ^ t2;
      };
    }, {}], 46: [function(t, e, r) {
      var h, d = t("../utils/common"), u = t("./trees"), c = t("./adler32"), p = t("./crc32"), i = t("./messages"), l = 0, f = 4, m = 0, _2 = -2, g = -1, b = 4, n = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
      function R(t2, e2) {
        return t2.msg = i[e2], e2;
      }
      function T(t2) {
        return (t2 << 1) - (4 < t2 ? 9 : 0);
      }
      function D(t2) {
        for (var e2 = t2.length; 0 <= --e2; )
          t2[e2] = 0;
      }
      function F(t2) {
        var e2 = t2.state, r2 = e2.pending;
        r2 > t2.avail_out && (r2 = t2.avail_out), r2 !== 0 && (d.arraySet(t2.output, e2.pending_buf, e2.pending_out, r2, t2.next_out), t2.next_out += r2, e2.pending_out += r2, t2.total_out += r2, t2.avail_out -= r2, e2.pending -= r2, e2.pending === 0 && (e2.pending_out = 0));
      }
      function N(t2, e2) {
        u._tr_flush_block(t2, 0 <= t2.block_start ? t2.block_start : -1, t2.strstart - t2.block_start, e2), t2.block_start = t2.strstart, F(t2.strm);
      }
      function U(t2, e2) {
        t2.pending_buf[t2.pending++] = e2;
      }
      function P(t2, e2) {
        t2.pending_buf[t2.pending++] = e2 >>> 8 & 255, t2.pending_buf[t2.pending++] = 255 & e2;
      }
      function L(t2, e2) {
        var r2, i2, n2 = t2.max_chain_length, s2 = t2.strstart, a2 = t2.prev_length, o2 = t2.nice_match, h2 = t2.strstart > t2.w_size - z ? t2.strstart - (t2.w_size - z) : 0, u2 = t2.window, l2 = t2.w_mask, f2 = t2.prev, d2 = t2.strstart + S, c2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
        t2.prev_length >= t2.good_match && (n2 >>= 2), o2 > t2.lookahead && (o2 = t2.lookahead);
        do {
          if (u2[(r2 = e2) + a2] === p2 && u2[r2 + a2 - 1] === c2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
            s2 += 2, r2++;
            do {
            } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < d2);
            if (i2 = S - (d2 - s2), s2 = d2 - S, a2 < i2) {
              if (t2.match_start = e2, o2 <= (a2 = i2))
                break;
              c2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            }
          }
        } while ((e2 = f2[e2 & l2]) > h2 && --n2 != 0);
        return a2 <= t2.lookahead ? a2 : t2.lookahead;
      }
      function j(t2) {
        var e2, r2, i2, n2, s2, a2, o2, h2, u2, l2, f2 = t2.w_size;
        do {
          if (n2 = t2.window_size - t2.lookahead - t2.strstart, t2.strstart >= f2 + (f2 - z)) {
            for (d.arraySet(t2.window, t2.window, f2, f2, 0), t2.match_start -= f2, t2.strstart -= f2, t2.block_start -= f2, e2 = r2 = t2.hash_size; i2 = t2.head[--e2], t2.head[e2] = f2 <= i2 ? i2 - f2 : 0, --r2; )
              ;
            for (e2 = r2 = f2; i2 = t2.prev[--e2], t2.prev[e2] = f2 <= i2 ? i2 - f2 : 0, --r2; )
              ;
            n2 += f2;
          }
          if (t2.strm.avail_in === 0)
            break;
          if (a2 = t2.strm, o2 = t2.window, h2 = t2.strstart + t2.lookahead, u2 = n2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = l2 === 0 ? 0 : (a2.avail_in -= l2, d.arraySet(o2, a2.input, a2.next_in, l2, h2), a2.state.wrap === 1 ? a2.adler = c(a2.adler, o2, l2, h2) : a2.state.wrap === 2 && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), t2.lookahead += r2, t2.lookahead + t2.insert >= x)
            for (s2 = t2.strstart - t2.insert, t2.ins_h = t2.window[s2], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[s2 + 1]) & t2.hash_mask; t2.insert && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[s2 + x - 1]) & t2.hash_mask, t2.prev[s2 & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = s2, s2++, t2.insert--, !(t2.lookahead + t2.insert < x)); )
              ;
        } while (t2.lookahead < z && t2.strm.avail_in !== 0);
      }
      function Z(t2, e2) {
        for (var r2, i2; ; ) {
          if (t2.lookahead < z) {
            if (j(t2), t2.lookahead < z && e2 === l)
              return A;
            if (t2.lookahead === 0)
              break;
          }
          if (r2 = 0, t2.lookahead >= x && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), r2 !== 0 && t2.strstart - r2 <= t2.w_size - z && (t2.match_length = L(t2, r2)), t2.match_length >= x)
            if (i2 = u._tr_tally(t2, t2.strstart - t2.match_start, t2.match_length - x), t2.lookahead -= t2.match_length, t2.match_length <= t2.max_lazy_match && t2.lookahead >= x) {
              for (t2.match_length--; t2.strstart++, t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart, --t2.match_length != 0; )
                ;
              t2.strstart++;
            } else
              t2.strstart += t2.match_length, t2.match_length = 0, t2.ins_h = t2.window[t2.strstart], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 1]) & t2.hash_mask;
          else
            i2 = u._tr_tally(t2, 0, t2.window[t2.strstart]), t2.lookahead--, t2.strstart++;
          if (i2 && (N(t2, false), t2.strm.avail_out === 0))
            return A;
        }
        return t2.insert = t2.strstart < x - 1 ? t2.strstart : x - 1, e2 === f ? (N(t2, true), t2.strm.avail_out === 0 ? O : B) : t2.last_lit && (N(t2, false), t2.strm.avail_out === 0) ? A : I;
      }
      function W(t2, e2) {
        for (var r2, i2, n2; ; ) {
          if (t2.lookahead < z) {
            if (j(t2), t2.lookahead < z && e2 === l)
              return A;
            if (t2.lookahead === 0)
              break;
          }
          if (r2 = 0, t2.lookahead >= x && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), t2.prev_length = t2.match_length, t2.prev_match = t2.match_start, t2.match_length = x - 1, r2 !== 0 && t2.prev_length < t2.max_lazy_match && t2.strstart - r2 <= t2.w_size - z && (t2.match_length = L(t2, r2), t2.match_length <= 5 && (t2.strategy === 1 || t2.match_length === x && 4096 < t2.strstart - t2.match_start) && (t2.match_length = x - 1)), t2.prev_length >= x && t2.match_length <= t2.prev_length) {
            for (n2 = t2.strstart + t2.lookahead - x, i2 = u._tr_tally(t2, t2.strstart - 1 - t2.prev_match, t2.prev_length - x), t2.lookahead -= t2.prev_length - 1, t2.prev_length -= 2; ++t2.strstart <= n2 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), --t2.prev_length != 0; )
              ;
            if (t2.match_available = 0, t2.match_length = x - 1, t2.strstart++, i2 && (N(t2, false), t2.strm.avail_out === 0))
              return A;
          } else if (t2.match_available) {
            if ((i2 = u._tr_tally(t2, 0, t2.window[t2.strstart - 1])) && N(t2, false), t2.strstart++, t2.lookahead--, t2.strm.avail_out === 0)
              return A;
          } else
            t2.match_available = 1, t2.strstart++, t2.lookahead--;
        }
        return t2.match_available && (i2 = u._tr_tally(t2, 0, t2.window[t2.strstart - 1]), t2.match_available = 0), t2.insert = t2.strstart < x - 1 ? t2.strstart : x - 1, e2 === f ? (N(t2, true), t2.strm.avail_out === 0 ? O : B) : t2.last_lit && (N(t2, false), t2.strm.avail_out === 0) ? A : I;
      }
      function M(t2, e2, r2, i2, n2) {
        this.good_length = t2, this.max_lazy = e2, this.nice_length = r2, this.max_chain = i2, this.func = n2;
      }
      function H() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new d.Buf16(2 * w), this.dyn_dtree = new d.Buf16(2 * (2 * a + 1)), this.bl_tree = new d.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new d.Buf16(k + 1), this.heap = new d.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new d.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G(t2) {
        var e2;
        return t2 && t2.state ? (t2.total_in = t2.total_out = 0, t2.data_type = n, (e2 = t2.state).pending = 0, e2.pending_out = 0, e2.wrap < 0 && (e2.wrap = -e2.wrap), e2.status = e2.wrap ? C : E, t2.adler = e2.wrap === 2 ? 0 : 1, e2.last_flush = l, u._tr_init(e2), m) : R(t2, _2);
      }
      function K(t2) {
        var e2 = G(t2);
        return e2 === m && function(t3) {
          t3.window_size = 2 * t3.w_size, D(t3.head), t3.max_lazy_match = h[t3.level].max_lazy, t3.good_match = h[t3.level].good_length, t3.nice_match = h[t3.level].nice_length, t3.max_chain_length = h[t3.level].max_chain, t3.strstart = 0, t3.block_start = 0, t3.lookahead = 0, t3.insert = 0, t3.match_length = t3.prev_length = x - 1, t3.match_available = 0, t3.ins_h = 0;
        }(t2.state), e2;
      }
      function Y(t2, e2, r2, i2, n2, s2) {
        if (!t2)
          return _2;
        var a2 = 1;
        if (e2 === g && (e2 = 6), i2 < 0 ? (a2 = 0, i2 = -i2) : 15 < i2 && (a2 = 2, i2 -= 16), n2 < 1 || y < n2 || r2 !== v || i2 < 8 || 15 < i2 || e2 < 0 || 9 < e2 || s2 < 0 || b < s2)
          return R(t2, _2);
        i2 === 8 && (i2 = 9);
        var o2 = new H();
        return (t2.state = o2).strm = t2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = i2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = n2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new d.Buf8(2 * o2.w_size), o2.head = new d.Buf16(o2.hash_size), o2.prev = new d.Buf16(o2.w_size), o2.lit_bufsize = 1 << n2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new d.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = e2, o2.strategy = s2, o2.method = r2, K(t2);
      }
      h = [new M(0, 0, 0, 0, function(t2, e2) {
        var r2 = 65535;
        for (r2 > t2.pending_buf_size - 5 && (r2 = t2.pending_buf_size - 5); ; ) {
          if (t2.lookahead <= 1) {
            if (j(t2), t2.lookahead === 0 && e2 === l)
              return A;
            if (t2.lookahead === 0)
              break;
          }
          t2.strstart += t2.lookahead, t2.lookahead = 0;
          var i2 = t2.block_start + r2;
          if ((t2.strstart === 0 || t2.strstart >= i2) && (t2.lookahead = t2.strstart - i2, t2.strstart = i2, N(t2, false), t2.strm.avail_out === 0))
            return A;
          if (t2.strstart - t2.block_start >= t2.w_size - z && (N(t2, false), t2.strm.avail_out === 0))
            return A;
        }
        return t2.insert = 0, e2 === f ? (N(t2, true), t2.strm.avail_out === 0 ? O : B) : (t2.strstart > t2.block_start && (N(t2, false), t2.strm.avail_out), A);
      }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(t2, e2) {
        return Y(t2, e2, v, 15, 8, 0);
      }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(t2, e2) {
        return t2 && t2.state ? t2.state.wrap !== 2 ? _2 : (t2.state.gzhead = e2, m) : _2;
      }, r.deflate = function(t2, e2) {
        var r2, i2, n2, s2;
        if (!t2 || !t2.state || 5 < e2 || e2 < 0)
          return t2 ? R(t2, _2) : _2;
        if (i2 = t2.state, !t2.output || !t2.input && t2.avail_in !== 0 || i2.status === 666 && e2 !== f)
          return R(t2, t2.avail_out === 0 ? -5 : _2);
        if (i2.strm = t2, r2 = i2.last_flush, i2.last_flush = e2, i2.status === C)
          if (i2.wrap === 2)
            t2.adler = 0, U(i2, 31), U(i2, 139), U(i2, 8), i2.gzhead ? (U(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), U(i2, 255 & i2.gzhead.time), U(i2, i2.gzhead.time >> 8 & 255), U(i2, i2.gzhead.time >> 16 & 255), U(i2, i2.gzhead.time >> 24 & 255), U(i2, i2.level === 9 ? 2 : 2 <= i2.strategy || i2.level < 2 ? 4 : 0), U(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (U(i2, 255 & i2.gzhead.extra.length), U(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69) : (U(i2, 0), U(i2, 0), U(i2, 0), U(i2, 0), U(i2, 0), U(i2, i2.level === 9 ? 2 : 2 <= i2.strategy || i2.level < 2 ? 4 : 0), U(i2, 3), i2.status = E);
          else {
            var a2 = v + (i2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= i2.strategy || i2.level < 2 ? 0 : i2.level < 6 ? 1 : i2.level === 6 ? 2 : 3) << 6, i2.strstart !== 0 && (a2 |= 32), a2 += 31 - a2 % 31, i2.status = E, P(i2, a2), i2.strstart !== 0 && (P(i2, t2.adler >>> 16), P(i2, 65535 & t2.adler)), t2.adler = 1;
          }
        if (i2.status === 69)
          if (i2.gzhead.extra) {
            for (n2 = i2.pending; i2.gzindex < (65535 & i2.gzhead.extra.length) && (i2.pending !== i2.pending_buf_size || (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending !== i2.pending_buf_size)); )
              U(i2, 255 & i2.gzhead.extra[i2.gzindex]), i2.gzindex++;
            i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), i2.gzindex === i2.gzhead.extra.length && (i2.gzindex = 0, i2.status = 73);
          } else
            i2.status = 73;
        if (i2.status === 73)
          if (i2.gzhead.name) {
            n2 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, U(i2, s2);
            } while (s2 !== 0);
            i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), s2 === 0 && (i2.gzindex = 0, i2.status = 91);
          } else
            i2.status = 91;
        if (i2.status === 91)
          if (i2.gzhead.comment) {
            n2 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, U(i2, s2);
            } while (s2 !== 0);
            i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), s2 === 0 && (i2.status = 103);
          } else
            i2.status = 103;
        if (i2.status === 103 && (i2.gzhead.hcrc ? (i2.pending + 2 > i2.pending_buf_size && F(t2), i2.pending + 2 <= i2.pending_buf_size && (U(i2, 255 & t2.adler), U(i2, t2.adler >> 8 & 255), t2.adler = 0, i2.status = E)) : i2.status = E), i2.pending !== 0) {
          if (F(t2), t2.avail_out === 0)
            return i2.last_flush = -1, m;
        } else if (t2.avail_in === 0 && T(e2) <= T(r2) && e2 !== f)
          return R(t2, -5);
        if (i2.status === 666 && t2.avail_in !== 0)
          return R(t2, -5);
        if (t2.avail_in !== 0 || i2.lookahead !== 0 || e2 !== l && i2.status !== 666) {
          var o2 = i2.strategy === 2 ? function(t3, e3) {
            for (var r3; ; ) {
              if (t3.lookahead === 0 && (j(t3), t3.lookahead === 0)) {
                if (e3 === l)
                  return A;
                break;
              }
              if (t3.match_length = 0, r3 = u._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++, r3 && (N(t3, false), t3.strm.avail_out === 0))
                return A;
            }
            return t3.insert = 0, e3 === f ? (N(t3, true), t3.strm.avail_out === 0 ? O : B) : t3.last_lit && (N(t3, false), t3.strm.avail_out === 0) ? A : I;
          }(i2, e2) : i2.strategy === 3 ? function(t3, e3) {
            for (var r3, i3, n3, s3, a3 = t3.window; ; ) {
              if (t3.lookahead <= S) {
                if (j(t3), t3.lookahead <= S && e3 === l)
                  return A;
                if (t3.lookahead === 0)
                  break;
              }
              if (t3.match_length = 0, t3.lookahead >= x && 0 < t3.strstart && (i3 = a3[n3 = t3.strstart - 1]) === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3]) {
                s3 = t3.strstart + S;
                do {
                } while (i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && n3 < s3);
                t3.match_length = S - (s3 - n3), t3.match_length > t3.lookahead && (t3.match_length = t3.lookahead);
              }
              if (t3.match_length >= x ? (r3 = u._tr_tally(t3, 1, t3.match_length - x), t3.lookahead -= t3.match_length, t3.strstart += t3.match_length, t3.match_length = 0) : (r3 = u._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++), r3 && (N(t3, false), t3.strm.avail_out === 0))
                return A;
            }
            return t3.insert = 0, e3 === f ? (N(t3, true), t3.strm.avail_out === 0 ? O : B) : t3.last_lit && (N(t3, false), t3.strm.avail_out === 0) ? A : I;
          }(i2, e2) : h[i2.level].func(i2, e2);
          if (o2 !== O && o2 !== B || (i2.status = 666), o2 === A || o2 === O)
            return t2.avail_out === 0 && (i2.last_flush = -1), m;
          if (o2 === I && (e2 === 1 ? u._tr_align(i2) : e2 !== 5 && (u._tr_stored_block(i2, 0, 0, false), e2 === 3 && (D(i2.head), i2.lookahead === 0 && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), F(t2), t2.avail_out === 0))
            return i2.last_flush = -1, m;
        }
        return e2 !== f ? m : i2.wrap <= 0 ? 1 : (i2.wrap === 2 ? (U(i2, 255 & t2.adler), U(i2, t2.adler >> 8 & 255), U(i2, t2.adler >> 16 & 255), U(i2, t2.adler >> 24 & 255), U(i2, 255 & t2.total_in), U(i2, t2.total_in >> 8 & 255), U(i2, t2.total_in >> 16 & 255), U(i2, t2.total_in >> 24 & 255)) : (P(i2, t2.adler >>> 16), P(i2, 65535 & t2.adler)), F(t2), 0 < i2.wrap && (i2.wrap = -i2.wrap), i2.pending !== 0 ? m : 1);
      }, r.deflateEnd = function(t2) {
        var e2;
        return t2 && t2.state ? (e2 = t2.state.status) !== C && e2 !== 69 && e2 !== 73 && e2 !== 91 && e2 !== 103 && e2 !== E && e2 !== 666 ? R(t2, _2) : (t2.state = null, e2 === E ? R(t2, -3) : m) : _2;
      }, r.deflateSetDictionary = function(t2, e2) {
        var r2, i2, n2, s2, a2, o2, h2, u2, l2 = e2.length;
        if (!t2 || !t2.state)
          return _2;
        if ((s2 = (r2 = t2.state).wrap) === 2 || s2 === 1 && r2.status !== C || r2.lookahead)
          return _2;
        for (s2 === 1 && (t2.adler = c(t2.adler, e2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (s2 === 0 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new d.Buf8(r2.w_size), d.arraySet(u2, e2, l2 - r2.w_size, r2.w_size, 0), e2 = u2, l2 = r2.w_size), a2 = t2.avail_in, o2 = t2.next_in, h2 = t2.input, t2.avail_in = l2, t2.next_in = 0, t2.input = e2, j(r2); r2.lookahead >= x; ) {
          for (i2 = r2.strstart, n2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[i2 + x - 1]) & r2.hash_mask, r2.prev[i2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = i2, i2++, --n2; )
            ;
          r2.strstart = i2, r2.lookahead = x - 1, j(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, t2.next_in = o2, t2.input = h2, t2.avail_in = a2, r2.wrap = s2, m;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, e, r) {
      e.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(t, e, r) {
      e.exports = function(t2, e2) {
        var r2, i, n, s, a, o, h, u, l, f, d, c, p, m, _2, g, b, v, y, w, k, x, S, z, C;
        r2 = t2.state, i = t2.next_in, z = t2.input, n = i + (t2.avail_in - 5), s = t2.next_out, C = t2.output, a = s - (e2 - t2.avail_out), o = s + (t2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, d = r2.window, c = r2.hold, p = r2.bits, m = r2.lencode, _2 = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
        t:
          do {
            p < 15 && (c += z[i++] << p, p += 8, c += z[i++] << p, p += 8), v = m[c & g];
            e:
              for (; ; ) {
                if (c >>>= y = v >>> 24, p -= y, (y = v >>> 16 & 255) === 0)
                  C[s++] = 65535 & v;
                else {
                  if (!(16 & y)) {
                    if ((64 & y) == 0) {
                      v = m[(65535 & v) + (c & (1 << y) - 1)];
                      continue e;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break t;
                    }
                    t2.msg = "invalid literal/length code", r2.mode = 30;
                    break t;
                  }
                  w = 65535 & v, (y &= 15) && (p < y && (c += z[i++] << p, p += 8), w += c & (1 << y) - 1, c >>>= y, p -= y), p < 15 && (c += z[i++] << p, p += 8, c += z[i++] << p, p += 8), v = _2[c & b];
                  r:
                    for (; ; ) {
                      if (c >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                        if ((64 & y) == 0) {
                          v = _2[(65535 & v) + (c & (1 << y) - 1)];
                          continue r;
                        }
                        t2.msg = "invalid distance code", r2.mode = 30;
                        break t;
                      }
                      if (k = 65535 & v, p < (y &= 15) && (c += z[i++] << p, (p += 8) < y && (c += z[i++] << p, p += 8)), h < (k += c & (1 << y) - 1)) {
                        t2.msg = "invalid distance too far back", r2.mode = 30;
                        break t;
                      }
                      if (c >>>= y, p -= y, (y = s - a) < k) {
                        if (l < (y = k - y) && r2.sane) {
                          t2.msg = "invalid distance too far back", r2.mode = 30;
                          break t;
                        }
                        if (S = d, (x = 0) === f) {
                          if (x += u - y, y < w) {
                            for (w -= y; C[s++] = d[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                        } else if (f < y) {
                          if (x += u + f - y, (y -= f) < w) {
                            for (w -= y; C[s++] = d[x++], --y; )
                              ;
                            if (x = 0, f < w) {
                              for (w -= y = f; C[s++] = d[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          }
                        } else if (x += f - y, y < w) {
                          for (w -= y; C[s++] = d[x++], --y; )
                            ;
                          x = s - k, S = C;
                        }
                        for (; 2 < w; )
                          C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                        w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                      } else {
                        for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                          ;
                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (i < n && s < o);
        i -= w = p >> 3, c &= (1 << (p -= w << 3)) - 1, t2.next_in = i, t2.next_out = s, t2.avail_in = i < n ? n - i + 5 : 5 - (i - n), t2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = c, r2.bits = p;
      };
    }, {}], 49: [function(t, e, r) {
      var I = t("../utils/common"), O = t("./adler32"), B = t("./crc32"), R = t("./inffast"), T = t("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, i = 852, n = 592;
      function L(t2) {
        return (t2 >>> 24 & 255) + (t2 >>> 8 & 65280) + ((65280 & t2) << 8) + ((255 & t2) << 24);
      }
      function s() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a(t2) {
        var e2;
        return t2 && t2.state ? (e2 = t2.state, t2.total_in = t2.total_out = e2.total = 0, t2.msg = "", e2.wrap && (t2.adler = 1 & e2.wrap), e2.mode = P, e2.last = 0, e2.havedict = 0, e2.dmax = 32768, e2.head = null, e2.hold = 0, e2.bits = 0, e2.lencode = e2.lendyn = new I.Buf32(i), e2.distcode = e2.distdyn = new I.Buf32(n), e2.sane = 1, e2.back = -1, N) : U;
      }
      function o(t2) {
        var e2;
        return t2 && t2.state ? ((e2 = t2.state).wsize = 0, e2.whave = 0, e2.wnext = 0, a(t2)) : U;
      }
      function h(t2, e2) {
        var r2, i2;
        return t2 && t2.state ? (i2 = t2.state, e2 < 0 ? (r2 = 0, e2 = -e2) : (r2 = 1 + (e2 >> 4), e2 < 48 && (e2 &= 15)), e2 && (e2 < 8 || 15 < e2) ? U : (i2.window !== null && i2.wbits !== e2 && (i2.window = null), i2.wrap = r2, i2.wbits = e2, o(t2))) : U;
      }
      function u(t2, e2) {
        var r2, i2;
        return t2 ? (i2 = new s(), (t2.state = i2).window = null, (r2 = h(t2, e2)) !== N && (t2.state = null), r2) : U;
      }
      var l, f, d = true;
      function j(t2) {
        if (d) {
          var e2;
          for (l = new I.Buf32(512), f = new I.Buf32(32), e2 = 0; e2 < 144; )
            t2.lens[e2++] = 8;
          for (; e2 < 256; )
            t2.lens[e2++] = 9;
          for (; e2 < 280; )
            t2.lens[e2++] = 7;
          for (; e2 < 288; )
            t2.lens[e2++] = 8;
          for (T(D, t2.lens, 0, 288, l, 0, t2.work, { bits: 9 }), e2 = 0; e2 < 32; )
            t2.lens[e2++] = 5;
          T(F, t2.lens, 0, 32, f, 0, t2.work, { bits: 5 }), d = false;
        }
        t2.lencode = l, t2.lenbits = 9, t2.distcode = f, t2.distbits = 5;
      }
      function Z(t2, e2, r2, i2) {
        var n2, s2 = t2.state;
        return s2.window === null && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), i2 >= s2.wsize ? (I.arraySet(s2.window, e2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (i2 < (n2 = s2.wsize - s2.wnext) && (n2 = i2), I.arraySet(s2.window, e2, r2 - i2, n2, s2.wnext), (i2 -= n2) ? (I.arraySet(s2.window, e2, r2 - i2, i2, 0), s2.wnext = i2, s2.whave = s2.wsize) : (s2.wnext += n2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += n2))), 0;
      }
      r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(t2) {
        return u(t2, 15);
      }, r.inflateInit2 = u, r.inflate = function(t2, e2) {
        var r2, i2, n2, s2, a2, o2, h2, u2, l2, f2, d2, c, p, m, _2, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!t2 || !t2.state || !t2.output || !t2.input && t2.avail_in !== 0)
          return U;
        (r2 = t2.state).mode === 12 && (r2.mode = 13), a2 = t2.next_out, n2 = t2.output, h2 = t2.avail_out, s2 = t2.next_in, i2 = t2.input, o2 = t2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, d2 = h2, x = N;
        t:
          for (; ; )
            switch (r2.mode) {
              case P:
                if (r2.wrap === 0) {
                  r2.mode = 13;
                  break;
                }
                for (; l2 < 16; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (2 & r2.wrap && u2 === 35615) {
                  E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  t2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if ((15 & u2) != 8) {
                  t2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), r2.wbits === 0)
                  r2.wbits = k;
                else if (k > r2.wbits) {
                  t2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k, t2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                break;
              case 2:
                for (; l2 < 16; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (r2.flags = u2, (255 & r2.flags) != 8) {
                  t2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  t2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l2 < 32; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l2 < 16; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (c = r2.length) && (c = o2), c && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, i2, s2, c, k)), 512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, r2.length -= c), r2.length))
                  break t;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (o2 === 0)
                    break t;
                  for (c = 0; k = i2[s2 + c++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && c < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, k)
                    break t;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (o2 === 0)
                    break t;
                  for (c = 0; k = i2[s2 + c++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && c < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, k)
                    break t;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    t2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), t2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l2 < 32; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                t2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
              case 11:
                if (r2.havedict === 0)
                  return t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                t2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (e2 === 5 || e2 === 6)
                  break t;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                  break;
                }
                for (; l2 < 3; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j(r2), r2.mode = 20, e2 !== 6)
                      break;
                    u2 >>>= 2, l2 -= 2;
                    break t;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    t2.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l2 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  t2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, e2 === 6)
                  break t;
              case 15:
                r2.mode = 16;
              case 16:
                if (c = r2.length) {
                  if (o2 < c && (c = o2), h2 < c && (c = h2), c === 0)
                    break t;
                  I.arraySet(n2, i2, s2, c, a2), o2 -= c, s2 += c, h2 -= c, a2 += c, r2.length -= c;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l2 < 14; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  t2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l2 < 3; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                }
                for (; r2.have < 19; )
                  r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  t2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  if (b < 16)
                    u2 >>>= _2, l2 -= _2, r2.lens[r2.have++] = b;
                  else {
                    if (b === 16) {
                      for (z = _2 + 2; l2 < z; ) {
                        if (o2 === 0)
                          break t;
                        o2--, u2 += i2[s2++] << l2, l2 += 8;
                      }
                      if (u2 >>>= _2, l2 -= _2, r2.have === 0) {
                        t2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k = r2.lens[r2.have - 1], c = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                    } else if (b === 17) {
                      for (z = _2 + 3; l2 < z; ) {
                        if (o2 === 0)
                          break t;
                        o2--, u2 += i2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _2, k = 0, c = 3 + (7 & (u2 >>>= _2)), u2 >>>= 3, l2 -= 3;
                    } else {
                      for (z = _2 + 7; l2 < z; ) {
                        if (o2 === 0)
                          break t;
                        o2--, u2 += i2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _2, k = 0, c = 11 + (127 & (u2 >>>= _2)), u2 >>>= 7, l2 -= 7;
                    }
                    if (r2.have + c > r2.nlen + r2.ndist) {
                      t2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; c--; )
                      r2.lens[r2.have++] = k;
                  }
                }
                if (r2.mode === 30)
                  break;
                if (r2.lens[256] === 0) {
                  t2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  t2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                  t2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, e2 === 6)
                  break t;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(t2, d2), a2 = t2.next_out, n2 = t2.output, h2 = t2.avail_out, s2 = t2.next_in, i2 = t2.input, o2 = t2.avail_in, u2 = r2.hold, l2 = r2.bits, r2.mode === 12 && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l2); ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (g && (240 & g) == 0) {
                  for (v = _2, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_2 = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _2, l2 -= _2, r2.back += _2, r2.length = b, g === 0) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  t2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l2); ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if ((240 & g) == 0) {
                  for (v = _2, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_2 = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _2, l2 -= _2, r2.back += _2, 64 & g) {
                  t2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  t2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (h2 === 0)
                  break t;
                if (c = d2 - h2, r2.offset > c) {
                  if ((c = r2.offset - c) > r2.whave && r2.sane) {
                    t2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p = c > r2.wnext ? (c -= r2.wnext, r2.wsize - c) : r2.wnext - c, c > r2.length && (c = r2.length), m = r2.window;
                } else
                  m = n2, p = a2 - r2.offset, c = r2.length;
                for (h2 < c && (c = h2), h2 -= c, r2.length -= c; n2[a2++] = m[p++], --c; )
                  ;
                r2.length === 0 && (r2.mode = 21);
                break;
              case 26:
                if (h2 === 0)
                  break t;
                n2[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l2 < 32; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 |= i2[s2++] << l2, l2 += 8;
                  }
                  if (d2 -= h2, t2.total_out += d2, r2.total += d2, d2 && (t2.adler = r2.check = r2.flags ? B(r2.check, n2, d2, a2 - d2) : O(r2.check, n2, d2, a2 - d2)), d2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                    t2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l2 < 32; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    t2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x = 1;
                break t;
              case 30:
                x = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return U;
            }
        return t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || d2 !== t2.avail_out && r2.mode < 30 && (r2.mode < 27 || e2 !== 4)) && Z(t2, t2.output, t2.next_out, d2 - t2.avail_out) ? (r2.mode = 31, -4) : (f2 -= t2.avail_in, d2 -= t2.avail_out, t2.total_in += f2, t2.total_out += d2, r2.total += d2, r2.wrap && d2 && (t2.adler = r2.check = r2.flags ? B(r2.check, n2, d2, t2.next_out - d2) : O(r2.check, n2, d2, t2.next_out - d2)), t2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (f2 == 0 && d2 === 0 || e2 === 4) && x === N && (x = -5), x);
      }, r.inflateEnd = function(t2) {
        if (!t2 || !t2.state)
          return U;
        var e2 = t2.state;
        return e2.window && (e2.window = null), t2.state = null, N;
      }, r.inflateGetHeader = function(t2, e2) {
        var r2;
        return t2 && t2.state ? (2 & (r2 = t2.state).wrap) == 0 ? U : ((r2.head = e2).done = false, N) : U;
      }, r.inflateSetDictionary = function(t2, e2) {
        var r2, i2 = e2.length;
        return t2 && t2.state ? (r2 = t2.state).wrap !== 0 && r2.mode !== 11 ? U : r2.mode === 11 && O(1, e2, i2, 0) !== r2.check ? -3 : Z(t2, e2, i2, i2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, e, r) {
      var D = t("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      e.exports = function(t2, e2, r2, i, n, s, a, o) {
        var h, u, l, f, d, c, p, m, _2, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
        for (b = 0; b <= 15; b++)
          O[b] = 0;
        for (v = 0; v < i; v++)
          O[e2[r2 + v]]++;
        for (k = g, w = 15; 1 <= w && O[w] === 0; w--)
          ;
        if (w < k && (k = w), w === 0)
          return n[s++] = 20971520, n[s++] = 20971520, o.bits = 1, 0;
        for (y = 1; y < w && O[y] === 0; y++)
          ;
        for (k < y && (k = y), b = z = 1; b <= 15; b++)
          if (z <<= 1, (z -= O[b]) < 0)
            return -1;
        if (0 < z && (t2 === 0 || w !== 1))
          return -1;
        for (B[1] = 0, b = 1; b < 15; b++)
          B[b + 1] = B[b] + O[b];
        for (v = 0; v < i; v++)
          e2[r2 + v] !== 0 && (a[B[e2[r2 + v]]++] = v);
        if (c = t2 === 0 ? (A = R = a, 19) : t2 === 1 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, d = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, t2 === 1 && 852 < C || t2 === 2 && 592 < C)
          return 1;
        for (; ; ) {
          for (p = b - S, _2 = a[v] < c ? (m = 0, a[v]) : a[v] > c ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; n[d + (E >> S) + (u -= h)] = p << 24 | m << 16 | _2 | 0, u !== 0; )
            ;
          for (h = 1 << b - 1; E & h; )
            h >>= 1;
          if (h !== 0 ? (E &= h - 1, E += h) : E = 0, v++, --O[b] == 0) {
            if (b === w)
              break;
            b = e2[r2 + a[v]];
          }
          if (k < b && (E & f) !== l) {
            for (S === 0 && (S = k), d += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
              x++, z <<= 1;
            if (C += 1 << x, t2 === 1 && 852 < C || t2 === 2 && 592 < C)
              return 1;
            n[l = E & f] = k << 24 | x << 16 | d - s | 0;
          }
        }
        return E !== 0 && (n[d + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(t, e, r) {
      e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(t, e, r) {
      var n = t("../utils/common"), o = 0, h = 1;
      function i(t2) {
        for (var e2 = t2.length; 0 <= --e2; )
          t2[e2] = 0;
      }
      var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, d = 19, _2 = 2 * l + 1, g = 15, c = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
      i(z);
      var C = new Array(2 * f);
      i(C);
      var E = new Array(512);
      i(E);
      var A = new Array(256);
      i(A);
      var I = new Array(a);
      i(I);
      var O, B, R, T = new Array(f);
      function D(t2, e2, r2, i2, n2) {
        this.static_tree = t2, this.extra_bits = e2, this.extra_base = r2, this.elems = i2, this.max_length = n2, this.has_stree = t2 && t2.length;
      }
      function F(t2, e2) {
        this.dyn_tree = t2, this.max_code = 0, this.stat_desc = e2;
      }
      function N(t2) {
        return t2 < 256 ? E[t2] : E[256 + (t2 >>> 7)];
      }
      function U(t2, e2) {
        t2.pending_buf[t2.pending++] = 255 & e2, t2.pending_buf[t2.pending++] = e2 >>> 8 & 255;
      }
      function P(t2, e2, r2) {
        t2.bi_valid > c - r2 ? (t2.bi_buf |= e2 << t2.bi_valid & 65535, U(t2, t2.bi_buf), t2.bi_buf = e2 >> c - t2.bi_valid, t2.bi_valid += r2 - c) : (t2.bi_buf |= e2 << t2.bi_valid & 65535, t2.bi_valid += r2);
      }
      function L(t2, e2, r2) {
        P(t2, r2[2 * e2], r2[2 * e2 + 1]);
      }
      function j(t2, e2) {
        for (var r2 = 0; r2 |= 1 & t2, t2 >>>= 1, r2 <<= 1, 0 < --e2; )
          ;
        return r2 >>> 1;
      }
      function Z(t2, e2, r2) {
        var i2, n2, s2 = new Array(g + 1), a2 = 0;
        for (i2 = 1; i2 <= g; i2++)
          s2[i2] = a2 = a2 + r2[i2 - 1] << 1;
        for (n2 = 0; n2 <= e2; n2++) {
          var o2 = t2[2 * n2 + 1];
          o2 !== 0 && (t2[2 * n2] = j(s2[o2]++, o2));
        }
      }
      function W(t2) {
        var e2;
        for (e2 = 0; e2 < l; e2++)
          t2.dyn_ltree[2 * e2] = 0;
        for (e2 = 0; e2 < f; e2++)
          t2.dyn_dtree[2 * e2] = 0;
        for (e2 = 0; e2 < d; e2++)
          t2.bl_tree[2 * e2] = 0;
        t2.dyn_ltree[2 * m] = 1, t2.opt_len = t2.static_len = 0, t2.last_lit = t2.matches = 0;
      }
      function M(t2) {
        8 < t2.bi_valid ? U(t2, t2.bi_buf) : 0 < t2.bi_valid && (t2.pending_buf[t2.pending++] = t2.bi_buf), t2.bi_buf = 0, t2.bi_valid = 0;
      }
      function H(t2, e2, r2, i2) {
        var n2 = 2 * e2, s2 = 2 * r2;
        return t2[n2] < t2[s2] || t2[n2] === t2[s2] && i2[e2] <= i2[r2];
      }
      function G(t2, e2, r2) {
        for (var i2 = t2.heap[r2], n2 = r2 << 1; n2 <= t2.heap_len && (n2 < t2.heap_len && H(e2, t2.heap[n2 + 1], t2.heap[n2], t2.depth) && n2++, !H(e2, i2, t2.heap[n2], t2.depth)); )
          t2.heap[r2] = t2.heap[n2], r2 = n2, n2 <<= 1;
        t2.heap[r2] = i2;
      }
      function K(t2, e2, r2) {
        var i2, n2, s2, a2, o2 = 0;
        if (t2.last_lit !== 0)
          for (; i2 = t2.pending_buf[t2.d_buf + 2 * o2] << 8 | t2.pending_buf[t2.d_buf + 2 * o2 + 1], n2 = t2.pending_buf[t2.l_buf + o2], o2++, i2 === 0 ? L(t2, n2, e2) : (L(t2, (s2 = A[n2]) + u + 1, e2), (a2 = w[s2]) !== 0 && P(t2, n2 -= I[s2], a2), L(t2, s2 = N(--i2), r2), (a2 = k[s2]) !== 0 && P(t2, i2 -= T[s2], a2)), o2 < t2.last_lit; )
            ;
        L(t2, m, e2);
      }
      function Y(t2, e2) {
        var r2, i2, n2, s2 = e2.dyn_tree, a2 = e2.stat_desc.static_tree, o2 = e2.stat_desc.has_stree, h2 = e2.stat_desc.elems, u2 = -1;
        for (t2.heap_len = 0, t2.heap_max = _2, r2 = 0; r2 < h2; r2++)
          s2[2 * r2] !== 0 ? (t2.heap[++t2.heap_len] = u2 = r2, t2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
        for (; t2.heap_len < 2; )
          s2[2 * (n2 = t2.heap[++t2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, t2.depth[n2] = 0, t2.opt_len--, o2 && (t2.static_len -= a2[2 * n2 + 1]);
        for (e2.max_code = u2, r2 = t2.heap_len >> 1; 1 <= r2; r2--)
          G(t2, s2, r2);
        for (n2 = h2; r2 = t2.heap[1], t2.heap[1] = t2.heap[t2.heap_len--], G(t2, s2, 1), i2 = t2.heap[1], t2.heap[--t2.heap_max] = r2, t2.heap[--t2.heap_max] = i2, s2[2 * n2] = s2[2 * r2] + s2[2 * i2], t2.depth[n2] = (t2.depth[r2] >= t2.depth[i2] ? t2.depth[r2] : t2.depth[i2]) + 1, s2[2 * r2 + 1] = s2[2 * i2 + 1] = n2, t2.heap[1] = n2++, G(t2, s2, 1), 2 <= t2.heap_len; )
          ;
        t2.heap[--t2.heap_max] = t2.heap[1], function(t3, e3) {
          var r3, i3, n3, s3, a3, o3, h3 = e3.dyn_tree, u3 = e3.max_code, l2 = e3.stat_desc.static_tree, f2 = e3.stat_desc.has_stree, d2 = e3.stat_desc.extra_bits, c2 = e3.stat_desc.extra_base, p2 = e3.stat_desc.max_length, m2 = 0;
          for (s3 = 0; s3 <= g; s3++)
            t3.bl_count[s3] = 0;
          for (h3[2 * t3.heap[t3.heap_max] + 1] = 0, r3 = t3.heap_max + 1; r3 < _2; r3++)
            p2 < (s3 = h3[2 * h3[2 * (i3 = t3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * i3 + 1] = s3, u3 < i3 || (t3.bl_count[s3]++, a3 = 0, c2 <= i3 && (a3 = d2[i3 - c2]), o3 = h3[2 * i3], t3.opt_len += o3 * (s3 + a3), f2 && (t3.static_len += o3 * (l2[2 * i3 + 1] + a3)));
          if (m2 !== 0) {
            do {
              for (s3 = p2 - 1; t3.bl_count[s3] === 0; )
                s3--;
              t3.bl_count[s3]--, t3.bl_count[s3 + 1] += 2, t3.bl_count[p2]--, m2 -= 2;
            } while (0 < m2);
            for (s3 = p2; s3 !== 0; s3--)
              for (i3 = t3.bl_count[s3]; i3 !== 0; )
                u3 < (n3 = t3.heap[--r3]) || (h3[2 * n3 + 1] !== s3 && (t3.opt_len += (s3 - h3[2 * n3 + 1]) * h3[2 * n3], h3[2 * n3 + 1] = s3), i3--);
          }
        }(t2, e2), Z(s2, u2, t2.bl_count);
      }
      function X(t2, e2, r2) {
        var i2, n2, s2 = -1, a2 = e2[1], o2 = 0, h2 = 7, u2 = 4;
        for (a2 === 0 && (h2 = 138, u2 = 3), e2[2 * (r2 + 1) + 1] = 65535, i2 = 0; i2 <= r2; i2++)
          n2 = a2, a2 = e2[2 * (i2 + 1) + 1], ++o2 < h2 && n2 === a2 || (o2 < u2 ? t2.bl_tree[2 * n2] += o2 : n2 !== 0 ? (n2 !== s2 && t2.bl_tree[2 * n2]++, t2.bl_tree[2 * b]++) : o2 <= 10 ? t2.bl_tree[2 * v]++ : t2.bl_tree[2 * y]++, s2 = n2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : n2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
      }
      function V(t2, e2, r2) {
        var i2, n2, s2 = -1, a2 = e2[1], o2 = 0, h2 = 7, u2 = 4;
        for (a2 === 0 && (h2 = 138, u2 = 3), i2 = 0; i2 <= r2; i2++)
          if (n2 = a2, a2 = e2[2 * (i2 + 1) + 1], !(++o2 < h2 && n2 === a2)) {
            if (o2 < u2)
              for (; L(t2, n2, t2.bl_tree), --o2 != 0; )
                ;
            else
              n2 !== 0 ? (n2 !== s2 && (L(t2, n2, t2.bl_tree), o2--), L(t2, b, t2.bl_tree), P(t2, o2 - 3, 2)) : o2 <= 10 ? (L(t2, v, t2.bl_tree), P(t2, o2 - 3, 3)) : (L(t2, y, t2.bl_tree), P(t2, o2 - 11, 7));
            s2 = n2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : n2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
      }
      i(T);
      var q = false;
      function J(t2, e2, r2, i2) {
        P(t2, (s << 1) + (i2 ? 1 : 0), 3), function(t3, e3, r3, i3) {
          M(t3), i3 && (U(t3, r3), U(t3, ~r3)), n.arraySet(t3.pending_buf, t3.window, e3, r3, t3.pending), t3.pending += r3;
        }(t2, e2, r2, true);
      }
      r._tr_init = function(t2) {
        q || (function() {
          var t3, e2, r2, i2, n2, s2 = new Array(g + 1);
          for (i2 = r2 = 0; i2 < a - 1; i2++)
            for (I[i2] = r2, t3 = 0; t3 < 1 << w[i2]; t3++)
              A[r2++] = i2;
          for (A[r2 - 1] = i2, i2 = n2 = 0; i2 < 16; i2++)
            for (T[i2] = n2, t3 = 0; t3 < 1 << k[i2]; t3++)
              E[n2++] = i2;
          for (n2 >>= 7; i2 < f; i2++)
            for (T[i2] = n2 << 7, t3 = 0; t3 < 1 << k[i2] - 7; t3++)
              E[256 + n2++] = i2;
          for (e2 = 0; e2 <= g; e2++)
            s2[e2] = 0;
          for (t3 = 0; t3 <= 143; )
            z[2 * t3 + 1] = 8, t3++, s2[8]++;
          for (; t3 <= 255; )
            z[2 * t3 + 1] = 9, t3++, s2[9]++;
          for (; t3 <= 279; )
            z[2 * t3 + 1] = 7, t3++, s2[7]++;
          for (; t3 <= 287; )
            z[2 * t3 + 1] = 8, t3++, s2[8]++;
          for (Z(z, l + 1, s2), t3 = 0; t3 < f; t3++)
            C[2 * t3 + 1] = 5, C[2 * t3] = j(t3, 5);
          O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, d, p);
        }(), q = true), t2.l_desc = new F(t2.dyn_ltree, O), t2.d_desc = new F(t2.dyn_dtree, B), t2.bl_desc = new F(t2.bl_tree, R), t2.bi_buf = 0, t2.bi_valid = 0, W(t2);
      }, r._tr_stored_block = J, r._tr_flush_block = function(t2, e2, r2, i2) {
        var n2, s2, a2 = 0;
        0 < t2.level ? (t2.strm.data_type === 2 && (t2.strm.data_type = function(t3) {
          var e3, r3 = 4093624447;
          for (e3 = 0; e3 <= 31; e3++, r3 >>>= 1)
            if (1 & r3 && t3.dyn_ltree[2 * e3] !== 0)
              return o;
          if (t3.dyn_ltree[18] !== 0 || t3.dyn_ltree[20] !== 0 || t3.dyn_ltree[26] !== 0)
            return h;
          for (e3 = 32; e3 < u; e3++)
            if (t3.dyn_ltree[2 * e3] !== 0)
              return h;
          return o;
        }(t2)), Y(t2, t2.l_desc), Y(t2, t2.d_desc), a2 = function(t3) {
          var e3;
          for (X(t3, t3.dyn_ltree, t3.l_desc.max_code), X(t3, t3.dyn_dtree, t3.d_desc.max_code), Y(t3, t3.bl_desc), e3 = d - 1; 3 <= e3 && t3.bl_tree[2 * S[e3] + 1] === 0; e3--)
            ;
          return t3.opt_len += 3 * (e3 + 1) + 5 + 5 + 4, e3;
        }(t2), n2 = t2.opt_len + 3 + 7 >>> 3, (s2 = t2.static_len + 3 + 7 >>> 3) <= n2 && (n2 = s2)) : n2 = s2 = r2 + 5, r2 + 4 <= n2 && e2 !== -1 ? J(t2, e2, r2, i2) : t2.strategy === 4 || s2 === n2 ? (P(t2, 2 + (i2 ? 1 : 0), 3), K(t2, z, C)) : (P(t2, 4 + (i2 ? 1 : 0), 3), function(t3, e3, r3, i3) {
          var n3;
          for (P(t3, e3 - 257, 5), P(t3, r3 - 1, 5), P(t3, i3 - 4, 4), n3 = 0; n3 < i3; n3++)
            P(t3, t3.bl_tree[2 * S[n3] + 1], 3);
          V(t3, t3.dyn_ltree, e3 - 1), V(t3, t3.dyn_dtree, r3 - 1);
        }(t2, t2.l_desc.max_code + 1, t2.d_desc.max_code + 1, a2 + 1), K(t2, t2.dyn_ltree, t2.dyn_dtree)), W(t2), i2 && M(t2);
      }, r._tr_tally = function(t2, e2, r2) {
        return t2.pending_buf[t2.d_buf + 2 * t2.last_lit] = e2 >>> 8 & 255, t2.pending_buf[t2.d_buf + 2 * t2.last_lit + 1] = 255 & e2, t2.pending_buf[t2.l_buf + t2.last_lit] = 255 & r2, t2.last_lit++, e2 === 0 ? t2.dyn_ltree[2 * r2]++ : (t2.matches++, e2--, t2.dyn_ltree[2 * (A[r2] + u + 1)]++, t2.dyn_dtree[2 * N(e2)]++), t2.last_lit === t2.lit_bufsize - 1;
      }, r._tr_align = function(t2) {
        P(t2, 2, 3), L(t2, m, z), function(t3) {
          t3.bi_valid === 16 ? (U(t3, t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0) : 8 <= t3.bi_valid && (t3.pending_buf[t3.pending++] = 255 & t3.bi_buf, t3.bi_buf >>= 8, t3.bi_valid -= 8);
        }(t2);
      };
    }, { "../utils/common": 41 }], 53: [function(t, e, r) {
      e.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(t, e, r) {
      e.exports = typeof setImmediate == "function" ? setImmediate : function() {
        var t2 = [].slice.apply(arguments);
        t2.splice(1, 0, 0), setTimeout.apply(null, t2);
      };
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var JSZip = jszip_min.exports;
var ARABIC_ZERO_CODE = 1632;
var DEFINED_NUMBER_FORMTATS = {
  thousands: "#,##0{0},&quot;K&quot;",
  millions: "#,##0{0},,&quot;M&quot;",
  billions: "#,##0{0},,,&quot;B&quot;",
  trillions: "#,##0{0},,,,&quot;T&quot;",
  percent: "0{0}%",
  decimal: "#{0}",
  fixedpoint: "#,##0{0}",
  exponential: "0{0}E+00",
  currency: " "
};
var PERIOD_REGEXP = /a+/g;
var DAY_REGEXP = /E/g;
var DO_REGEXP = /dE+/g;
var STANDALONE_MONTH_REGEXP = /L/g;
var HOUR_REGEXP = /h/g;
var ANY_REGEXP = /./g;
var excelFormatConverter = {
  _applyPrecision: function(format2, precision) {
    var result;
    var i;
    if (precision > 0) {
      result = format2 !== "decimal" ? "." : "";
      for (i = 0; i < precision; i++) {
        result += "0";
      }
      return result;
    }
    return "";
  },
  _hasArabicDigits: function(text) {
    var code;
    for (var i = 0; i < text.length; i++) {
      code = text.charCodeAt(i);
      if (code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10) {
        return true;
      }
    }
    return false;
  },
  _convertDateFormatToOpenXml: function(format2) {
    return format2.split("/").join("\\/").split("'").map(function(datePart, index2) {
      if (index2 % 2 === 0) {
        return datePart.replace(PERIOD_REGEXP, "AM/PM").replace(DO_REGEXP, "d").replace(DAY_REGEXP, "d").replace(STANDALONE_MONTH_REGEXP, "M").replace(HOUR_REGEXP, "H").split("[").join("\\[").split("]").join("\\]");
      }
      if (datePart) {
        return datePart.replace(ANY_REGEXP, "\\$&");
      }
      return "'";
    }).join("");
  },
  _convertDateFormat: function(format2) {
    var formattedValue = (dateLocalization.format(new Date(2009, 8, 8, 6, 5, 4), format2) || "").toString();
    var result = getFormat((value2) => dateLocalization.format(value2, format2));
    if (result) {
      result = this._convertDateFormatToOpenXml(result);
      result = this._getLanguageInfo(formattedValue) + result;
    }
    return result;
  },
  _getLanguageInfo: function(defaultPattern) {
    var languageID = getLanguageId();
    var languageIDStr = languageID ? languageID.toString(16) : "";
    var languageInfo = "";
    if (this._hasArabicDigits(defaultPattern)) {
      while (languageIDStr.length < 3) {
        languageIDStr = "0" + languageIDStr;
      }
      languageInfo = "[$-2010" + languageIDStr + "]";
    } else if (languageIDStr) {
      languageInfo = "[$-" + languageIDStr + "]";
    }
    return languageInfo;
  },
  _convertNumberFormat: function(format$1, precision, currency) {
    var result;
    var excelFormat;
    if (format$1 === "currency") {
      excelFormat = numberLocalization.getOpenXmlCurrencyFormat(currency);
    } else {
      excelFormat = DEFINED_NUMBER_FORMTATS[format$1.toLowerCase()];
    }
    if (excelFormat) {
      result = format(excelFormat, this._applyPrecision(format$1, precision));
    }
    return result;
  },
  convertFormat: function(format2, precision, type2, currency) {
    if (isDefined(format2)) {
      if (type2 === "date") {
        return excelFormatConverter._convertDateFormat(format2);
      } else if (isString$1(format2) && DEFINED_NUMBER_FORMTATS[format2.toLowerCase()]) {
        return excelFormatConverter._convertNumberFormat(format2, precision, currency);
      }
    }
  }
};
var tagHelper = {
  toXml: function(tagName, attributes, content) {
    var result = ["<", tagName];
    for (var attributeName in attributes) {
      var attributeValue = attributes[attributeName];
      if (isDefined(attributeValue)) {
        result.push(" ", attributeName, '="', attributeValue, '"');
      }
    }
    if (isDefined(content) && content !== "") {
      result.push(">", content, "</", tagName, ">");
    } else {
      result.push(" />");
    }
    return result.join("");
  }
};
var cellAlignmentHelper = {
  tryCreateTag: function(sourceObj) {
    var result = null;
    if (isDefined(sourceObj)) {
      result = {
        vertical: sourceObj.vertical,
        wrapText: sourceObj.wrapText,
        horizontal: sourceObj.horizontal
      };
      if (cellAlignmentHelper.isEmpty(result)) {
        result = null;
      }
    }
    return result;
  },
  copy: function(source) {
    var result = null;
    if (isDefined(source)) {
      result = {};
      if (source.horizontal !== void 0) {
        result.horizontal = source.horizontal;
      }
      if (source.vertical !== void 0) {
        result.vertical = source.vertical;
      }
      if (source.wrapText !== void 0) {
        result.wrapText = source.wrapText;
      }
    }
    return result;
  },
  areEqual: function(leftTag, rightTag) {
    return cellAlignmentHelper.isEmpty(leftTag) && cellAlignmentHelper.isEmpty(rightTag) || isDefined(leftTag) && isDefined(rightTag) && leftTag.vertical === rightTag.vertical && leftTag.wrapText === rightTag.wrapText && leftTag.horizontal === rightTag.horizontal;
  },
  isEmpty: function(tag) {
    return !isDefined(tag) || !isDefined(tag.vertical) && !isDefined(tag.wrapText) && !isDefined(tag.horizontal);
  },
  toXml: function(tag) {
    return tagHelper.toXml("alignment", {
      vertical: tag.vertical,
      wrapText: isDefined(tag.wrapText) ? Number(tag.wrapText) : void 0,
      horizontal: tag.horizontal
    });
  }
};
var colorHelper = {
  _tryConvertColor: function(source) {
    if (typeof source !== "string") {
      return source;
    }
    var result;
    if (source.length > 0 && source[0] === "#") {
      var colorCode = source.substr(1, source.length);
      if (colorCode.length === 6) {
        result = "FF" + colorCode;
      } else if (colorCode.length === 8) {
        result = colorCode[6] + colorCode[7] + colorCode.substr(0, 6);
      } else {
        result = colorCode;
      }
    } else {
      result = source;
    }
    return result;
  },
  tryCreateTag: function(sourceObj) {
    var result = null;
    if (isDefined(sourceObj)) {
      if (typeof sourceObj === "string") {
        result = {
          rgb: this._tryConvertColor(sourceObj)
        };
      } else {
        result = {
          rgb: this._tryConvertColor(sourceObj.rgb),
          theme: sourceObj.theme
        };
      }
      if (colorHelper.isEmpty(result)) {
        result = null;
      }
    }
    return result;
  },
  copy: function(source) {
    var result = null;
    if (isDefined(source)) {
      if (typeof source === "string") {
        result = source;
      } else {
        result = {};
        if (source.rgb !== void 0) {
          result.rgb = source.rgb;
        }
        if (source.theme !== void 0) {
          result.theme = source.theme;
        }
      }
    }
    return result;
  },
  isEmpty: function(tag) {
    return !isDefined(tag) || !isDefined(tag.rgb) && !isDefined(tag.theme);
  },
  areEqual: function(leftTag, rightTag) {
    return colorHelper.isEmpty(leftTag) && colorHelper.isEmpty(rightTag) || isDefined(leftTag) && isDefined(rightTag) && leftTag.rgb === rightTag.rgb && leftTag.theme === rightTag.theme;
  },
  toXml: function(tagName, tag) {
    return tagHelper.toXml(tagName, {
      rgb: tag.rgb,
      theme: tag.theme
    });
  }
};
var patternFillHelper = {
  tryCreateTag: function(sourceObj) {
    var result = null;
    if (isDefined(sourceObj)) {
      result = {
        patternType: sourceObj.patternType,
        backgroundColor: colorHelper.tryCreateTag(sourceObj.backgroundColor),
        foregroundColor: colorHelper.tryCreateTag(sourceObj.foregroundColor)
      };
      if (patternFillHelper.isEmpty(result)) {
        result = null;
      }
    }
    return result;
  },
  copy: function(source) {
    var result = null;
    if (isDefined(source)) {
      result = {};
      if (source.patternType !== void 0) {
        result.patternType = source.patternType;
      }
      if (source.backgroundColor !== void 0) {
        result.backgroundColor = colorHelper.copy(source.backgroundColor);
      }
      if (source.foregroundColor !== void 0) {
        result.foregroundColor = colorHelper.copy(source.foregroundColor);
      }
    }
    return result;
  },
  areEqual: function(leftTag, rightTag) {
    return patternFillHelper.isEmpty(leftTag) && patternFillHelper.isEmpty(rightTag) || isDefined(leftTag) && isDefined(rightTag) && leftTag.patternType === rightTag.patternType && colorHelper.areEqual(leftTag.backgroundColor, rightTag.backgroundColor) && colorHelper.areEqual(leftTag.foregroundColor, rightTag.foregroundColor);
  },
  isEmpty: function(tag) {
    return !isDefined(tag) || !isDefined(tag.patternType);
  },
  toXml: function(tag) {
    var content = [isDefined(tag.foregroundColor) ? colorHelper.toXml("fgColor", tag.foregroundColor) : "", isDefined(tag.backgroundColor) ? colorHelper.toXml("bgColor", tag.backgroundColor) : ""].join("");
    return tagHelper.toXml("patternFill", {
      patternType: tag.patternType
    }, content);
  }
};
var fillHelper = {
  tryCreateTag: function(sourceObj) {
    var result = null;
    if (isDefined(sourceObj)) {
      result = {
        patternFill: patternFillHelper.tryCreateTag(sourceObj.patternFill)
      };
      if (fillHelper.isEmpty(result)) {
        result = null;
      }
    }
    return result;
  },
  tryCreateFillFromSimpleFormat: function() {
    var {
      backgroundColor,
      fillPatternType,
      fillPatternColor
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (isDefined(backgroundColor) && !(isDefined(fillPatternType) && isDefined(fillPatternColor))) {
      return {
        patternFill: {
          patternType: "solid",
          foregroundColor: {
            rgb: backgroundColor
          }
        }
      };
    } else if (isDefined(fillPatternType) && isDefined(fillPatternColor)) {
      return {
        patternFill: {
          patternType: fillPatternType,
          foregroundColor: {
            rgb: fillPatternColor
          },
          backgroundColor: {
            rgb: backgroundColor
          }
        }
      };
    }
  },
  copySimpleFormat: function(source, target) {
    if (source.backgroundColor !== void 0) {
      target.backgroundColor = source.backgroundColor;
    }
    if (source.fillPatternType !== void 0) {
      target.fillPatternType = source.fillPatternType;
    }
    if (source.fillPatternColor !== void 0) {
      target.fillPatternColor = source.fillPatternColor;
    }
  },
  copy: function(source) {
    var result = null;
    if (isDefined(source)) {
      result = {};
      if (source.patternFill !== void 0) {
        result.patternFill = patternFillHelper.copy(source.patternFill);
      }
    }
    return result;
  },
  areEqual: function(leftTag, rightTag) {
    return fillHelper.isEmpty(leftTag) && fillHelper.isEmpty(rightTag) || isDefined(leftTag) && isDefined(rightTag) && patternFillHelper.areEqual(leftTag.patternFill, rightTag.patternFill);
  },
  isEmpty: function(tag) {
    return !isDefined(tag) || patternFillHelper.isEmpty(tag.patternFill);
  },
  toXml: function(tag) {
    return tagHelper.toXml("fill", {}, patternFillHelper.toXml(tag.patternFill));
  }
};
var fontHelper = {
  tryCreateTag: function(sourceObj) {
    var result = null;
    if (isDefined(sourceObj)) {
      result = {
        size: sourceObj.size,
        name: sourceObj.name,
        family: sourceObj.family,
        scheme: sourceObj.scheme,
        bold: sourceObj.bold,
        italic: sourceObj.italic,
        underline: sourceObj.underline,
        color: colorHelper.tryCreateTag(sourceObj.color)
      };
      if (fontHelper.isEmpty(result)) {
        result = null;
      }
    }
    return result;
  },
  copy: function(source) {
    var result = null;
    if (isDefined(source)) {
      result = {};
      if (source.size !== void 0) {
        result.size = source.size;
      }
      if (source.name !== void 0) {
        result.name = source.name;
      }
      if (source.family !== void 0) {
        result.family = source.family;
      }
      if (source.scheme !== void 0) {
        result.scheme = source.scheme;
      }
      if (source.bold !== void 0) {
        result.bold = source.bold;
      }
      if (source.italic !== void 0) {
        result.italic = source.italic;
      }
      if (source.underline !== void 0) {
        result.underline = source.underline;
      }
      if (source.color !== void 0) {
        result.color = colorHelper.copy(source.color);
      }
    }
    return result;
  },
  areEqual: function(leftTag, rightTag) {
    return fontHelper.isEmpty(leftTag) && fontHelper.isEmpty(rightTag) || isDefined(leftTag) && isDefined(rightTag) && leftTag.size === rightTag.size && leftTag.name === rightTag.name && leftTag.family === rightTag.family && leftTag.scheme === rightTag.scheme && (leftTag.bold === rightTag.bold || !leftTag.bold === !rightTag.bold) && (leftTag.italic === rightTag.italic || !leftTag.italic === !rightTag.italic) && leftTag.underline === rightTag.underline && colorHelper.areEqual(leftTag.color, rightTag.color);
  },
  isEmpty: function(tag) {
    return !isDefined(tag) || !isDefined(tag.size) && !isDefined(tag.name) && !isDefined(tag.family) && !isDefined(tag.scheme) && (!isDefined(tag.bold) || !tag.bold) && (!isDefined(tag.italic) || !tag.italic) && !isDefined(tag.underline) && colorHelper.isEmpty(tag.color);
  },
  toXml: function(tag) {
    var content = [isDefined(tag.bold) && tag.bold ? tagHelper.toXml("b", {}) : "", isDefined(tag.size) ? tagHelper.toXml("sz", {
      val: tag.size
    }) : "", isDefined(tag.color) ? colorHelper.toXml("color", tag.color) : "", isDefined(tag.name) ? tagHelper.toXml("name", {
      val: tag.name
    }) : "", isDefined(tag.family) ? tagHelper.toXml("family", {
      val: tag.family
    }) : "", isDefined(tag.scheme) ? tagHelper.toXml("scheme", {
      val: tag.scheme
    }) : "", isDefined(tag.italic) && tag.italic ? tagHelper.toXml("i", {}) : "", isDefined(tag.underline) ? tagHelper.toXml("u", {
      val: tag.underline
    }) : ""].join("");
    return tagHelper.toXml("font", {}, content);
  }
};
var cellFormatHelper = {
  tryCreateTag: function(sourceObj, sharedItemsContainer) {
    var result = null;
    if (isDefined(sourceObj)) {
      var numberFormatId;
      if (typeof sourceObj.numberFormat === "number") {
        numberFormatId = sourceObj.numberFormat;
      } else {
        numberFormatId = sharedItemsContainer.registerNumberFormat(sourceObj.numberFormat);
      }
      var fill = sourceObj.fill;
      if (!isDefined(fill)) {
        fill = fillHelper.tryCreateFillFromSimpleFormat(sourceObj);
      }
      result = {
        numberFormatId,
        alignment: cellAlignmentHelper.tryCreateTag(sourceObj.alignment),
        fontId: sharedItemsContainer.registerFont(sourceObj.font),
        fillId: sharedItemsContainer.registerFill(fill)
      };
      if (cellFormatHelper.isEmpty(result)) {
        result = null;
      }
    }
    return result;
  },
  copy: function(source) {
    var result;
    if (source === null) {
      result = null;
    } else if (isDefined(source)) {
      result = {};
      if (source.numberFormat !== void 0) {
        result.numberFormat = source.numberFormat;
      }
      if (source.fill !== void 0) {
        result.fill = fillHelper.copy(source.fill);
      } else {
        fillHelper.copySimpleFormat(source, result);
      }
      if (source.alignment !== void 0) {
        result.alignment = cellAlignmentHelper.copy(source.alignment);
      }
      if (source.font !== void 0) {
        result.font = fontHelper.copy(source.font);
      }
    }
    return result;
  },
  areEqual: function(leftTag, rightTag) {
    return cellFormatHelper.isEmpty(leftTag) && cellFormatHelper.isEmpty(rightTag) || isDefined(leftTag) && isDefined(rightTag) && leftTag.fontId === rightTag.fontId && leftTag.numberFormatId === rightTag.numberFormatId && leftTag.fillId === rightTag.fillId && cellAlignmentHelper.areEqual(leftTag.alignment, rightTag.alignment);
  },
  isEmpty: function(tag) {
    return !isDefined(tag) || !isDefined(tag.fontId) && !isDefined(tag.numberFormatId) && !isDefined(tag.fillId) && cellAlignmentHelper.isEmpty(tag.alignment);
  },
  toXml: function(tag) {
    var isAlignmentEmpty = cellAlignmentHelper.isEmpty(tag.alignment);
    var applyNumberFormat;
    if (isDefined(tag.numberFormatId)) {
      applyNumberFormat = tag.numberFormatId > 0 ? 1 : 0;
    }
    return tagHelper.toXml("xf", {
      xfId: 0,
      applyAlignment: isAlignmentEmpty ? null : 1,
      fontId: tag.fontId,
      applyNumberFormat,
      fillId: tag.fillId,
      numFmtId: tag.numberFormatId
    }, isAlignmentEmpty ? null : cellAlignmentHelper.toXml(tag.alignment));
  }
};
var numberFormatHelper = {
  ID_PROPERTY_NAME: "id",
  tryCreateTag: function(sourceObj) {
    var result = null;
    if (typeof sourceObj === "string") {
      result = {
        formatCode: sourceObj
      };
      if (numberFormatHelper.isEmpty(result)) {
        result = null;
      }
    }
    return result;
  },
  areEqual: function(leftTag, rightTag) {
    return numberFormatHelper.isEmpty(leftTag) && numberFormatHelper.isEmpty(rightTag) || isDefined(leftTag) && isDefined(rightTag) && leftTag.formatCode === rightTag.formatCode;
  },
  isEmpty: function(tag) {
    return !isDefined(tag) || !isDefined(tag.formatCode) || tag.formatCode === "";
  },
  toXml: function(tag) {
    return tagHelper.toXml("numFmt", {
      numFmtId: tag[numberFormatHelper.ID_PROPERTY_NAME],
      formatCode: tag.formatCode
    });
  }
};
class ExcelFile {
  constructor() {
    this._cellFormatTags = [];
    this._fillTags = [];
    this._fontTags = [];
    this._numberFormatTags = [];
    this._fillTags.push(fillHelper.tryCreateTag({
      patternFill: {
        patternType: "none"
      }
    }));
  }
  registerCellFormat(cellFormat) {
    var result;
    var cellFormatTag = cellFormatHelper.tryCreateTag(cellFormat, {
      registerFill: this.registerFill.bind(this),
      registerFont: this.registerFont.bind(this),
      registerNumberFormat: this.registerNumberFormat.bind(this)
    });
    if (isDefined(cellFormatTag)) {
      for (var i = 0; i < this._cellFormatTags.length; i++) {
        if (cellFormatHelper.areEqual(this._cellFormatTags[i], cellFormatTag)) {
          result = i;
          break;
        }
      }
      if (result === void 0) {
        result = this._cellFormatTags.push(cellFormatTag) - 1;
      }
    }
    return result;
  }
  static copyCellFormat(source) {
    return cellFormatHelper.copy(source);
  }
  generateCellFormatsXml() {
    var cellFormatTagsAsXmlStringsArray = this._cellFormatTags.map((tag) => cellFormatHelper.toXml(tag));
    return tagHelper.toXml("cellXfs", {
      count: cellFormatTagsAsXmlStringsArray.length
    }, cellFormatTagsAsXmlStringsArray.join(""));
  }
  registerFill(fill) {
    var result;
    var fillTag = fillHelper.tryCreateTag(fill);
    if (isDefined(fillTag)) {
      for (var i = 0; i < this._fillTags.length; i++) {
        if (fillHelper.areEqual(this._fillTags[i], fillTag)) {
          result = i;
          break;
        }
      }
      if (result === void 0) {
        if (this._fillTags.length < 2) {
          this._fillTags.push(fillHelper.tryCreateTag({
            patternFill: {
              patternType: "Gray125"
            }
          }));
        }
        result = this._fillTags.push(fillTag) - 1;
      }
    }
    return result;
  }
  generateFillsXml() {
    var tagsAsXmlStringsArray = this._fillTags.map((tag) => fillHelper.toXml(tag));
    return tagHelper.toXml("fills", {
      count: tagsAsXmlStringsArray.length
    }, tagsAsXmlStringsArray.join(""));
  }
  registerFont(font) {
    var result;
    var fontTag = fontHelper.tryCreateTag(font);
    if (isDefined(fontTag)) {
      for (var i = 0; i < this._fontTags.length; i++) {
        if (fontHelper.areEqual(this._fontTags[i], fontTag)) {
          result = i;
          break;
        }
      }
      if (result === void 0) {
        result = this._fontTags.push(fontTag) - 1;
      }
    }
    return result;
  }
  generateFontsXml() {
    var xmlStringsArray = this._fontTags.map((tag) => fontHelper.toXml(tag));
    return tagHelper.toXml("fonts", {
      count: xmlStringsArray.length
    }, xmlStringsArray.join(""));
  }
  _convertNumberFormatIndexToId(index2) {
    return 165 + index2;
  }
  registerNumberFormat(numberFormat) {
    var result;
    var tag = numberFormatHelper.tryCreateTag(numberFormat);
    if (isDefined(tag)) {
      for (var i = 0; i < this._numberFormatTags.length; i++) {
        if (numberFormatHelper.areEqual(this._numberFormatTags[i], tag)) {
          result = this._numberFormatTags[i][numberFormatHelper.ID_PROPERTY_NAME];
          break;
        }
      }
      if (result === void 0) {
        tag[numberFormatHelper.ID_PROPERTY_NAME] = this._convertNumberFormatIndexToId(this._numberFormatTags.length);
        result = tag[numberFormatHelper.ID_PROPERTY_NAME];
        this._numberFormatTags.push(tag);
      }
    }
    return result;
  }
  generateNumberFormatsXml() {
    if (this._numberFormatTags.length > 0) {
      var xmlStringsArray = this._numberFormatTags.map((tag) => numberFormatHelper.toXml(tag));
      return tagHelper.toXml("numFmts", {
        count: xmlStringsArray.length
      }, xmlStringsArray.join(""));
    } else {
      return "";
    }
  }
}
var XML_TAG = '<?xml version="1.0" encoding="utf-8"?>';
var GROUP_SHEET_PR_XML = '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>';
var SINGLE_SHEET_PR_XML = "<sheetPr/>";
var BASE_STYLE_XML2 = '<borders count="1"><border><left style="thin"><color rgb="FFD3D3D3"/></left><right style="thin"><color rgb="FFD3D3D3"/></right><top style="thin"><color rgb="FFD3D3D3"/></top><bottom style="thin"><color rgb="FFD3D3D3"/></bottom></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
var OPEN_XML_FORMAT_URL = "http://schemas.openxmlformats.org";
var RELATIONSHIP_PART_NAME = "rels";
var XL_FOLDER_NAME = "xl";
var WORKBOOK_FILE_NAME = "workbook.xml";
var CONTENTTYPES_FILE_NAME = "[Content_Types].xml";
var SHAREDSTRING_FILE_NAME = "sharedStrings.xml";
var STYLE_FILE_NAME = "styles.xml";
var WORKSHEETS_FOLDER = "worksheets";
var WORKSHEET_FILE_NAME = "sheet1.xml";
var WORKSHEET_HEADER_XML = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">';
var VALID_TYPES = {
  boolean: "b",
  date: "d",
  number: "n",
  string: "s"
};
var EXCEL_START_TIME = Date.UTC(1899, 11, 30);
var DAYS_COUNT_BEFORE_29_FEB_1900 = 60;
var MAX_DIGIT_WIDTH_IN_PIXELS = 7;
var UNSUPPORTED_FORMAT_MAPPING = {
  quarter: "shortDate",
  quarterAndYear: "shortDate",
  minute: "longTime",
  millisecond: "longTime"
};
var ExcelCreator = classImpl.inherit({
  _getXMLTag: function(tagName, attributes, content) {
    var result = "<" + tagName;
    var i;
    var length = attributes.length;
    var attr;
    for (i = 0; i < length; i++) {
      attr = attributes[i];
      if (attr.value !== void 0) {
        result = result + " " + attr.name + '="' + attr.value + '"';
      }
    }
    return isDefined(content) ? result + ">" + content + "</" + tagName + ">" : result + " />";
  },
  _convertToExcelCellRef: function(zeroBasedRowIndex, zeroBasedCellIndex) {
    var columnName = "";
    var charCode;
    var isCellIndexFound;
    while (!isCellIndexFound) {
      charCode = 65 + (zeroBasedCellIndex >= 26 ? zeroBasedCellIndex % 26 : Math.ceil(zeroBasedCellIndex));
      columnName = String.fromCharCode(charCode) + columnName;
      if (zeroBasedCellIndex >= 26) {
        zeroBasedCellIndex = Math.floor(zeroBasedCellIndex / 26) - 1;
      } else {
        isCellIndexFound = true;
      }
    }
    return columnName + (zeroBasedRowIndex + 1);
  },
  _convertToExcelCellRefAndTrackMaxIndex: function(rowIndex, cellIndex) {
    if (this._maxRowIndex < Number(rowIndex)) {
      this._maxRowIndex = Number(rowIndex);
    }
    if (this._maxColumnIndex < Number(cellIndex)) {
      this._maxColumnIndex = Number(cellIndex);
    }
    return this._convertToExcelCellRef(rowIndex, cellIndex);
  },
  _getDataType: function(dataType) {
    return VALID_TYPES[dataType] || VALID_TYPES.string;
  },
  _tryGetExcelCellDataType: function(object) {
    if (isDefined(object)) {
      if (typeof object === "number") {
        if (isFinite(object)) {
          return VALID_TYPES.number;
        } else {
          return VALID_TYPES.string;
        }
      } else if (isString$1(object)) {
        return VALID_TYPES.string;
      } else if (isDate(object)) {
        return VALID_TYPES.number;
      } else if (isBoolean(object)) {
        return VALID_TYPES.boolean;
      }
    }
  },
  _formatObjectConverter: function(format2, dataType) {
    var result = {
      format: format2,
      precision: format2 && format2.precision,
      dataType
    };
    if (isObject$1(format2)) {
      return extend(result, format2, {
        format: format2.formatter || format2.type,
        currency: format2.currency
      });
    }
    return result;
  },
  _tryConvertToExcelNumberFormat: function(format2, dataType) {
    var newFormat = this._formatObjectConverter(format2, dataType);
    format2 = newFormat.format;
    var currency = newFormat.currency;
    dataType = newFormat.dataType;
    if (isDefined(format2) && dataType === "date") {
      format2 = UNSUPPORTED_FORMAT_MAPPING[format2 && format2.type || format2] || format2;
    }
    return excelFormatConverter.convertFormat(format2, newFormat.precision, dataType, currency);
  },
  _appendString: function(value2) {
    if (isDefined(value2)) {
      value2 = String(value2);
      if (value2.length) {
        value2 = encodeHtml(value2);
        if (this._stringHash[value2] === void 0) {
          this._stringHash[value2] = this._stringArray.length;
          this._stringArray.push(value2);
        }
        return this._stringHash[value2];
      }
    }
  },
  _tryGetExcelDateValue: function(date) {
    var days;
    var totalTime;
    if (isDate(date)) {
      days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / 864e5);
      if (days < DAYS_COUNT_BEFORE_29_FEB_1900) {
        days--;
      }
      totalTime = (3600 * date.getHours() + 60 * date.getMinutes() + date.getSeconds()) / 86400;
      return days + totalTime;
    }
  },
  _prepareValue: function(rowIndex, cellIndex) {
    var dataProvider = this._dataProvider;
    var {
      cellSourceData
    } = dataProvider.getCellData(rowIndex, cellIndex) || {};
    var {
      value: value2
    } = dataProvider.getCellData(rowIndex, cellIndex) || {};
    var sourceValue;
    var type2 = this._getDataType(dataProvider.getCellType(rowIndex, cellIndex));
    if (type2 === VALID_TYPES.date && !isDate(value2)) {
      type2 = VALID_TYPES.string;
    }
    switch (type2) {
      case VALID_TYPES.string:
        sourceValue = value2;
        value2 = this._appendString(value2);
        break;
      case VALID_TYPES.date:
        sourceValue = value2;
        value2 = this._tryGetExcelDateValue(value2);
        type2 = VALID_TYPES.number;
    }
    return {
      value: value2,
      type: type2,
      sourceValue,
      cellSourceData
    };
  },
  _callCustomizeExcelCell: function(_ref) {
    var {
      dataProvider,
      value: value2,
      style,
      sourceData
    } = _ref;
    var styleCopy = ExcelFile.copyCellFormat(style);
    var args = {
      value: value2,
      numberFormat: styleCopy.numberFormat,
      clearStyle: function() {
        this.horizontalAlignment = null;
        this.verticalAlignment = null;
        this.wrapTextEnabled = null;
        this.font = null;
        this.numberFormat = null;
      }
    };
    if (isDefined(styleCopy)) {
      if (isDefined(styleCopy.alignment)) {
        args.horizontalAlignment = styleCopy.alignment.horizontal;
        args.verticalAlignment = styleCopy.alignment.vertical;
        args.wrapTextEnabled = styleCopy.alignment.wrapText;
      }
      args.backgroundColor = styleCopy.backgroundColor;
      args.fillPatternType = styleCopy.fillPatternType;
      args.fillPatternColor = styleCopy.fillPatternColor;
      args.font = styleCopy.font;
    }
    dataProvider.customizeExcelCell(args, sourceData);
    var newStyle = styleCopy || {};
    newStyle.font = args.font;
    newStyle.alignment = newStyle.alignment || {};
    newStyle.alignment.horizontal = args.horizontalAlignment;
    newStyle.alignment.vertical = args.verticalAlignment;
    newStyle.alignment.wrapText = args.wrapTextEnabled;
    newStyle.backgroundColor = args.backgroundColor;
    newStyle.fillPatternType = args.fillPatternType;
    newStyle.fillPatternColor = args.fillPatternColor;
    newStyle.numberFormat = args.numberFormat;
    return {
      value: args.value,
      style: newStyle
    };
  },
  _getDataArray: function() {
    var rowIndex;
    var cellIndex;
    var cellsArray;
    var cellData;
    var result = [];
    var dataProvider = this._dataProvider;
    var rowsLength = dataProvider.getRowsCount();
    var columns = dataProvider.getColumns();
    var cellsLength;
    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
      cellsArray = [];
      cellsLength = columns.length;
      for (cellIndex = 0; cellIndex !== cellsLength; cellIndex++) {
        cellData = this._prepareValue(rowIndex, cellIndex);
        var styleArrayIndex = dataProvider.getStyleId(rowIndex, cellIndex);
        var cellStyleId = this._styleArrayIndexToCellStyleIdMap[styleArrayIndex];
        if (dataProvider.hasCustomizeExcelCell && dataProvider.hasCustomizeExcelCell()) {
          var value2 = cellData.sourceValue || cellData.value;
          var modifiedExcelCell = this._callCustomizeExcelCell({
            dataProvider,
            value: value2,
            style: this._styleArray[styleArrayIndex],
            sourceData: cellData.cellSourceData
          });
          if (modifiedExcelCell.value !== value2) {
            if (typeof modifiedExcelCell.value !== typeof value2 || typeof modifiedExcelCell.value === "number" && !isFinite(modifiedExcelCell.value)) {
              var cellDataType = this._tryGetExcelCellDataType(modifiedExcelCell.value);
              if (isDefined(cellDataType)) {
                cellData.type = cellDataType;
              }
            }
            switch (cellData.type) {
              case VALID_TYPES.string:
                cellData.value = this._appendString(modifiedExcelCell.value);
                break;
              case VALID_TYPES.date:
                cellData.value = modifiedExcelCell.value;
                break;
              case VALID_TYPES.number:
                var newValue = modifiedExcelCell.value;
                var excelDateValue = this._tryGetExcelDateValue(newValue);
                if (isDefined(excelDateValue)) {
                  newValue = excelDateValue;
                }
                cellData.value = newValue;
                break;
              default:
                cellData.value = modifiedExcelCell.value;
            }
          }
          cellStyleId = this._excelFile.registerCellFormat(modifiedExcelCell.style);
        }
        cellsArray.push({
          style: cellStyleId,
          value: cellData.value,
          type: cellData.type
        });
      }
      if (!this._needSheetPr && dataProvider.getGroupLevel(rowIndex) > 0) {
        this._needSheetPr = true;
      }
      result.push(cellsArray);
    }
    return result;
  },
  _calculateWidth: function(pixelsWidth) {
    pixelsWidth = parseInt(pixelsWidth, 10);
    if (!pixelsWidth || pixelsWidth < 5) {
      pixelsWidth = 100;
    }
    return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + 0.5) / 100);
  },
  _prepareStyleData: function() {
    var that = this;
    var styles = that._dataProvider.getStyles();
    that._dataProvider.getColumns().forEach(function(column) {
      that._colsArray.push(that._calculateWidth(column.width));
    });
    var fonts = [{
      size: 11,
      color: {
        theme: 1
      },
      name: "Calibri",
      family: 2,
      scheme: "minor",
      bold: false
    }, {
      size: 11,
      color: {
        theme: 1
      },
      name: "Calibri",
      family: 2,
      scheme: "minor",
      bold: true
    }];
    this._excelFile.registerFont(fonts[0]);
    this._excelFile.registerFont(fonts[1]);
    styles.forEach(function(style) {
      var numberFormat = that._tryConvertToExcelNumberFormat(style.format, style.dataType);
      if (!isDefined(numberFormat)) {
        numberFormat = 0;
      }
      that._styleArray.push({
        font: fonts[Number(!!style.bold)],
        numberFormat,
        alignment: {
          vertical: "top",
          wrapText: !!style.wrapText,
          horizontal: style.alignment || "left"
        }
      });
    });
    that._styleArrayIndexToCellStyleIdMap = that._styleArray.map((item) => this._excelFile.registerCellFormat(item));
  },
  _prepareCellData: function() {
    this._cellsArray = this._getDataArray();
  },
  _createXMLRelationships: function(xmlRelationships) {
    return this._getXMLTag("Relationships", [{
      name: "xmlns",
      value: OPEN_XML_FORMAT_URL + "/package/2006/relationships"
    }], xmlRelationships);
  },
  _createXMLRelationship: function(id, type2, target) {
    return this._getXMLTag("Relationship", [{
      name: "Id",
      value: "rId" + id
    }, {
      name: "Type",
      value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships/" + type2
    }, {
      name: "Target",
      value: target
    }]);
  },
  _getWorkbookContent: function() {
    return XML_TAG + this._getXMLTag("workbook", [{
      name: "xmlns:r",
      value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships"
    }, {
      name: "xmlns",
      value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
    }], '<bookViews><workbookView xWindow="0" yWindow="0" windowWidth="0" windowHeight="0"/></bookViews><sheets><sheet name="Sheet" sheetId="1" r:id="rId1" /></sheets><definedNames><definedName name="_xlnm.Print_Titles" localSheetId="0">Sheet!$1:$1</definedName><definedName name="_xlnm._FilterDatabase" hidden="0" localSheetId="0">Sheet!$A$1:$F$6332</definedName></definedNames>');
  },
  _getContentTypesContent: function() {
    return XML_TAG + '<Types xmlns="' + OPEN_XML_FORMAT_URL + '/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" /><Default Extension="xml" ContentType="application/xml" /><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" /><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" /><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" /><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" /></Types>';
  },
  _generateStylesXML: function() {
    var folder = this._zip.folder(XL_FOLDER_NAME);
    var XML = "";
    XML += this._excelFile.generateNumberFormatsXml();
    XML += this._excelFile.generateFontsXml();
    XML += this._excelFile.generateFillsXml();
    XML += BASE_STYLE_XML2;
    XML += this._excelFile.generateCellFormatsXml();
    XML += this._getXMLTag("cellStyles", [{
      name: "count",
      value: 1
    }], this._getXMLTag("cellStyle", [{
      name: "name",
      value: "Normal"
    }, {
      name: "xfId",
      value: 0
    }, {
      name: "builtinId",
      value: 0
    }]));
    XML = XML_TAG + this._getXMLTag("styleSheet", [{
      name: "xmlns",
      value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
    }], XML);
    folder.file(STYLE_FILE_NAME, XML);
    this._styleArray = [];
  },
  _generateStringsXML: function() {
    var folder = this._zip.folder(XL_FOLDER_NAME);
    var stringIndex;
    var stringsLength = this._stringArray.length;
    var sharedStringXml = XML_TAG;
    for (stringIndex = 0; stringIndex < stringsLength; stringIndex++) {
      this._stringArray[stringIndex] = this._getXMLTag("si", [], this._getXMLTag("t", [], this._stringArray[stringIndex]));
    }
    sharedStringXml += this._getXMLTag("sst", [{
      name: "xmlns",
      value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
    }, {
      name: "count",
      value: this._stringArray.length
    }, {
      name: "uniqueCount",
      value: this._stringArray.length
    }], this._stringArray.join(""));
    folder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
    this._stringArray = [];
  },
  _getPaneXML: function() {
    var attributes = [{
      name: "activePane",
      value: "bottomLeft"
    }, {
      name: "state",
      value: "frozen"
    }];
    var frozenArea = this._dataProvider.getFrozenArea();
    if (!(frozenArea.x || frozenArea.y)) {
      return "";
    }
    if (frozenArea.x) {
      attributes.push({
        name: "xSplit",
        value: frozenArea.x
      });
    }
    if (frozenArea.y) {
      attributes.push({
        name: "ySplit",
        value: frozenArea.y
      });
    }
    attributes.push({
      name: "topLeftCell",
      value: this._convertToExcelCellRefAndTrackMaxIndex(frozenArea.y, frozenArea.x)
    });
    return this._getXMLTag("pane", attributes);
  },
  _getAutoFilterXML: function(maxCellIndex) {
    if (this._options.autoFilterEnabled) {
      return '<autoFilter ref="A' + this._dataProvider.getHeaderRowCount() + ":" + maxCellIndex + '" />';
    }
    return "";
  },
  _getIgnoredErrorsXML: function(maxCellIndex) {
    if (this._options.ignoreErrors) {
      return '<ignoredErrors><ignoredError sqref="A1:' + maxCellIndex + '" numberStoredAsText="1" /></ignoredErrors>';
    }
    return "";
  },
  _generateWorksheetXML: function() {
    var colIndex;
    var rowIndex;
    var cellData;
    var xmlCells;
    var xmlRows = [];
    var rowsLength = this._cellsArray.length;
    var cellsLength;
    var colsLength = this._colsArray.length;
    var rSpans = "1:" + colsLength;
    var headerRowCount = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 1;
    var xmlResult = [WORKSHEET_HEADER_XML];
    xmlResult.push(this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML);
    xmlResult.push('<dimension ref="A1:C1"/>');
    xmlResult.push("<sheetViews><sheetView ");
    xmlResult.push(this._rtlEnabled ? 'rightToLeft="1" ' : "");
    xmlResult.push('tabSelected="1" workbookViewId="0">');
    xmlResult.push(this._getPaneXML());
    xmlResult.push("</sheetView></sheetViews>");
    xmlResult.push('<sheetFormatPr defaultRowHeight="15"');
    xmlResult.push(' outlineLevelRow="' + (this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0) + '"');
    xmlResult.push(' x14ac:dyDescent="0.25"/>');
    for (colIndex = 0; colIndex < colsLength; colIndex++) {
      this._colsArray[colIndex] = this._getXMLTag("col", [{
        name: "width",
        value: this._colsArray[colIndex]
      }, {
        name: "min",
        value: Number(colIndex) + 1
      }, {
        name: "max",
        value: Number(colIndex) + 1
      }, {
        name: "customWidth",
        value: 1
      }]);
    }
    xmlResult.push(this._getXMLTag("cols", [], this._colsArray.join("")) + "<sheetData>");
    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
      xmlCells = [];
      cellsLength = this._cellsArray[rowIndex].length;
      for (colIndex = 0; colIndex < cellsLength; colIndex++) {
        rowIndex = Number(rowIndex);
        cellData = this._cellsArray[rowIndex][colIndex];
        xmlCells.push(this._getXMLTag("c", [{
          name: "r",
          value: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex, colIndex)
        }, {
          name: "s",
          value: cellData.style
        }, {
          name: "t",
          value: cellData.type
        }], isDefined(cellData.value) ? this._getXMLTag("v", [], cellData.value) : null));
      }
      xmlRows.push(this._getXMLTag("row", [{
        name: "r",
        value: Number(rowIndex) + 1
      }, {
        name: "spans",
        value: rSpans
      }, {
        name: "outlineLevel",
        value: rowIndex >= headerRowCount ? this._dataProvider.getGroupLevel(rowIndex) : 0
      }, {
        name: "x14ac:dyDescent",
        value: "0.25"
      }], xmlCells.join("")));
      this._cellsArray[rowIndex] = null;
      if (xmlRows.length > 1e4) {
        xmlResult.push(xmlRows.join(""));
        xmlRows = [];
      }
    }
    xmlResult.push(xmlRows.join(""));
    xmlRows = [];
    var rightBottomCellRef = this._convertToExcelCellRef(this._maxRowIndex, this._maxColumnIndex);
    xmlResult.push("</sheetData>" + this._getAutoFilterXML(rightBottomCellRef) + this._generateMergingXML() + this._getIgnoredErrorsXML(rightBottomCellRef) + "</worksheet>");
    this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(""));
    this._colsArray = [];
    this._cellsArray = [];
    xmlResult = [];
  },
  _generateMergingXML: function() {
    var k;
    var l;
    var cellIndex;
    var rowIndex;
    var rowsLength = isDefined(this._dataProvider.getHeaderRowCount) ? this._dataProvider.getHeaderRowCount() : this._dataProvider.getRowsCount();
    var columnsLength = this._dataProvider.getColumns().length;
    var usedArea = [];
    var mergeArray = [];
    var mergeIndex;
    var mergeXML = "";
    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
      for (cellIndex = 0; cellIndex !== columnsLength; cellIndex++) {
        if (!isDefined(usedArea[rowIndex]) || !isDefined(usedArea[rowIndex][cellIndex])) {
          var cellMerge = this._dataProvider.getCellMerging(rowIndex, cellIndex);
          if (cellMerge.colspan || cellMerge.rowspan) {
            mergeArray.push({
              start: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex, cellIndex),
              end: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex + (cellMerge.rowspan || 0), cellIndex + (cellMerge.colspan || 0))
            });
            for (k = rowIndex; k <= rowIndex + cellMerge.rowspan || 0; k++) {
              for (l = cellIndex; l <= cellIndex + cellMerge.colspan || 0; l++) {
                if (!isDefined(usedArea[k])) {
                  usedArea[k] = [];
                }
                usedArea[k][l] = true;
              }
            }
          }
        }
      }
    }
    var mergeArrayLength = mergeArray.length;
    for (mergeIndex = 0; mergeIndex < mergeArrayLength; mergeIndex++) {
      mergeXML += this._getXMLTag("mergeCell", [{
        name: "ref",
        value: mergeArray[mergeIndex].start + ":" + mergeArray[mergeIndex].end
      }]);
    }
    return mergeXML.length ? this._getXMLTag("mergeCells", [{
      name: "count",
      value: mergeArrayLength
    }], mergeXML) : "";
  },
  _generateCommonXML: function() {
    var relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, "officeDocument", "xl/" + WORKBOOK_FILE_NAME));
    var folder = this._zip.folder(XL_FOLDER_NAME);
    var relsXML = XML_TAG;
    this._zip.folder("_" + RELATIONSHIP_PART_NAME).file("." + RELATIONSHIP_PART_NAME, relsFileContent);
    var xmlRelationships = this._createXMLRelationship(1, "worksheet", "worksheets/" + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, "styles", STYLE_FILE_NAME) + this._createXMLRelationship(3, "sharedStrings", SHAREDSTRING_FILE_NAME);
    relsXML += this._createXMLRelationships(xmlRelationships);
    folder.folder("_" + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + ".rels", relsXML);
    folder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());
    this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent());
  },
  _generateContent: function() {
    this._prepareStyleData();
    this._prepareCellData();
    this._generateWorkXML();
    this._generateCommonXML();
  },
  _generateWorkXML: function() {
    this._generateStylesXML();
    this._generateStringsXML();
    this._generateWorksheetXML();
  },
  ctor: function(dataProvider, options) {
    this._rtlEnabled = options && !!options.rtlEnabled;
    this._options = options;
    this._maxRowIndex = 0;
    this._maxColumnIndex = 0;
    this._stringArray = [];
    this._stringHash = {};
    this._styleArray = [];
    this._colsArray = [];
    this._cellsArray = [];
    this._needSheetPr = false;
    this._dataProvider = dataProvider;
    this._excelFile = new ExcelFile();
    if (isDefined(ExcelCreator.JSZip)) {
      this._zip = new ExcelCreator.JSZip();
    } else {
      this._zip = null;
    }
  },
  _checkZipState: function() {
    if (!this._zip) {
      throw errors$1.Error("E1041", "JSZip");
    }
  },
  ready: function() {
    return this._dataProvider.ready();
  },
  getData: function(isBlob) {
    var options = {
      type: isBlob ? "blob" : "base64",
      compression: "DEFLATE",
      mimeType: MIME_TYPES.EXCEL
    };
    var deferred = new Deferred();
    this._checkZipState();
    this._generateContent();
    if (this._zip.generateAsync) {
      this._zip.generateAsync(options).then(deferred.resolve);
    } else {
      deferred.resolve(this._zip.generate(options));
    }
    return deferred;
  }
});
ExcelCreator.JSZip = JSZip;
function getData(data2, options) {
  var excelCreator = new ExcelCreator(data2, options);
  excelCreator._checkZipState();
  return excelCreator.ready().then(() => excelCreator.getData(isFunction$1(getWindow().Blob)));
}
function _export(data2, options, getData2) {
  if (!data2) {
    return new Deferred().resolve();
  }
  var exportingAction = options.exportingAction;
  var exportedAction = options.exportedAction;
  var fileSavingAction = options.fileSavingAction;
  var eventArgs = {
    fileName: options.fileName,
    format: options.format,
    cancel: false
  };
  isFunction$1(exportingAction) && exportingAction(eventArgs);
  if (!eventArgs.cancel) {
    return getData2(data2, options).then((blob) => {
      isFunction$1(exportedAction) && exportedAction();
      if (isFunction$1(fileSavingAction)) {
        eventArgs.data = blob;
        fileSavingAction(eventArgs);
      }
      if (!eventArgs.cancel) {
        fileSaver.saveAs(eventArgs.fileName, options.format, blob, options.proxyUrl, options.forceProxy);
      }
    });
  }
  return new Deferred().resolve();
}
var excel = {
  creator: ExcelCreator,
  getData,
  formatConverter: excelFormatConverter
};
var exportMixin = {
  _getEmptyCell: function() {
    return {
      text: "",
      value: void 0,
      colspan: 1,
      rowspan: 1
    };
  },
  _defaultSetter: function(value2) {
    return !value2 ? 1 : value2;
  },
  _cloneItem: function(item) {
    return extend({}, item, this._getEmptyCell());
  },
  _prepareItems: function(items) {
    var that = this;
    var resultItems = [];
    var cols = (items[0] || []).reduce((sum, item2) => sum + that._defaultSetter(item2.colspan), 0);
    var getItem = function(items2) {
      var rowIndex2 = 0;
      var cellIndex2 = 0;
      return function() {
        var row = items2[rowIndex2] || [];
        var item2 = row[cellIndex2++];
        if (cellIndex2 >= row.length) {
          rowIndex2++;
          cellIndex2 = 0;
        }
        if (item2) {
          item2.colspan = that._defaultSetter(item2.colspan);
          item2.rowspan = that._defaultSetter(item2.rowspan);
        }
        return item2;
      };
    }(items);
    function addItem(rowIndex2, cellIndex2, item2) {
      var row = resultItems[rowIndex2] = resultItems[rowIndex2] || [];
      row[cellIndex2] = item2;
      if (item2.colspan > 1 || item2.rowspan > 1) {
        var clone = that._cloneItem(item2);
        for (var c = 1; c < item2.colspan; c++) {
          addItem(rowIndex2, cellIndex2 + c, clone);
        }
        for (var r = 1; r < item2.rowspan; r++) {
          for (var _c = 0; _c < item2.colspan; _c++) {
            addItem(rowIndex2 + r, cellIndex2 + _c, clone);
          }
        }
      }
    }
    var item = getItem();
    var rowIndex = 0;
    while (item) {
      for (var cellIndex = 0; cellIndex < cols; cellIndex++) {
        if (!item) {
          break;
        }
        if (resultItems[rowIndex] && resultItems[rowIndex][cellIndex]) {
          continue;
        }
        addItem(rowIndex, cellIndex, item);
        cellIndex += item.colspan - 1;
        item = getItem();
      }
      rowIndex++;
    }
    return resultItems;
  }
};
var DEFAULT_DATA_TYPE = "string";
var DEFAUL_COLUMN_WIDTH = 100;
var ExportController = extend({}, exportMixin, {
  exportToExcel: function() {
    _export(this.getDataProvider(), {
      fileName: this.option("export.fileName"),
      proxyUrl: this.option("export.proxyUrl"),
      format: "EXCEL",
      rtlEnabled: this.option("rtlEnabled"),
      ignoreErrors: this.option("export.ignoreExcelErrors"),
      exportingAction: this._actions.onExporting,
      exportedAction: this._actions.onExported,
      fileSavingAction: this._actions.onFileSaving
    }, excel.getData);
  },
  _getLength: function(items) {
    var i;
    var itemCount = items[0].length;
    var cellCount = 0;
    for (i = 0; i < itemCount; i++) {
      cellCount += items[0][i].colspan || 1;
    }
    return cellCount;
  },
  _correctCellsInfoItemLengths: function(cellsInfo, expectedLength) {
    for (var i = 0; i < cellsInfo.length; i++) {
      while (cellsInfo[i].length < expectedLength) {
        cellsInfo[i].push({});
      }
    }
    return cellsInfo;
  },
  _calculateCellInfoItemLength: function(columnsRow) {
    var result = 0;
    for (var columnIndex = 0; columnIndex < columnsRow.length; columnIndex++) {
      result += isDefined(columnsRow[columnIndex].colspan) ? columnsRow[columnIndex].colspan : 1;
    }
    return result;
  },
  _getAllItems: function(columnsInfo, rowsInfoItems, cellsInfo) {
    var cellIndex;
    var rowIndex;
    var correctedCellsInfo = cellsInfo;
    var rowsLength = this._getLength(rowsInfoItems);
    var headerRowsCount = columnsInfo.length;
    if (columnsInfo.length > 0 && columnsInfo[0].length > 0 && cellsInfo.length > 0 && cellsInfo[0].length === 0) {
      var cellInfoItemLength = this._calculateCellInfoItemLength(columnsInfo[0]);
      if (cellInfoItemLength > 0) {
        correctedCellsInfo = this._correctCellsInfoItemLengths(cellsInfo, cellInfoItemLength);
      }
    }
    var sourceItems = columnsInfo.concat(correctedCellsInfo);
    for (rowIndex = 0; rowIndex < rowsInfoItems.length; rowIndex++) {
      for (cellIndex = rowsInfoItems[rowIndex].length - 1; cellIndex >= 0; cellIndex--) {
        if (!isDefined(sourceItems[rowIndex + headerRowsCount])) {
          sourceItems[rowIndex + headerRowsCount] = [];
        }
        sourceItems[rowIndex + headerRowsCount].splice(0, 0, extend({}, rowsInfoItems[rowIndex][cellIndex]));
      }
    }
    sourceItems[0].splice(0, 0, extend({}, this._getEmptyCell(), {
      alignment: getDefaultAlignment(this._options.rtlEnabled),
      colspan: rowsLength,
      rowspan: headerRowsCount
    }));
    return this._prepareItems(sourceItems);
  },
  getDataProvider: function() {
    return new DataProvider(this);
  }
});
var DataProvider = classImpl.inherit({
  ctor: function(exportController) {
    this._exportController = exportController;
  },
  ready: function() {
    this._initOptions();
    var options = this._options;
    return when(options.items).done((items) => {
      var headerSize = items[0][0].rowspan;
      var columns = items[headerSize - 1];
      each(columns, (columnIndex, column) => {
        column.width = DEFAUL_COLUMN_WIDTH;
      });
      options.columns = columns;
      options.items = items;
    });
  },
  _initOptions: function() {
    var exportController = this._exportController;
    var dataController = exportController._dataController;
    var items = new Deferred();
    dataController.beginLoading();
    setTimeout(function() {
      var columnsInfo = extend(true, [], dataController.getColumnsInfo(true));
      var rowsInfoItems = extend(true, [], dataController.getRowsInfo(true));
      var cellsInfo = dataController.getCellsInfo(true);
      items.resolve(exportController._getAllItems(columnsInfo, rowsInfoItems, cellsInfo));
      dataController.endLoading();
    });
    this._options = {
      items,
      rtlEnabled: exportController.option("rtlEnabled"),
      dataFields: exportController.getDataSource().getAreaFields("data"),
      customizeExcelCell: exportController.option("export.customizeExcelCell"),
      rowsArea: exportController._rowsArea,
      columnsArea: exportController._columnsArea
    };
  },
  getColumns: function() {
    return this._options.columns;
  },
  getColumnsWidths: function() {
    var colsArea = this._options.columnsArea;
    var rowsArea = this._options.rowsArea;
    var columns = this._options.columns;
    var useDefaultWidth = !hasWindow$1() || colsArea.option("scrolling.mode") === "virtual" || colsArea.element().is(":hidden");
    return useDefaultWidth ? columns.map((_2) => DEFAUL_COLUMN_WIDTH) : rowsArea.getColumnsWidth().concat(colsArea.getColumnsWidth());
  },
  getRowsCount: function() {
    return this._options.items.length;
  },
  getGroupLevel: function() {
    return 0;
  },
  getCellMerging: function(rowIndex, cellIndex) {
    var items = this._options.items;
    var item = items[rowIndex] && items[rowIndex][cellIndex];
    return item ? {
      colspan: item.colspan - 1,
      rowspan: item.rowspan - 1
    } : {
      colspan: 0,
      rowspan: 0
    };
  },
  getFrozenArea: function() {
    return {
      x: this.getRowAreaColCount(),
      y: this.getColumnAreaRowCount()
    };
  },
  getCellType: function(rowIndex, cellIndex) {
    var style = this.getStyles()[this.getStyleId(rowIndex, cellIndex)];
    return style && style.dataType || "string";
  },
  getCellData: function(rowIndex, cellIndex, isExcelJS) {
    var result = {};
    var items = this._options.items;
    var item = items[rowIndex] && items[rowIndex][cellIndex] || {};
    if (isExcelJS) {
      result.cellSourceData = item;
      var areaName = this._tryGetAreaName(item, rowIndex, cellIndex);
      if (areaName) {
        result.cellSourceData.area = areaName;
      }
      result.cellSourceData.rowIndex = rowIndex;
      result.cellSourceData.columnIndex = cellIndex;
    }
    if (this.getCellType(rowIndex, cellIndex) === "string") {
      result.value = item.text;
    } else {
      result.value = item.value;
    }
    if (result.cellSourceData && result.cellSourceData.isWhiteSpace) {
      result.value = "";
    }
    return result;
  },
  _tryGetAreaName(item, rowIndex, cellIndex) {
    if (this.isColumnAreaCell(rowIndex, cellIndex)) {
      return "column";
    } else if (this.isRowAreaCell(rowIndex, cellIndex)) {
      return "row";
    } else if (isDefined(item.dataIndex)) {
      return "data";
    }
  },
  isRowAreaCell(rowIndex, cellIndex) {
    return rowIndex >= this.getColumnAreaRowCount() && cellIndex < this.getRowAreaColCount();
  },
  isColumnAreaCell(rowIndex, cellIndex) {
    return cellIndex >= this.getRowAreaColCount() && rowIndex < this.getColumnAreaRowCount();
  },
  getColumnAreaRowCount() {
    return this._options.items[0][0].rowspan;
  },
  getRowAreaColCount() {
    return this._options.items[0][0].colspan;
  },
  getHeaderStyles() {
    return [{
      alignment: "center",
      dataType: "string"
    }, {
      alignment: getDefaultAlignment(this._options.rtlEnabled),
      dataType: "string"
    }];
  },
  getDataFieldStyles() {
    var dataFields = this._options.dataFields;
    var dataItemStyle = {
      alignment: this._options.rtlEnabled ? "left" : "right"
    };
    var dataFieldStyles = [];
    if (dataFields.length) {
      dataFields.forEach((dataField) => {
        dataFieldStyles.push(_extends({}, dataItemStyle, {
          format: dataField.format,
          dataType: this.getCellDataType(dataField)
        }));
      });
      return dataFieldStyles;
    }
    return [dataItemStyle];
  },
  getStyles: function() {
    if (this._styles) {
      return this._styles;
    }
    this._styles = [...this.getHeaderStyles(), ...this.getDataFieldStyles()];
    return this._styles;
  },
  getCellDataType: function(field) {
    if (field && field.customizeText) {
      return "string";
    }
    if (field.dataType) {
      return field.dataType;
    }
    if (field.format) {
      if (numberLocalization.parse(formatHelper.format(1, field.format)) === 1) {
        return "number";
      }
      if (formatHelper.format(new Date(), field.format)) {
        return "date";
      }
    }
    return DEFAULT_DATA_TYPE;
  },
  getStyleId: function(rowIndex, cellIndex) {
    var items = this._options.items;
    var item = items[rowIndex] && items[rowIndex][cellIndex] || {};
    if (cellIndex === 0 && rowIndex === 0 || this.isColumnAreaCell(rowIndex, cellIndex)) {
      return 0;
    } else if (this.isRowAreaCell(rowIndex, cellIndex)) {
      return 1;
    }
    return this.getHeaderStyles().length + (item.dataIndex || 0);
  },
  hasCustomizeExcelCell: function() {
    return isDefined(this._options.customizeExcelCell);
  },
  customizeExcelCell: function(e) {
    if (this._options.customizeExcelCell) {
      this._options.customizeExcelCell(e);
    }
  }
});
var FORMAT_DICTIONARY = {
  number: "numeric",
  date: "datetime"
};
var UNBIND_KEY = "dxPivotGridUnbinding";
function getFormattedValue(path, fields) {
  var value2 = [];
  var lastFieldIndex = fields.length - 1;
  each(path, function(i, item) {
    value2.push(item.text || formatValue(item.value, fields[lastFieldIndex - i]));
  });
  return value2.reverse();
}
function getExpandedLevel(node) {
  var level = 0;
  foreachTree(node, function(members) {
    level = Math.max(level, members.length - 1);
  });
  return level;
}
function processDataCell(processCellArgs, processCell) {
  var chartDataItem = processCellArgs.chartDataItem;
  var processedCell = processCell && processCell(processCellArgs);
  if (processedCell) {
    chartDataItem = extend({}, chartDataItem, processedCell.chartDataItem);
    processedCell = extend({}, processCellArgs, processedCell, {
      chartDataItem
    });
    return processedCell;
  }
  return processCellArgs;
}
function createChartDataSource(pivotGridDataSource, mapOptions, axisDictionary) {
  var data2 = pivotGridDataSource.getData();
  var dataSource = [];
  var dataFields = pivotGridDataSource.getAreaFields("data");
  var rowFields = pivotGridDataSource.getAreaFields("row");
  var columnFields = pivotGridDataSource.getAreaFields("column");
  var columnElements = [{
    index: data2.grandTotalColumnIndex,
    children: data2.columns
  }];
  var rowElements = [{
    index: data2.grandTotalRowIndex,
    children: data2.rows
  }];
  var rowLevel = getExpandedLevel(rowElements);
  var columnLevel = getExpandedLevel(columnElements);
  var measureIndex;
  var dataField;
  var rowMemberIndex;
  var rowVisibility;
  var rowPathFormatted;
  var rowPath;
  var columnMemberIndex;
  var columnVisibility;
  var columnPath;
  var columnPathFormatted;
  function createDataItem() {
    var dataCell = (data2.values[rowMemberIndex] || [])[columnMemberIndex] || [];
    var value2 = dataCell[measureIndex];
    var axis;
    var processCellArgs = {
      rowPath,
      maxRowLevel: rowLevel,
      rowPathFormatted,
      rowFields,
      columnPathFormatted,
      maxColumnLevel: columnLevel,
      columnPath,
      columnFields,
      dataFields,
      dataIndex: measureIndex,
      dataValues: dataCell,
      visible: columnVisibility && rowVisibility
    };
    var seriesName = (mapOptions.inverted ? columnPathFormatted : rowPathFormatted).join(" - ");
    var argument = (mapOptions.inverted ? rowPathFormatted : columnPathFormatted).join("/");
    if (dataFields.length > 1) {
      if (mapOptions.putDataFieldsInto === "args" || mapOptions.putDataFieldsInto === "both") {
        argument += " | " + dataField.caption;
      }
      if (mapOptions.putDataFieldsInto !== "args") {
        seriesName += " | " + dataField.caption;
        if (mapOptions.dataFieldsDisplayMode !== "singleAxis") {
          axis = dataField.caption;
        }
      }
    }
    processCellArgs.chartDataItem = {
      val: value2 === void 0 ? null : value2,
      series: seriesName,
      arg: argument
    };
    processCellArgs = processDataCell(processCellArgs, mapOptions.processCell);
    if (processCellArgs.visible) {
      axisDictionary[processCellArgs.chartDataItem.series] = axisDictionary[processCellArgs.chartDataItem.series] || axis;
      dataSource.push(processCellArgs.chartDataItem);
    }
  }
  function foreachRowColumn(callBack) {
    foreachTree(rowElements, function(rowMembers) {
      rowMemberIndex = rowMembers[0].index;
      rowMembers = rowMembers.slice(0, rowMembers.length - 1);
      rowVisibility = rowLevel === rowMembers.length;
      rowPath = createPath(rowMembers);
      rowPathFormatted = getFormattedValue(rowMembers, rowFields);
      if (rowPath.length === 0) {
        rowPathFormatted = [mapOptions.grandTotalText];
      }
      foreachTree(columnElements, function(columnMembers) {
        columnMemberIndex = columnMembers[0].index;
        columnMembers = columnMembers.slice(0, columnMembers.length - 1);
        columnVisibility = columnLevel === columnMembers.length;
        columnPath = createPath(columnMembers);
        columnPathFormatted = getFormattedValue(columnMembers, columnFields);
        if (columnPath.length === 0) {
          columnPathFormatted = [mapOptions.grandTotalText];
        }
        callBack();
      });
    });
  }
  function foreachDataField(callback) {
    each(dataFields, function(index2, field) {
      dataField = field;
      measureIndex = index2;
      callback();
    });
  }
  if (mapOptions.alternateDataFields === false) {
    foreachDataField(function() {
      foreachRowColumn(createDataItem);
    });
  } else {
    foreachRowColumn(function() {
      foreachDataField(createDataItem);
    });
  }
  return dataSource;
}
function createValueAxisOptions(dataSource, options) {
  var dataFields = dataSource.getAreaFields("data");
  if (options.putDataFieldsInto !== "args" && options.dataFieldsDisplayMode !== "singleAxis" || dataFields.length === 1) {
    var valueAxisSettings = [];
    each(dataFields, function(_2, dataField) {
      var valueAxisOptions = {
        name: dataField.caption,
        title: dataField.caption,
        valueType: FORMAT_DICTIONARY[dataField.dataType] || dataField.dataType,
        label: {
          format: dataField.format
        }
      };
      if (dataField.customizeText) {
        valueAxisOptions.label.customizeText = function(formatObject) {
          return dataField.customizeText.call(dataField, formatObject);
        };
      }
      if (options.dataFieldsDisplayMode === "splitPanes") {
        valueAxisOptions.pane = dataField.caption;
      }
      valueAxisSettings.push(valueAxisOptions);
    });
    return valueAxisSettings;
  }
  return [{}];
}
function createPanesOptions(dataSource, options) {
  var panes = [];
  var dataFields = dataSource.getAreaFields("data");
  if (dataFields.length > 1 && options.dataFieldsDisplayMode === "splitPanes" && options.putDataFieldsInto !== "args") {
    each(dataFields, function(_2, dataField) {
      panes.push({
        name: dataField.caption
      });
    });
  }
  if (!panes.length) {
    panes.push({});
  }
  return panes;
}
function createChartOptions(dataSource, options) {
  var _customizeSeries = options.customizeSeries;
  var customizeChart = options.customizeChart;
  var chartOptions = {
    valueAxis: createValueAxisOptions(dataSource, options),
    panes: createPanesOptions(dataSource, options)
  };
  var axisDictionary = {};
  if (customizeChart) {
    chartOptions = extend(true, {}, chartOptions, customizeChart(chartOptions));
  }
  chartOptions.dataSource = createChartDataSource(dataSource, options, axisDictionary);
  chartOptions.seriesTemplate = {
    nameField: "series",
    customizeSeries: function(seriesName) {
      var seriesOptions = {};
      if (options.dataFieldsDisplayMode === "splitPanes") {
        seriesOptions.pane = axisDictionary[seriesName];
      } else if (options.dataFieldsDisplayMode !== "singleAxis") {
        seriesOptions.axis = axisDictionary[seriesName];
      }
      if (_customizeSeries) {
        seriesOptions = extend(seriesOptions, _customizeSeries(seriesName, seriesOptions));
      }
      return seriesOptions;
    }
  };
  return chartOptions;
}
function getChartInstance(chartElement) {
  if (!chartElement) {
    return false;
  }
  if (chartElement.NAME) {
    return chartElement.NAME === "dxChart" && chartElement;
  }
  var element = $(chartElement);
  return element.data("dxChart") && element.dxChart("instance");
}
function removeBinding(chart) {
  var unbind = chart.$element().data(UNBIND_KEY);
  unbind && unbind();
}
var chartIntegrationMixin = {
  bindChart: function(chart, integrationOptions) {
    integrationOptions = extend({}, integrationOptions);
    var that = this;
    var updateChart = function() {
      integrationOptions.grandTotalText = that.option("texts.grandTotal");
      var chartOptions = createChartOptions(that.getDataSource(), integrationOptions);
      chart.option(chartOptions);
    };
    chart = getChartInstance(chart);
    if (!chart) {
      return null;
    }
    removeBinding(chart);
    that.on("changed", updateChart);
    updateChart();
    var disposeBinding = function() {
      chart.$element().removeData(UNBIND_KEY);
      that.off("changed", updateChart);
    };
    chart.on("disposing", disposeBinding);
    this.on("disposing", disposeBinding);
    chart.$element().data(UNBIND_KEY, disposeBinding);
    return disposeBinding;
  }
};
var window$1 = getWindow();
var DATA_AREA_CELL_CLASS = "dx-area-data-cell";
var ROW_AREA_CELL_CLASS = "dx-area-row-cell";
var COLUMN_AREA_CELL_CLASS = "dx-area-column-cell";
var DESCRIPTION_AREA_CELL_CLASS = "dx-area-description-cell";
var BORDERS_CLASS = "dx-pivotgrid-border";
var PIVOTGRID_CLASS = "dx-pivotgrid";
var ROW_LINES_CLASS = "dx-row-lines";
var BOTTOM_ROW_CLASS = "dx-bottom-row";
var BOTTOM_BORDER_CLASS = "dx-bottom-border";
var FIELDS_CONTAINER_CLASS = "dx-pivotgrid-fields-container";
var FIELDS_CLASS = "dx-area-fields";
var FIELD_CHOOSER_POPUP_CLASS = "dx-fieldchooser-popup";
var INCOMPRESSIBLE_FIELDS_CLASS = "dx-incompressible-fields";
var OVERFLOW_HIDDEN_CLASS = "dx-overflow-hidden";
var TR = "<tr>";
var TD = "<td>";
var DIV = "<div>";
var TEST_HEIGHT = 66666;
var FIELD_CALCULATED_OPTIONS = ["allowSorting", "allowSortingBySummary", "allowFiltering", "allowExpandAll"];
function getArraySum(array) {
  var sum = 0;
  each(array, function(_2, value2) {
    sum += value2 || 0;
  });
  return sum;
}
function adjustSizeArray(sizeArray, space) {
  var delta = space / sizeArray.length;
  for (var i = 0; i < sizeArray.length; i++) {
    sizeArray[i] -= delta;
  }
}
function unsubscribeScrollEvents(area) {
  area.off("scroll").off("stop");
}
function subscribeToScrollEvent(area, handler) {
  unsubscribeScrollEvents(area);
  area.on("scroll", handler).on("stop", handler);
}
var scrollBarInfoCache = {};
function getScrollBarInfo(useNativeScrolling) {
  if (scrollBarInfoCache[useNativeScrolling]) {
    return scrollBarInfoCache[useNativeScrolling];
  }
  var scrollBarWidth;
  var options = {};
  var container = $(DIV).css({
    position: "absolute",
    visibility: "hidden",
    top: -1e3,
    left: -1e3,
    width: 100,
    height: 100
  }).appendTo("body");
  var content = $("<p>").css({
    width: "100%",
    height: 200
  }).appendTo(container);
  if (useNativeScrolling !== "auto") {
    options.useNative = !!useNativeScrolling;
    options.useSimulatedScrollbar = !useNativeScrolling;
  }
  container.dxScrollable(options);
  var scrollBarUseNative = container.dxScrollable("instance").option("useNative");
  scrollBarWidth = scrollBarUseNative ? container.width() - content.width() : 0;
  container.remove();
  scrollBarInfoCache[useNativeScrolling] = {
    scrollBarWidth,
    scrollBarUseNative
  };
  return scrollBarInfoCache[useNativeScrolling];
}
function getCommonBorderWidth(elements, direction) {
  var borderStyleNames = direction === "width" ? ["borderLeftWidth", "borderRightWidth"] : ["borderTopWidth", "borderBottomWidth"];
  var width = 0;
  each(elements, function(_2, elem) {
    var computedStyle = window$1.getComputedStyle(elem.get(0));
    borderStyleNames.forEach(function(borderStyleName) {
      width += parseFloat(computedStyle[borderStyleName]) || 0;
    });
  });
  return width;
}
function clickedOnFieldsArea($targetElement) {
  return $targetElement.closest("." + FIELDS_CLASS).length || $targetElement.find("." + FIELDS_CLASS).length;
}
var PivotGrid = Widget.inherit({
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      scrolling: {
        timeout: 300,
        renderingThreshold: 150,
        minTimeout: 10,
        mode: "standard",
        useNative: "auto",
        removeInvisiblePages: true,
        virtualRowHeight: 50,
        virtualColumnWidth: 100,
        loadTwoPagesOnStart: true
      },
      encodeHtml: true,
      dataSource: null,
      activeStateEnabled: false,
      fieldChooser: {
        minWidth: 250,
        minHeight: 250,
        enabled: true,
        allowSearch: false,
        searchTimeout: 500,
        layout: 0,
        title: messageLocalization.format("dxPivotGrid-fieldChooserTitle"),
        width: 600,
        height: 600,
        applyChangesMode: "instantly"
      },
      onContextMenuPreparing: null,
      allowSorting: false,
      allowSortingBySummary: false,
      allowFiltering: false,
      allowExpandAll: false,
      wordWrapEnabled: true,
      fieldPanel: {
        showColumnFields: true,
        showFilterFields: true,
        showDataFields: true,
        showRowFields: true,
        allowFieldDragging: true,
        visible: false,
        texts: {
          columnFieldArea: messageLocalization.format("dxPivotGrid-columnFieldArea"),
          rowFieldArea: messageLocalization.format("dxPivotGrid-rowFieldArea"),
          filterFieldArea: messageLocalization.format("dxPivotGrid-filterFieldArea"),
          dataFieldArea: messageLocalization.format("dxPivotGrid-dataFieldArea")
        }
      },
      dataFieldArea: "column",
      export: {
        enabled: false,
        fileName: "PivotGrid",
        proxyUrl: void 0,
        ignoreExcelErrors: true
      },
      showRowTotals: true,
      showRowGrandTotals: true,
      showColumnTotals: true,
      showColumnGrandTotals: true,
      hideEmptySummaryCells: true,
      showTotalsPrior: "none",
      rowHeaderLayout: "standard",
      loadPanel: {
        enabled: true,
        text: messageLocalization.format("Loading"),
        width: 200,
        height: 70,
        showIndicator: true,
        indicatorSrc: "",
        showPane: true
      },
      texts: {
        grandTotal: messageLocalization.format("dxPivotGrid-grandTotal"),
        total: messageLocalization.getFormatter("dxPivotGrid-total"),
        noData: messageLocalization.format("dxDataGrid-noDataText"),
        showFieldChooser: messageLocalization.format("dxPivotGrid-showFieldChooser"),
        expandAll: messageLocalization.format("dxPivotGrid-expandAll"),
        collapseAll: messageLocalization.format("dxPivotGrid-collapseAll"),
        sortColumnBySummary: messageLocalization.getFormatter("dxPivotGrid-sortColumnBySummary"),
        sortRowBySummary: messageLocalization.getFormatter("dxPivotGrid-sortRowBySummary"),
        removeAllSorting: messageLocalization.format("dxPivotGrid-removeAllSorting"),
        exportToExcel: messageLocalization.format("dxDataGrid-exportToExcel"),
        dataNotAvailable: messageLocalization.format("dxPivotGrid-dataNotAvailable")
      },
      onCellClick: null,
      onCellPrepared: null,
      showBorders: false,
      stateStoring: {
        enabled: false,
        storageKey: null,
        type: "localStorage",
        customLoad: null,
        customSave: null,
        savingTimeout: 2e3
      },
      onExpandValueChanging: null,
      renderCellCountLimit: 2e4,
      onExporting: null,
      onExported: null,
      onFileSaving: null,
      headerFilter: {
        width: 252,
        height: 325,
        allowSearch: false,
        showRelevantValues: false,
        searchTimeout: 500,
        texts: {
          emptyValue: messageLocalization.format("dxDataGrid-headerFilterEmptyValue"),
          ok: messageLocalization.format("dxDataGrid-headerFilterOK"),
          cancel: messageLocalization.format("dxDataGrid-headerFilterCancel")
        }
      }
    });
  },
  _updateCalculatedOptions: function(fields) {
    var that = this;
    each(fields, function(index2, field) {
      each(FIELD_CALCULATED_OPTIONS, function(_2, optionName) {
        var isCalculated = field._initProperties && optionName in field._initProperties && field._initProperties[optionName] === void 0;
        var needUpdate = field[optionName] === void 0 || isCalculated;
        if (needUpdate) {
          setFieldProperty(field, optionName, that.option(optionName));
        }
      });
    });
  },
  _getDataControllerOptions: function() {
    var that = this;
    return {
      component: that,
      dataSource: that.option("dataSource"),
      texts: that.option("texts"),
      showRowTotals: that.option("showRowTotals"),
      showRowGrandTotals: that.option("showRowGrandTotals"),
      showColumnTotals: that.option("showColumnTotals"),
      showTotalsPrior: that.option("showTotalsPrior"),
      showColumnGrandTotals: that.option("showColumnGrandTotals"),
      dataFieldArea: that.option("dataFieldArea"),
      rowHeaderLayout: that.option("rowHeaderLayout"),
      hideEmptySummaryCells: that.option("hideEmptySummaryCells"),
      onFieldsPrepared: function(fields) {
        that._updateCalculatedOptions(fields);
      }
    };
  },
  _initDataController: function() {
    var that = this;
    that._dataController && that._dataController.dispose();
    that._dataController = new DataController(that._getDataControllerOptions());
    if (hasWindow$1()) {
      that._dataController.changed.add(function() {
        that._render();
      });
    }
    that._dataController.scrollChanged.add(function(options) {
      that._scrollLeft = options.left;
      that._scrollTop = options.top;
    });
    that._dataController.loadingChanged.add(function(isLoading) {
      that._updateLoading();
    });
    that._dataController.progressChanged.add(that._updateLoading.bind(that));
    that._dataController.dataSourceChanged.add(function() {
      that._trigger("onChanged");
    });
    var expandValueChanging = that.option("onExpandValueChanging");
    if (expandValueChanging) {
      that._dataController.expandValueChanging.add(function(e) {
        expandValueChanging(e);
      });
    }
  },
  _init: function() {
    this.callBase();
    this._initDataController();
    this._scrollLeft = this._scrollTop = null;
    this._initActions();
  },
  _initActions: function() {
    this._actions = {
      onChanged: this._createActionByOption("onChanged"),
      onContextMenuPreparing: this._createActionByOption("onContextMenuPreparing"),
      onCellClick: this._createActionByOption("onCellClick"),
      onExporting: this._createActionByOption("onExporting"),
      onExported: this._createActionByOption("onExported"),
      onFileSaving: this._createActionByOption("onFileSaving"),
      onCellPrepared: this._createActionByOption("onCellPrepared")
    };
  },
  _trigger: function(eventName, eventArg) {
    this._actions[eventName](eventArg);
  },
  _optionChanged: function(args) {
    if (FIELD_CALCULATED_OPTIONS.indexOf(args.name) >= 0) {
      var fields = this.getDataSource().fields();
      this._updateCalculatedOptions(fields);
    }
    switch (args.name) {
      case "dataSource":
      case "allowSorting":
      case "allowFiltering":
      case "allowExpandAll":
      case "allowSortingBySummary":
      case "scrolling":
      case "stateStoring":
        this._initDataController();
        this._fieldChooserPopup.hide();
        this._renderFieldChooser();
        this._invalidate();
        break;
      case "texts":
      case "showTotalsPrior":
      case "showRowTotals":
      case "showRowGrandTotals":
      case "showColumnTotals":
      case "showColumnGrandTotals":
      case "hideEmptySummaryCells":
      case "dataFieldArea":
        this._dataController.updateViewOptions(this._getDataControllerOptions());
        break;
      case "useNativeScrolling":
      case "encodeHtml":
      case "renderCellCountLimit":
        break;
      case "rtlEnabled":
        this.callBase(args);
        this._renderFieldChooser();
        this._renderContextMenu();
        hasWindow$1() && this._renderLoadPanel(this._dataArea.groupElement(), this.$element());
        this._invalidate();
        break;
      case "export":
        this._renderDescriptionArea();
        break;
      case "onExpandValueChanging":
        break;
      case "onCellClick":
      case "onContextMenuPreparing":
      case "onExporting":
      case "onExported":
      case "onFileSaving":
      case "onCellPrepared":
        this._actions[args.name] = this._createActionByOption(args.name);
        break;
      case "fieldChooser":
        this._renderFieldChooser();
        this._renderDescriptionArea();
        break;
      case "loadPanel":
        if (hasWindow$1()) {
          if (args.fullName === "loadPanel.enabled") {
            clearTimeout(this._hideLoadingTimeoutID);
            this._renderLoadPanel(this._dataArea.groupElement(), this.$element());
          } else {
            this._renderLoadPanel(this._dataArea.groupElement(), this.$element());
            this._invalidate();
          }
        }
        break;
      case "fieldPanel":
        this._renderDescriptionArea();
        this._invalidate();
        break;
      case "headerFilter":
        this._renderFieldChooser();
        this._invalidate();
        break;
      case "showBorders":
        this._tableElement().toggleClass(BORDERS_CLASS, !!args.value);
        this.updateDimensions();
        break;
      case "wordWrapEnabled":
        this._tableElement().toggleClass("dx-word-wrap", !!args.value);
        this.updateDimensions();
        break;
      case "rowHeaderLayout":
        this._tableElement().find("." + ROW_AREA_CELL_CLASS).toggleClass("dx-area-tree-view", args.value === "tree");
        this._dataController.updateViewOptions(this._getDataControllerOptions());
        break;
      case "height":
      case "width":
        this._hasHeight = null;
        this.callBase(args);
        this.resize();
        break;
      default:
        this.callBase(args);
    }
  },
  _updateScrollPosition: function(columnsArea, rowsArea, dataArea) {
    var scrollTop;
    var scrollLeft;
    var scrolled = this._scrollTop || this._scrollLeft;
    if (this._scrollUpdating) {
      return;
    }
    this._scrollUpdating = true;
    if (rowsArea && !rowsArea.hasScroll() && this._hasHeight) {
      this._scrollTop = null;
    }
    if (columnsArea && !columnsArea.hasScroll()) {
      this._scrollLeft = null;
    }
    if (this._scrollTop !== null || this._scrollLeft !== null || scrolled || this.option("rtlEnabled")) {
      scrollTop = this._scrollTop || 0;
      scrollLeft = this._scrollLeft || 0;
      dataArea.scrollTo({
        x: scrollLeft,
        y: scrollTop
      });
      columnsArea.scrollTo(scrollLeft);
      rowsArea.scrollTo(scrollTop);
      this._dataController.updateWindowScrollPosition(this._scrollTop);
    }
    this._scrollUpdating = false;
  },
  _subscribeToEvents: function(columnsArea, rowsArea, dataArea) {
    var that = this;
    var scrollHandler = function(e) {
      var scrollOffset = e.scrollOffset;
      var leftOffset = isDefined(scrollOffset.left) ? scrollOffset.left : that._scrollLeft;
      var topOffset = isDefined(scrollOffset.top) && that._hasHeight ? scrollOffset.top : that._scrollTop;
      if ((that._scrollLeft || 0) !== (leftOffset || 0) || (that._scrollTop || 0) !== (topOffset || 0)) {
        that._scrollLeft = leftOffset;
        that._scrollTop = topOffset;
        that._updateScrollPosition(columnsArea, rowsArea, dataArea);
        if (that.option("scrolling.mode") === "virtual") {
          that._dataController.setViewportPosition(that._scrollLeft, that._scrollTop);
        }
      }
    };
    each([columnsArea, rowsArea, dataArea], function(_2, area) {
      subscribeToScrollEvent(area, scrollHandler);
    });
    !that._hasHeight && that._dataController.subscribeToWindowScrollEvents(dataArea.groupElement());
  },
  _clean: noop,
  _needDelayResizing: function(cellsInfo) {
    var cellsCount = cellsInfo.length * (cellsInfo.length ? cellsInfo[0].length : 0);
    return cellsCount > this.option("renderCellCountLimit");
  },
  _renderFieldChooser: function() {
    var that = this;
    var container = that._pivotGridContainer;
    var fieldChooserOptions = that.option("fieldChooser") || {};
    var toolbarItems = fieldChooserOptions.applyChangesMode === "onDemand" ? [{
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: messageLocalization.format("OK"),
        onClick: function(e) {
          that._fieldChooserPopup.$content().dxPivotGridFieldChooser("applyChanges");
          that._fieldChooserPopup.hide();
        }
      }
    }, {
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: messageLocalization.format("Cancel"),
        onClick: function(e) {
          that._fieldChooserPopup.hide();
        }
      }
    }] : [];
    var fieldChooserComponentOptions = {
      layout: fieldChooserOptions.layout,
      texts: fieldChooserOptions.texts || {},
      dataSource: that.getDataSource(),
      allowSearch: fieldChooserOptions.allowSearch,
      searchTimeout: fieldChooserOptions.searchTimeout,
      width: void 0,
      height: void 0,
      headerFilter: that.option("headerFilter"),
      encodeHtml: that.option("encodeHtml"),
      applyChangesMode: fieldChooserOptions.applyChangesMode,
      onContextMenuPreparing: function(e) {
        that._trigger("onContextMenuPreparing", e);
      }
    };
    var popupOptions = {
      shading: false,
      title: fieldChooserOptions.title,
      width: fieldChooserOptions.width,
      height: fieldChooserOptions.height,
      showCloseButton: true,
      resizeEnabled: true,
      minWidth: fieldChooserOptions.minWidth,
      minHeight: fieldChooserOptions.minHeight,
      toolbarItems,
      onResize: function(e) {
        e.component.$content().dxPivotGridFieldChooser("updateDimensions");
      },
      onShown: function(e) {
        that._createComponent(e.component.content(), FieldChooser, fieldChooserComponentOptions);
      },
      onHidden: function(e) {
        var fieldChooser = e.component.$content().dxPivotGridFieldChooser("instance");
        fieldChooser.resetTreeView();
        fieldChooser.cancelChanges();
      }
    };
    if (that._fieldChooserPopup) {
      that._fieldChooserPopup.option(popupOptions);
      that._fieldChooserPopup.$content().dxPivotGridFieldChooser(fieldChooserComponentOptions);
    } else {
      that._fieldChooserPopup = that._createComponent($(DIV).addClass(FIELD_CHOOSER_POPUP_CLASS).appendTo(container), Popup, popupOptions);
    }
  },
  _renderContextMenu: function() {
    var that = this;
    var $container = that._pivotGridContainer;
    if (that._contextMenu) {
      that._contextMenu.$element().remove();
    }
    that._contextMenu = that._createComponent($(DIV).appendTo($container), ContextMenu, {
      onPositioning: function(actionArgs) {
        var event = actionArgs.event;
        actionArgs.cancel = true;
        if (!event) {
          return;
        }
        var targetElement = event.target.cellIndex >= 0 ? event.target : $(event.target).closest("td").get(0);
        if (!targetElement) {
          return;
        }
        var args = that._createEventArgs(targetElement, event);
        var items = that._getContextMenuItems(args);
        if (items) {
          actionArgs.component.option("items", items);
          actionArgs.cancel = false;
          return;
        }
      },
      onItemClick: function(params) {
        params.itemData.onItemClick && params.itemData.onItemClick(params);
      },
      cssClass: PIVOTGRID_CLASS,
      target: that.$element()
    });
  },
  _getContextMenuItems: function(e) {
    var that = this;
    var items = [];
    var texts = that.option("texts");
    if (e.area === "row" || e.area === "column") {
      var areaFields = e[e.area + "Fields"];
      var oppositeAreaFields = e[e.area === "column" ? "rowFields" : "columnFields"];
      var field = e.cell.path && areaFields[e.cell.path.length - 1];
      var dataSource = that.getDataSource();
      if (field && field.allowExpandAll && e.cell.path.length < e[e.area + "Fields"].length && !dataSource.paginate()) {
        items.push({
          beginGroup: true,
          icon: "none",
          text: texts.expandAll,
          onItemClick: function() {
            dataSource.expandAll(field.index);
          }
        });
        items.push({
          text: texts.collapseAll,
          icon: "none",
          onItemClick: function() {
            dataSource.collapseAll(field.index);
          }
        });
      }
      if (e.cell.isLast && !dataSource.paginate()) {
        var sortingBySummaryItemCount = 0;
        each(oppositeAreaFields, function(index2, field2) {
          if (!field2.allowSortingBySummary) {
            return;
          }
          each(e.dataFields, function(dataIndex, dataField) {
            if (isDefined(e.cell.dataIndex) && e.cell.dataIndex !== dataIndex) {
              return;
            }
            var showDataFieldCaption = !isDefined(e.cell.dataIndex) && e.dataFields.length > 1;
            var textFormat = e.area === "column" ? texts.sortColumnBySummary : texts.sortRowBySummary;
            var checked = findField(e.dataFields, field2.sortBySummaryField) === dataIndex && (e.cell.path || []).join("/") === (field2.sortBySummaryPath || []).join("/");
            var text = format(textFormat, showDataFieldCaption ? field2.caption + " - " + dataField.caption : field2.caption);
            items.push({
              beginGroup: sortingBySummaryItemCount === 0,
              icon: checked ? field2.sortOrder === "desc" ? "sortdowntext" : "sortuptext" : "none",
              text,
              onItemClick: function() {
                dataSource.field(field2.index, {
                  sortBySummaryField: dataField.name || dataField.caption || dataField.dataField,
                  sortBySummaryPath: e.cell.path,
                  sortOrder: field2.sortOrder === "desc" ? "asc" : "desc"
                });
                dataSource.load();
              }
            });
            sortingBySummaryItemCount++;
          });
        });
        each(oppositeAreaFields, function(index2, field2) {
          if (!field2.allowSortingBySummary || !isDefined(field2.sortBySummaryField)) {
            return;
          }
          items.push({
            beginGroup: sortingBySummaryItemCount === 0,
            icon: "none",
            text: texts.removeAllSorting,
            onItemClick: function() {
              each(oppositeAreaFields, function(index3, field3) {
                dataSource.field(field3.index, {
                  sortBySummaryField: void 0,
                  sortBySummaryPath: void 0,
                  sortOrder: void 0
                });
              });
              dataSource.load();
            }
          });
          return false;
        });
      }
    }
    if (that.option("fieldChooser.enabled")) {
      items.push({
        beginGroup: true,
        icon: "columnchooser",
        text: texts.showFieldChooser,
        onItemClick: function() {
          that._fieldChooserPopup.show();
        }
      });
    }
    if (that.option("export.enabled")) {
      items.push({
        beginGroup: true,
        icon: "xlsxfile",
        text: texts.exportToExcel,
        onItemClick: function() {
          that.exportToExcel();
        }
      });
    }
    e.items = items;
    that._trigger("onContextMenuPreparing", e);
    items = e.items;
    if (items && items.length) {
      return items;
    }
  },
  _createEventArgs: function(targetElement, dxEvent) {
    var dataSource = this.getDataSource();
    var args = {
      rowFields: dataSource.getAreaFields("row"),
      columnFields: dataSource.getAreaFields("column"),
      dataFields: dataSource.getAreaFields("data"),
      event: dxEvent
    };
    if (clickedOnFieldsArea($(targetElement))) {
      return extend(this._createFieldArgs(targetElement), args);
    } else {
      return extend(this._createCellArgs(targetElement), args);
    }
  },
  _createFieldArgs: function(targetElement) {
    var field = $(targetElement).children().data("field");
    var args = {
      field
    };
    return isDefined(field) ? args : {};
  },
  _createCellArgs: function(cellElement) {
    var $cellElement = $(cellElement);
    var columnIndex = cellElement.cellIndex;
    var rowIndex = cellElement.parentElement.rowIndex;
    var $table = $cellElement.closest("table");
    var data2 = $table.data("data");
    var cell = data2 && data2[rowIndex] && data2[rowIndex][columnIndex];
    var args = {
      area: $table.data("area"),
      rowIndex,
      columnIndex,
      cellElement: getPublicElement($cellElement),
      cell
    };
    return args;
  },
  _handleCellClick: function(e) {
    var that = this;
    var args = that._createEventArgs(e.currentTarget, e);
    var cell = args.cell;
    if (!cell || !args.area && (args.rowIndex || args.columnIndex)) {
      return;
    }
    that._trigger("onCellClick", args);
    cell && !args.cancel && isDefined(cell.expanded) && setTimeout(function() {
      that._dataController[cell.expanded ? "collapseHeaderItem" : "expandHeaderItem"](args.area, cell.path);
    });
  },
  _getNoDataText: function() {
    return this.option("texts.noData");
  },
  _renderNoDataText: gridCoreUtils.renderNoDataText,
  _renderLoadPanel: gridCoreUtils.renderLoadPanel,
  _updateLoading: function(progress) {
    var that = this;
    var isLoading = that._dataController.isLoading();
    if (!that._loadPanel) {
      return;
    }
    var loadPanelVisible = that._loadPanel.option("visible");
    if (!loadPanelVisible) {
      that._startLoadingTime = new Date();
    }
    if (isLoading) {
      if (progress) {
        if (new Date() - that._startLoadingTime >= 1e3) {
          that._loadPanel.option("message", Math.floor(100 * progress) + "%");
        }
      } else {
        that._loadPanel.option("message", that.option("loadPanel.text"));
      }
    }
    clearTimeout(that._hideLoadingTimeoutID);
    if (loadPanelVisible && !isLoading) {
      that._hideLoadingTimeoutID = setTimeout(function() {
        that._loadPanel.option("visible", false);
        that.$element().removeClass(OVERFLOW_HIDDEN_CLASS);
      });
    } else {
      that._loadPanel.option("visible", isLoading);
      that.$element().toggleClass(OVERFLOW_HIDDEN_CLASS, !isLoading);
    }
  },
  _renderDescriptionArea: function() {
    var $element = this.$element();
    var $descriptionCell = $element.find("." + DESCRIPTION_AREA_CELL_CLASS);
    var $toolbarContainer = $(DIV).addClass("dx-pivotgrid-toolbar");
    var fieldPanel = this.option("fieldPanel");
    var $filterHeader = $element.find(".dx-filter-header");
    var $columnHeader = $element.find(".dx-column-header");
    var $targetContainer;
    if (fieldPanel.visible && fieldPanel.showFilterFields) {
      $targetContainer = $filterHeader;
    } else if (fieldPanel.visible && (fieldPanel.showDataFields || fieldPanel.showColumnFields)) {
      $targetContainer = $columnHeader;
    } else {
      $targetContainer = $descriptionCell;
    }
    $columnHeader.toggleClass(BOTTOM_BORDER_CLASS, !!(fieldPanel.visible && (fieldPanel.showDataFields || fieldPanel.showColumnFields)));
    $filterHeader.toggleClass(BOTTOM_BORDER_CLASS, !!(fieldPanel.visible && fieldPanel.showFilterFields));
    $descriptionCell.toggleClass("dx-pivotgrid-background", fieldPanel.visible && (fieldPanel.showDataFields || fieldPanel.showColumnFields || fieldPanel.showRowFields));
    this.$element().find(".dx-pivotgrid-toolbar").remove();
    $toolbarContainer.prependTo($targetContainer);
    if (this.option("fieldChooser.enabled")) {
      var $buttonElement = $(DIV).appendTo($toolbarContainer).addClass("dx-pivotgrid-field-chooser-button");
      var buttonOptions = {
        icon: "columnchooser",
        hint: this.option("texts.showFieldChooser"),
        onClick: () => {
          this.getFieldChooserPopup().show();
        }
      };
      this._createComponent($buttonElement, "dxButton", buttonOptions);
    }
    if (this.option("export.enabled")) {
      var _$buttonElement = $(DIV).appendTo($toolbarContainer).addClass("dx-pivotgrid-export-button");
      var _buttonOptions = {
        icon: "xlsxfile",
        hint: this.option("texts.exportToExcel"),
        onClick: () => {
          this.exportToExcel();
        }
      };
      this._createComponent(_$buttonElement, "dxButton", _buttonOptions);
    }
  },
  _detectHasContainerHeight: function() {
    var element = this.$element();
    if (isDefined(this._hasHeight)) {
      var height = this.option("height") || this.$element().get(0).style.height;
      if (height && this._hasHeight ^ height !== "auto") {
        this._hasHeight = null;
      }
    }
    if (isDefined(this._hasHeight) || element.is(":hidden")) {
      return;
    }
    this._pivotGridContainer.addClass("dx-hidden");
    var testElement = $(DIV).height(TEST_HEIGHT);
    element.append(testElement);
    this._hasHeight = element.height() !== TEST_HEIGHT;
    this._pivotGridContainer.removeClass("dx-hidden");
    testElement.remove();
  },
  _renderHeaders: function(rowHeaderContainer, columnHeaderContainer, filterHeaderContainer, dataHeaderContainer) {
    var dataSource = this.getDataSource();
    this._rowFields = this._rowFields || new FieldsArea(this, "row");
    this._rowFields.render(rowHeaderContainer, dataSource.getAreaFields("row"));
    this._columnFields = this._columnFields || new FieldsArea(this, "column");
    this._columnFields.render(columnHeaderContainer, dataSource.getAreaFields("column"));
    this._filterFields = this._filterFields || new FieldsArea(this, "filter");
    this._filterFields.render(filterHeaderContainer, dataSource.getAreaFields("filter"));
    this._dataFields = this._dataFields || new FieldsArea(this, "data");
    this._dataFields.render(dataHeaderContainer, dataSource.getAreaFields("data"));
    this.$element().dxPivotGridFieldChooserBase("instance").renderSortable();
  },
  _createTableElement: function() {
    var $table = $("<table>").css({
      width: "100%"
    }).toggleClass(BORDERS_CLASS, !!this.option("showBorders")).toggleClass("dx-word-wrap", !!this.option("wordWrapEnabled"));
    eventsEngine.on($table, addNamespace$1(CLICK_EVENT_NAME$2, "dxPivotGrid"), "td", this._handleCellClick.bind(this));
    return $table;
  },
  _renderDataArea: function(dataAreaElement) {
    var dataArea = this._dataArea || new DataArea(this);
    this._dataArea = dataArea;
    dataArea.render(dataAreaElement, this._dataController.getCellsInfo());
    return dataArea;
  },
  _renderRowsArea: function(rowsAreaElement) {
    var rowsArea = this._rowsArea || new VerticalHeadersArea(this);
    this._rowsArea = rowsArea;
    rowsArea.render(rowsAreaElement, this._dataController.getRowsInfo());
    return rowsArea;
  },
  _renderColumnsArea: function(columnsAreaElement) {
    var columnsArea = this._columnsArea || new HorizontalHeadersArea(this);
    this._columnsArea = columnsArea;
    columnsArea.render(columnsAreaElement, this._dataController.getColumnsInfo());
    return columnsArea;
  },
  _initMarkup: function() {
    var that = this;
    that.callBase.apply(this, arguments);
    that.$element().addClass(PIVOTGRID_CLASS);
  },
  _renderContentImpl: function() {
    var columnsAreaElement;
    var rowsAreaElement;
    var dataAreaElement;
    var tableElement;
    var isFirstDrawing = !this._pivotGridContainer;
    var rowHeaderContainer;
    var columnHeaderContainer;
    var filterHeaderContainer;
    var dataHeaderContainer;
    tableElement = !isFirstDrawing && this._tableElement();
    if (!tableElement) {
      this.$element().addClass(ROW_LINES_CLASS).addClass(FIELDS_CONTAINER_CLASS);
      this._pivotGridContainer = $(DIV).addClass("dx-pivotgrid-container");
      this._renderFieldChooser();
      this._renderContextMenu();
      columnsAreaElement = $(TD).addClass(COLUMN_AREA_CELL_CLASS);
      rowsAreaElement = $(TD).addClass(ROW_AREA_CELL_CLASS);
      dataAreaElement = $(TD).addClass(DATA_AREA_CELL_CLASS);
      tableElement = this._createTableElement();
      dataHeaderContainer = $(TD).addClass("dx-data-header");
      filterHeaderContainer = $("<td>").attr("colspan", "2").addClass("dx-filter-header");
      columnHeaderContainer = $(TD).addClass("dx-column-header");
      rowHeaderContainer = $(TD).addClass(DESCRIPTION_AREA_CELL_CLASS);
      $(TR).append(filterHeaderContainer).appendTo(tableElement);
      $(TR).append(dataHeaderContainer).append(columnHeaderContainer).appendTo(tableElement);
      $(TR).toggleClass("dx-ie", coreBrowserUtils.msie === true).append(rowHeaderContainer).append(columnsAreaElement).appendTo(tableElement);
      $(TR).addClass(BOTTOM_ROW_CLASS).append(rowsAreaElement).append(dataAreaElement).appendTo(tableElement);
      this._pivotGridContainer.append(tableElement);
      this.$element().append(this._pivotGridContainer);
      if (this.option("rowHeaderLayout") === "tree") {
        rowsAreaElement.addClass("dx-area-tree-view");
      }
    }
    this.$element().addClass(OVERFLOW_HIDDEN_CLASS);
    this._createComponent(this.$element(), FieldChooserBase, {
      dataSource: this.getDataSource(),
      encodeHtml: this.option("encodeHtml"),
      allowFieldDragging: this.option("fieldPanel.allowFieldDragging"),
      headerFilter: this.option("headerFilter"),
      visible: this.option("visible")
    });
    var dataArea = this._renderDataArea(dataAreaElement);
    var rowsArea = this._renderRowsArea(rowsAreaElement);
    var columnsArea = this._renderColumnsArea(columnsAreaElement);
    dataArea.tableElement().prepend(columnsArea.headElement());
    if (isFirstDrawing) {
      this._renderLoadPanel(dataArea.groupElement().parent(), this.$element());
      this._renderDescriptionArea();
      rowsArea.processScroll();
      columnsArea.processScroll();
    }
    [dataArea, rowsArea, columnsArea].forEach(function(area) {
      unsubscribeScrollEvents(area);
    });
    this._renderHeaders(rowHeaderContainer, columnHeaderContainer, filterHeaderContainer, dataHeaderContainer);
    this._update(isFirstDrawing);
  },
  _update: function(isFirstDrawing) {
    var that = this;
    var updateHandler = function() {
      that.updateDimensions();
    };
    if (that._needDelayResizing(that._dataArea.getData()) && isFirstDrawing) {
      setTimeout(updateHandler);
    } else {
      updateHandler();
    }
  },
  _fireContentReadyAction: function() {
    if (!this._dataController.isLoading()) {
      this.callBase();
    }
  },
  getScrollPath: function(area) {
    if (area === "column") {
      return this._columnsArea.getScrollPath(this._scrollLeft);
    } else {
      return this._rowsArea.getScrollPath(this._scrollTop);
    }
  },
  getDataSource: function() {
    return this._dataController.getDataSource();
  },
  getFieldChooserPopup: function() {
    return this._fieldChooserPopup;
  },
  hasScroll: function(area) {
    return area === "column" ? this._columnsArea.hasScroll() : this._rowsArea.hasScroll();
  },
  _dimensionChanged: function() {
    this.updateDimensions();
  },
  _visibilityChanged: function(visible2) {
    if (visible2) {
      this.updateDimensions();
    }
  },
  _dispose: function() {
    var that = this;
    clearTimeout(that._hideLoadingTimeoutID);
    that.callBase.apply(that, arguments);
    if (that._dataController) {
      that._dataController.dispose();
    }
  },
  _tableElement: function() {
    return this.$element().find("table").first();
  },
  addWidgetPrefix: function(className) {
    return "dx-pivotgrid-" + className;
  },
  resize: function() {
    this.updateDimensions();
  },
  isReady: function() {
    return this.callBase() && !this._dataController.isLoading();
  },
  updateDimensions: function() {
    var that = this;
    var groupWidth;
    var tableElement = that._tableElement();
    var rowsArea = that._rowsArea;
    var columnsArea = that._columnsArea;
    var dataArea = that._dataArea;
    var bordersWidth;
    var totalWidth = 0;
    var totalHeight = 0;
    var rowsAreaWidth = 0;
    var hasRowsScroll;
    var hasColumnsScroll;
    var scrollingOptions = that.option("scrolling") || {};
    var scrollBarInfo = getScrollBarInfo(scrollingOptions.useNative);
    var scrollBarWidth = scrollBarInfo.scrollBarWidth;
    var dataAreaCell = tableElement.find("." + DATA_AREA_CELL_CLASS);
    var rowAreaCell = tableElement.find("." + ROW_AREA_CELL_CLASS);
    var columnAreaCell = tableElement.find("." + COLUMN_AREA_CELL_CLASS);
    var descriptionCell = tableElement.find("." + DESCRIPTION_AREA_CELL_CLASS);
    var filterHeaderCell = tableElement.find(".dx-filter-header");
    var columnHeaderCell = tableElement.find(".dx-column-header");
    var rowFieldsHeader = that._rowFields;
    var d = new Deferred();
    if (!hasWindow$1()) {
      return;
    }
    var needSynchronizeFieldPanel = rowFieldsHeader.isVisible() && that.option("rowHeaderLayout") !== "tree";
    that._detectHasContainerHeight();
    if (!dataArea.headElement().length) {
      dataArea.tableElement().prepend(columnsArea.headElement());
    }
    if (needSynchronizeFieldPanel) {
      rowsArea.updateColspans(rowFieldsHeader.getColumnsCount());
      rowsArea.tableElement().prepend(rowFieldsHeader.headElement());
    }
    tableElement.addClass(INCOMPRESSIBLE_FIELDS_CLASS);
    dataArea.reset();
    rowsArea.reset();
    columnsArea.reset();
    rowFieldsHeader.reset();
    var calculateHasScroll = (areaSize, totalSize) => totalSize - areaSize >= 1;
    var calculateGroupHeight = (dataAreaHeight, totalHeight2, hasRowsScroll2, hasColumnsScroll2, scrollBarWidth2) => hasRowsScroll2 ? dataAreaHeight : totalHeight2 + (hasColumnsScroll2 ? scrollBarWidth2 : 0);
    deferUpdate(function() {
      var resultWidths = dataArea.getColumnsWidth();
      var rowHeights = rowsArea.getRowsHeight();
      var rowsAreaHeights = needSynchronizeFieldPanel ? rowHeights.slice(1) : rowHeights;
      var dataAreaHeights = dataArea.getRowsHeight();
      var descriptionCellHeight = getSize(descriptionCell[0], "height", {
        paddings: true,
        borders: true,
        margins: true
      }) + (needSynchronizeFieldPanel ? rowHeights[0] : 0);
      var columnsAreaRowCount = that._dataController.getColumnsInfo().length;
      var resultHeights = mergeArraysByMaxValue(rowsAreaHeights, dataAreaHeights.slice(columnsAreaRowCount));
      var columnsAreaRowHeights = dataAreaHeights.slice(0, columnsAreaRowCount);
      var columnsAreaHeight = getArraySum(columnsAreaRowHeights);
      var rowsAreaColumnWidths = rowsArea.getColumnsWidth();
      var filterAreaHeight = 0;
      var dataAreaHeight = 0;
      if (that._hasHeight) {
        filterAreaHeight = filterHeaderCell.height();
        var $dataHeader = tableElement.find(".dx-data-header");
        var dataHeaderHeight = coreBrowserUtils.msie ? getSize($dataHeader.get(0), "height", {
          paddings: false,
          borders: false,
          margins: false
        }) : $dataHeader.height();
        bordersWidth = getCommonBorderWidth([columnAreaCell, dataAreaCell, tableElement, columnHeaderCell, filterHeaderCell], "height");
        dataAreaHeight = that.$element().height() - filterAreaHeight - dataHeaderHeight - (Math.max(dataArea.headElement().height(), columnAreaCell.height(), descriptionCellHeight) + bordersWidth);
      }
      totalWidth = dataArea.tableElement().width();
      totalHeight = getArraySum(resultHeights);
      if (!totalWidth || !totalHeight) {
        d.resolve();
        return;
      }
      rowsAreaWidth = getArraySum(rowsAreaColumnWidths);
      var elementWidth = that.$element().width();
      bordersWidth = getCommonBorderWidth([rowAreaCell, dataAreaCell, tableElement], "width");
      groupWidth = elementWidth - rowsAreaWidth - bordersWidth;
      groupWidth = groupWidth > 0 ? groupWidth : totalWidth;
      var diff = totalWidth - groupWidth;
      var needAdjustWidthOnZoom = diff >= 0 && diff <= 2;
      if (needAdjustWidthOnZoom) {
        adjustSizeArray(resultWidths, diff);
        totalWidth = groupWidth;
      }
      hasRowsScroll = that._hasHeight && calculateHasScroll(dataAreaHeight, totalHeight);
      hasColumnsScroll = calculateHasScroll(groupWidth, totalWidth);
      var groupHeight = calculateGroupHeight(dataAreaHeight, totalHeight, hasRowsScroll, hasColumnsScroll, scrollBarWidth);
      deferRender(function() {
        columnsArea.tableElement().append(dataArea.headElement());
        rowFieldsHeader.tableElement().append(rowsArea.headElement());
        if (!hasColumnsScroll && hasRowsScroll && scrollBarWidth) {
          adjustSizeArray(resultWidths, scrollBarWidth);
          totalWidth -= scrollBarWidth;
        }
        if (descriptionCellHeight > columnsAreaHeight) {
          adjustSizeArray(columnsAreaRowHeights, columnsAreaHeight - descriptionCellHeight);
          columnsArea.setRowsHeight(columnsAreaRowHeights);
        }
        tableElement.removeClass(INCOMPRESSIBLE_FIELDS_CLASS);
        columnHeaderCell.children().css("maxWidth", groupWidth);
        columnsArea.groupWidth(groupWidth);
        columnsArea.processScrollBarSpacing(hasRowsScroll ? scrollBarWidth : 0);
        columnsArea.setColumnsWidth(resultWidths);
        rowsArea.groupHeight(that._hasHeight ? groupHeight : "auto");
        rowsArea.processScrollBarSpacing(hasColumnsScroll ? scrollBarWidth : 0);
        rowsArea.setColumnsWidth(rowsAreaColumnWidths);
        rowsArea.setRowsHeight(resultHeights);
        dataArea.setColumnsWidth(resultWidths);
        dataArea.setRowsHeight(resultHeights);
        dataArea.groupWidth(groupWidth);
        dataArea.groupHeight(that._hasHeight ? groupHeight : "auto");
        needSynchronizeFieldPanel && rowFieldsHeader.setColumnsWidth(rowsAreaColumnWidths);
        dataAreaCell.toggleClass(BOTTOM_BORDER_CLASS, !hasRowsScroll);
        rowAreaCell.toggleClass(BOTTOM_BORDER_CLASS, !hasRowsScroll);
        if (!that._hasHeight && elementWidth !== that.$element().width()) {
          var _diff = elementWidth - that.$element().width();
          if (!hasColumnsScroll) {
            adjustSizeArray(resultWidths, _diff);
            columnsArea.setColumnsWidth(resultWidths);
            dataArea.setColumnsWidth(resultWidths);
          }
          dataArea.groupWidth(groupWidth - _diff);
          columnsArea.groupWidth(groupWidth - _diff);
        }
        if (that._hasHeight && that._filterFields.isVisible() && filterHeaderCell.height() !== filterAreaHeight) {
          var _diff2 = filterHeaderCell.height() - filterAreaHeight;
          if (_diff2 > 0) {
            hasRowsScroll = calculateHasScroll(dataAreaHeight - _diff2, totalHeight);
            var _groupHeight = calculateGroupHeight(dataAreaHeight - _diff2, totalHeight, hasRowsScroll, hasColumnsScroll, scrollBarWidth);
            dataArea.groupHeight(_groupHeight);
            rowsArea.groupHeight(_groupHeight);
          }
        }
        if (scrollingOptions.mode === "virtual") {
          var virtualContentParams = that._dataController.calculateVirtualContentParams({
            virtualRowHeight: scrollingOptions.virtualRowHeight,
            virtualColumnWidth: scrollingOptions.virtualColumnWidth,
            itemWidths: resultWidths,
            itemHeights: resultHeights,
            rowCount: resultHeights.length,
            columnCount: resultWidths.length,
            viewportWidth: groupWidth,
            viewportHeight: that._hasHeight ? groupHeight : $(window$1).outerHeight()
          });
          dataArea.setVirtualContentParams({
            top: virtualContentParams.contentTop,
            left: virtualContentParams.contentLeft,
            width: virtualContentParams.width,
            height: virtualContentParams.height
          });
          rowsArea.setVirtualContentParams({
            top: virtualContentParams.contentTop,
            width: rowsAreaWidth,
            height: virtualContentParams.height
          });
          columnsArea.setVirtualContentParams({
            left: virtualContentParams.contentLeft,
            width: virtualContentParams.width,
            height: columnsArea.groupElement().height()
          });
        }
        var updateScrollableResults = [];
        dataArea.processScroll(scrollBarInfo.scrollBarUseNative, that.option("rtlEnabled"), hasColumnsScroll, hasRowsScroll);
        each([columnsArea, rowsArea, dataArea], function(_2, area) {
          updateScrollableResults.push(area && area.updateScrollable());
        });
        that._updateLoading();
        that._renderNoDataText(dataAreaCell);
        when.apply($, updateScrollableResults).done(function() {
          that._updateScrollPosition(columnsArea, rowsArea, dataArea);
          that._subscribeToEvents(columnsArea, rowsArea, dataArea);
          d.resolve();
        });
      });
    });
    return d;
  },
  applyPartialDataSource: function(area, path, dataSource) {
    this._dataController.applyPartialDataSource(area, path, dataSource);
  }
}).inherit(ExportController).include(chartIntegrationMixin);
registerComponent("dxPivotGrid", PivotGrid);
var dx_carmine = "";
var dx_light = "";
var index = "";
function cssRulesObjToCssText(rules) {
  return Object.entries(rules).map(([k, v]) => {
    k = k.replace(/[A-Z]/g, (match2) => `-${match2.toLowerCase()}`);
    return `${k}:${v}`;
  }).join(";");
}
function isString(target) {
  return typeof target === "string";
}
function isFn(target) {
  return typeof target === "function";
}
function isMacOs() {
  return navigator.platform.indexOf("Mac") > -1;
}
class DataHandler {
  static setCustomFields(options) {
    var _a;
    if (!options.customFields)
      return;
    if (!((_a = options.dataSource) == null ? void 0 : _a.fields))
      return;
    options.dataSource.fields = options.dataSource.fields.concat(options.customFields);
  }
  static setTdCustomStyle(options) {
    var _a;
    if (!options.tdCustomStyle)
      return;
    let stylesObj = {};
    if (isString(options.tdCustomStyle)) {
      stylesObj.all = options.tdCustomStyle;
    } else {
      let { all, data: data2, row, column } = options.tdCustomStyle;
      if (all || data2 || row || column) {
        stylesObj.all = isString(all) ? all : cssRulesObjToCssText(all != null ? all : {});
        stylesObj.data = isString(data2) ? data2 : cssRulesObjToCssText(data2 != null ? data2 : {});
        stylesObj.row = isString(row) ? row : cssRulesObjToCssText(row != null ? row : {});
        stylesObj.column = isString(column) ? column : cssRulesObjToCssText(column != null ? column : {});
      } else {
        stylesObj.all = cssRulesObjToCssText((_a = options.tdCustomStyle) != null ? _a : {});
      }
    }
    options._customStyleHandler = function({ area, cellElement }) {
      let el = cellElement.querySelector("span");
      switch (area) {
        case "data":
          el.style.cssText = [stylesObj.all, stylesObj.data].join(";");
          break;
        case "row":
          el.style.cssText = [stylesObj.all, stylesObj.row].join(";");
          break;
        case "column":
          el.style.cssText = [stylesObj.all, stylesObj.column].join(";");
          break;
      }
    };
    if (!options.onCellPrepared) {
      options.onCellPrepared = function() {
      };
    }
  }
  static expandAllHandler(fields) {
    if (!fields)
      return;
    for (let i = 0; i < fields.length; i++) {
      fields[i].expanded = true;
    }
  }
  static setEmptyPlaceHolder(fields, placeHolder) {
    if (!fields || !placeHolder)
      return;
    for (let i = 0; i < fields.length; i++) {
      fields[i].emptyPlaceHolder = placeHolder;
    }
  }
  static setSummaryType(fields, summaryType) {
    if (!fields)
      return;
    for (let i = 0; i < fields.length; i++) {
      if (fields[i].area === "data") {
        fields[i].summaryType = summaryType;
      }
    }
  }
  static setWordWrapHandler(fields, isWrap) {
    if (!fields)
      return;
    for (let i = 0; i < fields.length; i++) {
      fields[i].wordWrapEnabled = isWrap;
    }
  }
}
function throttle(delay, noTrailing, callback, debounceMode) {
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel2() {
    clearExistingTimeout();
    cancelled = true;
  }
  if (typeof noTrailing !== "boolean") {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = void 0;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      exec();
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel2;
  return wrapper;
}
class Base {
  constructor() {
    __publicField(this, "options", {});
    __publicField(this, "DP", null);
    __publicField(this, "defaultOption", {});
  }
  getFirstField() {
    let dataSourceInstance = this.DP.getDataSource();
    return {
      row: dataSourceInstance._fields.find((item) => item.area === "row"),
      column: dataSourceInstance._fields.find((item) => item.area === "column")
    };
  }
  setInheritHeight() {
    this.options.height = `inherit`;
    const throttleFunc = throttle(300, () => {
      var _a, _b;
      (_b = (_a = this == null ? void 0 : this.DP) == null ? void 0 : _a.updateDimensions) == null ? void 0 : _b.call(_a);
    });
    window.addEventListener("resize", () => throttleFunc());
  }
  setExportable() {
    this.options.export = {
      enabled: true
    };
  }
  useBetterScroller() {
    this.options.scrolling = {
      mode: "virtual"
    };
    !isMacOs() && this.setClassName("use-better-scroller");
  }
  setClassName(name2) {
    if (this.options.elementAttr) {
      this.options.elementAttr.class = this.options.elementAttr.class ? this.options.elementAttr.class + ` ${name2}` : name2;
    } else {
      this.options.elementAttr = { class: name2 };
    }
  }
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var nativeObjectToString$1 = objectProto$c.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty$9.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$b = Object.prototype;
var nativeObjectToString = objectProto$b.toString;
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var isArray = Array.isArray;
var isArray$1 = isArray;
function isObject(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value2) {
  if (!isObject(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value2 = getValue(object, key);
  return baseIsNative(value2) ? value2 : void 0;
}
var WeakMap$1 = getNative(root$1, "WeakMap");
var WeakMap$2 = WeakMap$1;
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function copyArray(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty;
function arrayEach(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length) {
  var type2 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
function baseAssignValue(object, key, value2) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function assignValue(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty$7.call(object, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object)) {
    baseAssignValue(object, key, value2);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
function isArrayLike(value2) {
  return value2 != null && isLength(value2.length) && !isFunction(value2);
}
var objectProto$8 = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value2 === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike(value2) && baseGetTag(value2) == argsTag$2;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike(value2) && hasOwnProperty$6.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray$1(value2), isArg = !isArr && isArguments$1(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty$5.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function hashGet(key) {
  var data2 = this.__data__;
  if (nativeCreate$1) {
    var result = data2[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$2.call(data2, key) ? data2[key] : void 0;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function hashHas(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$1.call(data2, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value2) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate$1 && value2 === void 0 ? HASH_UNDEFINED : value2;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value2) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value2]);
  } else {
    data2[index2][1] = value2;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map = getNative(root$1, "Map");
var Map$1 = Map;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData(map2, key) {
  var data2 = map2.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value2) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value2);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset2 = array.length;
  while (++index2 < length) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value2) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache) {
    var pairs = data2.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value2]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache(pairs);
  }
  data2.set(key, value2);
  this.size = data2.size;
  return this;
}
function Stack(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value2 = array[index2];
    if (predicate(value2, index2, array)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$3 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value2) {
    var result = baseGetTag(value2), Ctor = result == objectTag$1 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object);
  }
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var mapTag$1 = "[object Map]";
function baseIsMap(value2) {
  return isObjectLike(value2) && getTag$1(value2) == mapTag$1;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$1 = "[object Set]";
function baseIsSet(value2) {
  return isObjectLike(value2) && getTag$1(value2) == setTag$1;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value2, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value2, key, object, stack) : customizer(value2);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject(value2)) {
    return value2;
  }
  var isArr = isArray$1(value2);
  if (isArr) {
    result = initCloneArray(value2);
    if (!isDeep) {
      return copyArray(value2, result);
    }
  } else {
    var tag = getTag$1(value2), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value2)) {
      return cloneBuffer(value2, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value2);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value2, baseAssignIn(result, value2)) : copySymbols(value2, baseAssign(result, value2));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value2 : {};
      }
      result = initCloneByTag(value2, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value2);
  if (stacked) {
    return stacked;
  }
  stack.set(value2, result);
  if (isSet$1(value2)) {
    value2.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
    });
  } else if (isMap$1(value2)) {
    value2.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value2);
  arrayEach(props || value2, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value2[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value2) {
  return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
const zh = {
  Yes: "\u662F",
  No: "\u5426",
  Cancel: "\u53D6\u6D88",
  Clear: "\u6E05\u9664",
  Done: "\u5B8C\u6210",
  Loading: "\u6B63\u5728\u52A0\u8F7D...",
  Select: "\u9009\u62E9...",
  Search: "\u641C\u7D22",
  Back: "\u8FD4\u56DE",
  OK: "\u786E\u5B9A",
  "dxCollectionWidget-noDataText": "\u6CA1\u6709\u8981\u663E\u793A\u7684\u6570\u636E",
  "dxDropDownEditor-selectLabel": "\u9009\u62E9",
  "validation-required": "\u5FC5\u9700",
  "validation-required-formatted": "{0} \u662F\u5FC5\u9700\u7684",
  "validation-numeric": "\u503C\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57",
  "validation-numeric-formatted": "{0} \u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57",
  "validation-range": "\u503C\u8D85\u51FA\u8303\u56F4",
  "validation-range-formatted": "{0} \u8D85\u51FA\u8303\u56F4",
  "validation-stringLength": "\u8BE5\u503C\u7684\u957F\u5EA6\u4E0D\u6B63\u786E",
  "validation-stringLength-formatted": "{0} \u7684\u957F\u5EA6\u4E0D\u6B63\u786E",
  "validation-custom": "\u503C\u65E0\u6548",
  "validation-custom-formatted": "{0} \u503C\u65E0\u6548",
  "validation-async": "\u503C\u65E0\u6548",
  "validation-async-formatted": "{0} \u503C\u65E0\u6548",
  "validation-compare": "\u503C\u4E0D\u5339\u914D",
  "validation-compare-formatted": "{0} \u4E0D\u5339\u914D",
  "validation-pattern": "\u503C\u4E0D\u7B26\u5408\u8BE5\u6A21\u5F0F",
  "validation-pattern-formatted": "{0} \u4E0D\u5339\u914D\u8BE5\u6A21\u5F0F",
  "validation-email": "\u7535\u5B50\u90AE\u4EF6\u65E0\u6548",
  "validation-email-formatted": "{0} \u65E0\u6548",
  "validation-mask": "\u503C\u65E0\u6548",
  "dxLookup-searchPlaceholder": "\u6700\u5C0F\u5B57\u7B26\u6570: {0}",
  "dxList-pullingDownText": "\u4E0B\u62C9\u4EE5\u5237\u65B0...",
  "dxList-pulledDownText": "\u653E\u5F00\u4EE5\u5237\u65B0...",
  "dxList-refreshingText": "\u5237\u65B0\u4E2D...",
  "dxList-pageLoadingText": "\u6B63\u5728\u52A0\u8F7D...",
  "dxList-nextButtonText": "\u66F4\u591A",
  "dxList-selectAll": "\u5168\u9009",
  "dxListEditDecorator-delete": "\u5220\u9664",
  "dxListEditDecorator-more": "\u66F4\u591A",
  "dxScrollView-pullingDownText": "\u4E0B\u62C9\u4EE5\u5237\u65B0...",
  "dxScrollView-pulledDownText": "\u653E\u5F00\u4EE5\u5237\u65B0...",
  "dxScrollView-refreshingText": "\u5237\u65B0\u4E2D...",
  "dxScrollView-reachBottomText": "\u6B63\u5728\u52A0\u8F7D...",
  "dxDateBox-simulatedDataPickerTitleTime": "\u9009\u62E9\u65F6\u95F4",
  "dxDateBox-simulatedDataPickerTitleDate": "\u9009\u62E9\u65E5\u671F",
  "dxDateBox-simulatedDataPickerTitleDateTime": "\u9009\u62E9\u65E5\u671F\u548C\u65F6\u95F4",
  "dxDateBox-validation-datetime": "\u503C\u5FC5\u987B\u662F\u65E5\u671F\u6216\u65F6\u95F4",
  "dxFileUploader-selectFile": "\u9009\u62E9\u6587\u4EF6",
  "dxFileUploader-dropFile": "\u6216\u8005\u628A\u6587\u4EF6\u653E\u5728\u6B64\u5904",
  "dxFileUploader-bytes": "bytes",
  "dxFileUploader-kb": "kb",
  "dxFileUploader-Mb": "Mb",
  "dxFileUploader-Gb": "Gb",
  "dxFileUploader-upload": "\u4E0A\u4F20",
  "dxFileUploader-uploaded": "\u5DF2\u4E0A\u4F20",
  "dxFileUploader-readyToUpload": "\u51C6\u5907\u4E0A\u4F20",
  "dxFileUploader-uploadAbortedMessage": "TODO",
  "dxFileUploader-uploadFailedMessage": "\u4E0A\u4F20\u5931\u8D25",
  "dxFileUploader-invalidFileExtension": "\u6587\u4EF6\u7C7B\u578B\u9519\u8BEF",
  "dxFileUploader-invalidMaxFileSize": "\u6587\u4EF6\u8FC7\u5927",
  "dxFileUploader-invalidMinFileSize": "\u6587\u4EF6\u8FC7\u5C0F",
  "dxRangeSlider-ariaFrom": "\u4ECE",
  "dxRangeSlider-ariaTill": "\u81F3",
  "dxSwitch-switchedOnText": "\u5F00",
  "dxSwitch-switchedOffText": "\u5173",
  "dxForm-optionalMark": "\u53EF\u9009",
  "dxForm-requiredMessage": "{0} \u662F\u5FC5\u987B\u7684",
  "dxNumberBox-invalidValueMessage": "\u503C\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57",
  "dxNumberBox-noDataText": "\u65E0\u6570\u636E",
  "dxDataGrid-columnChooserTitle": "\u5217\u9009\u62E9\u5668",
  "dxDataGrid-columnChooserEmptyText": "\u5728\u8FD9\u91CC\u62D6\u52A8\u4E00\u5217\u9690\u85CF\u5B83",
  "dxDataGrid-groupContinuesMessage": "\u4E0B\u4E00\u9875",
  "dxDataGrid-groupContinuedMessage": "\u4E0A\u4E00\u9875",
  "dxDataGrid-groupHeaderText": "\u901A\u8FC7\u8BE5\u5217\u5206\u7EC4",
  "dxDataGrid-ungroupHeaderText": "\u53D6\u6D88\u5206\u7EC4",
  "dxDataGrid-ungroupAllText": "\u53D6\u6D88\u6240\u6709\u5206\u7EC4",
  "dxDataGrid-editingEditRow": "\u7F16\u8F91",
  "dxDataGrid-editingSaveRowChanges": "\u4FDD\u5B58",
  "dxDataGrid-editingCancelRowChanges": "\u53D6\u6D88",
  "dxDataGrid-editingDeleteRow": "\u5220\u9664",
  "dxDataGrid-editingUndeleteRow": "\u53D6\u6D88\u5220\u9664",
  "dxDataGrid-editingConfirmDeleteMessage": "\u4F60\u786E\u5B9A\u8981\u5220\u9664\u8FD9\u6761\u8BB0\u5F55\u5417\uFF1F",
  "dxDataGrid-validationCancelChanges": "\u53D6\u6D88\u66F4\u6539",
  "dxDataGrid-groupPanelEmptyText": "\u62D6\u52A8\u5217\u6807\u9898\u81F3\u6B64\u4EE5\u8FDB\u884C\u5217\u5206\u7EC4",
  "dxDataGrid-noDataText": "\u65E0\u6570\u636E",
  "dxDataGrid-searchPanelPlaceholder": "\u641C\u7D22...",
  "dxDataGrid-filterRowShowAllText": "(\u5168\u90E8)",
  "dxDataGrid-filterRowResetOperationText": "\u91CD\u7F6E",
  "dxDataGrid-filterRowOperationEquals": "\u7B49\u4E8E",
  "dxDataGrid-filterRowOperationNotEquals": "\u4E0D\u7B49\u4E8E",
  "dxDataGrid-filterRowOperationLess": "\u5C0F\u4E8E",
  "dxDataGrid-filterRowOperationLessOrEquals": "\u5C0F\u4E8E\u6216\u7B49\u4E8E",
  "dxDataGrid-filterRowOperationGreater": "\u5927\u4E8E",
  "dxDataGrid-filterRowOperationGreaterOrEquals": "\u5927\u4E8E\u6216\u7B49\u4E8E",
  "dxDataGrid-filterRowOperationStartsWith": "\u4EE5...\u5F00\u59CB",
  "dxDataGrid-filterRowOperationContains": "\u5305\u542B",
  "dxDataGrid-filterRowOperationNotContains": "\u4E0D\u5305\u542B",
  "dxDataGrid-filterRowOperationEndsWith": "\u7ED3\u675F\u4E8E",
  "dxDataGrid-filterRowOperationBetween": "\u4E4B\u95F4",
  "dxDataGrid-filterRowOperationBetweenStartText": "\u5F00\u59CB",
  "dxDataGrid-filterRowOperationBetweenEndText": "\u7ED3\u675F",
  "dxDataGrid-applyFilterText": "\u5E94\u7528\u8FC7\u6EE4\u5668",
  "dxDataGrid-trueText": "\u771F",
  "dxDataGrid-falseText": "\u5047",
  "dxDataGrid-sortingAscendingText": "\u5347\u5E8F\u6392\u5E8F",
  "dxDataGrid-sortingDescendingText": "\u964D\u5E8F\u6392\u5E8F",
  "dxDataGrid-sortingClearText": "\u6E05\u9664\u6392\u5E8F",
  "dxDataGrid-editingSaveAllChanges": "\u4FDD\u5B58\u4FEE\u6539",
  "dxDataGrid-editingCancelAllChanges": "\u653E\u5F03\u4FEE\u6539",
  "dxDataGrid-editingAddRow": "\u6DFB\u52A0\u4E00\u884C",
  "dxDataGrid-summaryMin": "\u6700\u5C0F\u503C: {0}",
  "dxDataGrid-summaryMinOtherColumn": "{1} \u7684\u6700\u5C0F\u503C\u4E3A {0}",
  "dxDataGrid-summaryMax": "\u6700\u5927\u503C: {0}",
  "dxDataGrid-summaryMaxOtherColumn": "{1} \u7684\u6700\u5927\u503C\u4E3A {0}",
  "dxDataGrid-summaryAvg": "\u5E73\u5747\u503C: {0}",
  "dxDataGrid-summaryAvgOtherColumn": "{1} \u7684\u5E73\u5747\u503C\u4E3A {0}",
  "dxDataGrid-summarySum": "\u603B\u548C: {0}",
  "dxDataGrid-summarySumOtherColumn": "{1} \u7684\u603B\u548C\u4E3A {0}",
  "dxDataGrid-summaryCount": "\u8BA1\u6570: {0}",
  "dxDataGrid-columnFixingFix": "\u56FA\u5B9A",
  "dxDataGrid-columnFixingUnfix": "\u4E0D\u56FA\u5B9A",
  "dxDataGrid-columnFixingLeftPosition": "\u5411\u5DE6",
  "dxDataGrid-columnFixingRightPosition": "\u5411\u53F3",
  "dxDataGrid-exportTo": "\u5BFC\u51FA",
  "dxDataGrid-exportToExcel": "\u5BFC\u51FAExcel\u6587\u4EF6",
  "dxDataGrid-exporting": "\u5BFC\u51FA...",
  "dxDataGrid-excelFormat": "Excel\u6587\u4EF6",
  "dxDataGrid-selectedRows": "\u5DF2\u9009\u884C",
  "dxDataGrid-exportSelectedRows": "\u5BFC\u51FA\u5DF2\u9009\u884C",
  "dxDataGrid-exportAll": "\u5BFC\u51FA\u6240\u6709\u6570\u636E",
  "dxDataGrid-headerFilterEmptyValue": "(\u7A7A\u767D)",
  "dxDataGrid-headerFilterOK": "\u597D",
  "dxDataGrid-headerFilterCancel": "\u53D6\u6D88",
  "dxDataGrid-ariaColumn": "\u5217",
  "dxDataGrid-ariaValue": "\u503C",
  "dxDataGrid-ariaFilterCell": "\u8FC7\u6EE4\u5355\u5143",
  "dxDataGrid-ariaCollapse": "\u6298\u53E0",
  "dxDataGrid-ariaExpand": "\u5C55\u5F00",
  "dxDataGrid-ariaDataGrid": "\u6570\u636E\u7F51\u683C",
  "dxDataGrid-ariaSearchInGrid": "\u5728\u6570\u636E\u7F51\u683C\u4E2D\u641C\u7D22",
  "dxDataGrid-ariaSelectAll": "\u5168\u9009",
  "dxDataGrid-ariaSelectRow": "\u9009\u62E9\u884C",
  "dxDataGrid-filterBuilderPopupTitle": "\u8FC7\u6EE4\u5668\u751F\u6210\u5668",
  "dxDataGrid-filterPanelCreateFilter": "\u521B\u5EFA\u8FC7\u6EE4\u5668",
  "dxDataGrid-filterPanelClearFilter": "\u6E05\u7A7A",
  "dxDataGrid-filterPanelFilterEnabledHint": "\u542F\u7528\u8BE5\u8FC7\u6EE4\u5668",
  "dxTreeList-ariaTreeList": "\u6811\u72B6\u5217\u8868",
  "dxTreeList-editingAddRowToNode": "\u6DFB\u52A0",
  "dxPager-infoText": "\u7B2C{0}\u9875,\u5171{1}\u9875 ({2} \u4E2A\u9879\u76EE)",
  "dxPager-pagesCountText": "\u5230",
  "dxPager-pageSizesAllText": "\u5168\u90E8",
  "dxPivotGrid-grandTotal": "\u5408\u8BA1",
  "dxPivotGrid-total": "{0} \u603B\u8BA1",
  "dxPivotGrid-fieldChooserTitle": "\u5B57\u6BB5\u9009\u62E9\u5668",
  "dxPivotGrid-showFieldChooser": "\u663E\u793A\u5B57\u6BB5\u9009\u62E9\u5668",
  "dxPivotGrid-expandAll": "\u5168\u90E8\u5C55\u5F00",
  "dxPivotGrid-collapseAll": "\u5168\u90E8\u6298\u53E0",
  "dxPivotGrid-sortColumnBySummary": '\u6309 "{0}" \u5217\u6392\u5E8F',
  "dxPivotGrid-sortRowBySummary": '\u6309 "{0}" \u884C\u6392\u5E8F',
  "dxPivotGrid-removeAllSorting": "\u6E05\u9664\u6240\u6709\u6392\u5E8F",
  "dxPivotGrid-dataNotAvailable": "\u4E0D\u9002\u7528",
  "dxPivotGrid-rowFields": "\u884C\u5B57\u6BB5",
  "dxPivotGrid-columnFields": "\u5217\u5B57\u6BB5",
  "dxPivotGrid-dataFields": "\u6570\u636E\u5B57\u6BB5",
  "dxPivotGrid-filterFields": "\u8FC7\u6EE4\u5B57\u6BB5",
  "dxPivotGrid-allFields": "\u6240\u6709\u5B57\u6BB5",
  "dxPivotGrid-columnFieldArea": "\u5C06\u5217\u62D6\u52A8\u5230\u6B64\u5904",
  "dxPivotGrid-dataFieldArea": "\u5C06\u6570\u636E\u62D6\u52A8\u5230\u6B64\u5904",
  "dxPivotGrid-rowFieldArea": "\u5C06\u884C\u5B57\u6BB5\u62D6\u5230\u5230\u6B64\u6B21",
  "dxPivotGrid-filterFieldArea": "\u62D6\u52A8\u7B5B\u9009\u5B57\u6BB5\u5230\u6B64\u5904",
  "dxScheduler-editorLabelTitle": "\u6807\u9898",
  "dxScheduler-editorLabelStartDate": "\u5F00\u59CB\u65E5\u671F",
  "dxScheduler-editorLabelEndDate": "\u7ED3\u675F\u65E5\u671F",
  "dxScheduler-editorLabelDescription": "\u63CF\u8FF0",
  "dxScheduler-editorLabelRecurrence": "\u91CD\u590D",
  "dxScheduler-openAppointment": "\u6253\u5F00\u65E5\u7A0B",
  "dxScheduler-recurrenceNever": "\u6C38\u4E0D",
  "dxScheduler-recurrenceMinutely": "Minutely",
  "dxScheduler-recurrenceHourly": "Hourly",
  "dxScheduler-recurrenceDaily": "\u65E5\u5E38",
  "dxScheduler-recurrenceWeekly": "\u6BCF\u5468",
  "dxScheduler-recurrenceMonthly": "\u6BCF\u6708",
  "dxScheduler-recurrenceYearly": "\u6BCF\u5E74",
  "dxScheduler-recurrenceRepeatEvery": "\u6240\u6709",
  "dxScheduler-recurrenceRepeatOn": "Repeat On",
  "dxScheduler-recurrenceEnd": "\u505C\u6B62\u91CD\u590D",
  "dxScheduler-recurrenceAfter": "\u4E4B\u540E",
  "dxScheduler-recurrenceOn": "\u5728",
  "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
  "dxScheduler-recurrenceRepeatHourly": "hour(s)",
  "dxScheduler-recurrenceRepeatDaily": "\u65E5",
  "dxScheduler-recurrenceRepeatWeekly": "\u5468",
  "dxScheduler-recurrenceRepeatMonthly": "\u6708",
  "dxScheduler-recurrenceRepeatYearly": "\u5E74",
  "dxScheduler-switcherDay": "\u65E5",
  "dxScheduler-switcherWeek": "\u5468",
  "dxScheduler-switcherWorkWeek": "\u5DE5\u4F5C\u5468",
  "dxScheduler-switcherMonth": "\u6708",
  "dxScheduler-switcherAgenda": "\u8BAE\u7A0B",
  "dxScheduler-switcherTimelineDay": "\u65F6\u95F4\u8F74\u65E5",
  "dxScheduler-switcherTimelineWeek": "\u65F6\u95F4\u8F74\u5468",
  "dxScheduler-switcherTimelineWorkWeek": "\u65F6\u95F4\u8F74\u5DE5\u4F5C\u5468",
  "dxScheduler-switcherTimelineMonth": "\u65F6\u95F4\u8F74\u6708",
  "dxScheduler-recurrenceRepeatOnDate": "\u4E8E\u65E5\u671F",
  "dxScheduler-recurrenceRepeatCount": "\u4E8B\u4EF6",
  "dxScheduler-allDay": "\u5168\u5929",
  "dxScheduler-confirmRecurrenceEditMessage": "\u4F60\u60F3\u53EA\u4FEE\u6539\u8BE5\u65E5\u7A0B\u8FD8\u662F\u60F3\u4FEE\u6539\u6574\u4E2A\u7CFB\u5217\u7684\u65E5\u7A0B?",
  "dxScheduler-confirmRecurrenceDeleteMessage": "\u4F60\u60F3\u53EA\u5220\u9664\u8FD9\u4E2A\u65E5\u7A0B\u8FD8\u662F\u60F3\u5220\u9664\u6574\u4E2A\u7CFB\u5217\u7684\u65E5\u7A0B?",
  "dxScheduler-confirmRecurrenceEditSeries": "\u4FEE\u6539\u8BE5\u7CFB\u5217\u7684\u65E5\u7A0B",
  "dxScheduler-confirmRecurrenceDeleteSeries": "\u5220\u9664\u8BE5\u7CFB\u5217\u7684\u65E5\u7A0B",
  "dxScheduler-confirmRecurrenceEditOccurrence": "\u4FEE\u6539\u65E5\u7A0B",
  "dxScheduler-confirmRecurrenceDeleteOccurrence": "\u5220\u9664\u65E5\u7A0B",
  "dxScheduler-noTimezoneTitle": "\u6CA1\u6709\u65F6\u533A",
  "dxScheduler-moreAppointments": "{0} \u66F4\u591A",
  "dxCalendar-todayButtonText": "\u4ECA\u5929",
  "dxCalendar-ariaWidgetName": "\u65E5\u5386",
  "dxColorView-ariaRed": "\u7EA2\u8272",
  "dxColorView-ariaGreen": "\u7EFF\u8272",
  "dxColorView-ariaBlue": "\u84DD\u8272",
  "dxColorView-ariaAlpha": "\u900F\u660E\u5EA6",
  "dxColorView-ariaHex": "\u8272\u6807",
  "dxTagBox-selected": "{0} \u5DF2\u9009\u62E9",
  "dxTagBox-allSelected": "\u5DF2\u5168\u9009 ({0})",
  "dxTagBox-moreSelected": "{0} \u66F4\u591A",
  "vizExport-printingButtonText": "\u6253\u5370",
  "vizExport-titleMenuText": "\u5BFC\u51FA\u4E2D/\u6253\u5370\u4E2D",
  "vizExport-exportButtonText": "{0} \u6587\u4EF6",
  "dxFilterBuilder-and": "\u4E0E",
  "dxFilterBuilder-or": "\u6216",
  "dxFilterBuilder-notAnd": "\u4E0E\u975E",
  "dxFilterBuilder-notOr": "\u6216\u975E",
  "dxFilterBuilder-addCondition": "\u6DFB\u52A0\u6761\u4EF6",
  "dxFilterBuilder-addGroup": "\u6DFB\u52A0\u7EC4",
  "dxFilterBuilder-enterValueText": "<\u8F93\u5165\u503C>",
  "dxFilterBuilder-filterOperationEquals": "\u7B49\u4E8E",
  "dxFilterBuilder-filterOperationNotEquals": "\u4E0D\u7B49\u4E8E",
  "dxFilterBuilder-filterOperationLess": "\u5C0F\u4E8E",
  "dxFilterBuilder-filterOperationLessOrEquals": "\u5C0F\u4E8E\u6216\u7B49\u4E8E",
  "dxFilterBuilder-filterOperationGreater": "\u5927\u4E8E",
  "dxFilterBuilder-filterOperationGreaterOrEquals": "\u5927\u4E8E\u6216\u7B49\u4E8E",
  "dxFilterBuilder-filterOperationStartsWith": "\u5F00\u59CB\u4E8E",
  "dxFilterBuilder-filterOperationContains": "\u5305\u542B",
  "dxFilterBuilder-filterOperationNotContains": "\u4E0D\u5305\u542B",
  "dxFilterBuilder-filterOperationEndsWith": "\u7ED3\u675F\u4E8E",
  "dxFilterBuilder-filterOperationIsBlank": "\u7A7A",
  "dxFilterBuilder-filterOperationIsNotBlank": "\u4E0D\u4E3A\u7A7A",
  "dxFilterBuilder-filterOperationBetween": "\u4E4B\u95F4",
  "dxFilterBuilder-filterOperationAnyOf": "\u4EFB\u4F55\u4E00\u4E2A",
  "dxFilterBuilder-filterOperationNoneOf": "\u4EFB\u4F55\u4E00\u4E2A\u90FD\u4E0D",
  "dxHtmlEditor-dialogColorCaption": "\u66F4\u6539\u5B57\u4F53\u989C\u8272",
  "dxHtmlEditor-dialogBackgroundCaption": "\u66F4\u6539\u80CC\u666F\u989C\u8272",
  "dxHtmlEditor-dialogLinkCaption": "\u6DFB\u52A0\u94FE\u63A5",
  "dxHtmlEditor-dialogLinkUrlField": "\u94FE\u63A5\u5730\u5740",
  "dxHtmlEditor-dialogLinkTextField": "\u94FE\u63A5\u6587\u5B57",
  "dxHtmlEditor-dialogLinkTargetField": "\u5728\u65B0\u7A97\u53E3\u4E2D\u6253\u5F00",
  "dxHtmlEditor-dialogImageCaption": "\u6DFB\u52A0\u56FE\u7247",
  "dxHtmlEditor-dialogImageUrlField": "\u56FE\u7247\u5730\u5740",
  "dxHtmlEditor-dialogImageAltField": "\u66FF\u4EE3\u6587\u5B57",
  "dxHtmlEditor-dialogImageWidthField": "\u5BBD (px)",
  "dxHtmlEditor-dialogImageHeightField": "\u957F (px)",
  "dxHtmlEditor-dialogInsertTableRowsField": "!TODO",
  "dxHtmlEditor-dialogInsertTableColumnsField": "!TODO",
  "dxHtmlEditor-dialogInsertTableCaption": "!TODO",
  "dxHtmlEditor-heading": "\u6807\u9898",
  "dxHtmlEditor-normalText": "\u6B63\u6587",
  "dxHtmlEditor-background": "TODO",
  "dxHtmlEditor-bold": "TODO",
  "dxHtmlEditor-color": "TODO",
  "dxHtmlEditor-font": "TODO",
  "dxHtmlEditor-italic": "TODO",
  "dxHtmlEditor-link": "TODO",
  "dxHtmlEditor-image": "TODO",
  "dxHtmlEditor-size": "TODO",
  "dxHtmlEditor-strike": "TODO",
  "dxHtmlEditor-subscript": "TODO",
  "dxHtmlEditor-superscript": "TODO",
  "dxHtmlEditor-underline": "TODO",
  "dxHtmlEditor-blockquote": "TODO",
  "dxHtmlEditor-header": "TODO",
  "dxHtmlEditor-increaseIndent": "TODO",
  "dxHtmlEditor-decreaseIndent": "TODO",
  "dxHtmlEditor-orderedList": "TODO",
  "dxHtmlEditor-bulletList": "TODO",
  "dxHtmlEditor-alignLeft": "TODO",
  "dxHtmlEditor-alignCenter": "TODO",
  "dxHtmlEditor-alignRight": "TODO",
  "dxHtmlEditor-alignJustify": "TODO",
  "dxHtmlEditor-codeBlock": "TODO",
  "dxHtmlEditor-variable": "TODO",
  "dxHtmlEditor-undo": "TODO",
  "dxHtmlEditor-redo": "TODO",
  "dxHtmlEditor-clear": "TODO",
  "dxHtmlEditor-insertTable": "TODO",
  "dxHtmlEditor-insertRowAbove": "TODO",
  "dxHtmlEditor-insertRowBelow": "TODO",
  "dxHtmlEditor-insertColumnLeft": "TODO",
  "dxHtmlEditor-insertColumnRight": "TODO",
  "dxHtmlEditor-deleteColumn": "TODO",
  "dxHtmlEditor-deleteRow": "TODO",
  "dxHtmlEditor-deleteTable": "TODO",
  "dxHtmlEditor-list": "TODO",
  "dxHtmlEditor-ordered": "TODO",
  "dxHtmlEditor-bullet": "TODO",
  "dxHtmlEditor-align": "TODO",
  "dxHtmlEditor-center": "TODO",
  "dxHtmlEditor-left": "TODO",
  "dxHtmlEditor-right": "TODO",
  "dxHtmlEditor-indent": "TODO",
  "dxHtmlEditor-justify": "TODO",
  "dxFileManager-newDirectoryName": "TODO",
  "dxFileManager-rootDirectoryName": "TODO",
  "dxFileManager-errorNoAccess": "TODO",
  "dxFileManager-errorDirectoryExistsFormat": "TODO",
  "dxFileManager-errorFileExistsFormat": "TODO",
  "dxFileManager-errorFileNotFoundFormat": "TODO",
  "dxFileManager-errorDirectoryNotFoundFormat": "TODO",
  "dxFileManager-errorWrongFileExtension": "TODO",
  "dxFileManager-errorMaxFileSizeExceeded": "TODO",
  "dxFileManager-errorInvalidSymbols": "TODO",
  "dxFileManager-errorDefault": "TODO",
  "dxFileManager-errorDirectoryOpenFailed": "TODO",
  "dxDiagram-categoryGeneral": "TODO",
  "dxDiagram-categoryFlowchart": "TODO",
  "dxDiagram-categoryOrgChart": "TODO",
  "dxDiagram-categoryContainers": "TODO",
  "dxDiagram-categoryCustom": "TODO",
  "dxDiagram-commandExportToSvg": "TODO",
  "dxDiagram-commandExportToPng": "TODO",
  "dxDiagram-commandExportToJpg": "TODO",
  "dxDiagram-commandUndo": "TODO",
  "dxDiagram-commandRedo": "TODO",
  "dxDiagram-commandFontName": "TODO",
  "dxDiagram-commandFontSize": "TODO",
  "dxDiagram-commandBold": "TODO",
  "dxDiagram-commandItalic": "TODO",
  "dxDiagram-commandUnderline": "TODO",
  "dxDiagram-commandTextColor": "TODO",
  "dxDiagram-commandLineColor": "TODO",
  "dxDiagram-commandLineWidth": "TODO",
  "dxDiagram-commandLineStyle": "TODO",
  "dxDiagram-commandLineStyleSolid": "TODO",
  "dxDiagram-commandLineStyleDotted": "TODO",
  "dxDiagram-commandLineStyleDashed": "TODO",
  "dxDiagram-commandFillColor": "TODO",
  "dxDiagram-commandAlignLeft": "TODO",
  "dxDiagram-commandAlignCenter": "TODO",
  "dxDiagram-commandAlignRight": "TODO",
  "dxDiagram-commandConnectorLineType": "TODO",
  "dxDiagram-commandConnectorLineStraight": "TODO",
  "dxDiagram-commandConnectorLineOrthogonal": "TODO",
  "dxDiagram-commandConnectorLineStart": "TODO",
  "dxDiagram-commandConnectorLineEnd": "TODO",
  "dxDiagram-commandConnectorLineNone": "TODO",
  "dxDiagram-commandConnectorLineArrow": "TODO",
  "dxDiagram-commandFullscreen": "TODO",
  "dxDiagram-commandUnits": "TODO",
  "dxDiagram-commandPageSize": "TODO",
  "dxDiagram-commandPageOrientation": "TODO",
  "dxDiagram-commandPageOrientationLandscape": "TODO",
  "dxDiagram-commandPageOrientationPortrait": "TODO",
  "dxDiagram-commandPageColor": "TODO",
  "dxDiagram-commandShowGrid": "TODO",
  "dxDiagram-commandSnapToGrid": "TODO",
  "dxDiagram-commandGridSize": "TODO",
  "dxDiagram-commandZoomLevel": "TODO",
  "dxDiagram-commandAutoZoom": "TODO",
  "dxDiagram-commandFitToContent": "TODO",
  "dxDiagram-commandFitToWidth": "TODO",
  "dxDiagram-commandAutoZoomByContent": "TODO",
  "dxDiagram-commandAutoZoomByWidth": "TODO",
  "dxDiagram-commandSimpleView": "TODO",
  "dxDiagram-commandCut": "TODO",
  "dxDiagram-commandCopy": "TODO",
  "dxDiagram-commandPaste": "TODO",
  "dxDiagram-commandSelectAll": "TODO",
  "dxDiagram-commandDelete": "TODO",
  "dxDiagram-commandBringToFront": "TODO",
  "dxDiagram-commandSendToBack": "TODO",
  "dxDiagram-commandLock": "TODO",
  "dxDiagram-commandUnlock": "TODO",
  "dxDiagram-commandInsertShapeImage": "TODO",
  "dxDiagram-commandEditShapeImage": "TODO",
  "dxDiagram-commandDeleteShapeImage": "TODO",
  "dxDiagram-commandLayoutLeftToRight": "TODO",
  "dxDiagram-commandLayoutRightToLeft": "TODO",
  "dxDiagram-commandLayoutTopToBottom": "TODO",
  "dxDiagram-commandLayoutBottomToTop": "TODO",
  "dxDiagram-unitIn": "TODO",
  "dxDiagram-unitCm": "TODO",
  "dxDiagram-unitPx": "TODO",
  "dxDiagram-dialogButtonOK": "TODO",
  "dxDiagram-dialogButtonCancel": "TODO",
  "dxDiagram-dialogInsertShapeImageTitle": "TODO",
  "dxDiagram-dialogEditShapeImageTitle": "TODO",
  "dxDiagram-dialogEditShapeImageSelectButton": "TODO",
  "dxDiagram-dialogEditShapeImageLabelText": "TODO",
  "dxDiagram-uiExport": "TODO",
  "dxDiagram-uiProperties": "TODO",
  "dxDiagram-uiSettings": "TODO",
  "dxDiagram-uiShowToolbox": "TODO",
  "dxDiagram-uiSearch": "TODO",
  "dxDiagram-uiStyle": "TODO",
  "dxDiagram-uiLayout": "TODO",
  "dxDiagram-uiLayoutTree": "TODO",
  "dxDiagram-uiLayoutLayered": "TODO",
  "dxDiagram-uiDiagram": "TODO",
  "dxDiagram-uiText": "TODO",
  "dxDiagram-uiObject": "TODO",
  "dxDiagram-uiConnector": "TODO",
  "dxDiagram-uiPage": "TODO",
  "dxDiagram-shapeText": "TODO",
  "dxDiagram-shapeRectangle": "TODO",
  "dxDiagram-shapeEllipse": "TODO",
  "dxDiagram-shapeCross": "TODO",
  "dxDiagram-shapeTriangle": "TODO",
  "dxDiagram-shapeDiamond": "TODO",
  "dxDiagram-shapeHeart": "TODO",
  "dxDiagram-shapePentagon": "TODO",
  "dxDiagram-shapeHexagon": "TODO",
  "dxDiagram-shapeOctagon": "TODO",
  "dxDiagram-shapeStar": "TODO",
  "dxDiagram-shapeArrowLeft": "TODO",
  "dxDiagram-shapeArrowUp": "TODO",
  "dxDiagram-shapeArrowRight": "TODO",
  "dxDiagram-shapeArrowDown": "TODO",
  "dxDiagram-shapeArrowUpDown": "TODO",
  "dxDiagram-shapeArrowLeftRight": "TODO",
  "dxDiagram-shapeProcess": "TODO",
  "dxDiagram-shapeDecision": "TODO",
  "dxDiagram-shapeTerminator": "TODO",
  "dxDiagram-shapePredefinedProcess": "TODO",
  "dxDiagram-shapeDocument": "TODO",
  "dxDiagram-shapeMultipleDocuments": "TODO",
  "dxDiagram-shapeManualInput": "TODO",
  "dxDiagram-shapePreparation": "TODO",
  "dxDiagram-shapeData": "TODO",
  "dxDiagram-shapeDatabase": "TODO",
  "dxDiagram-shapeHardDisk": "TODO",
  "dxDiagram-shapeInternalStorage": "TODO",
  "dxDiagram-shapePaperTape": "TODO",
  "dxDiagram-shapeManualOperation": "TODO",
  "dxDiagram-shapeDelay": "TODO",
  "dxDiagram-shapeStoredData": "TODO",
  "dxDiagram-shapeDisplay": "TODO",
  "dxDiagram-shapeMerge": "TODO",
  "dxDiagram-shapeConnector": "TODO",
  "dxDiagram-shapeOr": "TODO",
  "dxDiagram-shapeSummingJunction": "TODO",
  "dxDiagram-shapeContainerDefaultText": "TODO",
  "dxDiagram-shapeVerticalContainer": "TODO",
  "dxDiagram-shapeHorizontalContainer": "TODO",
  "dxDiagram-shapeCardDefaultText": "TODO",
  "dxDiagram-shapeCardWithImageOnLeft": "TODO",
  "dxDiagram-shapeCardWithImageOnTop": "TODO",
  "dxDiagram-shapeCardWithImageOnRight": "TODO",
  "dxGantt-dialogTitle": "TODO",
  "dxGantt-dialogStartTitle": "TODO",
  "dxGantt-dialogEndTitle": "TODO",
  "dxGantt-dialogProgressTitle": "TODO",
  "dxGantt-dialogResourcesTitle": "TODO",
  "dxGantt-dialogResourceManagerTitle": "TODO",
  "dxGantt-dialogTaskDetailsTitle": "TODO",
  "dxGantt-dialogEditResourceListHint": "TODO",
  "dxGantt-dialogEditNoResources": "TODO",
  "dxGantt-dialogButtonAdd": "TODO",
  "dxGantt-contextMenuNewTask": "TODO",
  "dxGantt-contextMenuNewSubtask": "TODO",
  "dxGantt-contextMenuDeleteTask": "TODO",
  "dxGantt-contextMenuDeleteDependency": "TODO",
  "dxGantt-dialogTaskDeleteConfirmation": "TODO",
  "dxGantt-dialogDependencyDeleteConfirmation": "TODO",
  "dxGantt-dialogResourcesDeleteConfirmation": "TODO",
  "dxGantt-dialogConstraintCriticalViolationMessage": "TODO",
  "dxGantt-dialogConstraintViolationMessage": "TODO",
  "dxGantt-dialogCancelOperationMessage": "TODO",
  "dxGantt-dialogDeleteDependencyMessage": "TODO",
  "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "TODO",
  "dxGantt-undo": "TODO",
  "dxGantt-redo": "TODO",
  "dxGantt-expandAll": "TODO",
  "dxGantt-collapseAll": "TODO",
  "dxGantt-addNewTask": "TODO",
  "dxGantt-deleteSelectedTask": "TODO",
  "dxGantt-zoomIn": "TODO",
  "dxGantt-zoomOut": "TODO",
  "dxGantt-fullScreen": "TODO",
  "dxGantt-quarter": "TODO"
};
var zhMessages = {
  zh
};
var locale = core.locale.bind(core);
var loadMessages = messageLocalization.load.bind(messageLocalization);
messageLocalization.format.bind(messageLocalization);
numberLocalization.format.bind(numberLocalization);
numberLocalization.parse.bind(numberLocalization);
dateLocalization.format.bind(dateLocalization);
dateLocalization.parse.bind(dateLocalization);
class PivotGridPlus extends Base {
  constructor(options) {
    super();
    __publicField(this, "name", "pivot-grid-plus");
    __publicField(this, "defaultDataSource");
    this.defaultOption = {
      wordWrapEnabled: false,
      expandAll: true,
      showBorders: true,
      inheritHeight: false,
      useBetterScroller: true,
      emptyPlaceHolder: void 0,
      exportable: true,
      summaryType: "count",
      customFields: []
    };
    this.options = Object.assign(this.defaultOption, options);
    this.defaultDataSource = cloneDeep(this.options.dataSource);
    return this.init();
  }
  init() {
    this.setLocale();
    this.customizePivotGrid();
    this.customOptionsHandler(this.options);
    this.DP = new PivotGrid(this.options.el, this.options);
    return this.mixin();
  }
  setLocale() {
    loadMessages(zhMessages);
    locale("zh-CN");
  }
  updateOptions(options) {
    let dataSourceOptions = [
      "expandAll",
      "emptyPlaceHolder",
      "summaryType",
      "wordWrapEnabled",
      "tdCustomStyle",
      "customFields",
      "dataSource"
    ];
    this.options = Object.assign(this.options, {
      dataSource: cloneDeep(this.defaultDataSource)
    }, options);
    this.customOptionsHandler(this.options);
    Object.keys(options).map((key) => {
      if (!dataSourceOptions.includes(key)) {
        this.DP.option(key, this.options[key]);
      }
    });
    this.DP.option("dataSource", this.options.dataSource);
  }
  expandAll() {
    if (!this.DP)
      return;
    let dataSourceInstance = this.DP.getDataSource();
    let { row, column } = this.getFirstField();
    row && dataSourceInstance.expandAll(row.index);
    column && dataSourceInstance.expandAll(column.index);
  }
  collapseAll() {
    if (!this.DP)
      return;
    let dataSourceInstance = this.DP.getDataSource();
    let { row, column } = this.getFirstField();
    row && dataSourceInstance.collapseAll(row.index);
    column && dataSourceInstance.collapseAll(column.index);
  }
  mixin() {
    Object.getOwnPropertyNames(PivotGridPlus.prototype).filter((key) => {
      return !["constructor", "mixin", "init"].includes(key);
    }).forEach((key) => {
      if (isFn(this[key])) {
        this.DP[key] = this[key].bind(this);
      }
    });
    return this.DP;
  }
  customizePivotGrid() {
    this.setClassName(this.name);
    this.options.inheritHeight && this.setInheritHeight();
    this.options.useBetterScroller && this.useBetterScroller();
    this.options.exportable && this.setExportable();
  }
  customOptionsHandler(options) {
    var _a, _b, _c, _d, _e, _f;
    if (!((_a = options.dataSource) == null ? void 0 : _a.fields))
      return;
    options.expandAll && DataHandler.expandAllHandler((_b = options.dataSource) == null ? void 0 : _b.fields);
    options.emptyPlaceHolder && DataHandler.setEmptyPlaceHolder((_c = options.dataSource) == null ? void 0 : _c.fields, options.emptyPlaceHolder);
    options.summaryType && DataHandler.setSummaryType((_d = options.dataSource) == null ? void 0 : _d.fields, options.summaryType);
    options.wordWrapEnabled && DataHandler.setWordWrapHandler((_e = options.dataSource) == null ? void 0 : _e.fields, options.wordWrapEnabled);
    options.tdCustomStyle && DataHandler.setTdCustomStyle(options);
    ((_f = options.customFields) == null ? void 0 : _f.length) > 0 && DataHandler.setCustomFields(options);
  }
  destroy() {
    var _a, _b;
    (_b = (_a = this.DP) == null ? void 0 : _a.dispose) == null ? void 0 : _b.call(_a);
  }
}
export { PivotGridPlus };
